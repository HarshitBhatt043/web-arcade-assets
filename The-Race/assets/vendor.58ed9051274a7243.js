//  Merci-Michel [R]
//  https://www.merci-michel.com/
//  Build 20230208-113313

var e = Object.defineProperty,
  t = Object.defineProperties,
  n = Object.getOwnPropertyDescriptors,
  i = Object.getOwnPropertySymbols,
  r = Object.prototype.hasOwnProperty,
  s = Object.prototype.propertyIsEnumerable,
  a = (t, n, i) =>
    n in t
      ? e(t, n, { enumerable: !0, configurable: !0, writable: !0, value: i })
      : (t[n] = i),
  o = (e, t) => {
    for (var n in t || (t = {})) r.call(t, n) && a(e, n, t[n]);
    if (i) for (var n of i(t)) s.call(t, n) && a(e, n, t[n]);
    return e;
  },
  l = (e, i) => t(e, n(i));
function c(e, t) {
  const n = Object.create(null),
    i = e.split(",");
  for (let r = 0; r < i.length; r++) n[i[r]] = !0;
  return t ? (e) => !!n[e.toLowerCase()] : (e) => !!n[e];
}
const u = c(
  "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly"
);
function h(e) {
  return !!e || "" === e;
}
function d(e) {
  if (R(e)) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
      const i = e[n],
        r = F(i) ? m(i) : d(i);
      if (r) for (const e in r) t[e] = r[e];
    }
    return t;
  }
  return F(e) || U(e) ? e : void 0;
}
const p = /;(?![^(]*\))/g,
  f = /:(.+)/;
function m(e) {
  const t = {};
  return (
    e.split(p).forEach((e) => {
      if (e) {
        const n = e.split(f);
        n.length > 1 && (t[n[0].trim()] = n[1].trim());
      }
    }),
    t
  );
}
function g(e) {
  let t = "";
  if (F(e)) t = e;
  else if (R(e))
    for (let n = 0; n < e.length; n++) {
      const i = g(e[n]);
      i && (t += i + " ");
    }
  else if (U(e)) for (const n in e) e[n] && (t += n + " ");
  return t.trim();
}
function v(e, t) {
  if (e === t) return !0;
  let n = N(e),
    i = N(t);
  if (n || i) return !(!n || !i) && e.getTime() === t.getTime();
  if (((n = R(e)), (i = R(t)), n || i))
    return (
      !(!n || !i) &&
      (function (e, t) {
        if (e.length !== t.length) return !1;
        let n = !0;
        for (let i = 0; n && i < e.length; i++) n = v(e[i], t[i]);
        return n;
      })(e, t)
    );
  if (((n = U(e)), (i = U(t)), n || i)) {
    if (!n || !i) return !1;
    if (Object.keys(e).length !== Object.keys(t).length) return !1;
    for (const n in e) {
      const i = e.hasOwnProperty(n),
        r = t.hasOwnProperty(n);
      if ((i && !r) || (!i && r) || !v(e[n], t[n])) return !1;
    }
  }
  return String(e) === String(t);
}
function _(e, t) {
  return e.findIndex((e) => v(e, t));
}
const y = (e) =>
    null == e
      ? ""
      : R(e) || (U(e) && (e.toString === V || !O(e.toString)))
      ? JSON.stringify(e, x, 2)
      : String(e),
  x = (e, t) =>
    t && t.__v_isRef
      ? x(e, t.value)
      : D(t)
      ? {
          [`Map(${t.size})`]: [...t.entries()].reduce(
            (e, [t, n]) => ((e[`${t} =>`] = n), e),
            {}
          ),
        }
      : k(t)
      ? { [`Set(${t.size})`]: [...t.values()] }
      : !U(t) || R(t) || G(t)
      ? t
      : String(t),
  b = {},
  w = [],
  S = () => {},
  M = () => !1,
  T = /^on[^a-z]/,
  C = (e) => T.test(e),
  E = (e) => e.startsWith("onUpdate:"),
  A = Object.assign,
  P = (e, t) => {
    const n = e.indexOf(t);
    n > -1 && e.splice(n, 1);
  },
  L = Object.prototype.hasOwnProperty,
  I = (e, t) => L.call(e, t),
  R = Array.isArray,
  D = (e) => "[object Map]" === H(e),
  k = (e) => "[object Set]" === H(e),
  N = (e) => e instanceof Date,
  O = (e) => "function" == typeof e,
  F = (e) => "string" == typeof e,
  z = (e) => "symbol" == typeof e,
  U = (e) => null !== e && "object" == typeof e,
  B = (e) => U(e) && O(e.then) && O(e.catch),
  V = Object.prototype.toString,
  H = (e) => V.call(e),
  G = (e) => "[object Object]" === H(e),
  W = (e) => F(e) && "NaN" !== e && "-" !== e[0] && "" + parseInt(e, 10) === e,
  q = c(
    ",key,ref,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
  ),
  j = (e) => {
    const t = Object.create(null);
    return (n) => t[n] || (t[n] = e(n));
  },
  Y = /-(\w)/g,
  X = j((e) => e.replace(Y, (e, t) => (t ? t.toUpperCase() : ""))),
  $ = /\B([A-Z])/g,
  Z = j((e) => e.replace($, "-$1").toLowerCase()),
  K = j((e) => e.charAt(0).toUpperCase() + e.slice(1)),
  J = j((e) => (e ? `on${K(e)}` : "")),
  Q = (e, t) => !Object.is(e, t),
  ee = (e, t) => {
    for (let n = 0; n < e.length; n++) e[n](t);
  },
  te = (e, t, n) => {
    Object.defineProperty(e, t, { configurable: !0, enumerable: !1, value: n });
  },
  ne = (e) => {
    const t = parseFloat(e);
    return isNaN(t) ? e : t;
  };
let ie;
let re;
const se = [];
class ae {
  constructor(e = !1) {
    (this.active = !0),
      (this.effects = []),
      (this.cleanups = []),
      !e &&
        re &&
        ((this.parent = re),
        (this.index = (re.scopes || (re.scopes = [])).push(this) - 1));
  }
  run(e) {
    if (this.active)
      try {
        return this.on(), e();
      } finally {
        this.off();
      }
  }
  on() {
    this.active && (se.push(this), (re = this));
  }
  off() {
    this.active && (se.pop(), (re = se[se.length - 1]));
  }
  stop(e) {
    if (this.active) {
      if (
        (this.effects.forEach((e) => e.stop()),
        this.cleanups.forEach((e) => e()),
        this.scopes && this.scopes.forEach((e) => e.stop(!0)),
        this.parent && !e)
      ) {
        const e = this.parent.scopes.pop();
        e &&
          e !== this &&
          ((this.parent.scopes[this.index] = e), (e.index = this.index));
      }
      this.active = !1;
    }
  }
}
const oe = (e) => {
    const t = new Set(e);
    return (t.w = 0), (t.n = 0), t;
  },
  le = (e) => (e.w & de) > 0,
  ce = (e) => (e.n & de) > 0,
  ue = new WeakMap();
let he = 0,
  de = 1;
const pe = [];
let fe;
const me = Symbol(""),
  ge = Symbol("");
class ve {
  constructor(e, t = null, n) {
    (this.fn = e),
      (this.scheduler = t),
      (this.active = !0),
      (this.deps = []),
      (function (e, t) {
        (t = t || re) && t.active && t.effects.push(e);
      })(this, n);
  }
  run() {
    if (!this.active) return this.fn();
    if (!pe.includes(this))
      try {
        return (
          pe.push((fe = this)),
          xe.push(ye),
          (ye = !0),
          (de = 1 << ++he),
          he <= 30
            ? (({ deps: e }) => {
                if (e.length) for (let t = 0; t < e.length; t++) e[t].w |= de;
              })(this)
            : _e(this),
          this.fn()
        );
      } finally {
        he <= 30 &&
          ((e) => {
            const { deps: t } = e;
            if (t.length) {
              let n = 0;
              for (let i = 0; i < t.length; i++) {
                const r = t[i];
                le(r) && !ce(r) ? r.delete(e) : (t[n++] = r),
                  (r.w &= ~de),
                  (r.n &= ~de);
              }
              t.length = n;
            }
          })(this),
          (de = 1 << --he),
          we(),
          pe.pop();
        const e = pe.length;
        fe = e > 0 ? pe[e - 1] : void 0;
      }
  }
  stop() {
    this.active && (_e(this), this.onStop && this.onStop(), (this.active = !1));
  }
}
function _e(e) {
  const { deps: t } = e;
  if (t.length) {
    for (let n = 0; n < t.length; n++) t[n].delete(e);
    t.length = 0;
  }
}
let ye = !0;
const xe = [];
function be() {
  xe.push(ye), (ye = !1);
}
function we() {
  const e = xe.pop();
  ye = void 0 === e || e;
}
function Se(e, t, n) {
  if (!Me()) return;
  let i = ue.get(e);
  i || ue.set(e, (i = new Map()));
  let r = i.get(n);
  r || i.set(n, (r = oe())), Te(r);
}
function Me() {
  return ye && void 0 !== fe;
}
function Te(e, t) {
  let n = !1;
  he <= 30 ? ce(e) || ((e.n |= de), (n = !le(e))) : (n = !e.has(fe)),
    n && (e.add(fe), fe.deps.push(e));
}
function Ce(e, t, n, i, r, s) {
  const a = ue.get(e);
  if (!a) return;
  let o = [];
  if ("clear" === t) o = [...a.values()];
  else if ("length" === n && R(e))
    a.forEach((e, t) => {
      ("length" === t || t >= i) && o.push(e);
    });
  else
    switch ((void 0 !== n && o.push(a.get(n)), t)) {
      case "add":
        R(e)
          ? W(n) && o.push(a.get("length"))
          : (o.push(a.get(me)), D(e) && o.push(a.get(ge)));
        break;
      case "delete":
        R(e) || (o.push(a.get(me)), D(e) && o.push(a.get(ge)));
        break;
      case "set":
        D(e) && o.push(a.get(me));
    }
  if (1 === o.length) o[0] && Ee(o[0]);
  else {
    const e = [];
    for (const t of o) t && e.push(...t);
    Ee(oe(e));
  }
}
function Ee(e, t) {
  for (const n of R(e) ? e : [...e])
    (n !== fe || n.allowRecurse) && (n.scheduler ? n.scheduler() : n.run());
}
const Ae = c("__proto__,__v_isRef,__isVue"),
  Pe = new Set(
    Object.getOwnPropertyNames(Symbol)
      .map((e) => Symbol[e])
      .filter(z)
  ),
  Le = Ne(),
  Ie = Ne(!1, !0),
  Re = Ne(!0),
  De = ke();
function ke() {
  const e = {};
  return (
    ["includes", "indexOf", "lastIndexOf"].forEach((t) => {
      e[t] = function (...e) {
        const n = _t(this);
        for (let t = 0, r = this.length; t < r; t++) Se(n, 0, t + "");
        const i = n[t](...e);
        return -1 === i || !1 === i ? n[t](...e.map(_t)) : i;
      };
    }),
    ["push", "pop", "shift", "unshift", "splice"].forEach((t) => {
      e[t] = function (...e) {
        be();
        const n = _t(this)[t].apply(this, e);
        return we(), n;
      };
    }),
    e
  );
}
function Ne(e = !1, t = !1) {
  return function (n, i, r) {
    if ("__v_isReactive" === i) return !e;
    if ("__v_isReadonly" === i) return e;
    if ("__v_raw" === i && r === (e ? (t ? ut : ct) : t ? lt : ot).get(n))
      return n;
    const s = R(n);
    if (!e && s && I(De, i)) return Reflect.get(De, i, r);
    const a = Reflect.get(n, i, r);
    if (z(i) ? Pe.has(i) : Ae(i)) return a;
    if ((e || Se(n, 0, i), t)) return a;
    if (Mt(a)) {
      return !s || !W(i) ? a.value : a;
    }
    return U(a) ? (e ? pt(a) : dt(a)) : a;
  };
}
function Oe(e = !1) {
  return function (t, n, i, r) {
    let s = t[n];
    if (!e && ((i = _t(i)), (s = _t(s)), !R(t) && Mt(s) && !Mt(i)))
      return (s.value = i), !0;
    const a = R(t) && W(n) ? Number(n) < t.length : I(t, n),
      o = Reflect.set(t, n, i, r);
    return (
      t === _t(r) && (a ? Q(i, s) && Ce(t, "set", n, i) : Ce(t, "add", n, i)), o
    );
  };
}
const Fe = {
    get: Le,
    set: Oe(),
    deleteProperty: function (e, t) {
      const n = I(e, t);
      e[t];
      const i = Reflect.deleteProperty(e, t);
      return i && n && Ce(e, "delete", t, void 0), i;
    },
    has: function (e, t) {
      const n = Reflect.has(e, t);
      return (z(t) && Pe.has(t)) || Se(e, 0, t), n;
    },
    ownKeys: function (e) {
      return Se(e, 0, R(e) ? "length" : me), Reflect.ownKeys(e);
    },
  },
  ze = { get: Re, set: (e, t) => !0, deleteProperty: (e, t) => !0 },
  Ue = A({}, Fe, { get: Ie, set: Oe(!0) }),
  Be = (e) => e,
  Ve = (e) => Reflect.getPrototypeOf(e);
function He(e, t, n = !1, i = !1) {
  const r = _t((e = e.__v_raw)),
    s = _t(t);
  t !== s && !n && Se(r, 0, t), !n && Se(r, 0, s);
  const { has: a } = Ve(r),
    o = i ? Be : n ? bt : xt;
  return a.call(r, t)
    ? o(e.get(t))
    : a.call(r, s)
    ? o(e.get(s))
    : void (e !== r && e.get(t));
}
function Ge(e, t = !1) {
  const n = this.__v_raw,
    i = _t(n),
    r = _t(e);
  return (
    e !== r && !t && Se(i, 0, e),
    !t && Se(i, 0, r),
    e === r ? n.has(e) : n.has(e) || n.has(r)
  );
}
function We(e, t = !1) {
  return (e = e.__v_raw), !t && Se(_t(e), 0, me), Reflect.get(e, "size", e);
}
function qe(e) {
  e = _t(e);
  const t = _t(this);
  return Ve(t).has.call(t, e) || (t.add(e), Ce(t, "add", e, e)), this;
}
function je(e, t) {
  t = _t(t);
  const n = _t(this),
    { has: i, get: r } = Ve(n);
  let s = i.call(n, e);
  s || ((e = _t(e)), (s = i.call(n, e)));
  const a = r.call(n, e);
  return (
    n.set(e, t), s ? Q(t, a) && Ce(n, "set", e, t) : Ce(n, "add", e, t), this
  );
}
function Ye(e) {
  const t = _t(this),
    { has: n, get: i } = Ve(t);
  let r = n.call(t, e);
  r || ((e = _t(e)), (r = n.call(t, e))), i && i.call(t, e);
  const s = t.delete(e);
  return r && Ce(t, "delete", e, void 0), s;
}
function Xe() {
  const e = _t(this),
    t = 0 !== e.size,
    n = e.clear();
  return t && Ce(e, "clear", void 0, void 0), n;
}
function $e(e, t) {
  return function (n, i) {
    const r = this,
      s = r.__v_raw,
      a = _t(s),
      o = t ? Be : e ? bt : xt;
    return !e && Se(a, 0, me), s.forEach((e, t) => n.call(i, o(e), o(t), r));
  };
}
function Ze(e, t, n) {
  return function (...i) {
    const r = this.__v_raw,
      s = _t(r),
      a = D(s),
      o = "entries" === e || (e === Symbol.iterator && a),
      l = "keys" === e && a,
      c = r[e](...i),
      u = n ? Be : t ? bt : xt;
    return (
      !t && Se(s, 0, l ? ge : me),
      {
        next() {
          const { value: e, done: t } = c.next();
          return t
            ? { value: e, done: t }
            : { value: o ? [u(e[0]), u(e[1])] : u(e), done: t };
        },
        [Symbol.iterator]() {
          return this;
        },
      }
    );
  };
}
function Ke(e) {
  return function (...t) {
    return "delete" !== e && this;
  };
}
function Je() {
  const e = {
      get(e) {
        return He(this, e);
      },
      get size() {
        return We(this);
      },
      has: Ge,
      add: qe,
      set: je,
      delete: Ye,
      clear: Xe,
      forEach: $e(!1, !1),
    },
    t = {
      get(e) {
        return He(this, e, !1, !0);
      },
      get size() {
        return We(this);
      },
      has: Ge,
      add: qe,
      set: je,
      delete: Ye,
      clear: Xe,
      forEach: $e(!1, !0),
    },
    n = {
      get(e) {
        return He(this, e, !0);
      },
      get size() {
        return We(this, !0);
      },
      has(e) {
        return Ge.call(this, e, !0);
      },
      add: Ke("add"),
      set: Ke("set"),
      delete: Ke("delete"),
      clear: Ke("clear"),
      forEach: $e(!0, !1),
    },
    i = {
      get(e) {
        return He(this, e, !0, !0);
      },
      get size() {
        return We(this, !0);
      },
      has(e) {
        return Ge.call(this, e, !0);
      },
      add: Ke("add"),
      set: Ke("set"),
      delete: Ke("delete"),
      clear: Ke("clear"),
      forEach: $e(!0, !0),
    };
  return (
    ["keys", "values", "entries", Symbol.iterator].forEach((r) => {
      (e[r] = Ze(r, !1, !1)),
        (n[r] = Ze(r, !0, !1)),
        (t[r] = Ze(r, !1, !0)),
        (i[r] = Ze(r, !0, !0));
    }),
    [e, n, t, i]
  );
}
const [Qe, et, tt, nt] = Je();
function it(e, t) {
  const n = t ? (e ? nt : tt) : e ? et : Qe;
  return (t, i, r) =>
    "__v_isReactive" === i
      ? !e
      : "__v_isReadonly" === i
      ? e
      : "__v_raw" === i
      ? t
      : Reflect.get(I(n, i) && i in t ? n : t, i, r);
}
const rt = { get: it(!1, !1) },
  st = { get: it(!1, !0) },
  at = { get: it(!0, !1) },
  ot = new WeakMap(),
  lt = new WeakMap(),
  ct = new WeakMap(),
  ut = new WeakMap();
function ht(e) {
  return e.__v_skip || !Object.isExtensible(e)
    ? 0
    : (function (e) {
        switch (e) {
          case "Object":
          case "Array":
            return 1;
          case "Map":
          case "Set":
          case "WeakMap":
          case "WeakSet":
            return 2;
          default:
            return 0;
        }
      })(((e) => H(e).slice(8, -1))(e));
}
function dt(e) {
  return e && e.__v_isReadonly ? e : ft(e, !1, Fe, rt, ot);
}
function pt(e) {
  return ft(e, !0, ze, at, ct);
}
function ft(e, t, n, i, r) {
  if (!U(e)) return e;
  if (e.__v_raw && (!t || !e.__v_isReactive)) return e;
  const s = r.get(e);
  if (s) return s;
  const a = ht(e);
  if (0 === a) return e;
  const o = new Proxy(e, 2 === a ? i : n);
  return r.set(e, o), o;
}
function mt(e) {
  return gt(e) ? mt(e.__v_raw) : !(!e || !e.__v_isReactive);
}
function gt(e) {
  return !(!e || !e.__v_isReadonly);
}
function vt(e) {
  return mt(e) || gt(e);
}
function _t(e) {
  const t = e && e.__v_raw;
  return t ? _t(t) : e;
}
function yt(e) {
  return te(e, "__v_skip", !0), e;
}
const xt = (e) => (U(e) ? dt(e) : e),
  bt = (e) => (U(e) ? pt(e) : e);
function wt(e) {
  Me() && ((e = _t(e)).dep || (e.dep = oe()), Te(e.dep));
}
function St(e, t) {
  (e = _t(e)).dep && Ee(e.dep);
}
function Mt(e) {
  return Boolean(e && !0 === e.__v_isRef);
}
function Tt(e) {
  return Ct(e, !1);
}
function Ct(e, t) {
  return Mt(e) ? e : new Et(e, t);
}
class Et {
  constructor(e, t) {
    (this._shallow = t),
      (this.dep = void 0),
      (this.__v_isRef = !0),
      (this._rawValue = t ? e : _t(e)),
      (this._value = t ? e : xt(e));
  }
  get value() {
    return wt(this), this._value;
  }
  set value(e) {
    (e = this._shallow ? e : _t(e)),
      Q(e, this._rawValue) &&
        ((this._rawValue = e),
        (this._value = this._shallow ? e : xt(e)),
        St(this));
  }
}
function At(e) {
  return Mt(e) ? e.value : e;
}
const Pt = {
  get: (e, t, n) => At(Reflect.get(e, t, n)),
  set: (e, t, n, i) => {
    const r = e[t];
    return Mt(r) && !Mt(n) ? ((r.value = n), !0) : Reflect.set(e, t, n, i);
  },
};
function Lt(e) {
  return mt(e) ? e : new Proxy(e, Pt);
}
class It {
  constructor(e, t, n) {
    (this._setter = t),
      (this.dep = void 0),
      (this._dirty = !0),
      (this.__v_isRef = !0),
      (this.effect = new ve(e, () => {
        this._dirty || ((this._dirty = !0), St(this));
      })),
      (this.__v_isReadonly = n);
  }
  get value() {
    const e = _t(this);
    return (
      wt(e),
      e._dirty && ((e._dirty = !1), (e._value = e.effect.run())),
      e._value
    );
  }
  set value(e) {
    this._setter(e);
  }
}
function Rt(e, t) {
  let n, i;
  const r = O(e);
  r ? ((n = e), (i = S)) : ((n = e.get), (i = e.set));
  return new It(n, i, r || !i);
}
function Dt(e, t, ...n) {
  const i = e.vnode.props || b;
  let r = n;
  const s = t.startsWith("update:"),
    a = s && t.slice(7);
  if (a && a in i) {
    const e = `${"modelValue" === a ? "model" : a}Modifiers`,
      { number: t, trim: s } = i[e] || b;
    s ? (r = n.map((e) => e.trim())) : t && (r = n.map(ne));
  }
  let o,
    l = i[(o = J(t))] || i[(o = J(X(t)))];
  !l && s && (l = i[(o = J(Z(t)))]), l && Ji(l, e, 6, r);
  const c = i[o + "Once"];
  if (c) {
    if (e.emitted) {
      if (e.emitted[o]) return;
    } else e.emitted = {};
    (e.emitted[o] = !0), Ji(c, e, 6, r);
  }
}
function kt(e, t, n = !1) {
  const i = t.emitsCache,
    r = i.get(e);
  if (void 0 !== r) return r;
  const s = e.emits;
  let a = {},
    o = !1;
  if (!O(e)) {
    const i = (e) => {
      const n = kt(e, t, !0);
      n && ((o = !0), A(a, n));
    };
    !n && t.mixins.length && t.mixins.forEach(i),
      e.extends && i(e.extends),
      e.mixins && e.mixins.forEach(i);
  }
  return s || o
    ? (R(s) ? s.forEach((e) => (a[e] = null)) : A(a, s), i.set(e, a), a)
    : (i.set(e, null), null);
}
function Nt(e, t) {
  return (
    !(!e || !C(t)) &&
    ((t = t.slice(2).replace(/Once$/, "")),
    I(e, t[0].toLowerCase() + t.slice(1)) || I(e, Z(t)) || I(e, t))
  );
}
Promise.resolve();
let Ot = null,
  Ft = null;
function zt(e) {
  const t = Ot;
  return (Ot = e), (Ft = (e && e.type.__scopeId) || null), t;
}
function Ut(e) {
  Ft = e;
}
function Bt() {
  Ft = null;
}
function Vt(e, t = Ot, n) {
  if (!t) return e;
  if (e._n) return e;
  const i = (...n) => {
    i._d && mi(-1);
    const r = zt(t),
      s = e(...n);
    return zt(r), i._d && mi(1), s;
  };
  return (i._n = !0), (i._c = !0), (i._d = !0), i;
}
function Ht(e) {
  const {
    type: t,
    vnode: n,
    proxy: i,
    withProxy: r,
    props: s,
    propsOptions: [a],
    slots: o,
    attrs: l,
    emit: c,
    render: u,
    renderCache: h,
    data: d,
    setupState: p,
    ctx: f,
    inheritAttrs: m,
  } = e;
  let g, v;
  const _ = zt(e);
  try {
    if (4 & n.shapeFlag) {
      const e = r || i;
      (g = Li(u.call(e, e, h, s, p, d, f))), (v = l);
    } else {
      const e = t;
      0,
        (g = Li(
          e.length > 1 ? e(s, { attrs: l, slots: o, emit: c }) : e(s, null)
        )),
        (v = t.props ? l : Gt(l));
    }
  } catch (x) {
    (hi.length = 0), Qi(x, e, 1), (g = Ti(ci));
  }
  let y = g;
  if (v && !1 !== m) {
    const e = Object.keys(v),
      { shapeFlag: t } = y;
    e.length && 7 & t && (a && e.some(E) && (v = Wt(v, a)), (y = Ci(y, v)));
  }
  return (
    n.dirs && (y.dirs = y.dirs ? y.dirs.concat(n.dirs) : n.dirs),
    n.transition && (y.transition = n.transition),
    (g = y),
    zt(_),
    g
  );
}
const Gt = (e) => {
    let t;
    for (const n in e)
      ("class" === n || "style" === n || C(n)) && ((t || (t = {}))[n] = e[n]);
    return t;
  },
  Wt = (e, t) => {
    const n = {};
    for (const i in e) (E(i) && i.slice(9) in t) || (n[i] = e[i]);
    return n;
  };
function qt(e, t, n) {
  const i = Object.keys(t);
  if (i.length !== Object.keys(e).length) return !0;
  for (let r = 0; r < i.length; r++) {
    const s = i[r];
    if (t[s] !== e[s] && !Nt(n, s)) return !0;
  }
  return !1;
}
function jt(e, t) {
  if (Hi) {
    let n = Hi.provides;
    const i = Hi.parent && Hi.parent.provides;
    i === n && (n = Hi.provides = Object.create(i)), (n[e] = t);
  } else;
}
function Yt(e, t, n = !1) {
  const i = Hi || Ot;
  if (i) {
    const r =
      null == i.parent
        ? i.vnode.appContext && i.vnode.appContext.provides
        : i.parent.provides;
    if (r && e in r) return r[e];
    if (arguments.length > 1) return n && O(t) ? t.call(i.proxy) : t;
  }
}
const Xt = [Function, Array],
  $t = {
    name: "BaseTransition",
    props: {
      mode: String,
      appear: Boolean,
      persisted: Boolean,
      onBeforeEnter: Xt,
      onEnter: Xt,
      onAfterEnter: Xt,
      onEnterCancelled: Xt,
      onBeforeLeave: Xt,
      onLeave: Xt,
      onAfterLeave: Xt,
      onLeaveCancelled: Xt,
      onBeforeAppear: Xt,
      onAppear: Xt,
      onAfterAppear: Xt,
      onAppearCancelled: Xt,
    },
    setup(e, { slots: t }) {
      const n = Gi(),
        i = (function () {
          const e = {
            isMounted: !1,
            isLeaving: !1,
            isUnmounting: !1,
            leavingVNodes: new Map(),
          };
          return (
            pn(() => {
              e.isMounted = !0;
            }),
            gn(() => {
              e.isUnmounting = !0;
            }),
            e
          );
        })();
      let r;
      return () => {
        const s = t.default && tn(t.default(), !0);
        if (!s || !s.length) return;
        const a = _t(e),
          { mode: o } = a,
          l = s[0];
        if (i.isLeaving) return Jt(l);
        const c = Qt(l);
        if (!c) return Jt(l);
        const u = Kt(c, a, i, n);
        en(c, u);
        const h = n.subTree,
          d = h && Qt(h);
        let p = !1;
        const { getTransitionKey: f } = c.type;
        if (f) {
          const e = f();
          void 0 === r ? (r = e) : e !== r && ((r = e), (p = !0));
        }
        if (d && d.type !== ci && (!xi(c, d) || p)) {
          const e = Kt(d, a, i, n);
          if ((en(d, e), "out-in" === o))
            return (
              (i.isLeaving = !0),
              (e.afterLeave = () => {
                (i.isLeaving = !1), n.update();
              }),
              Jt(l)
            );
          "in-out" === o &&
            c.type !== ci &&
            (e.delayLeave = (e, t, n) => {
              (Zt(i, d)[String(d.key)] = d),
                (e._leaveCb = () => {
                  t(), (e._leaveCb = void 0), delete u.delayedLeave;
                }),
                (u.delayedLeave = n);
            });
        }
        return l;
      };
    },
  };
function Zt(e, t) {
  const { leavingVNodes: n } = e;
  let i = n.get(t.type);
  return i || ((i = Object.create(null)), n.set(t.type, i)), i;
}
function Kt(e, t, n, i) {
  const {
      appear: r,
      mode: s,
      persisted: a = !1,
      onBeforeEnter: o,
      onEnter: l,
      onAfterEnter: c,
      onEnterCancelled: u,
      onBeforeLeave: h,
      onLeave: d,
      onAfterLeave: p,
      onLeaveCancelled: f,
      onBeforeAppear: m,
      onAppear: g,
      onAfterAppear: v,
      onAppearCancelled: _,
    } = t,
    y = String(e.key),
    x = Zt(n, e),
    b = (e, t) => {
      e && Ji(e, i, 9, t);
    },
    w = {
      mode: s,
      persisted: a,
      beforeEnter(t) {
        let i = o;
        if (!n.isMounted) {
          if (!r) return;
          i = m || o;
        }
        t._leaveCb && t._leaveCb(!0);
        const s = x[y];
        s && xi(e, s) && s.el._leaveCb && s.el._leaveCb(), b(i, [t]);
      },
      enter(e) {
        let t = l,
          i = c,
          s = u;
        if (!n.isMounted) {
          if (!r) return;
          (t = g || l), (i = v || c), (s = _ || u);
        }
        let a = !1;
        const o = (e._enterCb = (t) => {
          a ||
            ((a = !0),
            b(t ? s : i, [e]),
            w.delayedLeave && w.delayedLeave(),
            (e._enterCb = void 0));
        });
        t ? (t(e, o), t.length <= 1 && o()) : o();
      },
      leave(t, i) {
        const r = String(e.key);
        if ((t._enterCb && t._enterCb(!0), n.isUnmounting)) return i();
        b(h, [t]);
        let s = !1;
        const a = (t._leaveCb = (n) => {
          s ||
            ((s = !0),
            i(),
            b(n ? f : p, [t]),
            (t._leaveCb = void 0),
            x[r] === e && delete x[r]);
        });
        (x[r] = e), d ? (d(t, a), d.length <= 1 && a()) : a();
      },
      clone: (e) => Kt(e, t, n, i),
    };
  return w;
}
function Jt(e) {
  if (sn(e)) return ((e = Ci(e)).children = null), e;
}
function Qt(e) {
  return sn(e) ? (e.children ? e.children[0] : void 0) : e;
}
function en(e, t) {
  6 & e.shapeFlag && e.component
    ? en(e.component.subTree, t)
    : 128 & e.shapeFlag
    ? ((e.ssContent.transition = t.clone(e.ssContent)),
      (e.ssFallback.transition = t.clone(e.ssFallback)))
    : (e.transition = t);
}
function tn(e, t = !1) {
  let n = [],
    i = 0;
  for (let r = 0; r < e.length; r++) {
    const s = e[r];
    s.type === oi
      ? (128 & s.patchFlag && i++, (n = n.concat(tn(s.children, t))))
      : (t || s.type !== ci) && n.push(s);
  }
  if (i > 1) for (let r = 0; r < n.length; r++) n[r].patchFlag = -2;
  return n;
}
function nn(e) {
  return O(e) ? { setup: e, name: e.name } : e;
}
const rn = (e) => !!e.type.__asyncLoader,
  sn = (e) => e.type.__isKeepAlive;
function an(e, t) {
  ln(e, "a", t);
}
function on(e, t) {
  ln(e, "da", t);
}
function ln(e, t, n = Hi) {
  const i =
    e.__wdc ||
    (e.__wdc = () => {
      let t = n;
      for (; t; ) {
        if (t.isDeactivated) return;
        t = t.parent;
      }
      e();
    });
  if ((un(t, i, n), n)) {
    let e = n.parent;
    for (; e && e.parent; )
      sn(e.parent.vnode) && cn(i, t, n, e), (e = e.parent);
  }
}
function cn(e, t, n, i) {
  const r = un(t, e, i, !0);
  vn(() => {
    P(i[t], r);
  }, n);
}
function un(e, t, n = Hi, i = !1) {
  if (n) {
    const r = n[e] || (n[e] = []),
      s =
        t.__weh ||
        (t.__weh = (...i) => {
          if (n.isUnmounted) return;
          be(), Wi(n);
          const r = Ji(t, n, e, i);
          return qi(), we(), r;
        });
    return i ? r.unshift(s) : r.push(s), s;
  }
}
const hn =
    (e) =>
    (t, n = Hi) =>
      (!Yi || "sp" === e) && un(e, t, n),
  dn = hn("bm"),
  pn = hn("m"),
  fn = hn("bu"),
  mn = hn("u"),
  gn = hn("bum"),
  vn = hn("um"),
  _n = hn("sp"),
  yn = hn("rtg"),
  xn = hn("rtc");
function bn(e, t = Hi) {
  un("ec", e, t);
}
let wn = !0;
function Sn(e) {
  const t = Cn(e),
    n = e.proxy,
    i = e.ctx;
  (wn = !1), t.beforeCreate && Mn(t.beforeCreate, e, "bc");
  const {
    data: r,
    computed: s,
    methods: a,
    watch: o,
    provide: l,
    inject: c,
    created: u,
    beforeMount: h,
    mounted: d,
    beforeUpdate: p,
    updated: f,
    activated: m,
    deactivated: g,
    beforeDestroy: v,
    beforeUnmount: _,
    destroyed: y,
    unmounted: x,
    render: b,
    renderTracked: w,
    renderTriggered: M,
    errorCaptured: T,
    serverPrefetch: C,
    expose: E,
    inheritAttrs: A,
    components: P,
    directives: L,
    filters: I,
  } = t;
  if (
    (c &&
      (function (e, t, n = S, i = !1) {
        R(e) && (e = Ln(e));
        for (const r in e) {
          const n = e[r];
          let s;
          (s = U(n)
            ? "default" in n
              ? Yt(n.from || r, n.default, !0)
              : Yt(n.from || r)
            : Yt(n)),
            Mt(s) && i
              ? Object.defineProperty(t, r, {
                  enumerable: !0,
                  configurable: !0,
                  get: () => s.value,
                  set: (e) => (s.value = e),
                })
              : (t[r] = s);
        }
      })(c, i, null, e.appContext.config.unwrapInjectedRef),
    a)
  )
    for (const S in a) {
      const e = a[S];
      O(e) && (i[S] = e.bind(n));
    }
  if (r) {
    const t = r.call(n, n);
    U(t) && (e.data = dt(t));
  }
  if (((wn = !0), s))
    for (const R in s) {
      const e = s[R],
        t = Rt({
          get: O(e) ? e.bind(n, n) : O(e.get) ? e.get.bind(n, n) : S,
          set: !O(e) && O(e.set) ? e.set.bind(n) : S,
        });
      Object.defineProperty(i, R, {
        enumerable: !0,
        configurable: !0,
        get: () => t.value,
        set: (e) => (t.value = e),
      });
    }
  if (o) for (const S in o) Tn(o[S], i, n, S);
  if (l) {
    const e = O(l) ? l.call(n) : l;
    Reflect.ownKeys(e).forEach((t) => {
      jt(t, e[t]);
    });
  }
  function D(e, t) {
    R(t) ? t.forEach((t) => e(t.bind(n))) : t && e(t.bind(n));
  }
  if (
    (u && Mn(u, e, "c"),
    D(dn, h),
    D(pn, d),
    D(fn, p),
    D(mn, f),
    D(an, m),
    D(on, g),
    D(bn, T),
    D(xn, w),
    D(yn, M),
    D(gn, _),
    D(vn, x),
    D(_n, C),
    R(E))
  )
    if (E.length) {
      const t = e.exposed || (e.exposed = {});
      E.forEach((e) => {
        Object.defineProperty(t, e, {
          get: () => n[e],
          set: (t) => (n[e] = t),
        });
      });
    } else e.exposed || (e.exposed = {});
  b && e.render === S && (e.render = b),
    null != A && (e.inheritAttrs = A),
    P && (e.components = P),
    L && (e.directives = L);
}
function Mn(e, t, n) {
  Ji(R(e) ? e.map((e) => e.bind(t.proxy)) : e.bind(t.proxy), t, n);
}
function Tn(e, t, n, i) {
  const r = i.includes(".") ? Cr(n, i) : () => n[i];
  if (F(e)) {
    const n = t[e];
    O(n) && Sr(r, n);
  } else if (O(e)) Sr(r, e.bind(n));
  else if (U(e))
    if (R(e)) e.forEach((e) => Tn(e, t, n, i));
    else {
      const i = O(e.handler) ? e.handler.bind(n) : t[e.handler];
      O(i) && Sr(r, i, e);
    }
}
function Cn(e) {
  const t = e.type,
    { mixins: n, extends: i } = t,
    {
      mixins: r,
      optionsCache: s,
      config: { optionMergeStrategies: a },
    } = e.appContext,
    o = s.get(t);
  let l;
  return (
    o
      ? (l = o)
      : r.length || n || i
      ? ((l = {}), r.length && r.forEach((e) => En(l, e, a, !0)), En(l, t, a))
      : (l = t),
    s.set(t, l),
    l
  );
}
function En(e, t, n, i = !1) {
  const { mixins: r, extends: s } = t;
  s && En(e, s, n, !0), r && r.forEach((t) => En(e, t, n, !0));
  for (const a in t)
    if (i && "expose" === a);
    else {
      const i = An[a] || (n && n[a]);
      e[a] = i ? i(e[a], t[a]) : t[a];
    }
  return e;
}
const An = {
  data: Pn,
  props: Rn,
  emits: Rn,
  methods: Rn,
  computed: Rn,
  beforeCreate: In,
  created: In,
  beforeMount: In,
  mounted: In,
  beforeUpdate: In,
  updated: In,
  beforeDestroy: In,
  beforeUnmount: In,
  destroyed: In,
  unmounted: In,
  activated: In,
  deactivated: In,
  errorCaptured: In,
  serverPrefetch: In,
  components: Rn,
  directives: Rn,
  watch: function (e, t) {
    if (!e) return t;
    if (!t) return e;
    const n = A(Object.create(null), e);
    for (const i in t) n[i] = In(e[i], t[i]);
    return n;
  },
  provide: Pn,
  inject: function (e, t) {
    return Rn(Ln(e), Ln(t));
  },
};
function Pn(e, t) {
  return t
    ? e
      ? function () {
          return A(
            O(e) ? e.call(this, this) : e,
            O(t) ? t.call(this, this) : t
          );
        }
      : t
    : e;
}
function Ln(e) {
  if (R(e)) {
    const t = {};
    for (let n = 0; n < e.length; n++) t[e[n]] = e[n];
    return t;
  }
  return e;
}
function In(e, t) {
  return e ? [...new Set([].concat(e, t))] : t;
}
function Rn(e, t) {
  return e ? A(A(Object.create(null), e), t) : t;
}
function Dn(e, t, n, i = !1) {
  const r = {},
    s = {};
  te(s, bi, 1), (e.propsDefaults = Object.create(null)), kn(e, t, r, s);
  for (const a in e.propsOptions[0]) a in r || (r[a] = void 0);
  n
    ? (e.props = i ? r : ft(r, !1, Ue, st, lt))
    : e.type.props
    ? (e.props = r)
    : (e.props = s),
    (e.attrs = s);
}
function kn(e, t, n, i) {
  const [r, s] = e.propsOptions;
  let a,
    o = !1;
  if (t)
    for (let l in t) {
      if (q(l)) continue;
      const c = t[l];
      let u;
      r && I(r, (u = X(l)))
        ? s && s.includes(u)
          ? ((a || (a = {}))[u] = c)
          : (n[u] = c)
        : Nt(e.emitsOptions, l) || (c !== i[l] && ((i[l] = c), (o = !0)));
    }
  if (s) {
    const t = _t(n),
      i = a || b;
    for (let a = 0; a < s.length; a++) {
      const o = s[a];
      n[o] = Nn(r, t, o, i[o], e, !I(i, o));
    }
  }
  return o;
}
function Nn(e, t, n, i, r, s) {
  const a = e[n];
  if (null != a) {
    const e = I(a, "default");
    if (e && void 0 === i) {
      const e = a.default;
      if (a.type !== Function && O(e)) {
        const { propsDefaults: s } = r;
        n in s ? (i = s[n]) : (Wi(r), (i = s[n] = e.call(null, t)), qi());
      } else i = e;
    }
    a[0] &&
      (s && !e ? (i = !1) : !a[1] || ("" !== i && i !== Z(n)) || (i = !0));
  }
  return i;
}
function On(e, t, n = !1) {
  const i = t.propsCache,
    r = i.get(e);
  if (r) return r;
  const s = e.props,
    a = {},
    o = [];
  let l = !1;
  if (!O(e)) {
    const i = (e) => {
      l = !0;
      const [n, i] = On(e, t, !0);
      A(a, n), i && o.push(...i);
    };
    !n && t.mixins.length && t.mixins.forEach(i),
      e.extends && i(e.extends),
      e.mixins && e.mixins.forEach(i);
  }
  if (!s && !l) return i.set(e, w), w;
  if (R(s))
    for (let u = 0; u < s.length; u++) {
      const e = X(s[u]);
      Fn(e) && (a[e] = b);
    }
  else if (s)
    for (const u in s) {
      const e = X(u);
      if (Fn(e)) {
        const t = s[u],
          n = (a[e] = R(t) || O(t) ? { type: t } : t);
        if (n) {
          const t = Bn(Boolean, n.type),
            i = Bn(String, n.type);
          (n[0] = t > -1),
            (n[1] = i < 0 || t < i),
            (t > -1 || I(n, "default")) && o.push(e);
        }
      }
    }
  const c = [a, o];
  return i.set(e, c), c;
}
function Fn(e) {
  return "$" !== e[0];
}
function zn(e) {
  const t = e && e.toString().match(/^\s*function (\w+)/);
  return t ? t[1] : null === e ? "null" : "";
}
function Un(e, t) {
  return zn(e) === zn(t);
}
function Bn(e, t) {
  return R(t) ? t.findIndex((t) => Un(t, e)) : O(t) && Un(t, e) ? 0 : -1;
}
const Vn = (e) => "_" === e[0] || "$stable" === e,
  Hn = (e) => (R(e) ? e.map(Li) : [Li(e)]),
  Gn = (e, t, n) => {
    const i = Vt((...e) => Hn(t(...e)), n);
    return (i._c = !1), i;
  },
  Wn = (e, t, n) => {
    const i = e._ctx;
    for (const r in e) {
      if (Vn(r)) continue;
      const n = e[r];
      if (O(n)) t[r] = Gn(0, n, i);
      else if (null != n) {
        const e = Hn(n);
        t[r] = () => e;
      }
    }
  },
  qn = (e, t) => {
    const n = Hn(t);
    e.slots.default = () => n;
  };
function jn(e, t) {
  if (null === Ot) return e;
  const n = Ot.proxy,
    i = e.dirs || (e.dirs = []);
  for (let r = 0; r < t.length; r++) {
    let [e, s, a, o = b] = t[r];
    O(e) && (e = { mounted: e, updated: e }),
      e.deep && Er(s),
      i.push({
        dir: e,
        instance: n,
        value: s,
        oldValue: void 0,
        arg: a,
        modifiers: o,
      });
  }
  return e;
}
function Yn(e, t, n, i) {
  const r = e.dirs,
    s = t && t.dirs;
  for (let a = 0; a < r.length; a++) {
    const o = r[a];
    s && (o.oldValue = s[a].value);
    let l = o.dir[i];
    l && (be(), Ji(l, n, 8, [e.el, o, e, t]), we());
  }
}
function Xn() {
  return {
    app: null,
    config: {
      isNativeTag: M,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {},
    },
    mixins: [],
    components: {},
    directives: {},
    provides: Object.create(null),
    optionsCache: new WeakMap(),
    propsCache: new WeakMap(),
    emitsCache: new WeakMap(),
  };
}
let $n = 0;
function Zn(e, t) {
  return function (n, i = null) {
    null == i || U(i) || (i = null);
    const r = Xn(),
      s = new Set();
    let a = !1;
    const o = (r.app = {
      _uid: $n++,
      _component: n,
      _props: i,
      _container: null,
      _context: r,
      _instance: null,
      version: Pr,
      get config() {
        return r.config;
      },
      set config(e) {},
      use: (e, ...t) => (
        s.has(e) ||
          (e && O(e.install)
            ? (s.add(e), e.install(o, ...t))
            : O(e) && (s.add(e), e(o, ...t))),
        o
      ),
      mixin: (e) => (r.mixins.includes(e) || r.mixins.push(e), o),
      component: (e, t) => (t ? ((r.components[e] = t), o) : r.components[e]),
      directive: (e, t) => (t ? ((r.directives[e] = t), o) : r.directives[e]),
      mount(s, l, c) {
        if (!a) {
          const u = Ti(n, i);
          return (
            (u.appContext = r),
            l && t ? t(u, s) : e(u, s, c),
            (a = !0),
            (o._container = s),
            (s.__vue_app__ = o),
            Zi(u.component) || u.component.proxy
          );
        }
      },
      unmount() {
        a && (e(null, o._container), delete o._container.__vue_app__);
      },
      provide: (e, t) => ((r.provides[e] = t), o),
    });
    return o;
  };
}
const Kn = function (e, t) {
  t && t.pendingBranch
    ? R(e)
      ? t.effects.push(...e)
      : t.effects.push(e)
    : gr(e, lr, or, cr);
};
function Jn(e) {
  return (function (e, t) {
    (
      ie ||
      (ie =
        "undefined" != typeof globalThis
          ? globalThis
          : "undefined" != typeof self
          ? self
          : "undefined" != typeof window
          ? window
          : "undefined" != typeof global
          ? global
          : {})
    ).__VUE__ = !0;
    const {
        insert: n,
        remove: i,
        patchProp: r,
        createElement: s,
        createText: a,
        createComment: o,
        setText: l,
        setElementText: c,
        parentNode: u,
        nextSibling: h,
        setScopeId: d = S,
        cloneNode: p,
        insertStaticContent: f,
      } = e,
      m = (
        e,
        t,
        n,
        i = null,
        r = null,
        s = null,
        a = !1,
        o = null,
        l = !!t.dynamicChildren
      ) => {
        if (e === t) return;
        e && !xi(e, t) && ((i = J(e)), W(e, r, s, !0), (e = null)),
          -2 === t.patchFlag && ((l = !1), (t.dynamicChildren = null));
        const { type: c, ref: u, shapeFlag: h } = t;
        switch (c) {
          case li:
            g(e, t, n, i);
            break;
          case ci:
            v(e, t, n, i);
            break;
          case ui:
            null == e && _(t, n, i, a);
            break;
          case oi:
            D(e, t, n, i, r, s, a, o, l);
            break;
          default:
            1 & h
              ? M(e, t, n, i, r, s, a, o, l)
              : 6 & h
              ? k(e, t, n, i, r, s, a, o, l)
              : (64 & h || 128 & h) && c.process(e, t, n, i, r, s, a, o, l, ne);
        }
        null != u && r && Qn(u, e && e.ref, s, t || e, !t);
      },
      g = (e, t, i, r) => {
        if (null == e) n((t.el = a(t.children)), i, r);
        else {
          const n = (t.el = e.el);
          t.children !== e.children && l(n, t.children);
        }
      },
      v = (e, t, i, r) => {
        null == e ? n((t.el = o(t.children || "")), i, r) : (t.el = e.el);
      },
      _ = (e, t, n, i) => {
        [e.el, e.anchor] = f(e.children, t, n, i);
      },
      y = ({ el: e, anchor: t }, i, r) => {
        let s;
        for (; e && e !== t; ) (s = h(e)), n(e, i, r), (e = s);
        n(t, i, r);
      },
      x = ({ el: e, anchor: t }) => {
        let n;
        for (; e && e !== t; ) (n = h(e)), i(e), (e = n);
        i(t);
      },
      M = (e, t, n, i, r, s, a, o, l) => {
        (a = a || "svg" === t.type),
          null == e ? T(t, n, i, r, s, a, o, l) : P(e, t, r, s, a, o, l);
      },
      T = (e, t, i, a, o, l, u, h) => {
        let d, f;
        const {
          type: m,
          props: g,
          shapeFlag: v,
          transition: _,
          patchFlag: y,
          dirs: x,
        } = e;
        if (e.el && void 0 !== p && -1 === y) d = e.el = p(e.el);
        else {
          if (
            ((d = e.el = s(e.type, l, g && g.is, g)),
            8 & v
              ? c(d, e.children)
              : 16 & v &&
                E(e.children, d, null, a, o, l && "foreignObject" !== m, u, h),
            x && Yn(e, null, a, "created"),
            g)
          ) {
            for (const t in g)
              "value" === t ||
                q(t) ||
                r(d, t, null, g[t], l, e.children, a, o, K);
            "value" in g && r(d, "value", null, g.value),
              (f = g.onVnodeBeforeMount) && ei(f, a, e);
          }
          C(d, e, e.scopeId, u, a);
        }
        x && Yn(e, null, a, "beforeMount");
        const b = (!o || (o && !o.pendingBranch)) && _ && !_.persisted;
        b && _.beforeEnter(d),
          n(d, t, i),
          ((f = g && g.onVnodeMounted) || b || x) &&
            Kn(() => {
              f && ei(f, a, e), b && _.enter(d), x && Yn(e, null, a, "mounted");
            }, o);
      },
      C = (e, t, n, i, r) => {
        if ((n && d(e, n), i)) for (let s = 0; s < i.length; s++) d(e, i[s]);
        if (r) {
          if (t === r.subTree) {
            const t = r.vnode;
            C(e, t, t.scopeId, t.slotScopeIds, r.parent);
          }
        }
      },
      E = (e, t, n, i, r, s, a, o, l = 0) => {
        for (let c = l; c < e.length; c++) {
          const l = (e[c] = o ? Ii(e[c]) : Li(e[c]));
          m(null, l, t, n, i, r, s, a, o);
        }
      },
      P = (e, t, n, i, s, a, o) => {
        const l = (t.el = e.el);
        let { patchFlag: u, dynamicChildren: h, dirs: d } = t;
        u |= 16 & e.patchFlag;
        const p = e.props || b,
          f = t.props || b;
        let m;
        (m = f.onVnodeBeforeUpdate) && ei(m, n, t, e),
          d && Yn(t, e, n, "beforeUpdate");
        const g = s && "foreignObject" !== t.type;
        if (
          (h
            ? L(e.dynamicChildren, h, l, n, i, g, a)
            : o || U(e, t, l, null, n, i, g, a, !1),
          u > 0)
        ) {
          if (16 & u) R(l, t, p, f, n, i, s);
          else if (
            (2 & u && p.class !== f.class && r(l, "class", null, f.class, s),
            4 & u && r(l, "style", p.style, f.style, s),
            8 & u)
          ) {
            const a = t.dynamicProps;
            for (let t = 0; t < a.length; t++) {
              const o = a[t],
                c = p[o],
                u = f[o];
              (u === c && "value" !== o) ||
                r(l, o, c, u, s, e.children, n, i, K);
            }
          }
          1 & u && e.children !== t.children && c(l, t.children);
        } else o || null != h || R(l, t, p, f, n, i, s);
        ((m = f.onVnodeUpdated) || d) &&
          Kn(() => {
            m && ei(m, n, t, e), d && Yn(t, e, n, "updated");
          }, i);
      },
      L = (e, t, n, i, r, s, a) => {
        for (let o = 0; o < t.length; o++) {
          const l = e[o],
            c = t[o],
            h =
              l.el && (l.type === oi || !xi(l, c) || 70 & l.shapeFlag)
                ? u(l.el)
                : n;
          m(l, c, h, null, i, r, s, a, !0);
        }
      },
      R = (e, t, n, i, s, a, o) => {
        if (n !== i) {
          for (const l in i) {
            if (q(l)) continue;
            const c = i[l],
              u = n[l];
            c !== u && "value" !== l && r(e, l, u, c, o, t.children, s, a, K);
          }
          if (n !== b)
            for (const l in n)
              q(l) || l in i || r(e, l, n[l], null, o, t.children, s, a, K);
          "value" in i && r(e, "value", n.value, i.value);
        }
      },
      D = (e, t, i, r, s, o, l, c, u) => {
        const h = (t.el = e ? e.el : a("")),
          d = (t.anchor = e ? e.anchor : a(""));
        let { patchFlag: p, dynamicChildren: f, slotScopeIds: m } = t;
        m && (c = c ? c.concat(m) : m),
          null == e
            ? (n(h, i, r), n(d, i, r), E(t.children, i, d, s, o, l, c, u))
            : p > 0 && 64 & p && f && e.dynamicChildren
            ? (L(e.dynamicChildren, f, i, s, o, l, c),
              (null != t.key || (s && t === s.subTree)) && ti(e, t, !0))
            : U(e, t, i, d, s, o, l, c, u);
      },
      k = (e, t, n, i, r, s, a, o, l) => {
        (t.slotScopeIds = o),
          null == e
            ? 512 & t.shapeFlag
              ? r.ctx.activate(t, n, i, a, l)
              : N(t, n, i, r, s, a, l)
            : O(e, t, l);
      },
      N = (e, t, n, i, r, s, a) => {
        const o = (e.component = (function (e, t, n) {
          const i = e.type,
            r = (t ? t.appContext : e.appContext) || Bi,
            s = {
              uid: Vi++,
              vnode: e,
              type: i,
              parent: t,
              appContext: r,
              root: null,
              next: null,
              subTree: null,
              update: null,
              scope: new ae(!0),
              render: null,
              proxy: null,
              exposed: null,
              exposeProxy: null,
              withProxy: null,
              provides: t ? t.provides : Object.create(r.provides),
              accessCache: null,
              renderCache: [],
              components: null,
              directives: null,
              propsOptions: On(i, r),
              emitsOptions: kt(i, r),
              emit: null,
              emitted: null,
              propsDefaults: b,
              inheritAttrs: i.inheritAttrs,
              ctx: b,
              data: b,
              props: b,
              attrs: b,
              slots: b,
              refs: b,
              setupState: b,
              setupContext: null,
              suspense: n,
              suspenseId: n ? n.pendingId : 0,
              asyncDep: null,
              asyncResolved: !1,
              isMounted: !1,
              isUnmounted: !1,
              isDeactivated: !1,
              bc: null,
              c: null,
              bm: null,
              m: null,
              bu: null,
              u: null,
              um: null,
              bum: null,
              da: null,
              a: null,
              rtg: null,
              rtc: null,
              ec: null,
              sp: null,
            };
          (s.ctx = { _: s }),
            (s.root = t ? t.root : s),
            (s.emit = Dt.bind(null, s)),
            e.ce && e.ce(s);
          return s;
        })(e, i, r));
        if (
          (sn(e) && (o.ctx.renderer = ne),
          (function (e, t = !1) {
            Yi = t;
            const { props: n, children: i } = e.vnode,
              r = ji(e);
            Dn(e, n, r, t),
              ((e, t) => {
                if (32 & e.vnode.shapeFlag) {
                  const n = t._;
                  n
                    ? ((e.slots = _t(t)), te(t, "_", n))
                    : Wn(t, (e.slots = {}));
                } else (e.slots = {}), t && qn(e, t);
                te(e.slots, bi, 1);
              })(e, i);
            const s = r
              ? (function (e, t) {
                  const n = e.type;
                  (e.accessCache = Object.create(null)),
                    (e.proxy = yt(new Proxy(e.ctx, Ui)));
                  const { setup: i } = n;
                  if (i) {
                    const n = (e.setupContext =
                      i.length > 1
                        ? (function (e) {
                            const t = (t) => {
                              e.exposed = t || {};
                            };
                            let n;
                            return {
                              get attrs() {
                                return (
                                  n ||
                                  (n = (function (e) {
                                    return new Proxy(e.attrs, {
                                      get: (t, n) => (Se(e, 0, "$attrs"), t[n]),
                                    });
                                  })(e))
                                );
                              },
                              slots: e.slots,
                              emit: e.emit,
                              expose: t,
                            };
                          })(e)
                        : null);
                    Wi(e), be();
                    const r = Ki(i, e, 0, [e.props, n]);
                    if ((we(), qi(), B(r))) {
                      if ((r.then(qi, qi), t))
                        return r
                          .then((n) => {
                            Xi(e, n, t);
                          })
                          .catch((t) => {
                            Qi(t, e, 0);
                          });
                      e.asyncDep = r;
                    } else Xi(e, r, t);
                  } else $i(e, t);
                })(e, t)
              : void 0;
            Yi = !1;
          })(o),
          o.asyncDep)
        ) {
          if ((r && r.registerDep(o, F), !e.el)) {
            const e = (o.subTree = Ti(ci));
            v(null, e, t, n);
          }
        } else F(o, e, t, n, r, s, a);
      },
      O = (e, t, n) => {
        const i = (t.component = e.component);
        if (
          (function (e, t, n) {
            const { props: i, children: r, component: s } = e,
              { props: a, children: o, patchFlag: l } = t,
              c = s.emitsOptions;
            if (t.dirs || t.transition) return !0;
            if (!(n && l >= 0))
              return (
                !((!r && !o) || (o && o.$stable)) ||
                (i !== a && (i ? !a || qt(i, a, c) : !!a))
              );
            if (1024 & l) return !0;
            if (16 & l) return i ? qt(i, a, c) : !!a;
            if (8 & l) {
              const e = t.dynamicProps;
              for (let t = 0; t < e.length; t++) {
                const n = e[t];
                if (a[n] !== i[n] && !Nt(c, n)) return !0;
              }
            }
            return !1;
          })(e, t, n)
        ) {
          if (i.asyncDep && !i.asyncResolved) return void z(i, t, n);
          (i.next = t),
            (function (e) {
              const t = nr.indexOf(e);
              t > ir && nr.splice(t, 1);
            })(i.update),
            i.update();
        } else (t.component = e.component), (t.el = e.el), (i.vnode = t);
      },
      F = (e, t, n, i, r, s, a) => {
        const o = new ve(
            () => {
              if (e.isMounted) {
                let t,
                  { next: n, bu: i, u: l, parent: c, vnode: h } = e,
                  d = n;
                (o.allowRecurse = !1),
                  n ? ((n.el = h.el), z(e, n, a)) : (n = h),
                  i && ee(i),
                  (t = n.props && n.props.onVnodeBeforeUpdate) &&
                    ei(t, c, n, h),
                  (o.allowRecurse = !0);
                const p = Ht(e),
                  f = e.subTree;
                (e.subTree = p),
                  m(f, p, u(f.el), J(f), e, r, s),
                  (n.el = p.el),
                  null === d &&
                    (function ({ vnode: e, parent: t }, n) {
                      for (; t && t.subTree === e; )
                        ((e = t.vnode).el = n), (t = t.parent);
                    })(e, p.el),
                  l && Kn(l, r),
                  (t = n.props && n.props.onVnodeUpdated) &&
                    Kn(() => ei(t, c, n, h), r);
              } else {
                let a;
                const { el: l, props: c } = t,
                  { bm: u, m: h, parent: d } = e,
                  p = rn(t);
                if (
                  ((o.allowRecurse = !1),
                  u && ee(u),
                  !p && (a = c && c.onVnodeBeforeMount) && ei(a, d, t),
                  (o.allowRecurse = !0),
                  l && se)
                ) {
                  const n = () => {
                    (e.subTree = Ht(e)), se(l, e.subTree, e, r, null);
                  };
                  p
                    ? t.type.__asyncLoader().then(() => !e.isUnmounted && n())
                    : n();
                } else {
                  const a = (e.subTree = Ht(e));
                  m(null, a, n, i, e, r, s), (t.el = a.el);
                }
                if ((h && Kn(h, r), !p && (a = c && c.onVnodeMounted))) {
                  const e = t;
                  Kn(() => ei(a, d, e), r);
                }
                256 & t.shapeFlag && e.a && Kn(e.a, r),
                  (e.isMounted = !0),
                  (t = n = i = null);
              }
            },
            () => fr(e.update),
            e.scope
          ),
          l = (e.update = o.run.bind(o));
        (l.id = e.uid), (o.allowRecurse = l.allowRecurse = !0), l();
      },
      z = (e, t, n) => {
        t.component = e;
        const i = e.vnode.props;
        (e.vnode = t),
          (e.next = null),
          (function (e, t, n, i) {
            const {
                props: r,
                attrs: s,
                vnode: { patchFlag: a },
              } = e,
              o = _t(r),
              [l] = e.propsOptions;
            let c = !1;
            if (!(i || a > 0) || 16 & a) {
              let i;
              kn(e, t, r, s) && (c = !0);
              for (const s in o)
                (t && (I(t, s) || ((i = Z(s)) !== s && I(t, i)))) ||
                  (l
                    ? !n ||
                      (void 0 === n[s] && void 0 === n[i]) ||
                      (r[s] = Nn(l, o, s, void 0, e, !0))
                    : delete r[s]);
              if (s !== o)
                for (const e in s) (t && I(t, e)) || (delete s[e], (c = !0));
            } else if (8 & a) {
              const n = e.vnode.dynamicProps;
              for (let i = 0; i < n.length; i++) {
                let a = n[i];
                const u = t[a];
                if (l)
                  if (I(s, a)) u !== s[a] && ((s[a] = u), (c = !0));
                  else {
                    const t = X(a);
                    r[t] = Nn(l, o, t, u, e, !1);
                  }
                else u !== s[a] && ((s[a] = u), (c = !0));
              }
            }
            c && Ce(e, "set", "$attrs");
          })(e, t.props, i, n),
          ((e, t, n) => {
            const { vnode: i, slots: r } = e;
            let s = !0,
              a = b;
            if (32 & i.shapeFlag) {
              const e = t._;
              e
                ? n && 1 === e
                  ? (s = !1)
                  : (A(r, t), n || 1 !== e || delete r._)
                : ((s = !t.$stable), Wn(t, r)),
                (a = t);
            } else t && (qn(e, t), (a = { default: 1 }));
            if (s) for (const o in r) Vn(o) || o in a || delete r[o];
          })(e, t.children, n),
          be(),
          vr(void 0, e.update),
          we();
      },
      U = (e, t, n, i, r, s, a, o, l = !1) => {
        const u = e && e.children,
          h = e ? e.shapeFlag : 0,
          d = t.children,
          { patchFlag: p, shapeFlag: f } = t;
        if (p > 0) {
          if (128 & p) return void H(u, d, n, i, r, s, a, o, l);
          if (256 & p) return void V(u, d, n, i, r, s, a, o, l);
        }
        8 & f
          ? (16 & h && K(u, r, s), d !== u && c(n, d))
          : 16 & h
          ? 16 & f
            ? H(u, d, n, i, r, s, a, o, l)
            : K(u, r, s, !0)
          : (8 & h && c(n, ""), 16 & f && E(d, n, i, r, s, a, o, l));
      },
      V = (e, t, n, i, r, s, a, o, l) => {
        t = t || w;
        const c = (e = e || w).length,
          u = t.length,
          h = Math.min(c, u);
        let d;
        for (d = 0; d < h; d++) {
          const i = (t[d] = l ? Ii(t[d]) : Li(t[d]));
          m(e[d], i, n, null, r, s, a, o, l);
        }
        c > u ? K(e, r, s, !0, !1, h) : E(t, n, i, r, s, a, o, l, h);
      },
      H = (e, t, n, i, r, s, a, o, l) => {
        let c = 0;
        const u = t.length;
        let h = e.length - 1,
          d = u - 1;
        for (; c <= h && c <= d; ) {
          const i = e[c],
            u = (t[c] = l ? Ii(t[c]) : Li(t[c]));
          if (!xi(i, u)) break;
          m(i, u, n, null, r, s, a, o, l), c++;
        }
        for (; c <= h && c <= d; ) {
          const i = e[h],
            c = (t[d] = l ? Ii(t[d]) : Li(t[d]));
          if (!xi(i, c)) break;
          m(i, c, n, null, r, s, a, o, l), h--, d--;
        }
        if (c > h) {
          if (c <= d) {
            const e = d + 1,
              h = e < u ? t[e].el : i;
            for (; c <= d; )
              m(null, (t[c] = l ? Ii(t[c]) : Li(t[c])), n, h, r, s, a, o, l),
                c++;
          }
        } else if (c > d) for (; c <= h; ) W(e[c], r, s, !0), c++;
        else {
          const p = c,
            f = c,
            g = new Map();
          for (c = f; c <= d; c++) {
            const e = (t[c] = l ? Ii(t[c]) : Li(t[c]));
            null != e.key && g.set(e.key, c);
          }
          let v,
            _ = 0;
          const y = d - f + 1;
          let x = !1,
            b = 0;
          const S = new Array(y);
          for (c = 0; c < y; c++) S[c] = 0;
          for (c = p; c <= h; c++) {
            const i = e[c];
            if (_ >= y) {
              W(i, r, s, !0);
              continue;
            }
            let u;
            if (null != i.key) u = g.get(i.key);
            else
              for (v = f; v <= d; v++)
                if (0 === S[v - f] && xi(i, t[v])) {
                  u = v;
                  break;
                }
            void 0 === u
              ? W(i, r, s, !0)
              : ((S[u - f] = c + 1),
                u >= b ? (b = u) : (x = !0),
                m(i, t[u], n, null, r, s, a, o, l),
                _++);
          }
          const M = x
            ? (function (e) {
                const t = e.slice(),
                  n = [0];
                let i, r, s, a, o;
                const l = e.length;
                for (i = 0; i < l; i++) {
                  const l = e[i];
                  if (0 !== l) {
                    if (((r = n[n.length - 1]), e[r] < l)) {
                      (t[i] = r), n.push(i);
                      continue;
                    }
                    for (s = 0, a = n.length - 1; s < a; )
                      (o = (s + a) >> 1), e[n[o]] < l ? (s = o + 1) : (a = o);
                    l < e[n[s]] && (s > 0 && (t[i] = n[s - 1]), (n[s] = i));
                  }
                }
                (s = n.length), (a = n[s - 1]);
                for (; s-- > 0; ) (n[s] = a), (a = t[a]);
                return n;
              })(S)
            : w;
          for (v = M.length - 1, c = y - 1; c >= 0; c--) {
            const e = f + c,
              h = t[e],
              d = e + 1 < u ? t[e + 1].el : i;
            0 === S[c]
              ? m(null, h, n, d, r, s, a, o, l)
              : x && (v < 0 || c !== M[v] ? G(h, n, d, 2) : v--);
          }
        }
      },
      G = (e, t, i, r, s = null) => {
        const { el: a, type: o, transition: l, children: c, shapeFlag: u } = e;
        if (6 & u) return void G(e.component.subTree, t, i, r);
        if (128 & u) return void e.suspense.move(t, i, r);
        if (64 & u) return void o.move(e, t, i, ne);
        if (o === oi) {
          n(a, t, i);
          for (let e = 0; e < c.length; e++) G(c[e], t, i, r);
          return void n(e.anchor, t, i);
        }
        if (o === ui) return void y(e, t, i);
        if (2 !== r && 1 & u && l)
          if (0 === r) l.beforeEnter(a), n(a, t, i), Kn(() => l.enter(a), s);
          else {
            const { leave: e, delayLeave: r, afterLeave: s } = l,
              o = () => n(a, t, i),
              c = () => {
                e(a, () => {
                  o(), s && s();
                });
              };
            r ? r(a, o, c) : c();
          }
        else n(a, t, i);
      },
      W = (e, t, n, i = !1, r = !1) => {
        const {
          type: s,
          props: a,
          ref: o,
          children: l,
          dynamicChildren: c,
          shapeFlag: u,
          patchFlag: h,
          dirs: d,
        } = e;
        if ((null != o && Qn(o, null, n, e, !0), 256 & u))
          return void t.ctx.deactivate(e);
        const p = 1 & u && d,
          f = !rn(e);
        let m;
        if ((f && (m = a && a.onVnodeBeforeUnmount) && ei(m, t, e), 6 & u))
          $(e.component, n, i);
        else {
          if (128 & u) return void e.suspense.unmount(n, i);
          p && Yn(e, null, t, "beforeUnmount"),
            64 & u
              ? e.type.remove(e, t, n, r, ne, i)
              : c && (s !== oi || (h > 0 && 64 & h))
              ? K(c, t, n, !1, !0)
              : ((s === oi && 384 & h) || (!r && 16 & u)) && K(l, t, n),
            i && j(e);
        }
        ((f && (m = a && a.onVnodeUnmounted)) || p) &&
          Kn(() => {
            m && ei(m, t, e), p && Yn(e, null, t, "unmounted");
          }, n);
      },
      j = (e) => {
        const { type: t, el: n, anchor: r, transition: s } = e;
        if (t === oi) return void Y(n, r);
        if (t === ui) return void x(e);
        const a = () => {
          i(n), s && !s.persisted && s.afterLeave && s.afterLeave();
        };
        if (1 & e.shapeFlag && s && !s.persisted) {
          const { leave: t, delayLeave: i } = s,
            r = () => t(n, a);
          i ? i(e.el, a, r) : r();
        } else a();
      },
      Y = (e, t) => {
        let n;
        for (; e !== t; ) (n = h(e)), i(e), (e = n);
        i(t);
      },
      $ = (e, t, n) => {
        const { bum: i, scope: r, update: s, subTree: a, um: o } = e;
        i && ee(i),
          r.stop(),
          s && ((s.active = !1), W(a, e, t, n)),
          o && Kn(o, t),
          Kn(() => {
            e.isUnmounted = !0;
          }, t),
          t &&
            t.pendingBranch &&
            !t.isUnmounted &&
            e.asyncDep &&
            !e.asyncResolved &&
            e.suspenseId === t.pendingId &&
            (t.deps--, 0 === t.deps && t.resolve());
      },
      K = (e, t, n, i = !1, r = !1, s = 0) => {
        for (let a = s; a < e.length; a++) W(e[a], t, n, i, r);
      },
      J = (e) =>
        6 & e.shapeFlag
          ? J(e.component.subTree)
          : 128 & e.shapeFlag
          ? e.suspense.next()
          : h(e.anchor || e.el),
      Q = (e, t, n) => {
        null == e
          ? t._vnode && W(t._vnode, null, null, !0)
          : m(t._vnode || null, e, t, null, null, null, n),
          _r(),
          (t._vnode = e);
      },
      ne = { p: m, um: W, m: G, r: j, mt: N, mc: E, pc: U, pbc: L, n: J, o: e };
    let re, se;
    t && ([re, se] = t(ne));
    return { render: Q, hydrate: re, createApp: Zn(Q, re) };
  })(e);
}
function Qn(e, t, n, i, r = !1) {
  if (R(e))
    return void e.forEach((e, s) => Qn(e, t && (R(t) ? t[s] : t), n, i, r));
  if (rn(i) && !r) return;
  const s = 4 & i.shapeFlag ? Zi(i.component) || i.component.proxy : i.el,
    a = r ? null : s,
    { i: o, r: l } = e,
    c = t && t.r,
    u = o.refs === b ? (o.refs = {}) : o.refs,
    h = o.setupState;
  if (
    (null != c &&
      c !== l &&
      (F(c)
        ? ((u[c] = null), I(h, c) && (h[c] = null))
        : Mt(c) && (c.value = null)),
    F(l))
  ) {
    const e = () => {
      (u[l] = a), I(h, l) && (h[l] = a);
    };
    a ? ((e.id = -1), Kn(e, n)) : e();
  } else if (Mt(l)) {
    const e = () => {
      l.value = a;
    };
    a ? ((e.id = -1), Kn(e, n)) : e();
  } else O(l) && Ki(l, o, 12, [a, u]);
}
function ei(e, t, n, i = null) {
  Ji(e, t, 7, [n, i]);
}
function ti(e, t, n = !1) {
  const i = e.children,
    r = t.children;
  if (R(i) && R(r))
    for (let s = 0; s < i.length; s++) {
      const e = i[s];
      let t = r[s];
      1 & t.shapeFlag &&
        !t.dynamicChildren &&
        ((t.patchFlag <= 0 || 32 === t.patchFlag) &&
          ((t = r[s] = Ii(r[s])), (t.el = e.el)),
        n || ti(e, t));
    }
}
function ni(e, t) {
  return si("components", e, !0, t) || e;
}
const ii = Symbol();
function ri(e) {
  return F(e) ? si("components", e, !1) || e : e || ii;
}
function si(e, t, n = !0, i = !1) {
  const r = Ot || Hi;
  if (r) {
    const n = r.type;
    if ("components" === e) {
      const e = (function (e) {
        return (O(e) && e.displayName) || e.name;
      })(n);
      if (e && (e === t || e === X(t) || e === K(X(t)))) return n;
    }
    const s = ai(r[e] || n[e], t) || ai(r.appContext[e], t);
    return !s && i ? n : s;
  }
}
function ai(e, t) {
  return e && (e[t] || e[X(t)] || e[K(X(t))]);
}
const oi = Symbol(void 0),
  li = Symbol(void 0),
  ci = Symbol(void 0),
  ui = Symbol(void 0),
  hi = [];
let di = null;
function pi(e = !1) {
  hi.push((di = e ? null : []));
}
let fi = 1;
function mi(e) {
  fi += e;
}
function gi(e) {
  return (
    (e.dynamicChildren = fi > 0 ? di || w : null),
    hi.pop(),
    (di = hi[hi.length - 1] || null),
    fi > 0 && di && di.push(e),
    e
  );
}
function vi(e, t, n, i, r, s) {
  return gi(Mi(e, t, n, i, r, s, !0));
}
function _i(e, t, n, i, r) {
  return gi(Ti(e, t, n, i, r, !0));
}
function yi(e) {
  return !!e && !0 === e.__v_isVNode;
}
function xi(e, t) {
  return e.type === t.type && e.key === t.key;
}
const bi = "__vInternal",
  wi = ({ key: e }) => (null != e ? e : null),
  Si = ({ ref: e }) =>
    null != e ? (F(e) || Mt(e) || O(e) ? { i: Ot, r: e } : e) : null;
function Mi(
  e,
  t = null,
  n = null,
  i = 0,
  r = null,
  s = e === oi ? 0 : 1,
  a = !1,
  o = !1
) {
  const l = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e,
    props: t,
    key: t && wi(t),
    ref: t && Si(t),
    scopeId: Ft,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: s,
    patchFlag: i,
    dynamicProps: r,
    dynamicChildren: null,
    appContext: null,
  };
  return (
    o
      ? (Ri(l, n), 128 & s && e.normalize(l))
      : n && (l.shapeFlag |= F(n) ? 8 : 16),
    fi > 0 &&
      !a &&
      di &&
      (l.patchFlag > 0 || 6 & s) &&
      32 !== l.patchFlag &&
      di.push(l),
    l
  );
}
const Ti = function (e, t = null, n = null, i = 0, r = null, s = !1) {
  (e && e !== ii) || (e = ci);
  if (yi(e)) {
    const i = Ci(e, t, !0);
    return n && Ri(i, n), i;
  }
  (a = e), O(a) && "__vccOpts" in a && (e = e.__vccOpts);
  var a;
  if (t) {
    t = (function (e) {
      return e ? (vt(e) || bi in e ? A({}, e) : e) : null;
    })(t);
    let { class: e, style: n } = t;
    e && !F(e) && (t.class = g(e)),
      U(n) && (vt(n) && !R(n) && (n = A({}, n)), (t.style = d(n)));
  }
  const o = F(e)
    ? 1
    : ((e) => e.__isSuspense)(e)
    ? 128
    : ((e) => e.__isTeleport)(e)
    ? 64
    : U(e)
    ? 4
    : O(e)
    ? 2
    : 0;
  return Mi(e, t, n, i, r, o, s, !0);
};
function Ci(e, t, n = !1) {
  const { props: i, ref: r, patchFlag: s, children: a } = e,
    o = t ? Di(i || {}, t) : i;
  return {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e.type,
    props: o,
    key: o && wi(o),
    ref:
      t && t.ref ? (n && r ? (R(r) ? r.concat(Si(t)) : [r, Si(t)]) : Si(t)) : r,
    scopeId: e.scopeId,
    slotScopeIds: e.slotScopeIds,
    children: a,
    target: e.target,
    targetAnchor: e.targetAnchor,
    staticCount: e.staticCount,
    shapeFlag: e.shapeFlag,
    patchFlag: t && e.type !== oi ? (-1 === s ? 16 : 16 | s) : s,
    dynamicProps: e.dynamicProps,
    dynamicChildren: e.dynamicChildren,
    appContext: e.appContext,
    dirs: e.dirs,
    transition: e.transition,
    component: e.component,
    suspense: e.suspense,
    ssContent: e.ssContent && Ci(e.ssContent),
    ssFallback: e.ssFallback && Ci(e.ssFallback),
    el: e.el,
    anchor: e.anchor,
  };
}
function Ei(e = " ", t = 0) {
  return Ti(li, null, e, t);
}
function Ai(e, t) {
  const n = Ti(ui, null, e);
  return (n.staticCount = t), n;
}
function Pi(e = "", t = !1) {
  return t ? (pi(), _i(ci, null, e)) : Ti(ci, null, e);
}
function Li(e) {
  return null == e || "boolean" == typeof e
    ? Ti(ci)
    : R(e)
    ? Ti(oi, null, e.slice())
    : "object" == typeof e
    ? Ii(e)
    : Ti(li, null, String(e));
}
function Ii(e) {
  return null === e.el || e.memo ? e : Ci(e);
}
function Ri(e, t) {
  let n = 0;
  const { shapeFlag: i } = e;
  if (null == t) t = null;
  else if (R(t)) n = 16;
  else if ("object" == typeof t) {
    if (65 & i) {
      const n = t.default;
      return void (n && (n._c && (n._d = !1), Ri(e, n()), n._c && (n._d = !0)));
    }
    {
      n = 32;
      const i = t._;
      i || bi in t
        ? 3 === i &&
          Ot &&
          (1 === Ot.slots._ ? (t._ = 1) : ((t._ = 2), (e.patchFlag |= 1024)))
        : (t._ctx = Ot);
    }
  } else
    O(t)
      ? ((t = { default: t, _ctx: Ot }), (n = 32))
      : ((t = String(t)), 64 & i ? ((n = 16), (t = [Ei(t)])) : (n = 8));
  (e.children = t), (e.shapeFlag |= n);
}
function Di(...e) {
  const t = {};
  for (let n = 0; n < e.length; n++) {
    const i = e[n];
    for (const e in i)
      if ("class" === e)
        t.class !== i.class && (t.class = g([t.class, i.class]));
      else if ("style" === e) t.style = d([t.style, i.style]);
      else if (C(e)) {
        const n = t[e],
          r = i[e];
        n !== r && (t[e] = n ? [].concat(n, r) : r);
      } else "" !== e && (t[e] = i[e]);
  }
  return t;
}
function ki(e, t, n, i) {
  let r;
  const s = n && n[i];
  if (R(e) || F(e)) {
    r = new Array(e.length);
    for (let n = 0, i = e.length; n < i; n++)
      r[n] = t(e[n], n, void 0, s && s[n]);
  } else if ("number" == typeof e) {
    r = new Array(e);
    for (let n = 0; n < e; n++) r[n] = t(n + 1, n, void 0, s && s[n]);
  } else if (U(e))
    if (e[Symbol.iterator])
      r = Array.from(e, (e, n) => t(e, n, void 0, s && s[n]));
    else {
      const n = Object.keys(e);
      r = new Array(n.length);
      for (let i = 0, a = n.length; i < a; i++) {
        const a = n[i];
        r[i] = t(e[a], a, i, s && s[i]);
      }
    }
  else r = [];
  return n && (n[i] = r), r;
}
function Ni(e, t, n = {}, i, r) {
  if (Ot.isCE)
    return Ti("slot", "default" === t ? null : { name: t }, i && i());
  let s = e[t];
  s && s._c && (s._d = !1), pi();
  const a = s && Oi(s(n)),
    o = _i(
      oi,
      { key: n.key || `_${t}` },
      a || (i ? i() : []),
      a && 1 === e._ ? 64 : -2
    );
  return (
    !r && o.scopeId && (o.slotScopeIds = [o.scopeId + "-s"]),
    s && s._c && (s._d = !0),
    o
  );
}
function Oi(e) {
  return e.some(
    (e) => !yi(e) || (e.type !== ci && !(e.type === oi && !Oi(e.children)))
  )
    ? e
    : null;
}
const Fi = (e) => (e ? (ji(e) ? Zi(e) || e.proxy : Fi(e.parent)) : null),
  zi = A(Object.create(null), {
    $: (e) => e,
    $el: (e) => e.vnode.el,
    $data: (e) => e.data,
    $props: (e) => e.props,
    $attrs: (e) => e.attrs,
    $slots: (e) => e.slots,
    $refs: (e) => e.refs,
    $parent: (e) => Fi(e.parent),
    $root: (e) => Fi(e.root),
    $emit: (e) => e.emit,
    $options: (e) => Cn(e),
    $forceUpdate: (e) => () => fr(e.update),
    $nextTick: (e) => pr.bind(e.proxy),
    $watch: (e) => Tr.bind(e),
  }),
  Ui = {
    get({ _: e }, t) {
      const {
        ctx: n,
        setupState: i,
        data: r,
        props: s,
        accessCache: a,
        type: o,
        appContext: l,
      } = e;
      let c;
      if ("$" !== t[0]) {
        const o = a[t];
        if (void 0 !== o)
          switch (o) {
            case 0:
              return i[t];
            case 1:
              return r[t];
            case 3:
              return n[t];
            case 2:
              return s[t];
          }
        else {
          if (i !== b && I(i, t)) return (a[t] = 0), i[t];
          if (r !== b && I(r, t)) return (a[t] = 1), r[t];
          if ((c = e.propsOptions[0]) && I(c, t)) return (a[t] = 2), s[t];
          if (n !== b && I(n, t)) return (a[t] = 3), n[t];
          wn && (a[t] = 4);
        }
      }
      const u = zi[t];
      let h, d;
      return u
        ? ("$attrs" === t && Se(e, 0, t), u(e))
        : (h = o.__cssModules) && (h = h[t])
        ? h
        : n !== b && I(n, t)
        ? ((a[t] = 3), n[t])
        : ((d = l.config.globalProperties), I(d, t) ? d[t] : void 0);
    },
    set({ _: e }, t, n) {
      const { data: i, setupState: r, ctx: s } = e;
      if (r !== b && I(r, t)) r[t] = n;
      else if (i !== b && I(i, t)) i[t] = n;
      else if (I(e.props, t)) return !1;
      return ("$" !== t[0] || !(t.slice(1) in e)) && ((s[t] = n), !0);
    },
    has(
      {
        _: {
          data: e,
          setupState: t,
          accessCache: n,
          ctx: i,
          appContext: r,
          propsOptions: s,
        },
      },
      a
    ) {
      let o;
      return (
        void 0 !== n[a] ||
        (e !== b && I(e, a)) ||
        (t !== b && I(t, a)) ||
        ((o = s[0]) && I(o, a)) ||
        I(i, a) ||
        I(zi, a) ||
        I(r.config.globalProperties, a)
      );
    },
  },
  Bi = Xn();
let Vi = 0;
let Hi = null;
const Gi = () => Hi || Ot,
  Wi = (e) => {
    (Hi = e), e.scope.on();
  },
  qi = () => {
    Hi && Hi.scope.off(), (Hi = null);
  };
function ji(e) {
  return 4 & e.vnode.shapeFlag;
}
let Yi = !1;
function Xi(e, t, n) {
  O(t)
    ? e.type.__ssrInlineRender
      ? (e.ssrRender = t)
      : (e.render = t)
    : U(t) && (e.setupState = Lt(t)),
    $i(e, n);
}
function $i(e, t, n) {
  const i = e.type;
  e.render || (e.render = i.render || S), Wi(e), be(), Sn(e), we(), qi();
}
function Zi(e) {
  if (e.exposed)
    return (
      e.exposeProxy ||
      (e.exposeProxy = new Proxy(Lt(yt(e.exposed)), {
        get: (t, n) => (n in t ? t[n] : n in zi ? zi[n](e) : void 0),
      }))
    );
}
function Ki(e, t, n, i) {
  let r;
  try {
    r = i ? e(...i) : e();
  } catch (s) {
    Qi(s, t, n);
  }
  return r;
}
function Ji(e, t, n, i) {
  if (O(e)) {
    const r = Ki(e, t, n, i);
    return (
      r &&
        B(r) &&
        r.catch((e) => {
          Qi(e, t, n);
        }),
      r
    );
  }
  const r = [];
  for (let s = 0; s < e.length; s++) r.push(Ji(e[s], t, n, i));
  return r;
}
function Qi(e, t, n, i = !0) {
  t && t.vnode;
  if (t) {
    let i = t.parent;
    const r = t.proxy,
      s = n;
    for (; i; ) {
      const t = i.ec;
      if (t)
        for (let n = 0; n < t.length; n++) if (!1 === t[n](e, r, s)) return;
      i = i.parent;
    }
    const a = t.appContext.config.errorHandler;
    if (a) return void Ki(a, null, 10, [e, r, s]);
  }
}
let er = !1,
  tr = !1;
const nr = [];
let ir = 0;
const rr = [];
let sr = null,
  ar = 0;
const or = [];
let lr = null,
  cr = 0;
const ur = Promise.resolve();
let hr = null,
  dr = null;
function pr(e) {
  const t = hr || ur;
  return e ? t.then(this ? e.bind(this) : e) : t;
}
function fr(e) {
  (nr.length && nr.includes(e, er && e.allowRecurse ? ir + 1 : ir)) ||
    e === dr ||
    (null == e.id
      ? nr.push(e)
      : nr.splice(
          (function (e) {
            let t = ir + 1,
              n = nr.length;
            for (; t < n; ) {
              const i = (t + n) >>> 1;
              yr(nr[i]) < e ? (t = i + 1) : (n = i);
            }
            return t;
          })(e.id),
          0,
          e
        ),
    mr());
}
function mr() {
  er || tr || ((tr = !0), (hr = ur.then(xr)));
}
function gr(e, t, n, i) {
  R(e)
    ? n.push(...e)
    : (t && t.includes(e, e.allowRecurse ? i + 1 : i)) || n.push(e),
    mr();
}
function vr(e, t = null) {
  if (rr.length) {
    for (
      dr = t, sr = [...new Set(rr)], rr.length = 0, ar = 0;
      ar < sr.length;
      ar++
    )
      sr[ar]();
    (sr = null), (ar = 0), (dr = null), vr(e, t);
  }
}
function _r(e) {
  if (or.length) {
    const e = [...new Set(or)];
    if (((or.length = 0), lr)) return void lr.push(...e);
    for (lr = e, lr.sort((e, t) => yr(e) - yr(t)), cr = 0; cr < lr.length; cr++)
      lr[cr]();
    (lr = null), (cr = 0);
  }
}
const yr = (e) => (null == e.id ? Infinity : e.id);
function xr(e) {
  (tr = !1), (er = !0), vr(e), nr.sort((e, t) => yr(e) - yr(t));
  try {
    for (ir = 0; ir < nr.length; ir++) {
      const e = nr[ir];
      e && !1 !== e.active && Ki(e, null, 14);
    }
  } finally {
    (ir = 0),
      (nr.length = 0),
      _r(),
      (er = !1),
      (hr = null),
      (nr.length || rr.length || or.length) && xr(e);
  }
}
function br(e, t) {
  return Mr(e, null, t);
}
const wr = {};
function Sr(e, t, n) {
  return Mr(e, t, n);
}
function Mr(
  e,
  t,
  { immediate: n, deep: i, flush: r, onTrack: s, onTrigger: a } = b
) {
  const o = Hi;
  let l,
    c,
    u = !1,
    h = !1;
  if (
    (Mt(e)
      ? ((l = () => e.value), (u = !!e._shallow))
      : mt(e)
      ? ((l = () => e), (i = !0))
      : R(e)
      ? ((h = !0),
        (u = e.some(mt)),
        (l = () =>
          e.map((e) =>
            Mt(e) ? e.value : mt(e) ? Er(e) : O(e) ? Ki(e, o, 2) : void 0
          )))
      : (l = O(e)
          ? t
            ? () => Ki(e, o, 2)
            : () => {
                if (!o || !o.isUnmounted) return c && c(), Ji(e, o, 3, [d]);
              }
          : S),
    t && i)
  ) {
    const e = l;
    l = () => Er(e());
  }
  let d = (e) => {
    c = g.onStop = () => {
      Ki(e, o, 4);
    };
  };
  if (Yi)
    return (d = S), t ? n && Ji(t, o, 3, [l(), h ? [] : void 0, d]) : l(), S;
  let p = h ? [] : wr;
  const f = () => {
    if (g.active)
      if (t) {
        const e = g.run();
        (i || u || (h ? e.some((e, t) => Q(e, p[t])) : Q(e, p))) &&
          (c && c(), Ji(t, o, 3, [e, p === wr ? void 0 : p, d]), (p = e));
      } else g.run();
  };
  let m;
  (f.allowRecurse = !!t),
    (m =
      "sync" === r
        ? f
        : "post" === r
        ? () => Kn(f, o && o.suspense)
        : () => {
            !o || o.isMounted
              ? (function (e) {
                  gr(e, sr, rr, ar);
                })(f)
              : f();
          });
  const g = new ve(l, m);
  return (
    t
      ? n
        ? f()
        : (p = g.run())
      : "post" === r
      ? Kn(g.run.bind(g), o && o.suspense)
      : g.run(),
    () => {
      g.stop(), o && o.scope && P(o.scope.effects, g);
    }
  );
}
function Tr(e, t, n) {
  const i = this.proxy,
    r = F(e) ? (e.includes(".") ? Cr(i, e) : () => i[e]) : e.bind(i, i);
  let s;
  O(t) ? (s = t) : ((s = t.handler), (n = t));
  const a = Hi;
  Wi(this);
  const o = Mr(r, s.bind(i), n);
  return a ? Wi(a) : qi(), o;
}
function Cr(e, t) {
  const n = t.split(".");
  return () => {
    let t = e;
    for (let e = 0; e < n.length && t; e++) t = t[n[e]];
    return t;
  };
}
function Er(e, t) {
  if (!U(e) || e.__v_skip) return e;
  if ((t = t || new Set()).has(e)) return e;
  if ((t.add(e), Mt(e))) Er(e.value, t);
  else if (R(e)) for (let n = 0; n < e.length; n++) Er(e[n], t);
  else if (k(e) || D(e))
    e.forEach((e) => {
      Er(e, t);
    });
  else if (G(e)) for (const n in e) Er(e[n], t);
  return e;
}
function Ar(e, t, n) {
  const i = arguments.length;
  return 2 === i
    ? U(t) && !R(t)
      ? yi(t)
        ? Ti(e, null, [t])
        : Ti(e, t)
      : Ti(e, null, t)
    : (i > 3
        ? (n = Array.prototype.slice.call(arguments, 2))
        : 3 === i && yi(n) && (n = [n]),
      Ti(e, t, n));
}
const Pr = "3.2.19",
  Lr = "undefined" != typeof document ? document : null,
  Ir = new Map(),
  Rr = {
    insert: (e, t, n) => {
      t.insertBefore(e, n || null);
    },
    remove: (e) => {
      const t = e.parentNode;
      t && t.removeChild(e);
    },
    createElement: (e, t, n, i) => {
      const r = t
        ? Lr.createElementNS("http://www.w3.org/2000/svg", e)
        : Lr.createElement(e, n ? { is: n } : void 0);
      return (
        "select" === e &&
          i &&
          null != i.multiple &&
          r.setAttribute("multiple", i.multiple),
        r
      );
    },
    createText: (e) => Lr.createTextNode(e),
    createComment: (e) => Lr.createComment(e),
    setText: (e, t) => {
      e.nodeValue = t;
    },
    setElementText: (e, t) => {
      e.textContent = t;
    },
    parentNode: (e) => e.parentNode,
    nextSibling: (e) => e.nextSibling,
    querySelector: (e) => Lr.querySelector(e),
    setScopeId(e, t) {
      e.setAttribute(t, "");
    },
    cloneNode(e) {
      const t = e.cloneNode(!0);
      return "_value" in e && (t._value = e._value), t;
    },
    insertStaticContent(e, t, n, i) {
      const r = n ? n.previousSibling : t.lastChild;
      let s = Ir.get(e);
      if (!s) {
        const t = Lr.createElement("template");
        if (((t.innerHTML = i ? `<svg>${e}</svg>` : e), (s = t.content), i)) {
          const e = s.firstChild;
          for (; e.firstChild; ) s.appendChild(e.firstChild);
          s.removeChild(e);
        }
        Ir.set(e, s);
      }
      return (
        t.insertBefore(s.cloneNode(!0), n),
        [r ? r.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild]
      );
    },
  };
const Dr = /\s*!important$/;
function kr(e, t, n) {
  if (R(n)) n.forEach((n) => kr(e, t, n));
  else if (t.startsWith("--")) e.setProperty(t, n);
  else {
    const i = (function (e, t) {
      const n = Or[t];
      if (n) return n;
      let i = X(t);
      if ("filter" !== i && i in e) return (Or[t] = i);
      i = K(i);
      for (let r = 0; r < Nr.length; r++) {
        const n = Nr[r] + i;
        if (n in e) return (Or[t] = n);
      }
      return t;
    })(e, t);
    Dr.test(n)
      ? e.setProperty(Z(i), n.replace(Dr, ""), "important")
      : (e[i] = n);
  }
}
const Nr = ["Webkit", "Moz", "ms"],
  Or = {};
const Fr = "http://www.w3.org/1999/xlink";
let zr = Date.now,
  Ur = !1;
if ("undefined" != typeof window) {
  zr() > document.createEvent("Event").timeStamp &&
    (zr = () => performance.now());
  const e = navigator.userAgent.match(/firefox\/(\d+)/i);
  Ur = !!(e && Number(e[1]) <= 53);
}
let Br = 0;
const Vr = Promise.resolve(),
  Hr = () => {
    Br = 0;
  };
function Gr(e, t, n, i) {
  e.addEventListener(t, n, i);
}
function Wr(e, t, n, i, r = null) {
  const s = e._vei || (e._vei = {}),
    a = s[t];
  if (i && a) a.value = i;
  else {
    const [n, o] = (function (e) {
      let t;
      if (qr.test(e)) {
        let n;
        for (t = {}; (n = e.match(qr)); )
          (e = e.slice(0, e.length - n[0].length)),
            (t[n[0].toLowerCase()] = !0);
      }
      return [Z(e.slice(2)), t];
    })(t);
    if (i) {
      const a = (s[t] = (function (e, t) {
        const n = (e) => {
          const i = e.timeStamp || zr();
          (Ur || i >= n.attached - 1) &&
            Ji(
              (function (e, t) {
                if (R(t)) {
                  const n = e.stopImmediatePropagation;
                  return (
                    (e.stopImmediatePropagation = () => {
                      n.call(e), (e._stopped = !0);
                    }),
                    t.map((e) => (t) => !t._stopped && e(t))
                  );
                }
                return t;
              })(e, n.value),
              t,
              5,
              [e]
            );
        };
        return (
          (n.value = e),
          (n.attached = (() => Br || (Vr.then(Hr), (Br = zr())))()),
          n
        );
      })(i, r));
      Gr(e, n, a, o);
    } else
      a &&
        (!(function (e, t, n, i) {
          e.removeEventListener(t, n, i);
        })(e, n, a, o),
        (s[t] = void 0));
  }
}
const qr = /(?:Once|Passive|Capture)$/;
const jr = /^on[a-z]/;
const Yr = "transition",
  Xr = (e, { slots: t }) =>
    Ar(
      $t,
      (function (e) {
        const t = {};
        for (const A in e) A in $r || (t[A] = e[A]);
        if (!1 === e.css) return t;
        const {
            name: n = "v",
            type: i,
            duration: r,
            enterFromClass: s = `${n}-enter-from`,
            enterActiveClass: a = `${n}-enter-active`,
            enterToClass: o = `${n}-enter-to`,
            appearFromClass: l = s,
            appearActiveClass: c = a,
            appearToClass: u = o,
            leaveFromClass: h = `${n}-leave-from`,
            leaveActiveClass: d = `${n}-leave-active`,
            leaveToClass: p = `${n}-leave-to`,
          } = e,
          f = (function (e) {
            if (null == e) return null;
            if (U(e)) return [Jr(e.enter), Jr(e.leave)];
            {
              const t = Jr(e);
              return [t, t];
            }
          })(r),
          m = f && f[0],
          g = f && f[1],
          {
            onBeforeEnter: v,
            onEnter: _,
            onEnterCancelled: y,
            onLeave: x,
            onLeaveCancelled: b,
            onBeforeAppear: w = v,
            onAppear: S = _,
            onAppearCancelled: M = y,
          } = t,
          T = (e, t, n) => {
            es(e, t ? u : o), es(e, t ? c : a), n && n();
          },
          C = (e, t) => {
            es(e, p), es(e, d), t && t();
          },
          E = (e) => (t, n) => {
            const r = e ? S : _,
              a = () => T(t, e, n);
            Zr(r, [t, a]),
              ts(() => {
                es(t, e ? l : s), Qr(t, e ? u : o), Kr(r) || is(t, i, m, a);
              });
          };
        return A(t, {
          onBeforeEnter(e) {
            Zr(v, [e]), Qr(e, s), Qr(e, a);
          },
          onBeforeAppear(e) {
            Zr(w, [e]), Qr(e, l), Qr(e, c);
          },
          onEnter: E(!1),
          onAppear: E(!0),
          onLeave(e, t) {
            const n = () => C(e, t);
            Qr(e, h),
              document.body.offsetHeight,
              Qr(e, d),
              ts(() => {
                es(e, h), Qr(e, p), Kr(x) || is(e, i, g, n);
              }),
              Zr(x, [e, n]);
          },
          onEnterCancelled(e) {
            T(e, !1), Zr(y, [e]);
          },
          onAppearCancelled(e) {
            T(e, !0), Zr(M, [e]);
          },
          onLeaveCancelled(e) {
            C(e), Zr(b, [e]);
          },
        });
      })(e),
      t
    );
Xr.displayName = "Transition";
const $r = {
  name: String,
  type: String,
  css: { type: Boolean, default: !0 },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String,
};
Xr.props = A({}, $t.props, $r);
const Zr = (e, t = []) => {
    R(e) ? e.forEach((e) => e(...t)) : e && e(...t);
  },
  Kr = (e) => !!e && (R(e) ? e.some((e) => e.length > 1) : e.length > 1);
function Jr(e) {
  return ne(e);
}
function Qr(e, t) {
  t.split(/\s+/).forEach((t) => t && e.classList.add(t)),
    (e._vtc || (e._vtc = new Set())).add(t);
}
function es(e, t) {
  t.split(/\s+/).forEach((t) => t && e.classList.remove(t));
  const { _vtc: n } = e;
  n && (n.delete(t), n.size || (e._vtc = void 0));
}
function ts(e) {
  requestAnimationFrame(() => {
    requestAnimationFrame(e);
  });
}
let ns = 0;
function is(e, t, n, i) {
  const r = (e._endId = ++ns),
    s = () => {
      r === e._endId && i();
    };
  if (n) return setTimeout(s, n);
  const {
    type: a,
    timeout: o,
    propCount: l,
  } = (function (e, t) {
    const n = window.getComputedStyle(e),
      i = (e) => (n[e] || "").split(", "),
      r = i("transitionDelay"),
      s = i("transitionDuration"),
      a = rs(r, s),
      o = i("animationDelay"),
      l = i("animationDuration"),
      c = rs(o, l);
    let u = null,
      h = 0,
      d = 0;
    t === Yr
      ? a > 0 && ((u = Yr), (h = a), (d = s.length))
      : "animation" === t
      ? c > 0 && ((u = "animation"), (h = c), (d = l.length))
      : ((h = Math.max(a, c)),
        (u = h > 0 ? (a > c ? Yr : "animation") : null),
        (d = u ? (u === Yr ? s.length : l.length) : 0));
    const p = u === Yr && /\b(transform|all)(,|$)/.test(n.transitionProperty);
    return { type: u, timeout: h, propCount: d, hasTransform: p };
  })(e, t);
  if (!a) return i();
  const c = a + "end";
  let u = 0;
  const h = () => {
      e.removeEventListener(c, d), s();
    },
    d = (t) => {
      t.target === e && ++u >= l && h();
    };
  setTimeout(() => {
    u < l && h();
  }, o + 1),
    e.addEventListener(c, d);
}
function rs(e, t) {
  for (; e.length < t.length; ) e = e.concat(e);
  return Math.max(...t.map((t, n) => ss(t) + ss(e[n])));
}
function ss(e) {
  return 1e3 * Number(e.slice(0, -1).replace(",", "."));
}
const as = (e) => {
  const t = e.props["onUpdate:modelValue"];
  return R(t) ? (e) => ee(t, e) : t;
};
function os(e) {
  e.target.composing = !0;
}
function ls(e) {
  const t = e.target;
  t.composing &&
    ((t.composing = !1),
    (function (e, t) {
      const n = document.createEvent("HTMLEvents");
      n.initEvent(t, !0, !0), e.dispatchEvent(n);
    })(t, "input"));
}
const cs = {
    created(e, { modifiers: { lazy: t, trim: n, number: i } }, r) {
      e._assign = as(r);
      const s = i || (r.props && "number" === r.props.type);
      Gr(e, t ? "change" : "input", (t) => {
        if (t.target.composing) return;
        let i = e.value;
        n ? (i = i.trim()) : s && (i = ne(i)), e._assign(i);
      }),
        n &&
          Gr(e, "change", () => {
            e.value = e.value.trim();
          }),
        t ||
          (Gr(e, "compositionstart", os),
          Gr(e, "compositionend", ls),
          Gr(e, "change", ls));
    },
    mounted(e, { value: t }) {
      e.value = null == t ? "" : t;
    },
    beforeUpdate(
      e,
      { value: t, modifiers: { lazy: n, trim: i, number: r } },
      s
    ) {
      if (((e._assign = as(s)), e.composing)) return;
      if (document.activeElement === e) {
        if (n) return;
        if (i && e.value.trim() === t) return;
        if ((r || "number" === e.type) && ne(e.value) === t) return;
      }
      const a = null == t ? "" : t;
      e.value !== a && (e.value = a);
    },
  },
  us = {
    deep: !0,
    created(e, t, n) {
      (e._assign = as(n)),
        Gr(e, "change", () => {
          const t = e._modelValue,
            n = (function (e) {
              return "_value" in e ? e._value : e.value;
            })(e),
            i = e.checked,
            r = e._assign;
          if (R(t)) {
            const e = _(t, n),
              s = -1 !== e;
            if (i && !s) r(t.concat(n));
            else if (!i && s) {
              const n = [...t];
              n.splice(e, 1), r(n);
            }
          } else if (k(t)) {
            const e = new Set(t);
            i ? e.add(n) : e.delete(n), r(e);
          } else r(ds(e, i));
        });
    },
    mounted: hs,
    beforeUpdate(e, t, n) {
      (e._assign = as(n)), hs(e, t, n);
    },
  };
function hs(e, { value: t, oldValue: n }, i) {
  (e._modelValue = t),
    R(t)
      ? (e.checked = _(t, i.props.value) > -1)
      : k(t)
      ? (e.checked = t.has(i.props.value))
      : t !== n && (e.checked = v(t, ds(e, !0)));
}
function ds(e, t) {
  const n = t ? "_trueValue" : "_falseValue";
  return n in e ? e[n] : t;
}
const ps = ["ctrl", "shift", "alt", "meta"],
  fs = {
    stop: (e) => e.stopPropagation(),
    prevent: (e) => e.preventDefault(),
    self: (e) => e.target !== e.currentTarget,
    ctrl: (e) => !e.ctrlKey,
    shift: (e) => !e.shiftKey,
    alt: (e) => !e.altKey,
    meta: (e) => !e.metaKey,
    left: (e) => "button" in e && 0 !== e.button,
    middle: (e) => "button" in e && 1 !== e.button,
    right: (e) => "button" in e && 2 !== e.button,
    exact: (e, t) => ps.some((n) => e[`${n}Key`] && !t.includes(n)),
  },
  ms =
    (e, t) =>
    (n, ...i) => {
      for (let e = 0; e < t.length; e++) {
        const i = fs[t[e]];
        if (i && i(n, t)) return;
      }
      return e(n, ...i);
    },
  gs = A(
    {
      patchProp: (e, t, n, i, r = !1, s, a, o, l) => {
        "class" === t
          ? (function (e, t, n) {
              const i = e._vtc;
              i && (t = (t ? [t, ...i] : [...i]).join(" ")),
                null == t
                  ? e.removeAttribute("class")
                  : n
                  ? e.setAttribute("class", t)
                  : (e.className = t);
            })(e, i, r)
          : "style" === t
          ? (function (e, t, n) {
              const i = e.style,
                r = i.display;
              if (n)
                if (F(n)) t !== n && (i.cssText = n);
                else {
                  for (const e in n) kr(i, e, n[e]);
                  if (t && !F(t))
                    for (const e in t) null == n[e] && kr(i, e, "");
                }
              else e.removeAttribute("style");
              "_vod" in e && (i.display = r);
            })(e, n, i)
          : C(t)
          ? E(t) || Wr(e, t, 0, i, a)
          : (
              "." === t[0]
                ? ((t = t.slice(1)), 1)
                : "^" === t[0]
                ? ((t = t.slice(1)), 0)
                : (function (e, t, n, i) {
                    if (i)
                      return (
                        "innerHTML" === t ||
                        "textContent" === t ||
                        !!(t in e && jr.test(t) && O(n))
                      );
                    if ("spellcheck" === t || "draggable" === t) return !1;
                    if ("form" === t) return !1;
                    if ("list" === t && "INPUT" === e.tagName) return !1;
                    if ("type" === t && "TEXTAREA" === e.tagName) return !1;
                    if (jr.test(t) && F(n)) return !1;
                    return t in e;
                  })(e, t, i, r)
            )
          ? (function (e, t, n, i, r, s, a) {
              if ("innerHTML" === t || "textContent" === t)
                return i && a(i, r, s), void (e[t] = null == n ? "" : n);
              if ("value" === t && "PROGRESS" !== e.tagName) {
                e._value = n;
                const i = null == n ? "" : n;
                return (
                  e.value !== i && (e.value = i),
                  void (null == n && e.removeAttribute(t))
                );
              }
              if ("" === n || null == n) {
                const i = typeof e[t];
                if ("boolean" === i) return void (e[t] = h(n));
                if (null == n && "string" === i)
                  return (e[t] = ""), void e.removeAttribute(t);
                if ("number" === i) {
                  try {
                    e[t] = 0;
                  } catch (o) {}
                  return void e.removeAttribute(t);
                }
              }
              try {
                e[t] = n;
              } catch (l) {}
            })(e, t, i, s, a, o, l)
          : ("true-value" === t
              ? (e._trueValue = i)
              : "false-value" === t && (e._falseValue = i),
            (function (e, t, n, i, r) {
              if (i && t.startsWith("xlink:"))
                null == n
                  ? e.removeAttributeNS(Fr, t.slice(6, t.length))
                  : e.setAttributeNS(Fr, t, n);
              else {
                const i = u(t);
                null == n || (i && !h(n))
                  ? e.removeAttribute(t)
                  : e.setAttribute(t, i ? "" : n);
              }
            })(e, t, i, r));
      },
    },
    Rr
  );
let vs;
const _s = (...e) => {
  const t = (vs || (vs = Jn(gs))).createApp(...e),
    { mount: n } = t;
  return (
    (t.mount = (e) => {
      const i = (function (e) {
        if (F(e)) {
          return document.querySelector(e);
        }
        return e;
      })(e);
      if (!i) return;
      const r = t._component;
      O(r) || r.render || r.template || (r.template = i.innerHTML),
        (i.innerHTML = "");
      const s = n(i, !1, i instanceof SVGElement);
      return (
        i instanceof Element &&
          (i.removeAttribute("v-cloak"), i.setAttribute("data-v-app", "")),
        s
      );
    }),
    t
  );
};
function ys() {
  let e, t;
  const n = [],
    i = [];
  return {
    install: function (n) {
      (e = n),
        (t = e.mount.bind(e)),
        (e.mount = a.bind(e)),
        (e.onBeforeMount = r),
        (e.onAfterMount = s);
    },
  };
  function r(e, t) {
    t ? n.unshift(e) : n.push(e);
  }
  function s(e, t) {
    t ? i.unshift(e) : i.push(e);
  }
  function a(r, s) {
    for (const t of n) t(e);
    t(r, s);
    for (const t of i) t(e);
    i.length = n.length = 0;
  }
}
const xs = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag,
  bs = (e) => (xs ? Symbol(e) : "_vr_" + e),
  ws = bs("rvlm"),
  Ss = bs("rvd"),
  Ms = bs("r"),
  Ts = bs("rl"),
  Cs = bs("rvl"),
  Es = "undefined" != typeof window;
const As = Object.assign;
function Ps(e, t) {
  const n = {};
  for (const i in t) {
    const r = t[i];
    n[i] = Array.isArray(r) ? r.map(e) : e(r);
  }
  return n;
}
const Ls = () => {};
function Is(e, t, n = "/") {
  let i,
    r = {},
    s = "",
    a = "";
  const o = t.indexOf("?"),
    l = t.indexOf("#", o > -1 ? o : 0);
  return (
    o > -1 &&
      ((i = t.slice(0, o)),
      (s = t.slice(o + 1, l > -1 ? l : t.length)),
      (r = e(s))),
    l > -1 && ((i = i || t.slice(0, l)), (a = t.slice(l, t.length))),
    (i = (function (e, t) {
      if (e.startsWith("/")) return e;
      if (!e) return t;
      const n = t.split("/"),
        i = e.split("/");
      let r,
        s,
        a = n.length - 1;
      for (r = 0; r < i.length; r++)
        if (((s = i[r]), 1 !== a && "." !== s)) {
          if (".." !== s) break;
          a--;
        }
      return (
        n.slice(0, a).join("/") +
        "/" +
        i.slice(r - (r === i.length ? 1 : 0)).join("/")
      );
    })(null != i ? i : t, n)),
    { fullPath: i + (s && "?") + s + a, path: i, query: r, hash: a }
  );
}
function Rs(e, t) {
  return (e.aliasOf || e) === (t.aliasOf || t);
}
function Ds(e, t) {
  if (Object.keys(e).length !== Object.keys(t).length) return !1;
  for (const n in e) if (!ks(e[n], t[n])) return !1;
  return !0;
}
function ks(e, t) {
  return Array.isArray(e) ? Ns(e, t) : Array.isArray(t) ? Ns(t, e) : e === t;
}
function Ns(e, t) {
  return Array.isArray(t)
    ? e.length === t.length && e.every((e, n) => e === t[n])
    : 1 === e.length && e[0] === t;
}
var Os, Fs, zs, Us;
((Fs = Os || (Os = {})).pop = "pop"),
  (Fs.push = "push"),
  ((Us = zs || (zs = {})).back = "back"),
  (Us.forward = "forward"),
  (Us.unknown = "");
const Bs = /^[^#]+#/;
function Vs(e, t) {
  return e.replace(Bs, "#") + t;
}
function Hs(e) {
  let t;
  if ("el" in e) {
    const n = e.el,
      i = "string" == typeof n && n.startsWith("#"),
      r =
        "string" == typeof n
          ? i
            ? document.getElementById(n.slice(1))
            : document.querySelector(n)
          : n;
    if (!r) return;
    t = (function (e, t) {
      const n = document.documentElement.getBoundingClientRect(),
        i = e.getBoundingClientRect();
      return {
        behavior: t.behavior,
        left: i.left - n.left - (t.left || 0),
        top: i.top - n.top - (t.top || 0),
      };
    })(r, e);
  } else t = e;
  "scrollBehavior" in document.documentElement.style
    ? window.scrollTo(t)
    : window.scrollTo(
        null != t.left ? t.left : window.pageXOffset,
        null != t.top ? t.top : window.pageYOffset
      );
}
function Gs(e, t) {
  return (history.state ? history.state.position - t : -1) + e;
}
const Ws = new Map();
function qs(e = "") {
  let t = [],
    n = [""],
    i = 0;
  function r(e) {
    i++, i === n.length || n.splice(i), n.push(e);
  }
  const s = {
    location: "",
    state: {},
    base: e,
    createHref: Vs.bind(null, e),
    replace(e) {
      n.splice(i--, 1), r(e);
    },
    push(e, t) {
      r(e);
    },
    listen: (e) => (
      t.push(e),
      () => {
        const n = t.indexOf(e);
        n > -1 && t.splice(n, 1);
      }
    ),
    destroy() {
      (t = []), (n = [""]), (i = 0);
    },
    go(e, r = !0) {
      const s = this.location,
        a = e < 0 ? zs.back : zs.forward;
      (i = Math.max(0, Math.min(i + e, n.length - 1))),
        r &&
          (function (e, n, { direction: i, delta: r }) {
            const s = { direction: i, delta: r, type: Os.pop };
            for (const a of t) a(e, n, s);
          })(this.location, s, { direction: a, delta: e });
    },
  };
  return (
    Object.defineProperty(s, "location", { enumerable: !0, get: () => n[i] }), s
  );
}
function js(e) {
  return "string" == typeof e || "symbol" == typeof e;
}
const Ys = {
    path: "/",
    name: void 0,
    params: {},
    query: {},
    hash: "",
    fullPath: "/",
    matched: [],
    meta: {},
    redirectedFrom: void 0,
  },
  Xs = bs("nf");
var $s, Zs;
function Ks(e, t) {
  return As(new Error(), { type: e, [Xs]: !0 }, t);
}
function Js(e, t) {
  return e instanceof Error && Xs in e && (null == t || !!(e.type & t));
}
((Zs = $s || ($s = {}))[(Zs.aborted = 4)] = "aborted"),
  (Zs[(Zs.cancelled = 8)] = "cancelled"),
  (Zs[(Zs.duplicated = 16)] = "duplicated");
const Qs = { sensitive: !1, strict: !1, start: !0, end: !0 },
  ea = /[.+*?^${}()[\]/\\]/g;
function ta(e, t) {
  let n = 0;
  for (; n < e.length && n < t.length; ) {
    const i = t[n] - e[n];
    if (i) return i;
    n++;
  }
  return e.length < t.length
    ? 1 === e.length && 80 === e[0]
      ? -1
      : 1
    : e.length > t.length
    ? 1 === t.length && 80 === t[0]
      ? 1
      : -1
    : 0;
}
function na(e, t) {
  let n = 0;
  const i = e.score,
    r = t.score;
  for (; n < i.length && n < r.length; ) {
    const e = ta(i[n], r[n]);
    if (e) return e;
    n++;
  }
  return r.length - i.length;
}
const ia = { type: 0, value: "" },
  ra = /[a-zA-Z0-9_]/;
function sa(e, t, n) {
  const i = (function (e, t) {
      const n = As({}, Qs, t),
        i = [];
      let r = n.start ? "^" : "";
      const s = [];
      for (const l of e) {
        const e = l.length ? [] : [90];
        n.strict && !l.length && (r += "/");
        for (let t = 0; t < l.length; t++) {
          const i = l[t];
          let a = 40 + (n.sensitive ? 0.25 : 0);
          if (0 === i.type)
            t || (r += "/"), (r += i.value.replace(ea, "\\$&")), (a += 40);
          else if (1 === i.type) {
            const { value: e, repeatable: n, optional: c, regexp: u } = i;
            s.push({ name: e, repeatable: n, optional: c });
            const h = u || "[^/]+?";
            if ("[^/]+?" !== h) {
              a += 10;
              try {
                new RegExp(`(${h})`);
              } catch (o) {
                throw new Error(
                  `Invalid custom RegExp for param "${e}" (${h}): ` + o.message
                );
              }
            }
            let d = n ? `((?:${h})(?:/(?:${h}))*)` : `(${h})`;
            t || (d = c && l.length < 2 ? `(?:/${d})` : "/" + d),
              c && (d += "?"),
              (r += d),
              (a += 20),
              c && (a += -8),
              n && (a += -20),
              ".*" === h && (a += -50);
          }
          e.push(a);
        }
        i.push(e);
      }
      if (n.strict && n.end) {
        const e = i.length - 1;
        i[e][i[e].length - 1] += 0.7000000000000001;
      }
      n.strict || (r += "/?"),
        n.end ? (r += "$") : n.strict && (r += "(?:/|$)");
      const a = new RegExp(r, n.sensitive ? "" : "i");
      return {
        re: a,
        score: i,
        keys: s,
        parse: function (e) {
          const t = e.match(a),
            n = {};
          if (!t) return null;
          for (let i = 1; i < t.length; i++) {
            const e = t[i] || "",
              r = s[i - 1];
            n[r.name] = e && r.repeatable ? e.split("/") : e;
          }
          return n;
        },
        stringify: function (t) {
          let n = "",
            i = !1;
          for (const r of e) {
            (i && n.endsWith("/")) || (n += "/"), (i = !1);
            for (const e of r)
              if (0 === e.type) n += e.value;
              else if (1 === e.type) {
                const { value: s, repeatable: a, optional: o } = e,
                  l = s in t ? t[s] : "";
                if (Array.isArray(l) && !a)
                  throw new Error(
                    `Provided param "${s}" is an array but it is not repeatable (* or + modifiers)`
                  );
                const c = Array.isArray(l) ? l.join("/") : l;
                if (!c) {
                  if (!o) throw new Error(`Missing required param "${s}"`);
                  r.length < 2 &&
                    (n.endsWith("/") ? (n = n.slice(0, -1)) : (i = !0));
                }
                n += c;
              }
          }
          return n;
        },
      };
    })(
      (function (e) {
        if (!e) return [[]];
        if ("/" === e) return [[ia]];
        if (!e.startsWith("/")) throw new Error(`Invalid path "${e}"`);
        function t(e) {
          throw new Error(`ERR (${n})/"${c}": ${e}`);
        }
        let n = 0,
          i = n;
        const r = [];
        let s;
        function a() {
          s && r.push(s), (s = []);
        }
        let o,
          l = 0,
          c = "",
          u = "";
        function h() {
          c &&
            (0 === n
              ? s.push({ type: 0, value: c })
              : 1 === n || 2 === n || 3 === n
              ? (s.length > 1 &&
                  ("*" === o || "+" === o) &&
                  t(
                    `A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`
                  ),
                s.push({
                  type: 1,
                  value: c,
                  regexp: u,
                  repeatable: "*" === o || "+" === o,
                  optional: "*" === o || "?" === o,
                }))
              : t("Invalid state to consume buffer"),
            (c = ""));
        }
        function d() {
          c += o;
        }
        for (; l < e.length; )
          if (((o = e[l++]), "\\" !== o || 2 === n))
            switch (n) {
              case 0:
                "/" === o ? (c && h(), a()) : ":" === o ? (h(), (n = 1)) : d();
                break;
              case 4:
                d(), (n = i);
                break;
              case 1:
                "(" === o
                  ? (n = 2)
                  : ra.test(o)
                  ? d()
                  : (h(), (n = 0), "*" !== o && "?" !== o && "+" !== o && l--);
                break;
              case 2:
                ")" === o
                  ? "\\" == u[u.length - 1]
                    ? (u = u.slice(0, -1) + o)
                    : (n = 3)
                  : (u += o);
                break;
              case 3:
                h(),
                  (n = 0),
                  "*" !== o && "?" !== o && "+" !== o && l--,
                  (u = "");
                break;
              default:
                t("Unknown state");
            }
          else (i = n), (n = 4);
        return (
          2 === n && t(`Unfinished custom RegExp for param "${c}"`), h(), a(), r
        );
      })(e.path),
      n
    ),
    r = As(i, { record: e, parent: t, children: [], alias: [] });
  return t && !r.record.aliasOf == !t.record.aliasOf && t.children.push(r), r;
}
function aa(e, t) {
  const n = [],
    i = new Map();
  function r(e, n, i) {
    const o = !i,
      l = (function (e) {
        return {
          path: e.path,
          redirect: e.redirect,
          name: e.name,
          meta: e.meta || {},
          aliasOf: void 0,
          beforeEnter: e.beforeEnter,
          props: oa(e),
          children: e.children || [],
          instances: {},
          leaveGuards: new Set(),
          updateGuards: new Set(),
          enterCallbacks: {},
          components:
            "components" in e ? e.components || {} : { default: e.component },
        };
      })(e);
    l.aliasOf = i && i.record;
    const c = ua(t, e),
      u = [l];
    if ("alias" in e) {
      const t = "string" == typeof e.alias ? [e.alias] : e.alias;
      for (const e of t)
        u.push(
          As({}, l, {
            components: i ? i.record.components : l.components,
            path: e,
            aliasOf: i ? i.record : l,
          })
        );
    }
    let h, d;
    for (const t of u) {
      const { path: u } = t;
      if (n && "/" !== u[0]) {
        const e = n.record.path,
          i = "/" === e[e.length - 1] ? "" : "/";
        t.path = n.record.path + (u && i + u);
      }
      if (
        ((h = sa(t, n, c)),
        i
          ? i.alias.push(h)
          : ((d = d || h),
            d !== h && d.alias.push(h),
            o && e.name && !la(h) && s(e.name)),
        "children" in l)
      ) {
        const e = l.children;
        for (let t = 0; t < e.length; t++) r(e[t], h, i && i.children[t]);
      }
      (i = i || h), a(h);
    }
    return d
      ? () => {
          s(d);
        }
      : Ls;
  }
  function s(e) {
    if (js(e)) {
      const t = i.get(e);
      t &&
        (i.delete(e),
        n.splice(n.indexOf(t), 1),
        t.children.forEach(s),
        t.alias.forEach(s));
    } else {
      const t = n.indexOf(e);
      t > -1 &&
        (n.splice(t, 1),
        e.record.name && i.delete(e.record.name),
        e.children.forEach(s),
        e.alias.forEach(s));
    }
  }
  function a(e) {
    let t = 0;
    for (; t < n.length && na(e, n[t]) >= 0; ) t++;
    n.splice(t, 0, e), e.record.name && !la(e) && i.set(e.record.name, e);
  }
  return (
    (t = ua({ strict: !1, end: !0, sensitive: !1 }, t)),
    e.forEach((e) => r(e)),
    {
      addRoute: r,
      resolve: function (e, t) {
        let r,
          s,
          a,
          o = {};
        if ("name" in e && e.name) {
          if (((r = i.get(e.name)), !r)) throw Ks(1, { location: e });
          (a = r.record.name),
            (o = As(
              (function (e, t) {
                const n = {};
                for (const i of t) i in e && (n[i] = e[i]);
                return n;
              })(
                t.params,
                r.keys.filter((e) => !e.optional).map((e) => e.name)
              ),
              e.params
            )),
            (s = r.stringify(o));
        } else if ("path" in e)
          (s = e.path),
            (r = n.find((e) => e.re.test(s))),
            r && ((o = r.parse(s)), (a = r.record.name));
        else {
          if (
            ((r = t.name ? i.get(t.name) : n.find((e) => e.re.test(t.path))),
            !r)
          )
            throw Ks(1, { location: e, currentLocation: t });
          (a = r.record.name),
            (o = As({}, t.params, e.params)),
            (s = r.stringify(o));
        }
        const l = [];
        let c = r;
        for (; c; ) l.unshift(c.record), (c = c.parent);
        return { name: a, path: s, params: o, matched: l, meta: ca(l) };
      },
      removeRoute: s,
      getRoutes: function () {
        return n;
      },
      getRecordMatcher: function (e) {
        return i.get(e);
      },
    }
  );
}
function oa(e) {
  const t = {},
    n = e.props || !1;
  if ("component" in e) t.default = n;
  else for (const i in e.components) t[i] = "boolean" == typeof n ? n : n[i];
  return t;
}
function la(e) {
  for (; e; ) {
    if (e.record.aliasOf) return !0;
    e = e.parent;
  }
  return !1;
}
function ca(e) {
  return e.reduce((e, t) => As(e, t.meta), {});
}
function ua(e, t) {
  const n = {};
  for (const i in e) n[i] = i in t ? t[i] : e[i];
  return n;
}
const ha = /#/g,
  da = /&/g,
  pa = /\//g,
  fa = /=/g,
  ma = /\?/g,
  ga = /\+/g,
  va = /%5B/g,
  _a = /%5D/g,
  ya = /%5E/g,
  xa = /%60/g,
  ba = /%7B/g,
  wa = /%7C/g,
  Sa = /%7D/g,
  Ma = /%20/g;
function Ta(e) {
  return encodeURI("" + e)
    .replace(wa, "|")
    .replace(va, "[")
    .replace(_a, "]");
}
function Ca(e) {
  return Ta(e)
    .replace(ga, "%2B")
    .replace(Ma, "+")
    .replace(ha, "%23")
    .replace(da, "%26")
    .replace(xa, "`")
    .replace(ba, "{")
    .replace(Sa, "}")
    .replace(ya, "^");
}
function Ea(e) {
  return null == e
    ? ""
    : (function (e) {
        return Ta(e).replace(ha, "%23").replace(ma, "%3F");
      })(e).replace(pa, "%2F");
}
function Aa(e) {
  try {
    return decodeURIComponent("" + e);
  } catch (t) {}
  return "" + e;
}
function Pa(e) {
  const t = {};
  if ("" === e || "?" === e) return t;
  const n = ("?" === e[0] ? e.slice(1) : e).split("&");
  for (let i = 0; i < n.length; ++i) {
    const e = n[i].replace(ga, " "),
      r = e.indexOf("="),
      s = Aa(r < 0 ? e : e.slice(0, r)),
      a = r < 0 ? null : Aa(e.slice(r + 1));
    if (s in t) {
      let e = t[s];
      Array.isArray(e) || (e = t[s] = [e]), e.push(a);
    } else t[s] = a;
  }
  return t;
}
function La(e) {
  let t = "";
  for (let n in e) {
    const i = e[n];
    if (((n = Ca(n).replace(fa, "%3D")), null == i)) {
      void 0 !== i && (t += (t.length ? "&" : "") + n);
      continue;
    }
    (Array.isArray(i) ? i.map((e) => e && Ca(e)) : [i && Ca(i)]).forEach(
      (e) => {
        void 0 !== e &&
          ((t += (t.length ? "&" : "") + n), null != e && (t += "=" + e));
      }
    );
  }
  return t;
}
function Ia(e) {
  const t = {};
  for (const n in e) {
    const i = e[n];
    void 0 !== i &&
      (t[n] = Array.isArray(i)
        ? i.map((e) => (null == e ? null : "" + e))
        : null == i
        ? i
        : "" + i);
  }
  return t;
}
function Ra() {
  let e = [];
  return {
    add: function (t) {
      return (
        e.push(t),
        () => {
          const n = e.indexOf(t);
          n > -1 && e.splice(n, 1);
        }
      );
    },
    list: () => e,
    reset: function () {
      e = [];
    },
  };
}
function Da(e, t, n, i, r) {
  const s = i && (i.enterCallbacks[r] = i.enterCallbacks[r] || []);
  return () =>
    new Promise((a, o) => {
      const l = (e) => {
          var l;
          !1 === e
            ? o(Ks(4, { from: n, to: t }))
            : e instanceof Error
            ? o(e)
            : "string" == typeof (l = e) || (l && "object" == typeof l)
            ? o(Ks(2, { from: t, to: e }))
            : (s &&
                i.enterCallbacks[r] === s &&
                "function" == typeof e &&
                s.push(e),
              a());
        },
        c = e.call(i && i.instances[r], t, n, l);
      let u = Promise.resolve(c);
      e.length < 3 && (u = u.then(l)), u.catch((e) => o(e));
    });
}
function ka(e, t, n, i) {
  const r = [];
  for (const a of e)
    for (const e in a.components) {
      let o = a.components[e];
      if ("beforeRouteEnter" === t || a.instances[e])
        if (
          "object" == typeof (s = o) ||
          "displayName" in s ||
          "props" in s ||
          "__vccOpts" in s
        ) {
          const s = (o.__vccOpts || o)[t];
          s && r.push(Da(s, n, i, a, e));
        } else {
          let s = o();
          r.push(() =>
            s.then((r) => {
              if (!r)
                return Promise.reject(
                  new Error(`Couldn't resolve component "${e}" at "${a.path}"`)
                );
              const s =
                (o = r).__esModule || (xs && "Module" === o[Symbol.toStringTag])
                  ? r.default
                  : r;
              var o;
              a.components[e] = s;
              const l = (s.__vccOpts || s)[t];
              return l && Da(l, n, i, a, e)();
            })
          );
        }
    }
  var s;
  return r;
}
function Na(e) {
  const t = Yt(Ms),
    n = Yt(Ts),
    i = Rt(() => t.resolve(At(e.to))),
    r = Rt(() => {
      const { matched: e } = i.value,
        { length: t } = e,
        r = e[t - 1],
        s = n.matched;
      if (!r || !s.length) return -1;
      const a = s.findIndex(Rs.bind(null, r));
      if (a > -1) return a;
      const o = Fa(e[t - 2]);
      return t > 1 && Fa(r) === o && s[s.length - 1].path !== o
        ? s.findIndex(Rs.bind(null, e[t - 2]))
        : a;
    }),
    s = Rt(
      () =>
        r.value > -1 &&
        (function (e, t) {
          for (const n in t) {
            const i = t[n],
              r = e[n];
            if ("string" == typeof i) {
              if (i !== r) return !1;
            } else if (
              !Array.isArray(r) ||
              r.length !== i.length ||
              i.some((e, t) => e !== r[t])
            )
              return !1;
          }
          return !0;
        })(n.params, i.value.params)
    ),
    a = Rt(
      () =>
        r.value > -1 &&
        r.value === n.matched.length - 1 &&
        Ds(n.params, i.value.params)
    );
  return {
    route: i,
    href: Rt(() => i.value.href),
    isActive: s,
    isExactActive: a,
    navigate: function (n = {}) {
      return (function (e) {
        if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) return;
        if (e.defaultPrevented) return;
        if (void 0 !== e.button && 0 !== e.button) return;
        if (e.currentTarget && e.currentTarget.getAttribute) {
          const t = e.currentTarget.getAttribute("target");
          if (/\b_blank\b/i.test(t)) return;
        }
        e.preventDefault && e.preventDefault();
        return !0;
      })(n)
        ? t[At(e.replace) ? "replace" : "push"](At(e.to)).catch(Ls)
        : Promise.resolve();
    },
  };
}
const Oa = nn({
  name: "RouterLink",
  props: {
    to: { type: [String, Object], required: !0 },
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: { type: String, default: "page" },
  },
  useLink: Na,
  setup(e, { slots: t }) {
    const n = dt(Na(e)),
      { options: i } = Yt(Ms),
      r = Rt(() => ({
        [za(e.activeClass, i.linkActiveClass, "router-link-active")]:
          n.isActive,
        [za(
          e.exactActiveClass,
          i.linkExactActiveClass,
          "router-link-exact-active"
        )]: n.isExactActive,
      }));
    return () => {
      const i = t.default && t.default(n);
      return e.custom
        ? i
        : Ar(
            "a",
            {
              "aria-current": n.isExactActive ? e.ariaCurrentValue : null,
              href: n.href,
              onClick: n.navigate,
              class: r.value,
            },
            i
          );
    };
  },
});
function Fa(e) {
  return e ? (e.aliasOf ? e.aliasOf.path : e.path) : "";
}
const za = (e, t, n) => (null != e ? e : null != t ? t : n);
function Ua(e, t) {
  if (!e) return null;
  const n = e(t);
  return 1 === n.length ? n[0] : n;
}
const Ba = nn({
  name: "RouterView",
  inheritAttrs: !1,
  props: { name: { type: String, default: "default" }, route: Object },
  setup(e, { attrs: t, slots: n }) {
    const i = Yt(Cs),
      r = Rt(() => e.route || i.value),
      s = Yt(Ss, 0),
      a = Rt(() => r.value.matched[s]);
    jt(Ss, s + 1), jt(ws, a), jt(Cs, r);
    const o = Tt();
    return (
      Sr(
        () => [o.value, a.value, e.name],
        ([e, t, n], [i, r, s]) => {
          t &&
            ((t.instances[n] = e),
            r &&
              r !== t &&
              e &&
              e === i &&
              (t.leaveGuards.size || (t.leaveGuards = r.leaveGuards),
              t.updateGuards.size || (t.updateGuards = r.updateGuards))),
            !e ||
              !t ||
              (r && Rs(t, r) && i) ||
              (t.enterCallbacks[n] || []).forEach((t) => t(e));
        },
        { flush: "post" }
      ),
      () => {
        const i = r.value,
          s = a.value,
          l = s && s.components[e.name],
          c = e.name;
        if (!l) return Ua(n.default, { Component: l, route: i });
        const u = s.props[e.name],
          h = u
            ? !0 === u
              ? i.params
              : "function" == typeof u
              ? u(i)
              : u
            : null,
          d = Ar(
            l,
            As({}, h, t, {
              onVnodeUnmounted: (e) => {
                e.component.isUnmounted && (s.instances[c] = null);
              },
              ref: o,
            })
          );
        return Ua(n.default, { Component: d, route: i }) || d;
      }
    );
  },
});
function Va(e) {
  const t = aa(e.routes, e),
    n = e.parseQuery || Pa,
    i = e.stringifyQuery || La,
    r = e.history,
    s = Ra(),
    a = Ra(),
    o = Ra(),
    l = Ct(Ys, !0);
  let c = Ys;
  Es &&
    e.scrollBehavior &&
    "scrollRestoration" in history &&
    (history.scrollRestoration = "manual");
  const u = Ps.bind(null, (e) => "" + e),
    h = Ps.bind(null, Ea),
    d = Ps.bind(null, Aa);
  function p(e, s) {
    if (((s = As({}, s || l.value)), "string" == typeof e)) {
      const i = Is(n, e, s.path),
        a = t.resolve({ path: i.path }, s),
        o = r.createHref(i.fullPath);
      return As(i, a, {
        params: d(a.params),
        hash: Aa(i.hash),
        redirectedFrom: void 0,
        href: o,
      });
    }
    let a;
    if ("path" in e) a = As({}, e, { path: Is(n, e.path, s.path).path });
    else {
      const t = As({}, e.params);
      for (const e in t) null == t[e] && delete t[e];
      (a = As({}, e, { params: h(e.params) })), (s.params = h(s.params));
    }
    const o = t.resolve(a, s),
      c = e.hash || "";
    o.params = u(d(o.params));
    const p = (function (e, t) {
      const n = t.query ? e(t.query) : "";
      return t.path + (n && "?") + n + (t.hash || "");
    })(
      i,
      As({}, e, {
        hash:
          ((f = c), Ta(f).replace(ba, "{").replace(Sa, "}").replace(ya, "^")),
        path: o.path,
      })
    );
    var f;
    const m = r.createHref(p);
    return As(
      { fullPath: p, hash: c, query: i === La ? Ia(e.query) : e.query || {} },
      o,
      { redirectedFrom: void 0, href: m }
    );
  }
  function f(e) {
    return "string" == typeof e ? Is(n, e, l.value.path) : As({}, e);
  }
  function m(e, t) {
    if (c !== e) return Ks(8, { from: t, to: e });
  }
  function g(e) {
    return _(e);
  }
  function v(e) {
    const t = e.matched[e.matched.length - 1];
    if (t && t.redirect) {
      const { redirect: n } = t;
      let i = "function" == typeof n ? n(e) : n;
      return (
        "string" == typeof i &&
          ((i = i.includes("?") || i.includes("#") ? (i = f(i)) : { path: i }),
          (i.params = {})),
        As({ query: e.query, hash: e.hash, params: e.params }, i)
      );
    }
  }
  function _(e, t) {
    const n = (c = p(e)),
      r = l.value,
      s = e.state,
      a = e.force,
      o = !0 === e.replace,
      u = v(n);
    if (u) return _(As(f(u), { state: s, force: a, replace: o }), t || n);
    const h = n;
    let d;
    return (
      (h.redirectedFrom = t),
      !a &&
        (function (e, t, n) {
          const i = t.matched.length - 1,
            r = n.matched.length - 1;
          return (
            i > -1 &&
            i === r &&
            Rs(t.matched[i], n.matched[r]) &&
            Ds(t.params, n.params) &&
            e(t.query) === e(n.query) &&
            t.hash === n.hash
          );
        })(i, r, n) &&
        ((d = Ks(16, { to: h, from: r })), L(r, r, !0, !1)),
      (d ? Promise.resolve(d) : x(h, r))
        .catch((e) => (Js(e) ? e : A(e, h, r)))
        .then((e) => {
          if (e) {
            if (Js(e, 2))
              return _(As(f(e.to), { state: s, force: a, replace: o }), t || h);
          } else e = w(h, r, !0, o, s);
          return b(h, r, e), e;
        })
    );
  }
  function y(e, t) {
    const n = m(e, t);
    return n ? Promise.reject(n) : Promise.resolve();
  }
  function x(e, t) {
    let n;
    const [i, r, o] = (function (e, t) {
      const n = [],
        i = [],
        r = [],
        s = Math.max(t.matched.length, e.matched.length);
      for (let a = 0; a < s; a++) {
        const s = t.matched[a];
        s && (e.matched.find((e) => Rs(e, s)) ? i.push(s) : n.push(s));
        const o = e.matched[a];
        o && (t.matched.find((e) => Rs(e, o)) || r.push(o));
      }
      return [n, i, r];
    })(e, t);
    n = ka(i.reverse(), "beforeRouteLeave", e, t);
    for (const s of i)
      s.leaveGuards.forEach((i) => {
        n.push(Da(i, e, t));
      });
    const l = y.bind(null, e, t);
    return (
      n.push(l),
      Ha(n)
        .then(() => {
          n = [];
          for (const i of s.list()) n.push(Da(i, e, t));
          return n.push(l), Ha(n);
        })
        .then(() => {
          n = ka(r, "beforeRouteUpdate", e, t);
          for (const i of r)
            i.updateGuards.forEach((i) => {
              n.push(Da(i, e, t));
            });
          return n.push(l), Ha(n);
        })
        .then(() => {
          n = [];
          for (const i of e.matched)
            if (i.beforeEnter && !t.matched.includes(i))
              if (Array.isArray(i.beforeEnter))
                for (const r of i.beforeEnter) n.push(Da(r, e, t));
              else n.push(Da(i.beforeEnter, e, t));
          return n.push(l), Ha(n);
        })
        .then(
          () => (
            e.matched.forEach((e) => (e.enterCallbacks = {})),
            (n = ka(o, "beforeRouteEnter", e, t)),
            n.push(l),
            Ha(n)
          )
        )
        .then(() => {
          n = [];
          for (const i of a.list()) n.push(Da(i, e, t));
          return n.push(l), Ha(n);
        })
        .catch((e) => (Js(e, 8) ? e : Promise.reject(e)))
    );
  }
  function b(e, t, n) {
    for (const i of o.list()) i(e, t, n);
  }
  function w(e, t, n, i, s) {
    const a = m(e, t);
    if (a) return a;
    const o = t === Ys,
      c = Es ? history.state : {};
    n &&
      (i || o
        ? r.replace(e.fullPath, As({ scroll: o && c && c.scroll }, s))
        : r.push(e.fullPath, s)),
      (l.value = e),
      L(e, t, n, o),
      P();
  }
  let S;
  function M() {
    S = r.listen((e, t, n) => {
      const i = p(e),
        s = v(i);
      if (s) return void _(As(s, { replace: !0 }), i).catch(Ls);
      c = i;
      const a = l.value;
      var o, u;
      Es &&
        ((o = Gs(a.fullPath, n.delta)),
        (u = { left: window.pageXOffset, top: window.pageYOffset }),
        Ws.set(o, u)),
        x(i, a)
          .catch((e) =>
            Js(e, 12)
              ? e
              : Js(e, 2)
              ? (_(e.to, i)
                  .then((e) => {
                    Js(e, 20) && !n.delta && n.type === Os.pop && r.go(-1, !1);
                  })
                  .catch(Ls),
                Promise.reject())
              : (n.delta && r.go(-n.delta, !1), A(e, i, a))
          )
          .then((e) => {
            (e = e || w(i, a, !1)) &&
              (n.delta
                ? r.go(-n.delta, !1)
                : n.type === Os.pop && Js(e, 20) && r.go(-1, !1)),
              b(i, a, e);
          })
          .catch(Ls);
    });
  }
  let T,
    C = Ra(),
    E = Ra();
  function A(e, t, n) {
    P(e);
    const i = E.list();
    return i.length && i.forEach((i) => i(e, t, n)), Promise.reject(e);
  }
  function P(e) {
    T ||
      ((T = !0),
      M(),
      C.list().forEach(([t, n]) => (e ? n(e) : t())),
      C.reset());
  }
  function L(t, n, i, r) {
    const { scrollBehavior: s } = e;
    if (!Es || !s) return Promise.resolve();
    const a =
      (!i &&
        (function (e) {
          const t = Ws.get(e);
          return Ws.delete(e), t;
        })(Gs(t.fullPath, 0))) ||
      ((r || !i) && history.state && history.state.scroll) ||
      null;
    return pr()
      .then(() => s(t, n, a))
      .then((e) => e && Hs(e))
      .catch((e) => A(e, t, n));
  }
  const I = (e) => r.go(e);
  let R;
  const D = new Set();
  return {
    currentRoute: l,
    addRoute: function (e, n) {
      let i, r;
      return (
        js(e) ? ((i = t.getRecordMatcher(e)), (r = n)) : (r = e),
        t.addRoute(r, i)
      );
    },
    removeRoute: function (e) {
      const n = t.getRecordMatcher(e);
      n && t.removeRoute(n);
    },
    hasRoute: function (e) {
      return !!t.getRecordMatcher(e);
    },
    getRoutes: function () {
      return t.getRoutes().map((e) => e.record);
    },
    resolve: p,
    options: e,
    push: g,
    replace: function (e) {
      return g(As(f(e), { replace: !0 }));
    },
    go: I,
    back: () => I(-1),
    forward: () => I(1),
    beforeEach: s.add,
    beforeResolve: a.add,
    afterEach: o.add,
    onError: E.add,
    isReady: function () {
      return T && l.value !== Ys
        ? Promise.resolve()
        : new Promise((e, t) => {
            C.add([e, t]);
          });
    },
    install(e) {
      e.component("RouterLink", Oa),
        e.component("RouterView", Ba),
        (e.config.globalProperties.$router = this),
        Object.defineProperty(e.config.globalProperties, "$route", {
          enumerable: !0,
          get: () => At(l),
        }),
        Es &&
          !R &&
          l.value === Ys &&
          ((R = !0), g(r.location).catch((e) => {}));
      const t = {};
      for (const i in Ys) t[i] = Rt(() => l.value[i]);
      e.provide(Ms, this), e.provide(Ts, dt(t)), e.provide(Cs, l);
      const n = e.unmount;
      D.add(e),
        (e.unmount = function () {
          D.delete(e),
            D.size < 1 &&
              ((c = Ys), S && S(), (l.value = Ys), (R = !1), (T = !1)),
            n();
        });
    },
  };
}
function Ha(e) {
  return e.reduce((e, t) => e.then(() => t()), Promise.resolve());
}
function Ga() {
  return Yt(Ms);
}
function Wa() {
  return Yt(Ts);
}
var qa = {
    update: null,
    begin: null,
    loopBegin: null,
    changeBegin: null,
    change: null,
    changeComplete: null,
    loopComplete: null,
    complete: null,
    loop: 1,
    direction: "normal",
    autoplay: !0,
    timelineOffset: 0,
  },
  ja = {
    duration: 1e3,
    delay: 0,
    endDelay: 0,
    easing: "easeOutElastic(1, .5)",
    round: 0,
  },
  Ya = [
    "translateX",
    "translateY",
    "translateZ",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "scale",
    "scaleX",
    "scaleY",
    "scaleZ",
    "skew",
    "skewX",
    "skewY",
    "perspective",
    "matrix",
    "matrix3d",
  ],
  Xa = { CSS: {}, springs: {} };
function $a(e, t, n) {
  return Math.min(Math.max(e, t), n);
}
function Za(e, t) {
  return e.indexOf(t) > -1;
}
function Ka(e, t) {
  return e.apply(null, t);
}
var Ja = {
  arr: function (e) {
    return Array.isArray(e);
  },
  obj: function (e) {
    return Za(Object.prototype.toString.call(e), "Object");
  },
  pth: function (e) {
    return Ja.obj(e) && e.hasOwnProperty("totalLength");
  },
  svg: function (e) {
    return e instanceof SVGElement;
  },
  inp: function (e) {
    return e instanceof HTMLInputElement;
  },
  dom: function (e) {
    return e.nodeType || Ja.svg(e);
  },
  str: function (e) {
    return "string" == typeof e;
  },
  fnc: function (e) {
    return "function" == typeof e;
  },
  und: function (e) {
    return void 0 === e;
  },
  nil: function (e) {
    return Ja.und(e) || null === e;
  },
  hex: function (e) {
    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(e);
  },
  rgb: function (e) {
    return /^rgb/.test(e);
  },
  hsl: function (e) {
    return /^hsl/.test(e);
  },
  col: function (e) {
    return Ja.hex(e) || Ja.rgb(e) || Ja.hsl(e);
  },
  key: function (e) {
    return (
      !qa.hasOwnProperty(e) &&
      !ja.hasOwnProperty(e) &&
      "targets" !== e &&
      "keyframes" !== e
    );
  },
};
function Qa(e) {
  var t = /\(([^)]+)\)/.exec(e);
  return t
    ? t[1].split(",").map(function (e) {
        return parseFloat(e);
      })
    : [];
}
function eo(e, t) {
  var n = Qa(e),
    i = $a(Ja.und(n[0]) ? 1 : n[0], 0.1, 100),
    r = $a(Ja.und(n[1]) ? 100 : n[1], 0.1, 100),
    s = $a(Ja.und(n[2]) ? 10 : n[2], 0.1, 100),
    a = $a(Ja.und(n[3]) ? 0 : n[3], 0.1, 100),
    o = Math.sqrt(r / i),
    l = s / (2 * Math.sqrt(r * i)),
    c = l < 1 ? o * Math.sqrt(1 - l * l) : 0,
    u = l < 1 ? (l * o - a) / c : -a + o;
  function h(e) {
    var n = t ? (t * e) / 1e3 : e;
    return (
      (n =
        l < 1
          ? Math.exp(-n * l * o) * (1 * Math.cos(c * n) + u * Math.sin(c * n))
          : (1 + u * n) * Math.exp(-n * o)),
      0 === e || 1 === e ? e : 1 - n
    );
  }
  return t
    ? h
    : function () {
        var t = Xa.springs[e];
        if (t) return t;
        for (var n = 1 / 6, i = 0, r = 0; ; )
          if (1 === h((i += n))) {
            if (++r >= 16) break;
          } else r = 0;
        var s = i * n * 1e3;
        return (Xa.springs[e] = s), s;
      };
}
function to(e) {
  return (
    void 0 === e && (e = 10),
    function (t) {
      return Math.ceil($a(t, 1e-6, 1) * e) * (1 / e);
    }
  );
}
var no,
  io,
  ro = (function () {
    var e = 0.1;
    function t(e, t) {
      return 1 - 3 * t + 3 * e;
    }
    function n(e, t) {
      return 3 * t - 6 * e;
    }
    function i(e) {
      return 3 * e;
    }
    function r(e, r, s) {
      return ((t(r, s) * e + n(r, s)) * e + i(r)) * e;
    }
    function s(e, r, s) {
      return 3 * t(r, s) * e * e + 2 * n(r, s) * e + i(r);
    }
    return function (t, n, i, a) {
      if (0 <= t && t <= 1 && 0 <= i && i <= 1) {
        var o = new Float32Array(11);
        if (t !== n || i !== a)
          for (var l = 0; l < 11; ++l) o[l] = r(l * e, t, i);
        return function (e) {
          return (t === n && i === a) || 0 === e || 1 === e ? e : r(c(e), n, a);
        };
      }
      function c(n) {
        for (var a = 0, l = 1; 10 !== l && o[l] <= n; ++l) a += e;
        --l;
        var c = a + ((n - o[l]) / (o[l + 1] - o[l])) * e,
          u = s(c, t, i);
        return u >= 0.001
          ? (function (e, t, n, i) {
              for (var a = 0; a < 4; ++a) {
                var o = s(t, n, i);
                if (0 === o) return t;
                t -= (r(t, n, i) - e) / o;
              }
              return t;
            })(n, c, t, i)
          : 0 === u
          ? c
          : (function (e, t, n, i, s) {
              var a,
                o,
                l = 0;
              do {
                (a = r((o = t + (n - t) / 2), i, s) - e) > 0
                  ? (n = o)
                  : (t = o);
              } while (Math.abs(a) > 1e-7 && ++l < 10);
              return o;
            })(n, a, a + e, t, i);
      }
    };
  })(),
  so =
    ((no = {
      linear: function () {
        return function (e) {
          return e;
        };
      },
    }),
    (io = {
      Sine: function () {
        return function (e) {
          return 1 - Math.cos((e * Math.PI) / 2);
        };
      },
      Circ: function () {
        return function (e) {
          return 1 - Math.sqrt(1 - e * e);
        };
      },
      Back: function () {
        return function (e) {
          return e * e * (3 * e - 2);
        };
      },
      Bounce: function () {
        return function (e) {
          for (var t, n = 4; e < ((t = Math.pow(2, --n)) - 1) / 11; );
          return (
            1 / Math.pow(4, 3 - n) - 7.5625 * Math.pow((3 * t - 2) / 22 - e, 2)
          );
        };
      },
      Elastic: function (e, t) {
        void 0 === e && (e = 1), void 0 === t && (t = 0.5);
        var n = $a(e, 1, 10),
          i = $a(t, 0.1, 2);
        return function (e) {
          return 0 === e || 1 === e
            ? e
            : -n *
                Math.pow(2, 10 * (e - 1)) *
                Math.sin(
                  ((e - 1 - (i / (2 * Math.PI)) * Math.asin(1 / n)) *
                    (2 * Math.PI)) /
                    i
                );
        };
      },
    }),
    ["Quad", "Cubic", "Quart", "Quint", "Expo"].forEach(function (e, t) {
      io[e] = function () {
        return function (e) {
          return Math.pow(e, t + 2);
        };
      };
    }),
    Object.keys(io).forEach(function (e) {
      var t = io[e];
      (no["easeIn" + e] = t),
        (no["easeOut" + e] = function (e, n) {
          return function (i) {
            return 1 - t(e, n)(1 - i);
          };
        }),
        (no["easeInOut" + e] = function (e, n) {
          return function (i) {
            return i < 0.5 ? t(e, n)(2 * i) / 2 : 1 - t(e, n)(-2 * i + 2) / 2;
          };
        }),
        (no["easeOutIn" + e] = function (e, n) {
          return function (i) {
            return i < 0.5
              ? (1 - t(e, n)(1 - 2 * i)) / 2
              : (t(e, n)(2 * i - 1) + 1) / 2;
          };
        });
    }),
    no);
function ao(e, t) {
  if (Ja.fnc(e)) return e;
  var n = e.split("(")[0],
    i = so[n],
    r = Qa(e);
  switch (n) {
    case "spring":
      return eo(e, t);
    case "cubicBezier":
      return Ka(ro, r);
    case "steps":
      return Ka(to, r);
    default:
      return Ka(i, r);
  }
}
function oo(e) {
  try {
    return document.querySelectorAll(e);
  } catch (t) {
    return;
  }
}
function lo(e, t) {
  for (
    var n = e.length,
      i = arguments.length >= 2 ? arguments[1] : void 0,
      r = [],
      s = 0;
    s < n;
    s++
  )
    if (s in e) {
      var a = e[s];
      t.call(i, a, s, e) && r.push(a);
    }
  return r;
}
function co(e) {
  return e.reduce(function (e, t) {
    return e.concat(Ja.arr(t) ? co(t) : t);
  }, []);
}
function uo(e) {
  return Ja.arr(e)
    ? e
    : (Ja.str(e) && (e = oo(e) || e),
      e instanceof NodeList || e instanceof HTMLCollection
        ? [].slice.call(e)
        : [e]);
}
function ho(e, t) {
  return e.some(function (e) {
    return e === t;
  });
}
function po(e) {
  var t = {};
  for (var n in e) t[n] = e[n];
  return t;
}
function fo(e, t) {
  var n = po(e);
  for (var i in e) n[i] = t.hasOwnProperty(i) ? t[i] : e[i];
  return n;
}
function mo(e, t) {
  var n = po(e);
  for (var i in t) n[i] = Ja.und(e[i]) ? t[i] : e[i];
  return n;
}
function go(e) {
  return Ja.rgb(e)
    ? (n = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec((t = e)))
      ? "rgba(" + n[1] + ",1)"
      : t
    : Ja.hex(e)
    ? (function (e) {
        var t = e.replace(
            /^#?([a-f\d])([a-f\d])([a-f\d])$/i,
            function (e, t, n, i) {
              return t + t + n + n + i + i;
            }
          ),
          n = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);
        return (
          "rgba(" +
          parseInt(n[1], 16) +
          "," +
          parseInt(n[2], 16) +
          "," +
          parseInt(n[3], 16) +
          ",1)"
        );
      })(e)
    : Ja.hsl(e)
    ? (function (e) {
        var t,
          n,
          i,
          r =
            /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(e) ||
            /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(e),
          s = parseInt(r[1], 10) / 360,
          a = parseInt(r[2], 10) / 100,
          o = parseInt(r[3], 10) / 100,
          l = r[4] || 1;
        function c(e, t, n) {
          return (
            n < 0 && (n += 1),
            n > 1 && (n -= 1),
            n < 1 / 6
              ? e + 6 * (t - e) * n
              : n < 0.5
              ? t
              : n < 2 / 3
              ? e + (t - e) * (2 / 3 - n) * 6
              : e
          );
        }
        if (0 == a) t = n = i = o;
        else {
          var u = o < 0.5 ? o * (1 + a) : o + a - o * a,
            h = 2 * o - u;
          (t = c(h, u, s + 1 / 3)), (n = c(h, u, s)), (i = c(h, u, s - 1 / 3));
        }
        return (
          "rgba(" + 255 * t + "," + 255 * n + "," + 255 * i + "," + l + ")"
        );
      })(e)
    : void 0;
  var t, n;
}
function vo(e) {
  var t =
    /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(
      e
    );
  if (t) return t[1];
}
function _o(e, t) {
  return Ja.fnc(e) ? e(t.target, t.id, t.total) : e;
}
function yo(e, t) {
  return e.getAttribute(t);
}
function xo(e, t, n) {
  if (ho([n, "deg", "rad", "turn"], vo(t))) return t;
  var i = Xa.CSS[t + n];
  if (!Ja.und(i)) return i;
  var r = document.createElement(e.tagName),
    s =
      e.parentNode && e.parentNode !== document ? e.parentNode : document.body;
  s.appendChild(r), (r.style.position = "absolute"), (r.style.width = 100 + n);
  var a = 100 / r.offsetWidth;
  s.removeChild(r);
  var o = a * parseFloat(t);
  return (Xa.CSS[t + n] = o), o;
}
function bo(e, t, n) {
  if (t in e.style) {
    var i = t.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
      r = e.style[t] || getComputedStyle(e).getPropertyValue(i) || "0";
    return n ? xo(e, r, n) : r;
  }
}
function wo(e, t) {
  return Ja.dom(e) && !Ja.inp(e) && (!Ja.nil(yo(e, t)) || (Ja.svg(e) && e[t]))
    ? "attribute"
    : Ja.dom(e) && ho(Ya, t)
    ? "transform"
    : Ja.dom(e) && "transform" !== t && bo(e, t)
    ? "css"
    : null != e[t]
    ? "object"
    : void 0;
}
function So(e) {
  if (Ja.dom(e)) {
    for (
      var t,
        n = e.style.transform || "",
        i = /(\w+)\(([^)]*)\)/g,
        r = new Map();
      (t = i.exec(n));

    )
      r.set(t[1], t[2]);
    return r;
  }
}
function Mo(e, t, n, i) {
  var r = Za(t, "scale")
      ? 1
      : 0 +
        (function (e) {
          return Za(e, "translate") || "perspective" === e
            ? "px"
            : Za(e, "rotate") || Za(e, "skew")
            ? "deg"
            : void 0;
        })(t),
    s = So(e).get(t) || r;
  return (
    n && (n.transforms.list.set(t, s), (n.transforms.last = t)),
    i ? xo(e, s, i) : s
  );
}
function To(e, t, n, i) {
  switch (wo(e, t)) {
    case "transform":
      return Mo(e, t, i, n);
    case "css":
      return bo(e, t, n);
    case "attribute":
      return yo(e, t);
    default:
      return e[t] || 0;
  }
}
function Co(e, t) {
  var n = /^(\*=|\+=|-=)/.exec(e);
  if (!n) return e;
  var i = vo(e) || 0,
    r = parseFloat(t),
    s = parseFloat(e.replace(n[0], ""));
  switch (n[0][0]) {
    case "+":
      return r + s + i;
    case "-":
      return r - s + i;
    case "*":
      return r * s + i;
  }
}
function Eo(e, t) {
  if (Ja.col(e)) return go(e);
  if (/\s/g.test(e)) return e;
  var n = vo(e),
    i = n ? e.substr(0, e.length - n.length) : e;
  return t ? i + t : i;
}
function Ao(e, t) {
  return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
}
function Po(e) {
  for (var t, n = e.points, i = 0, r = 0; r < n.numberOfItems; r++) {
    var s = n.getItem(r);
    r > 0 && (i += Ao(t, s)), (t = s);
  }
  return i;
}
function Lo(e) {
  if (e.getTotalLength) return e.getTotalLength();
  switch (e.tagName.toLowerCase()) {
    case "circle":
      return (function (e) {
        return 2 * Math.PI * yo(e, "r");
      })(e);
    case "rect":
      return (function (e) {
        return 2 * yo(e, "width") + 2 * yo(e, "height");
      })(e);
    case "line":
      return (function (e) {
        return Ao(
          { x: yo(e, "x1"), y: yo(e, "y1") },
          { x: yo(e, "x2"), y: yo(e, "y2") }
        );
      })(e);
    case "polyline":
      return Po(e);
    case "polygon":
      return (function (e) {
        var t = e.points;
        return Po(e) + Ao(t.getItem(t.numberOfItems - 1), t.getItem(0));
      })(e);
  }
}
function Io(e, t) {
  var n = t || {},
    i =
      n.el ||
      (function (e) {
        for (var t = e.parentNode; Ja.svg(t) && Ja.svg(t.parentNode); )
          t = t.parentNode;
        return t;
      })(e),
    r = i.getBoundingClientRect(),
    s = yo(i, "viewBox"),
    a = r.width,
    o = r.height,
    l = n.viewBox || (s ? s.split(" ") : [0, 0, a, o]);
  return {
    el: i,
    viewBox: l,
    x: l[0] / 1,
    y: l[1] / 1,
    w: a,
    h: o,
    vW: l[2],
    vH: l[3],
  };
}
function Ro(e, t, n) {
  function i(n) {
    void 0 === n && (n = 0);
    var i = t + n >= 1 ? t + n : 0;
    return e.el.getPointAtLength(i);
  }
  var r = Io(e.el, e.svg),
    s = i(),
    a = i(-1),
    o = i(1),
    l = n ? 1 : r.w / r.vW,
    c = n ? 1 : r.h / r.vH;
  switch (e.property) {
    case "x":
      return (s.x - r.x) * l;
    case "y":
      return (s.y - r.y) * c;
    case "angle":
      return (180 * Math.atan2(o.y - a.y, o.x - a.x)) / Math.PI;
  }
}
function Do(e, t) {
  var n = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g,
    i = Eo(Ja.pth(e) ? e.totalLength : e, t) + "";
  return {
    original: i,
    numbers: i.match(n) ? i.match(n).map(Number) : [0],
    strings: Ja.str(e) || t ? i.split(n) : [],
  };
}
function ko(e) {
  return lo(e ? co(Ja.arr(e) ? e.map(uo) : uo(e)) : [], function (e, t, n) {
    return n.indexOf(e) === t;
  });
}
function No(e) {
  var t = ko(e);
  return t.map(function (e, n) {
    return { target: e, id: n, total: t.length, transforms: { list: So(e) } };
  });
}
function Oo(e, t) {
  var n = po(t);
  if ((/^spring/.test(n.easing) && (n.duration = eo(n.easing)), Ja.arr(e))) {
    var i = e.length;
    2 === i && !Ja.obj(e[0])
      ? (e = { value: e })
      : Ja.fnc(t.duration) || (n.duration = t.duration / i);
  }
  var r = Ja.arr(e) ? e : [e];
  return r
    .map(function (e, n) {
      var i = Ja.obj(e) && !Ja.pth(e) ? e : { value: e };
      return (
        Ja.und(i.delay) && (i.delay = n ? 0 : t.delay),
        Ja.und(i.endDelay) &&
          (i.endDelay = n === r.length - 1 ? t.endDelay : 0),
        i
      );
    })
    .map(function (e) {
      return mo(e, n);
    });
}
function Fo(e, t) {
  var n = [],
    i = t.keyframes;
  for (var r in (i &&
    (t = mo(
      (function (e) {
        for (
          var t = lo(
              co(
                e.map(function (e) {
                  return Object.keys(e);
                })
              ),
              function (e) {
                return Ja.key(e);
              }
            ).reduce(function (e, t) {
              return e.indexOf(t) < 0 && e.push(t), e;
            }, []),
            n = {},
            i = function (i) {
              var r = t[i];
              n[r] = e.map(function (e) {
                var t = {};
                for (var n in e)
                  Ja.key(n) ? n == r && (t.value = e[n]) : (t[n] = e[n]);
                return t;
              });
            },
            r = 0;
          r < t.length;
          r++
        )
          i(r);
        return n;
      })(i),
      t
    )),
  t))
    Ja.key(r) && n.push({ name: r, tweens: Oo(t[r], e) });
  return n;
}
function zo(e, t) {
  var n;
  return e.tweens.map(function (i) {
    var r = (function (e, t) {
        var n = {};
        for (var i in e) {
          var r = _o(e[i], t);
          Ja.arr(r) &&
            1 ===
              (r = r.map(function (e) {
                return _o(e, t);
              })).length &&
            (r = r[0]),
            (n[i] = r);
        }
        return (
          (n.duration = parseFloat(n.duration)),
          (n.delay = parseFloat(n.delay)),
          n
        );
      })(i, t),
      s = r.value,
      a = Ja.arr(s) ? s[1] : s,
      o = vo(a),
      l = To(t.target, e.name, o, t),
      c = n ? n.to.original : l,
      u = Ja.arr(s) ? s[0] : c,
      h = vo(u) || vo(l),
      d = o || h;
    return (
      Ja.und(a) && (a = c),
      (r.from = Do(u, d)),
      (r.to = Do(Co(a, u), d)),
      (r.start = n ? n.end : 0),
      (r.end = r.start + r.delay + r.duration + r.endDelay),
      (r.easing = ao(r.easing, r.duration)),
      (r.isPath = Ja.pth(s)),
      (r.isPathTargetInsideSVG = r.isPath && Ja.svg(t.target)),
      (r.isColor = Ja.col(r.from.original)),
      r.isColor && (r.round = 1),
      (n = r),
      r
    );
  });
}
var Uo = {
  css: function (e, t, n) {
    return (e.style[t] = n);
  },
  attribute: function (e, t, n) {
    return e.setAttribute(t, n);
  },
  object: function (e, t, n) {
    return (e[t] = n);
  },
  transform: function (e, t, n, i, r) {
    if ((i.list.set(t, n), t === i.last || r)) {
      var s = "";
      i.list.forEach(function (e, t) {
        s += t + "(" + e + ") ";
      }),
        (e.style.transform = s);
    }
  },
};
function Bo(e, t) {
  No(e).forEach(function (e) {
    for (var n in t) {
      var i = _o(t[n], e),
        r = e.target,
        s = vo(i),
        a = To(r, n, s, e),
        o = Co(Eo(i, s || vo(a)), a),
        l = wo(r, n);
      Uo[l](r, n, o, e.transforms, !0);
    }
  });
}
function Vo(e, t) {
  return lo(
    co(
      e.map(function (e) {
        return t.map(function (t) {
          return (function (e, t) {
            var n = wo(e.target, t.name);
            if (n) {
              var i = zo(t, e),
                r = i[i.length - 1];
              return {
                type: n,
                property: t.name,
                animatable: e,
                tweens: i,
                duration: r.end,
                delay: i[0].delay,
                endDelay: r.endDelay,
              };
            }
          })(e, t);
        });
      })
    ),
    function (e) {
      return !Ja.und(e);
    }
  );
}
function Ho(e, t) {
  var n = e.length,
    i = function (e) {
      return e.timelineOffset ? e.timelineOffset : 0;
    },
    r = {};
  return (
    (r.duration = n
      ? Math.max.apply(
          Math,
          e.map(function (e) {
            return i(e) + e.duration;
          })
        )
      : t.duration),
    (r.delay = n
      ? Math.min.apply(
          Math,
          e.map(function (e) {
            return i(e) + e.delay;
          })
        )
      : t.delay),
    (r.endDelay = n
      ? r.duration -
        Math.max.apply(
          Math,
          e.map(function (e) {
            return i(e) + e.duration - e.endDelay;
          })
        )
      : t.endDelay),
    r
  );
}
var Go = 0;
var Wo = [],
  qo = (function () {
    var e;
    function t(n) {
      for (var i = Wo.length, r = 0; r < i; ) {
        var s = Wo[r];
        s.paused ? (Wo.splice(r, 1), i--) : (s.tick(n), r++);
      }
      e = r > 0 ? requestAnimationFrame(t) : void 0;
    }
    return (
      "undefined" != typeof document &&
        document.addEventListener("visibilitychange", function () {
          Yo.suspendWhenDocumentHidden &&
            (jo()
              ? (e = cancelAnimationFrame(e))
              : (Wo.forEach(function (e) {
                  return e._onDocumentVisibility();
                }),
                qo()));
        }),
      function () {
        e ||
          (jo() && Yo.suspendWhenDocumentHidden) ||
          !(Wo.length > 0) ||
          (e = requestAnimationFrame(t));
      }
    );
  })();
function jo() {
  return !!document && document.hidden;
}
function Yo(e) {
  void 0 === e && (e = {});
  var t,
    n = 0,
    i = 0,
    r = 0,
    s = 0,
    a = null;
  function o(e) {
    var t =
      window.Promise &&
      new Promise(function (e) {
        return (a = e);
      });
    return (e.finished = t), t;
  }
  var l = (function (e) {
    var t = fo(qa, e),
      n = fo(ja, e),
      i = Fo(n, e),
      r = No(e.targets),
      s = Vo(r, i),
      a = Ho(s, n),
      o = Go;
    return (
      Go++,
      mo(t, {
        id: o,
        children: [],
        animatables: r,
        animations: s,
        duration: a.duration,
        delay: a.delay,
        endDelay: a.endDelay,
      })
    );
  })(e);
  function c() {
    var e = l.direction;
    "alternate" !== e && (l.direction = "normal" !== e ? "normal" : "reverse"),
      (l.reversed = !l.reversed),
      t.forEach(function (e) {
        return (e.reversed = l.reversed);
      });
  }
  function u(e) {
    return l.reversed ? l.duration - e : e;
  }
  function h() {
    (n = 0), (i = u(l.currentTime) * (1 / Yo.speed));
  }
  function d(e, t) {
    t && t.seek(e - t.timelineOffset);
  }
  function p(e) {
    for (var t = 0, n = l.animations, i = n.length; t < i; ) {
      var r = n[t],
        s = r.animatable,
        a = r.tweens,
        o = a.length - 1,
        c = a[o];
      o &&
        (c =
          lo(a, function (t) {
            return e < t.end;
          })[0] || c);
      for (
        var u = $a(e - c.start - c.delay, 0, c.duration) / c.duration,
          h = isNaN(u) ? 1 : c.easing(u),
          d = c.to.strings,
          p = c.round,
          f = [],
          m = c.to.numbers.length,
          g = void 0,
          v = 0;
        v < m;
        v++
      ) {
        var _ = void 0,
          y = c.to.numbers[v],
          x = c.from.numbers[v] || 0;
        (_ = c.isPath
          ? Ro(c.value, h * y, c.isPathTargetInsideSVG)
          : x + h * (y - x)),
          p && ((c.isColor && v > 2) || (_ = Math.round(_ * p) / p)),
          f.push(_);
      }
      var b = d.length;
      if (b) {
        g = d[0];
        for (var w = 0; w < b; w++) {
          d[w];
          var S = d[w + 1],
            M = f[w];
          isNaN(M) || (g += S ? M + S : M + " ");
        }
      } else g = f[0];
      Uo[r.type](s.target, r.property, g, s.transforms),
        (r.currentValue = g),
        t++;
    }
  }
  function f(e) {
    l[e] && !l.passThrough && l[e](l);
  }
  function m(e) {
    var h = l.duration,
      m = l.delay,
      g = h - l.endDelay,
      v = u(e);
    (l.progress = $a((v / h) * 100, 0, 100)),
      (l.reversePlayback = v < l.currentTime),
      t &&
        (function (e) {
          if (l.reversePlayback) for (var n = s; n--; ) d(e, t[n]);
          else for (var i = 0; i < s; i++) d(e, t[i]);
        })(v),
      !l.began && l.currentTime > 0 && ((l.began = !0), f("begin")),
      !l.loopBegan && l.currentTime > 0 && ((l.loopBegan = !0), f("loopBegin")),
      v <= m && 0 !== l.currentTime && p(0),
      ((v >= g && l.currentTime !== h) || !h) && p(h),
      v > m && v < g
        ? (l.changeBegan ||
            ((l.changeBegan = !0), (l.changeCompleted = !1), f("changeBegin")),
          f("change"),
          p(v))
        : l.changeBegan &&
          ((l.changeCompleted = !0), (l.changeBegan = !1), f("changeComplete")),
      (l.currentTime = $a(v, 0, h)),
      l.began && f("update"),
      e >= h &&
        ((i = 0),
        l.remaining && !0 !== l.remaining && l.remaining--,
        l.remaining
          ? ((n = r),
            f("loopComplete"),
            (l.loopBegan = !1),
            "alternate" === l.direction && c())
          : ((l.paused = !0),
            l.completed ||
              ((l.completed = !0),
              f("loopComplete"),
              f("complete"),
              !l.passThrough && "Promise" in window && (a(), o(l)))));
  }
  return (
    o(l),
    (l.reset = function () {
      var e = l.direction;
      (l.passThrough = !1),
        (l.currentTime = 0),
        (l.progress = 0),
        (l.paused = !0),
        (l.began = !1),
        (l.loopBegan = !1),
        (l.changeBegan = !1),
        (l.completed = !1),
        (l.changeCompleted = !1),
        (l.reversePlayback = !1),
        (l.reversed = "reverse" === e),
        (l.remaining = l.loop),
        (t = l.children);
      for (var n = (s = t.length); n--; ) l.children[n].reset();
      ((l.reversed && !0 !== l.loop) || ("alternate" === e && 1 === l.loop)) &&
        l.remaining++,
        p(l.reversed ? l.duration : 0);
    }),
    (l._onDocumentVisibility = h),
    (l.set = function (e, t) {
      return Bo(e, t), l;
    }),
    (l.tick = function (e) {
      (r = e), n || (n = r), m((r + (i - n)) * Yo.speed);
    }),
    (l.seek = function (e) {
      m(u(e));
    }),
    (l.pause = function () {
      (l.paused = !0), h();
    }),
    (l.play = function () {
      l.paused &&
        (l.completed && l.reset(), (l.paused = !1), Wo.push(l), h(), qo());
    }),
    (l.reverse = function () {
      c(), (l.completed = !l.reversed), h();
    }),
    (l.restart = function () {
      l.reset(), l.play();
    }),
    (l.remove = function (e) {
      $o(ko(e), l);
    }),
    l.reset(),
    l.autoplay && l.play(),
    l
  );
}
function Xo(e, t) {
  for (var n = t.length; n--; ) ho(e, t[n].animatable.target) && t.splice(n, 1);
}
function $o(e, t) {
  var n = t.animations,
    i = t.children;
  Xo(e, n);
  for (var r = i.length; r--; ) {
    var s = i[r],
      a = s.animations;
    Xo(e, a), a.length || s.children.length || i.splice(r, 1);
  }
  n.length || i.length || t.pause();
}
(Yo.version = "3.2.1"),
  (Yo.speed = 1),
  (Yo.suspendWhenDocumentHidden = !0),
  (Yo.running = Wo),
  (Yo.remove = function (e) {
    for (var t = ko(e), n = Wo.length; n--; ) {
      $o(t, Wo[n]);
    }
  }),
  (Yo.get = To),
  (Yo.set = Bo),
  (Yo.convertPx = xo),
  (Yo.path = function (e, t) {
    var n = Ja.str(e) ? oo(e)[0] : e,
      i = t || 100;
    return function (e) {
      return { property: e, el: n, svg: Io(n), totalLength: Lo(n) * (i / 100) };
    };
  }),
  (Yo.setDashoffset = function (e) {
    var t = Lo(e);
    return e.setAttribute("stroke-dasharray", t), t;
  }),
  (Yo.stagger = function (e, t) {
    void 0 === t && (t = {});
    var n = t.direction || "normal",
      i = t.easing ? ao(t.easing) : null,
      r = t.grid,
      s = t.axis,
      a = t.from || 0,
      o = "first" === a,
      l = "center" === a,
      c = "last" === a,
      u = Ja.arr(e),
      h = u ? parseFloat(e[0]) : parseFloat(e),
      d = u ? parseFloat(e[1]) : 0,
      p = vo(u ? e[1] : e) || 0,
      f = t.start || 0 + (u ? h : 0),
      m = [],
      g = 0;
    return function (e, t, v) {
      if ((o && (a = 0), l && (a = (v - 1) / 2), c && (a = v - 1), !m.length)) {
        for (var _ = 0; _ < v; _++) {
          if (r) {
            var y = l ? (r[0] - 1) / 2 : a % r[0],
              x = l ? (r[1] - 1) / 2 : Math.floor(a / r[0]),
              b = y - (_ % r[0]),
              w = x - Math.floor(_ / r[0]),
              S = Math.sqrt(b * b + w * w);
            "x" === s && (S = -b), "y" === s && (S = -w), m.push(S);
          } else m.push(Math.abs(a - _));
          g = Math.max.apply(Math, m);
        }
        i &&
          (m = m.map(function (e) {
            return i(e / g) * g;
          })),
          "reverse" === n &&
            (m = m.map(function (e) {
              return s ? (e < 0 ? -1 * e : -e) : Math.abs(g - e);
            }));
      }
      return f + (u ? (d - h) / g : h) * (Math.round(100 * m[t]) / 100) + p;
    };
  }),
  (Yo.timeline = function (e) {
    void 0 === e && (e = {});
    var t = Yo(e);
    return (
      (t.duration = 0),
      (t.add = function (n, i) {
        var r = Wo.indexOf(t),
          s = t.children;
        function a(e) {
          e.passThrough = !0;
        }
        r > -1 && Wo.splice(r, 1);
        for (var o = 0; o < s.length; o++) a(s[o]);
        var l = mo(n, fo(ja, e));
        l.targets = l.targets || e.targets;
        var c = t.duration;
        (l.autoplay = !1),
          (l.direction = t.direction),
          (l.timelineOffset = Ja.und(i) ? c : Co(i, c)),
          a(t),
          t.seek(l.timelineOffset);
        var u = Yo(l);
        a(u), s.push(u);
        var h = Ho(s, e);
        return (
          (t.delay = h.delay),
          (t.endDelay = h.endDelay),
          (t.duration = h.duration),
          t.seek(0),
          t.reset(),
          t.autoplay && t.play(),
          t
        );
      }),
      t
    );
  }),
  (Yo.easing = ao),
  (Yo.penner = so),
  (Yo.random = function (e, t) {
    return Math.floor(Math.random() * (t - e + 1)) + e;
  });
const Zo = {
  linear: [0.25, 0.25, 0.75, 0.75],
  inSine: [0.47, 0, 0.745, 0.715],
  outSine: [0.39, 0.575, 0.565, 1],
  inOutSine: [0.445, 0.05, 0.55, 0.95],
  inQuad: [0.55, 0.085, 0.68, 0.53],
  outQuad: [0.25, 0.46, 0.45, 0.94],
  inOutQuad: [0.455, 0.03, 0.515, 0.955],
  inCubic: [0.55, 0.055, 0.675, 0.19],
  outCubic: [0.215, 0.61, 0.355, 1],
  inOutCubic: [0.645, 0.045, 0.355, 1],
  inQuart: [0.895, 0.03, 0.685, 0.22],
  outQuart: [0.165, 0.84, 0.44, 1],
  inOutQuart: [0.77, 0, 0.175, 1],
  inQuint: [0.755, 0.05, 0.855, 0.06],
  outQuint: [0.23, 1, 0.32, 1],
  inOutQuint: [0.86, 0, 0.07, 1],
  inExpo: [0.95, 0.05, 0.795, 0.035],
  outExpo: [0.19, 1, 0.22, 1],
  inOutExpo: [1, 0, 0, 1],
  inCirc: [0.6, 0.04, 0.98, 0.335],
  outCirc: [0.075, 0.82, 0.165, 1],
  inOutCirc: [0.785, 0.135, 0.15, 0.86],
  outSwift: [0.55, 0, 0.1, 1],
  snap2: [0, 0.975, 0, 1],
  bounce: [0.18, 0.89, 0.34, 1.76],
  bounce2: [0.865, -0.005, 0, 1.47],
  bounce3: [0.865, -0.005, 0, 1.64],
  bounce4: [0, 1.49, 0.105, 0.94],
  hardBounce: [0.07, 1.525, 0.36, 0.935],
  longKeyframe: [0.49, 0.05, 0.32, 1.04],
  elastic: [0, 0.49, 0.205, 1],
};
var Ko =
    "undefined" != typeof globalThis
      ? globalThis
      : "undefined" != typeof window
      ? window
      : "undefined" != typeof global
      ? global
      : "undefined" != typeof self
      ? self
      : {},
  Jo = "function" == typeof Float32Array;
function Qo(e, t) {
  return 1 - 3 * t + 3 * e;
}
function el(e, t) {
  return 3 * t - 6 * e;
}
function tl(e) {
  return 3 * e;
}
function nl(e, t, n) {
  return ((Qo(t, n) * e + el(t, n)) * e + tl(t)) * e;
}
function il(e, t, n) {
  return 3 * Qo(t, n) * e * e + 2 * el(t, n) * e + tl(t);
}
function rl(e) {
  return e;
}
var sl = function (e, t, n, i) {
  if (!(0 <= e && e <= 1 && 0 <= n && n <= 1))
    throw new Error("bezier x values must be in [0, 1] range");
  if (e === t && n === i) return rl;
  for (var r = Jo ? new Float32Array(11) : new Array(11), s = 0; s < 11; ++s)
    r[s] = nl(0.1 * s, e, n);
  function a(t) {
    for (var i = 0, s = 1; 10 !== s && r[s] <= t; ++s) i += 0.1;
    --s;
    var a = i + 0.1 * ((t - r[s]) / (r[s + 1] - r[s])),
      o = il(a, e, n);
    return o >= 0.001
      ? (function (e, t, n, i) {
          for (var r = 0; r < 4; ++r) {
            var s = il(t, n, i);
            if (0 === s) return t;
            t -= (nl(t, n, i) - e) / s;
          }
          return t;
        })(t, a, e, n)
      : 0 === o
      ? a
      : (function (e, t, n, i, r) {
          var s,
            a,
            o = 0;
          do {
            (s = nl((a = t + (n - t) / 2), i, r) - e) > 0 ? (n = a) : (t = a);
          } while (Math.abs(s) > 1e-7 && ++o < 10);
          return a;
        })(t, i, i + 0.1, e, n);
  }
  return function (e) {
    return 0 === e ? 0 : 1 === e ? 1 : nl(a(e), t, i);
  };
};
let al = 0;
const ol = () => ++al,
  ll = (e, t) => (void 0 !== e ? e : t),
  cl = new Set(["opacity", "transform"]),
  ul = new Set(["target", "ease", "duration", "delay", "willChange"]),
  hl = new Map(),
  dl = [],
  pl = [],
  fl = [];
let ml = !1;
function gl() {
  let e, t;
  for (e = 0, t = dl.length; e < t; e++) dl[e]();
  for (e = 0, t = pl.length; e < t; e++) pl[e]();
  for (e = 0, t = fl.length; e < t; e++) fl[e]();
  (dl.length = 0), (pl.length = 0), (fl.length = 0), (ml = !1);
}
const vl =
  "function" == typeof window.queueMicrotask
    ? () => queueMicrotask(gl)
    : () => Promise.resolve().then(gl);
const _l = function (e, t, n) {
  e && dl.push(e), t && pl.push(t), n && fl.push(n), ml || ((ml = !0), vl());
};
function yl(e, t = 1e3, n = "linear", i = 0) {
  Zo[n] && (n = Zo[n]);
  return `${e} ${t}ms ${
    Array.isArray(n) ? `cubic-bezier(${n.join(",")})` : n
  } ${i}ms`;
}
function xl(e = {}) {
  let t = e.complete;
  const n = !!e.instant,
    i = !!e.willChange;
  let r = e.target;
  e.selector && (r = r.querySelector(e.selector));
  const s = {
    easing: e.ease || e.easing || "linear",
    duration: e.duration || 1e3,
    delay: e.delay || 0,
  };
  r.dataset.csstween || (r.dataset.csstween = ol());
  const a = r.dataset.csstween;
  let o = null,
    l = new Promise((e) => (o = e));
  e.queue && e.queue.push(l);
  const c = { destroy: x, stop: x, finished: l },
    u = new Set();
  let h = null,
    d = !1;
  const p = [],
    f = [],
    m = {},
    g = {};
  let v = 0;
  for (const b in e) {
    if (ul.has(b)) continue;
    if (void 0 === r.style[b]) continue;
    const t = e[b];
    if (null == t) continue;
    const i = "object" != typeof t || Array.isArray(t) ? { value: t } : t,
      a = ll(i.duration, s.duration),
      o = ll(i.delay, s.delay),
      l = ll(i.easing, s.easing);
    f.push(yl(b, a, l, o)), (v = Math.max(v, a + o));
    const c = Array.isArray(i.value) ? i.value : [null, i.value];
    (n || (o <= 0 && (!a || a <= 0))) && ((c[0] = c[1]), (c[1] = null)),
      null !== c[0] && (m[b] = c[0]),
      null !== c[1] && (g[b] = c[1]),
      cl.has(b) && p.push(b);
  }
  return (
    _l(
      function () {
        if (d) return;
        hl.has(a) && hl.get(a).destroy();
        hl.set(a, c),
          (r.style.animation = ""),
          i && p.length > 0 && (r.style.willChange = p.join(", "));
        if (Object.keys(m).length > 0) for (const e in m) r.style[e] = m[e];
      },
      function () {
        if (d) return;
        r.getBoundingClientRect();
      },
      function () {
        if (d) return;
        if (Object.keys(g).length > 0) {
          r.style.transition = f.join(", ");
          for (const e in g) (r.style[e] = g[e]), u.add(e);
          r.addEventListener("transitionend", y),
            r.addEventListener("webkitTransitionEnd", y),
            (h = window.setTimeout(_, 1.1 * v + 200));
        } else _();
      }
    ),
    c
  );
  function _() {
    d || (window.clearTimeout(h), t && t(), o(), x());
  }
  function y(e) {
    (r.style.willChange = ""), u.delete(e.propertyName), u.size < 1 && _();
  }
  function x() {
    d ||
      (window.clearTimeout(h),
      (h = null),
      (r.style.transition = ""),
      (r.style.animation = ""),
      r.removeEventListener("transitionend", y),
      r.removeEventListener("webkitTransitionEnd", y),
      hl.delete(a),
      u.clear(),
      (r = null),
      (l = null),
      (t = null),
      (o = null),
      (d = !0));
  }
}
function bl(e = {}) {
  let t = e.complete,
    n = e.start,
    i = e.target;
  e.selector && (i = i.querySelector(e.selector));
  const r = (function (e) {
      return (
        e || (e = "linear"),
        Zo[e] && (e = Zo[e]),
        Array.isArray(e) ? `cubic-bezier(${e.join(",")})` : e
      );
    })(e.ease || e.easing),
    s = !!e.instant,
    a = !!e.willChange,
    o = e.delay || 0,
    l = s ? "0ms" : e.duration || 1e3,
    c = e.fillMode || "forwards",
    u = e.direction || "normal",
    h = e.animation || e.name || "pop",
    d = l + o,
    p = [h, l + "ms", r, o > 0 ? o + "ms" : null, 1, u, c]
      .filter((e) => null !== e)
      .join(" ");
  i.dataset.csstween || (i.dataset.csstween = ol());
  const f = i.dataset.csstween;
  let m = null,
    g = new Promise((e) => (m = e));
  e.queue && e.queue.push(g);
  const v = { destroy: S, stop: S, finished: g };
  let _ = null,
    y = !1;
  return (
    _l(
      function () {
        if (y) return;
        hl.has(f) && hl.get(f).destroy();
        hl.set(f, v), (i.style.animation = "");
      },
      function () {
        if (y || !i) return;
        i.getBoundingClientRect();
      },
      function () {
        if (y || !i) return;
        i.addEventListener("animationstart", b),
          i.addEventListener("webkitAnimationStart", b),
          i.addEventListener("animationend", w),
          i.addEventListener("webkitAnimationEnd", w),
          a && (i.style.willChange = "transform, opacity");
        (i.style.animation = p), (_ = window.setTimeout(x, 1.1 * d + 200));
      }
    ),
    v
  );
  function x() {
    y || (window.clearTimeout(_), m && m(), t && t(i), S());
  }
  function b(e) {
    n && n(i, e),
      (n = null),
      i.removeEventListener("animationstart", b),
      i.removeEventListener("webkitAnimationStart", b);
  }
  function w() {
    (i.style.willChange = ""), x();
  }
  function S() {
    y ||
      (window.clearTimeout(_),
      (_ = null),
      i.removeEventListener("animationend", w),
      i.removeEventListener("webkitAnimationEnd", w),
      i.removeEventListener("animationstart", b),
      i.removeEventListener("webkitAnimationStart", b),
      hl.delete(f),
      (i = null),
      (g = null),
      (t = null),
      (n = null),
      (m = null),
      (y = !0));
  }
}
function wl() {
  const e = [];
  return (
    Gi() && vn(() => n()),
    {
      csstween: function (e) {
        return t(e, xl);
      },
      cssanimate: function (e) {
        return t(e, bl);
      },
      clear: n,
    }
  );
  function t(t, n) {
    const i = n(t);
    return (null == t.autoClear || t.autoClear) && e.push(i), i;
  }
  function n(t) {
    for (let n = e.length - 1; n >= 0; n--) {
      const i = e[n];
      i && i.destroy
        ? (t && i.target !== t) || (i.destroy(), e.splice(n, 1))
        : e.splice(n, 1);
    }
  }
}
let Sl = null,
  Ml = {};
function Tl(e) {
  return (
    (Sl = _s(e)),
    (Ml = Sl.config.globalProperties),
    Sl.provide("appProps", Ml),
    Sl
  );
}
function Cl() {
  return Yt("appProps") || Ml;
}
function El() {
  return Ml;
}
function Al(e) {
  if (!window.isOldBrowser) {
    const t = document;
    "l" === t.readyState[0] ? t.addEventListener("DOMContentLoaded", e) : e();
  }
}
const Pl = new Proxy({}, { get: (e, t) => Ml[t] }),
  Ll = [];
let Il = {},
  Rl = null;
let Dl = null;
function kl() {
  return Dl;
}
const Nl = new Proxy({}, { get: (e, t) => Dl[t] }),
  Ol = function (e) {
    Rl && e(Il), Ll.push(e);
  };
var Fl = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [i, r] of t) n[i] = r;
  return n;
};
var zl = Fl(
  {
    props: {
      to: { type: [String, Object], default: null },
      href: { type: String, default: null },
      text: { type: String, default: null },
      type: { type: String, default: null },
    },
    setup(e, { expose: t }) {
      const n = e,
        i = Tt();
      function r() {
        const e = kl();
        e && e.audio.playSound("UI_Hover_Tiny");
      }
      t({ text: i });
      const s = n.to ? Oa : n.href ? "a" : "button";
      return (e, t) => (
        pi(),
        _i(
          ri(At(s)),
          {
            to: n.to,
            href: n.href,
            class: "cta",
            type: n.type,
            onMouseenter: r,
          },
          {
            default: Vt(() => [
              Mi(
                "p",
                {
                  ref: (e, t) => {
                    (t.text = e), (i.value = e);
                  },
                  class: "cta__text",
                },
                y(n.text),
                513
              ),
              Ni(e.$slots, "default", {}, void 0, !0),
            ]),
            _: 3,
          },
          8,
          ["to", "href", "type"]
        )
      );
    },
  },
  [["__scopeId", "data-v-393c1b9c"]]
);
const Ul = (e) => (Ut("data-v-38f76d36"), (e = e()), Bt(), e),
  Bl = ["innerHTML"],
  Vl = { class: "borders" },
  Hl = Ul(() => Mi("div", null, null, -1)),
  Gl = Ul(() => Mi("div", null, null, -1)),
  Wl = { key: 0, class: "big-line" };
var ql = Fl(
  {
    props: [
      ["icon", String, ""],
      ["noBigLine", Boolean, !1],
      ["isEmpty", Boolean, !1],
      ["transparent", Boolean, !1],
      ["to", [String, Object], null],
      ["href", String, null],
      ["text", String, ""],
      ["smallText", Boolean, !1],
      ["type", String, null],
    ].reduce((e, t) => ((e[t[0]] = { value: t[1], default: t[2] }), e), {}),
    setup(e) {
      const t = e,
        n = Tt(),
        i = Tt();
      function r() {
        n.value &&
          (i.value.classList.add("hoverIn"),
          i.value.getBoundingClientRect(),
          i.value.classList.remove("hoverIn"),
          xl({
            target: n.value.text,
            transform: ["translateX(-1em)", ""],
            easing: "snap2",
            duration: 2e3,
          }));
      }
      function s() {
        n.value &&
          xl({
            target: n.value.text,
            transform: ["scale(0.85)", ""],
            easing: "outQuint",
            duration: 350,
          });
      }
      function a() {
        if (!i.value) return;
        const e = kl();
        e && e.audio.playSound("UI_Validate_Big"),
          i.value.classList.add("onClick"),
          i.value.getBoundingClientRect(),
          i.value.classList.remove("onClick");
      }
      const o = {
        next: '<svg width="43" height="43" viewBox="0 0 43 43" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="21.749" y="1.475" width="28.671" height="28.671" rx="1.5" transform="rotate(45 21.749 1.475)" fill="#fff" stroke="url(#a)"/><path d="M23 21.5 17.886 17H13l4.886 4.5L13 26h4.886L23 21.5Z" fill="#DD2527" fill-opacity=".3"/><path d="M31 21.5 25.886 17H21l4.886 4.5L21 26h4.886L31 21.5Z" fill="#DD2526"/><defs><linearGradient id="a" x1="22.091" y1="30.452" x2="49.668" y2="2.875" gradientUnits="userSpaceOnUse"><stop stop-color="#E1E1E1"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient></defs></svg>',
        play: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 43 43" style="enable-background:new 0 0 43 43" xml:space="preserve"><path d="M28.5 20.6c.5.3.6.9.3 1.4-.1.1-.2.3-.3.3L8.4 34.6c-.5.3-1.1.1-1.4-.3-.1-.2-.1-.3-.1-.5V9.3c0-.6.4-1 1-1 .2 0 .4.1.5.1l20.1 12.2z" style="fill:#fff"/><path d="M37.5 20.6c.5.3.6.9.3 1.4-.1.1-.2.3-.3.3L17.4 34.6c-.5.3-1.1.1-1.4-.3-.1-.2-.1-.3-.1-.5V9.3c0-.6.4-1 1-1 .2 0 .4.1.5.1l20.1 12.2z" style="opacity:.33;fill:#fff;enable-background:new"/></svg>\n',
      }[t.icon];
      return (e, l) => (
        pi(),
        vi(
          "div",
          {
            ref: (e, t) => {
              (t.base = e), (i.value = e);
            },
            class: g(["framed", { isSkew: t.skew }]),
            onMouseenter: r,
            onMouseleave: s,
            onMousedown: a,
            onTouchdown: a,
          },
          [
            t.text.length > 0
              ? (pi(),
                _i(
                  zl,
                  {
                    key: 0,
                    ref: (e, t) => {
                      (t.cta = e), (n.value = e);
                    },
                    to: t.to,
                    text: t.text,
                    href: t.href,
                    class: g({ smallSize: t.smallText }),
                    type: t.type,
                  },
                  null,
                  8,
                  ["to", "text", "href", "class", "type"]
                ))
              : Pi("", !0),
            At(o)
              ? (pi(),
                vi(
                  "div",
                  { key: 1, class: "icon", innerHTML: At(o) },
                  null,
                  8,
                  Bl
                ))
              : Pi("", !0),
            Mi("figure", Vl, [
              Hl,
              Gl,
              t.noBigLine ? Pi("", !0) : (pi(), vi("div", Wl)),
            ]),
          ],
          34
        )
      );
    },
  },
  [["__scopeId", "data-v-38f76d36"]]
);
const jl = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1250.22 135.73",
    class: "gameLogo",
  },
  Yl = [
    Ai(
      '<path class="cls-1" d="M55.2,43.47l.09-.58H.58L6.76,3.11H173.38L167,42.89H112.33l-.07.42-14.18,89H41Z" stroke-width="1" stroke="#fff" fill="#fff" data-v-7a5f33f4></path><path class="cls-2" d="M220,132.34H163.13L183.73,3.11h56.86L233.47,47l-.1.58h72.79l.07-.42,7.14-44h56.86l-20.6,129.23H292.77l7.48-47.21.09-.58H227.55l-.06.42Z" stroke-width="1" stroke="#fff" fill="#fff" data-v-7a5f33f4></path><path class="cls-3" d="M424.65,98.5h91.24l-5.3,33.84H362.79L383.39,3.11H530.13l-5.46,33.48h-90.6L434,37,432.07,49.8l-.08.57h89.35l-5.29,33H426.51l-.07.42-2.28,14.17-.1.58Z" stroke-width="1" stroke="#fff" fill="#fff" data-v-7a5f33f4></path><path class="cls-4" d="M564.13,132.77,584.82,3H715c14.88,0,26.52,2.5,34.42,7.55s12.08,12.6,12.08,22.89a30.29,30.29,0,0,1-10.72,23.65c-6.34,5.53-14.65,8.84-22.45,10.32l0,1a35.59,35.59,0,0,1,17.79,10.72l-30.83,49.84-2.39,3.86H689.66c-.48-1.06-.48-2.63,0-5.57h0l2.47-14.77h0c1.16-7.1.34-12.87-3.32-16.86s-10-6-19.61-6H628.14l-.06.42-6.83,42.83Zm69.25-77.29-.1.58H686c5.64,0,9.4-1.43,11.75-3.58A10.14,10.14,0,0,0,701,44.83a7.78,7.78,0,0,0-2.82-6.45c-2-1.6-5.14-2.49-9.7-2.49H636.63l-.07.42Z" stroke-width="1" stroke="#fff" fill="#fff" data-v-7a5f33f4></path><path class="cls-5" d="M889.6,76c0,10.45,2,21.6,7.73,31.79,5.49,9.71,14.42,18.52,28.33,25H873.35L867.8,115l-.11-.35h-69l-.15.25-10.45,17.86H730.4L810.71,3H890.3l10.18,28.87a76.06,76.06,0,0,0-9.73,27.93A104.43,104.43,0,0,0,889.6,76Zm-70.06,2.91-.44.76h37.95l-.2-.65L844.31,38.53,844,37.45l-.57,1Z" stroke-width="1" stroke="#fff" fill="#fff" data-v-7a5f33f4></path><path class="cls-6" d="M903.64,76h0a97.32,97.32,0,0,1,1.06-14.87c1.84-12.06,6.49-27.18,20.88-39.29S964.17.5,1005.27.5h6.19c37.15,0,59.29,7.21,72.23,16.64l-6.24,39.15h-35.69A16.3,16.3,0,0,0,1036,46.1c-4.87-4.21-13.75-7.92-30-7.92-18.64,0-29.4,5-35.49,11.7s-7.41,15.21-7.41,22c0,6.52,1.93,12.87,7.41,17.59s14.4,7.7,28.25,7.7c16.69,0,26.31-4.11,31.92-8.66a23.92,23.92,0,0,0,7.57-10.5,1.34,1.34,0,0,0,.07-.18H1074L1067,122.19c-14.07,7.63-35.07,13-66.63,13h-6.18c-37.22,0-59.84-7.73-73.14-19S903.64,90.27,903.64,76Z" stroke-width="1" stroke="#fff" fill="#fff" data-v-7a5f33f4></path><path class="cls-7" d="M1143.67,98.78h91.66l-5.33,34H1081.53L1102.22,3h147.41l-5.49,33.64h-91l-.07.42-1.94,12.84-.09.57h89.76l-5.32,33.11h-89.94l-.06.42-2.3,14.24-.09.58Z" stroke-width="1" stroke="#fff" fill="#fff" data-v-7a5f33f4></path>',
      7
    ),
  ];
var Xl = Fl({ setup: (e) => (e, t) => (pi(), vi("svg", jl, Yl)) }, [
  ["__scopeId", "data-v-7a5f33f4"],
]);
const $l = () => {},
  Zl = ["INPUT", "SELECT", "TEXTAREA", "A", "BUTTON"].reduce(
    (e, t) => ((e[t] = 1), e),
    {}
  ),
  Kl = "ARROWUP",
  Jl = [
    Kl,
    Kl,
    "ARROWDOWN",
    "ARROWDOWN",
    "ARROWLEFT",
    "ARROWRIGHT",
    "ARROWLEFT",
    "ARROWRIGHT",
    "B",
    "A",
  ],
  Ql = {};
let ec = 0,
  tc = !1,
  nc = $l;
function ic() {
  for (const e in Ql) Ql[e] = !1;
  ec = 0;
}
function rc(e) {
  if (Zl[e.tagName]) return;
  const t = e.key.toUpperCase();
  Ql[t] ||
    (function (e) {
      if (e !== Jl[ec]) return (ec = 0);
      ec++, ec >= Jl.length && ((ec = 0), nc());
    })(t),
    (Ql[t] = !0);
}
function sc(e) {
  const t = e.key.toUpperCase();
  Ql[t] = !1;
}
var ac = {
  start: function () {
    !(function (e, t = "log", n = "console") {
      window[n][t](
        "%c ▲  ▲  ▼  ▼  ◀  ▶  ◀  ▶  %cB  %cA ",
        "font-size: 16px; background: black; color: #aaa;",
        "font-size: 16px; background: black; color: #fd605b;",
        "font-size: 16px; background: black; color: #32c850;"
      );
    })(),
      tc ||
        (ic(),
        window.addEventListener("keydown", rc),
        window.addEventListener("keyup", sc),
        document.addEventListener("visibilitychange", ic),
        (tc = !0));
  },
  stop: function () {
    tc &&
      (ic(),
      window.removeEventListener("keydown", rc),
      window.removeEventListener("keyup", sc),
      document.removeEventListener("visibilitychange", ic),
      (tc = !1));
  },
  reset: ic,
  get callback() {
    return nc;
  },
  set callback(e) {
    nc = e || $l;
  },
};
const oc = { class: "home__container" },
  lc = { class: "home__title" },
  cc = ((e) => (Ut("data-v-20f8a6d9"), (e = e()), Bt(), e))(() =>
    Mi("div", { class: "legal_trad reference" }, " * ", -1)
  ),
  uc = { class: "legal_trad mention" },
  hc = { async beforeRouteEnter() {} };
var dc = Fl(
  Object.assign(hc, {
    setup: function (e, { expose: t }) {
      const { csstween: n } = wl();
      function i() {
        Pl.$stats.event({ name: "start" });
      }
      function r() {
        (window.KONAMI_ACTIVE = !0), Pl.$router.push({ name: "qrcode-home" });
      }
      return (
        pn(() => {
          ac.start(),
            (ac.callback = r),
            Pl.$rtcDisplay.disable(),
            Pl.$stats.pageview({ title: "home", url: "/" });
        }),
        vn(() => {
          (ac.callback = null), ac.stop();
        }),
        t({
          enter: async function (e) {
            Nl.audio.setBgm("intro"),
              (Pl.$stores.isPlaying = !1),
              Nl.audio.playSound("UI_Title_TheRace", { delay: 1500 }),
              Yo.timeline()
                .add({
                  targets: ".gameLogo",
                  translateY: {
                    value: [0, 30],
                    duration: 1500,
                    easing: "cubicBezier(.2,0,.15,1)",
                  },
                  scale: {
                    value: [1.8, 1],
                    easing: "cubicBezier(.2,0,.15,1)",
                    duration: 1500,
                  },
                })
                .add(
                  {
                    targets: ".gameLogo path",
                    strokeDashoffset: [Yo.setDashoffset, 0],
                    duration: 1500,
                    easing: "cubicBezier(.87,0,.13,1)",
                    delay: Yo.stagger(80),
                  },
                  "-=1500"
                )
                .add(
                  {
                    targets: ".gameLogo path",
                    fillOpacity: [0, 1],
                    duration: 500,
                    easing: "cubicBezier(.87,0,.13,1)",
                    delay: Yo.stagger(80),
                  },
                  "-=1400"
                )
                .add(
                  {
                    targets: ".gameLogo",
                    translateY: 0,
                    duration: 1e3,
                    easing: "cubicBezier(.6,0,0,1)",
                  },
                  "-=500"
                )
                .add(
                  {
                    targets: ".home__cta",
                    translateY: ["50%", "0%"],
                    opacity: [0, 1],
                    duration: 800,
                    easing: "cubicBezier(.2,0,.15,1)",
                  },
                  "-=700"
                );
          },
          leave: async function (e) {
            return n({
              target: e,
              transform: ["", "scale3d(0.6,0.6,0.6)"],
              duration: 800,
              ease: "cubic-bezier(.87,0,.13,1)",
              opacity: ["", 0],
              autoClear: !1,
            }).finished;
          },
        }),
        (e, t) => (
          pi(),
          vi(
            "section",
            {
              class: g(["page page-home home", { hidden: e.$stores.menuOpen }]),
            },
            [
              Mi("div", oc, [
                Mi("h1", lc, [Ti(Xl), cc]),
                Ti(
                  ql,
                  {
                    to: { name: "game" },
                    text: e.$l("home.cta.start"),
                    icon: "next",
                    class: "home__cta",
                    onClickPassive: i,
                  },
                  null,
                  8,
                  ["text"]
                ),
              ]),
              Mi("div", uc, y(e.$l("home.legal")), 1),
            ],
            2
          )
        )
      );
    },
  }),
  [["__scopeId", "data-v-20f8a6d9"]]
);
const pc = {
    "/src/stores/index.js": Object.freeze({
      __proto__: null,
      [Symbol.toStringTag]: "Module",
      default: (e) => {
        const t = window.__DATA.site.locales[window.__DATA.site.locale],
          n = dt({
            pb: 0,
            muted: !1,
            menuOpen: !1,
            gamePaused: !1,
            needTimer: !1,
            isPlaying: !1,
            cookieVisible: !1,
            cookieAccepted: !1,
            gameTutorialVisible: !1,
            remoteCountDownFinished: !1,
            keysVisible: !1,
            webRtc: !1,
            noForm: !!t.noForm,
            noCookie: !!t.noCookie,
          });
        return (
          e.onBeforeMount(() => {
            n.pb = localStorage.getItem("score_highscore") || 0;
            const t = localStorage.getItem("muted");
            (n.muted = null != t && !!+t),
              br(() => {
                const e = n.muted;
                localStorage.setItem("muted", +!!e);
              });
            const i = e.config.globalProperties;
            br(() => {
              n.gamePaused =
                n.menuOpen ||
                (i.$rtcDisplay.enabled.value && i.$rtcDisplay.error.value);
            });
          }),
          n
        );
      },
    }),
  },
  fc = (e) => "object" == typeof e && !Array.isArray(e) && null !== e;
let mc = {};
function gc() {
  let e;
  return {
    install: function (t) {
      const n = {};
      for (const e in pc) {
        const i = e.split("/").pop().slice(0, -3);
        (n[i] = pc[e].default), "function" == typeof n[i] && (n[i] = n[i](t));
      }
      e = fc(n.index) ? n.index : {};
      for (const i in n) "index" !== i && fc(n[i]) && (e[i] = n[i]);
      (e = dt(e)),
        (t.config.globalProperties.$stores = e),
        t.provide("stores", e),
        (mc = e);
    },
  };
}
function vc() {
  return Gi() ? Yt("stores") : mc;
}
const _c = {},
  yc = { class: "separator" },
  xc = [
    ((e) => (Ut("data-v-2c1274ff"), (e = e()), Bt(), e))(() =>
      Mi(
        "svg",
        {
          width: "72",
          height: "7",
          viewBox: "0 0 72 7",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        [
          Mi("path", {
            class: "sepA",
            d: "M3.496 0H22.8l-3.048 6.108H.448L3.496 0Z",
          }),
          Mi("path", {
            class: "sepB",
            d: "M27.88 0h19.304l-3.048 6.108H24.832L27.88 0Z",
          }),
          Mi("path", {
            class: "sepC",
            d: "M52.264 0h19.304L68.52 6.108H49.216L52.264 0Z",
          }),
        ],
        -1
      )
    ),
  ];
var bc = Fl(_c, [
  [
    "render",
    function (e, t) {
      return pi(), vi("div", yc, xc);
    },
  ],
  ["__scopeId", "data-v-2c1274ff"],
]);
function wc() {
  return Gi() ? Yt("stats") : undefined;
}
const Sc = "undefined" == typeof window ? global : window,
  Mc = [],
  Tc = [],
  Cc = [];
let Ec,
  Ac,
  Pc = null,
  Lc = null,
  Ic = !1,
  Rc = !1;
function Dc() {
  const e = performance.now();
  let t;
  if (
    (null === Lc && (Lc = e),
    (Ac = e - Lc),
    (Ec += Ac),
    (Lc = e),
    (Pc = Ic ? null : Sc.requestAnimationFrame(Dc)),
    Ic && (Ic = !1),
    Rc)
  ) {
    for (t = 0; t < Cc.length; t++) Cc[t](Ac);
    for (t = 0; t < Mc.length; t++) Mc[t](Ac);
    for (t = 0; t < Tc.length; t++) Tc[t](Ac);
  } else for (t = 0; t < Mc.length; t++) Mc[t](Ac);
}
function kc() {
  Rc = !!(Tc.length > 0 || Cc.length > 0);
}
function Nc(e, t, n) {
  return (
    !(!t || !e) && !~e.indexOf(t) && ((n = !!n) ? e.unshift(t) : e.push(t), !0)
  );
}
function Oc(e, t) {
  if (!t) return !1;
  const n = e.indexOf(t);
  return !!~n && (e.splice(n, 1), !(0 !== e.length));
}
function Fc(e) {
  (Ic = !1),
    Pc || ((Lc = null), (e = !!e) ? Dc() : (Pc = Sc.requestAnimationFrame(Dc)));
}
function zc() {
  Pc && (Sc.cancelAnimationFrame(Pc), (Pc = null));
}
var Uc = {
  add: function (e, t) {
    Nc(Mc, e, t) && Fc();
  },
  addAfter: function (e, t) {
    Nc(Tc, e, t) && kc();
  },
  addBefore: function (e, t) {
    Nc(Cc, e, t) && kc();
  },
  remove: function (e) {
    Oc(Mc, e) && zc();
  },
  removeAfter: function (e) {
    Oc(Tc, e) && kc();
  },
  removeBefore: function (e) {
    Oc(Cc, e) && kc();
  },
  start: Fc,
  stop: zc,
  time: Ec,
  dt: Ac,
  requestOnce: function () {
    Pc || ((Ic = !0), (Lc = null), (Pc = Sc.requestAnimationFrame(Dc)));
  },
  dispose: function () {
    zc(),
      (Mc.length = 0),
      (Tc.length = 0),
      (Cc.length = 0),
      (Rc = !1),
      (Lc = null),
      (Ec = 0),
      (Ac = 0);
  },
};
class Bc {
  constructor(e, t, n = {}) {
    const i = void 0 === n.autostart || n.autostart;
    (this._standalone = void 0 === n.standalone || n.standalone),
      (this._selfdestruct = void 0 === n.selfdestruct || n.selfdestruct),
      (this._stopped = !0),
      (this._remainder = 0),
      (this._delay = 0 | e),
      (this._remainingTime = e),
      (this._callback = void 0 === t ? function () {} : t);
    const r = this,
      s = this.update,
      a = this.restart;
    (this.update = function (e) {
      s.call(r, e);
    }),
      (this.restart = function (e, t) {
        a.call(r, e, t);
      }),
      i && this.start(),
      0 === this._delay && this.stop();
  }
  setCallback(e, t) {
    (this._callback = void 0 === e ? function () {} : e), t && this.restart(t);
  }
  stop() {
    (this._stopped = !0), this._standalone && Uc.remove(this.update);
  }
  start() {
    this._stopped && this.restart();
  }
  restart(e, t) {
    void 0 === t && (t = !0),
      void 0 !== e && (this._delay = e),
      this._standalone && this._stopped && Uc.add(this.update),
      (this._stopped = !1),
      (this._remainingTime = this._delay - this._remainder * +t);
  }
  update(e) {
    this._stopped ||
      ((this._remainingTime -= e),
      this._remainingTime <= 0
        ? ((this._stopped = !0),
          (this._remainder = -this._remainingTime % this._delay),
          this._callback(this.restart),
          this._selfdestruct && this.dispose())
        : (this._remainder = 0));
  }
  dispose() {
    this._standalone && Uc.add(this.update),
      (this._callback = this.restart = null),
      this.stop(),
      (this._remainder = 0),
      (this._remainingTime = this._delay);
  }
}
function Vc(e, t, n) {
  return new Bc(e, t, n);
}
const Hc = { autostart: !0, standalone: !0, selfdestruct: !0 };
function Gc() {
  const e = [],
    t = [];
  return (
    Gi() && vn(r),
    {
      setTimeout: n,
      setInterval: function (e, n) {
        const i = window.setInterval(e, n);
        return t.push(i), i;
      },
      wait: function (e, t) {
        return new Promise((n) => i(e, n, t));
      },
      timer: i,
      clearTimers: r,
    }
  );
  function n(t, n) {
    const i = window.setTimeout(t, n);
    return e.push(i), i;
  }
  function i(t, i, r) {
    if (r) {
      const n = Vc(t, i, Hc);
      return e.push(n), n;
    }
    {
      const r = n(i, t);
      return e.push(r), r;
    }
  }
  function r() {
    for (let t = 0, n = e.length; t < n; t++) {
      const n = e[t];
      n.dispose ? n.dispose() : clearTimeout(n);
    }
    for (let e = 0, n = t.length; e < n; e++) clearInterval(t[e]);
    (t.length = 0), (e.length = 0);
  }
}
const Wc = { class: "result__container" },
  qc = { class: "result__frame" },
  jc = ((e) => (Ut("data-v-9ad5651c"), (e = e()), Bt(), e))(() =>
    Mi(
      "defs",
      null,
      [
        Mi(
          "linearGradient",
          {
            id: "a",
            x1: "-1",
            y1: "70.668",
            x2: "276",
            y2: "70.668",
            gradientUnits: "userSpaceOnUse",
          },
          [
            Mi("stop", { "stop-color": "#fff" }),
            Mi("stop", {
              offset: "1",
              "stop-color": "#fff",
              "stop-opacity": "0",
            }),
          ]
        ),
      ],
      -1
    )
  ),
  Yc = ["innerHTML"],
  Xc = { class: "result__content" },
  $c = { class: "time__value" },
  Zc = { class: "time__unit" },
  Kc = { class: "result__pb" },
  Jc = { class: "pb__text" },
  Qc = { class: "pb__value" },
  eu = { class: "pb__unit" },
  tu = { key: 0, class: "result__buttons" },
  nu = { key: 1, class: "result__webrtc" },
  iu = { class: "result__webrtc__texts" },
  ru = { key: 0, class: "result__webrtc__title" },
  su = { key: 1, class: "result__webrtc__description" },
  au = { class: "result__webrtc__waiting" };
var ou = Fl(
    {
      setup(e, { expose: t }) {
        Gc();
        const n = wc(),
          i = Ga(),
          { csstween: r } = wl(),
          s = Tt(""),
          a = Tt(""),
          o = Tt(),
          l = Tt(),
          c = Tt(),
          u = vc(),
          h = Pl.$rtcDisplay.enabled.value,
          d = Yo.timeline({});
        let p;
        const f = {
          setUp: function () {
            p = setTimeout(function () {
              i.push({ name: "qrcode-home" }), f.clear();
            }, 1e4);
          },
          clear: function () {
            clearTimeout(p);
          },
        };
        return (
          pn(() => {
            n.pageview({ title: "result", url: "/result" }),
              Nl.audio.setBgm("outro"),
              (u.isPlaying = !1),
              (u.menuOpen = !1),
              (u.score = Nl.game.racetime),
              (u.bestTime = Nl.game.bestTime),
              (s.value = (Math.max(0, Nl.game.racetime || 0) / 1e3).toFixed(2)),
              (a.value = (Math.max(0, Nl.game.bestTime || 0) / 1e3).toFixed(2)),
              h && f.setUp();
          }),
          vn(() => {
            h && f.clear();
          }),
          t({
            enter: function (e) {
              Nl.audio.playSound("UI_ResulTime", { delay: 650 }),
                d
                  .add(
                    {
                      targets: ".result__frame",
                      skewX: [-4, -4],
                      rotate: [-11, 0],
                      scale: [1.4, 1],
                      duration: 1500,
                      easing: "cubicBezier(.87,0,.13,1)",
                    },
                    "+=500"
                  )
                  .add(
                    {
                      targets: ".path",
                      strokeDashoffset: [Yo.setDashoffset, 0],
                      duration: 1500,
                      easing: "cubicBezier(.87,0,.13,1)",
                    },
                    "-=1500"
                  )
                  .add(
                    {
                      targets: ".result__icon",
                      translateX: ["6px", "6px"],
                      scale: [0, 1],
                      duration: 1e3,
                      easing: "cubicBezier(.64,.01,.11,1.28)",
                    },
                    "-=1000"
                  )
                  .add(
                    {
                      targets: ".result__content p",
                      opacity: [0, 1],
                      translateY: ["40px", "0px"],
                      duration: 1e3,
                      delay: Yo.stagger(200),
                      easing: "cubicBezier(0,0,.13,1)",
                    },
                    "-=700"
                  )
                  .add(
                    {
                      targets: ".light",
                      opacity: [0, 1],
                      duration: 1500,
                      easing: "cubicBezier(.87,0,.13,1)",
                    },
                    "-=1300"
                  )
                  .add(
                    {
                      targets: ".result__register, .result__again",
                      opacity: [0, 1],
                      translateX: ["-40px", "0px"],
                      duration: 1e3,
                      delay: Yo.stagger(150),
                      easing: "cubicBezier(0,0,.13,1)",
                    },
                    "-=1200"
                  )
                  .add(
                    {
                      targets: ".separator",
                      opacity: [0, 1],
                      duration: 1e3,
                      easing: "cubicBezier(0,0,.13,1)",
                    },
                    "-=1000"
                  )
                  .add(
                    {
                      targets: ".result__webrtc__texts div",
                      opacity: [0, 1],
                      translateY: ["40px", "0px"],
                      delay: Yo.stagger(150),
                      duration: 1e3,
                      easing: "cubicBezier(0,0,.13,1)",
                    },
                    "-=1200"
                  );
            },
            leave: async function (e) {
              return r({
                target: e,
                transform: ["", "scale3d(0.6,0.6,0.6)"],
                duration: 800,
                ease: "cubic-bezier(.87,0,.13,1)",
                opacity: ["", 0],
                autoClear: !1,
              }).finished;
            },
          }),
          (e, t) => (
            pi(),
            vi(
              "section",
              {
                class: g([
                  "page page-result result",
                  { hidden: At(u).menuOpen },
                ]),
              },
              [
                Mi("div", Wc, [
                  Mi(
                    "div",
                    { class: g(["result__timer", { marginB: At(u).webRtc }]) },
                    [
                      Mi("div", qc, [
                        (pi(),
                        vi(
                          "svg",
                          {
                            ref: (e, t) => {
                              (t.square = e), (o.value = e);
                            },
                            viewBox: "0 0 293 141",
                            fill: "none",
                            xmlns: "http://www.w3.org/2000/svg",
                            class: "result__square",
                          },
                          [
                            Mi(
                              "path",
                              {
                                ref: (e, t) => {
                                  (t.path = e), (l.value = e);
                                },
                                d: "M16.599 7.711a7.5 7.5 0 0 1 7.438-6.543h260.869c4.521 0 8.015 3.971 7.438 8.456l-15.943 124a7.5 7.5 0 0 1-7.438 6.544H8.094c-4.521 0-8.015-3.972-7.438-8.457l15.943-124Z",
                                stroke: "#fff",
                                "stroke-opacity": ".2",
                                class: "path",
                              },
                              null,
                              512
                            ),
                            Mi(
                              "path",
                              {
                                ref: (e, t) => {
                                  (t.light = e), (c.value = e);
                                },
                                d: "M16.599 7.711a7.5 7.5 0 0 1 7.438-6.543h260.869c4.521 0 8.015 3.971 7.438 8.456l-15.943 124a7.5 7.5 0 0 1-7.438 6.544H8.094c-4.521 0-8.015-3.972-7.438-8.457l15.943-124Z",
                                stroke: "url(#a)",
                                class: "light",
                              },
                              null,
                              512
                            ),
                            jc,
                          ],
                          512
                        )),
                      ]),
                      Mi(
                        "div",
                        {
                          class: "result__icon",
                          innerHTML: At(
                            '<svg viewBox="0 0 39 39" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="19.942" width="26.952" height="26.952" rx="5.256" transform="rotate(45 19.942 0)" fill="#fff"/><rect x="19.942" y=".902" width="25.676" height="25.676" rx="4.618" transform="rotate(45 19.942 .902)" stroke="url(#a)" stroke-opacity=".25" stroke-width="1.275"/><path d="M18.473 11.479a.554.554 0 1 0 0 1.107h.908v1.188a6.288 6.288 0 0 0-3.026 1.089l-.591-.585a.727.727 0 0 0-.996-.025c-.159.141-.311.289-.457.443a.728.728 0 0 0 .016 1.019l.564.557a6.287 6.287 0 1 0 10.072 0l.564-.557a.727.727 0 0 0 .017-1.02 7.74 7.74 0 0 0-.458-.442.727.727 0 0 0-.995.025l-.592.585a6.289 6.289 0 0 0-3.027-1.089v-1.188h.908a.554.554 0 1 0 0-1.107h-2.907Zm1.33 3.336a5.199 5.199 0 0 1 5.32 5.223 5.198 5.198 0 1 1-10.394 0 5.197 5.197 0 0 1 5.073-5.223Z" fill="#DD2526"/><path d="m18.032 17.86-.774-.775a.2.2 0 0 0-.284.284l.775.775a.2.2 0 0 0 .284-.284ZM18.033 22.217l-.775.775a.2.2 0 0 1-.284-.284l.775-.775a.2.2 0 0 1 .284.284ZM17.046 20.24a.201.201 0 0 0 0-.402h-1.095a.201.201 0 0 0 0 .401h1.095ZM19.726 24.015a.201.201 0 0 0 .401 0V22.92a.201.201 0 0 0-.401 0v1.096ZM21.88 23.73a4.178 4.178 0 0 0-1.953-7.87v4.178l1.953 3.692Z" fill="#DD2526"/><defs><linearGradient id="a" x1="21.347" y1="25.651" x2="45.697" y2="1.301" gradientUnits="userSpaceOnUse"><stop stop-color="#BFBFBF"/><stop offset="1" stop-color="#fff" stop-opacity="0"/></linearGradient></defs></svg>\n'
                          ),
                        },
                        null,
                        8,
                        Yc
                      ),
                      Mi("div", Xc, [
                        Mi(
                          "p",
                          {
                            ref: (e, t) => {
                              t.finish = e;
                            },
                            class: "result__time",
                          },
                          [
                            Mi("span", $c, y(s.value), 1),
                            Mi("span", Zc, y(e.$l("game_end.time")), 1),
                          ],
                          512
                        ),
                        Mi("p", Kc, [
                          Mi("span", Jc, y(e.$l("game_end.pb")) + " ", 1),
                          Mi("span", Qc, y(a.value), 1),
                          Mi("span", eu, y(e.$l("game_end.time")), 1),
                        ]),
                      ]),
                    ],
                    2
                  ),
                  e.$rtcDisplay.enabled.value
                    ? Pi("", !0)
                    : (pi(),
                      vi("div", tu, [
                        Ti(
                          ql,
                          {
                            "no-big-line": !0,
                            to: { name: "game" },
                            text: e.$l("game_end.cta.playagain"),
                            icon: "play",
                            "small-text": !0,
                            class: "result__again",
                            onClick:
                              t[0] ||
                              (t[0] = (e) => {
                                At(n).event({ name: "click_again_finish" });
                              }),
                          },
                          null,
                          8,
                          ["text"]
                        ),
                        e.$stores.noForm
                          ? Pi("", !0)
                          : (pi(),
                            _i(
                              ql,
                              {
                                key: 0,
                                text: e.$l("game_end.cta.register"),
                                to: { name: "register" },
                                icon: "next",
                                class: "result__register",
                                onClick:
                                  t[1] ||
                                  (t[1] = (e) => {
                                    At(n).event({ name: "click_register" });
                                  }),
                              },
                              null,
                              8,
                              ["text"]
                            )),
                      ])),
                  e.$rtcDisplay.enabled.value
                    ? (pi(),
                      vi("div", nu, [
                        e.$stores.noForm
                          ? Pi("", !0)
                          : (pi(), _i(bc, { key: 0 })),
                        Mi("div", iu, [
                          e.$stores.noForm
                            ? Pi("", !0)
                            : (pi(),
                              vi("div", ru, [
                                Mi(
                                  "p",
                                  null,
                                  y(e.$l("webRTC.recap.borne.title")),
                                  1
                                ),
                              ])),
                          e.$stores.noForm
                            ? Pi("", !0)
                            : (pi(),
                              vi("div", su, [
                                Mi(
                                  "p",
                                  null,
                                  y(e.$l("webRTC.recap.borne.text")),
                                  1
                                ),
                              ])),
                          Mi("div", au, [
                            Mi(
                              "p",
                              null,
                              y(e.$l("webRTC.recap.borne.wait")),
                              1
                            ),
                          ]),
                        ]),
                      ]))
                    : Pi("", !0),
                ]),
              ],
              2
            )
          )
        );
      },
    },
    [["__scopeId", "data-v-9ad5651c"]]
  ),
  lu = JSON.parse(
    '{"af":"Afghanistan","al":"Albania","dz":"Algeria","as":"American Samoa","ad":"Andorra","ao":"Angola","ai":"Anguilla","aq":"Antarctica","ag":"Antigua and Barbuda","ar":"Argentina","am":"Armenia","aw":"Aruba","au":"Australia","at":"Austria","az":"Azerbaijan","bs":"Bahamas","bh":"Bahrain","bd":"Bangladesh","bb":"Barbados","by":"Belarus","be":"Belgium","bz":"Belize","bj":"Benin","bm":"Bermuda","bt":"Bhutan","bo":"Bolivia","ba":"Bosnia and Herzegovina","bw":"Botswana","br":"Brazil","io":"British Indian Ocean Territory","vg":"British Virgin Islands","bn":"Brunei","bg":"Bulgaria","bf":"Burkina Faso","bi":"Burundi","kh":"Cambodia","cm":"Cameroon","ca":"Canada","cv":"Cape Verde","ky":"Cayman Islands","cf":"Central African Republic","td":"Chad","cl":"Chile","cn":"China","cx":"Christmas Island","cc":"Cocos Islands","co":"Colombia","km":"Comoros","ck":"Cook Islands","cr":"Costa Rica","hr":"Croatia","cu":"Cuba","cw":"Curacao","cy":"Cyprus","cz":"Czech Republic","cd":"Democratic Republic of the Congo","dk":"Denmark","dj":"Djibouti","dm":"Dominica","do":"Dominican Republic","tp":"East Timor","ec":"Ecuador","eg":"Egypt","sv":"El Salvador","gq":"Equatorial Guinea","er":"Eritrea","ee":"Estonia","et":"Ethiopia","fk":"Falkland Islands","fo":"Faroe Islands","fj":"Fiji","fi":"Finland","fr":"France","pf":"French Polynesia","ga":"Gabon","gm":"Gambia","ge":"Georgia","de":"Germany","gh":"Ghana","gi":"Gibraltar","gr":"Greece","gl":"Greenland","gd":"Grenada","gu":"Guam","gt":"Guatemala","gg":"Guernsey","gn":"Guinea","gw":"Guinea-Bissau","gy":"Guyana","ht":"Haiti","hn":"Honduras","hk":"Hong Kong, China","hu":"Hungary","is":"Iceland","in":"India","id":"Indonesia","ir":"Iran","iq":"Iraq","ie":"Ireland","im":"Isle of Man","il":"Israel","it":"Italy","ci":"Ivory Coast","jm":"Jamaica","jp":"Japan","je":"Jersey","jo":"Jordan","kz":"Kazakhstan","ke":"Kenya","ki":"Kiribati","xk":"Kosovo","kw":"Kuwait","kg":"Kyrgyzstan","la":"Laos","lv":"Latvia","lb":"Lebanon","ls":"Lesotho","lr":"Liberia","ly":"Libya","li":"Liechtenstein","lt":"Lithuania","lu":"Luxembourg","mo":"Macao, China","mk":"Macedonia","mg":"Madagascar","mw":"Malawi","my":"Malaysia","mv":"Maldives","ml":"Mali","mt":"Malta","mh":"Marshall Islands","mr":"Mauritania","mu":"Mauritius","yt":"Mayotte","mx":"Mexico","fm":"Micronesia","md":"Moldova","mc":"Monaco","mn":"Mongolia","me":"Montenegro","ms":"Montserrat","ma":"Morocco","mz":"Mozambique","mm":"Myanmar","na":"Namibia","nr":"Nauru","np":"Nepal","nl":"Netherlands","an":"Netherlands Antilles","nc":"New Caledonia","nz":"New Zealand","ni":"Nicaragua","ne":"Niger","ng":"Nigeria","nu":"Niue","kp":"North Korea","mp":"Northern Mariana Islands","no":"Norway","om":"Oman","pk":"Pakistan","pw":"Palau","ps":"Palestine","pa":"Panama","pg":"Papua New Guinea","py":"Paraguay","pe":"Peru","ph":"Philippines","pn":"Pitcairn","pl":"Poland","pt":"Portugal","pr":"Puerto Rico","qa":"Qatar","cg":"Republic of the Congo","re":"Reunion","ro":"Romania","ru":"Russia","rw":"Rwanda","bl":"Saint Barthelemy","sh":"Saint Helena","kn":"Saint Kitts and Nevis","lc":"Saint Lucia","mf":"Saint Martin","pm":"Saint Pierre and Miquelon","vc":"Saint Vincent and the Grenadines","ws":"Samoa","sm":"San Marino","st":"Sao Tome and Principe","sa":"Saudi Arabia","sn":"Senegal","rs":"Serbia","sc":"Seychelles","sl":"Sierra Leone","sg":"Singapore","sx":"Sint Maarten","sk":"Slovakia","si":"Slovenia","sb":"Solomon Islands","so":"Somalia","za":"South Africa","kr":"Korea","ss":"South Sudan","es":"Spain","lk":"Sri Lanka","sd":"Sudan","sr":"Suriname","sj":"Svalbard and Jan Mayen","sz":"Swaziland","se":"Sweden","ch":"Switzerland","sy":"Syria","tw":"Taiwan, China","tj":"Tajikistan","tz":"Tanzania","th":"Thailand","tg":"Togo","tk":"Tokelau","to":"Tonga","tt":"Trinidad and Tobago","tn":"Tunisia","tr":"Turkey","tm":"Turkmenistan","tc":"Turks and Caicos Islands","tv":"Tuvalu","vi":"U.S. Virgin Islands","ug":"Uganda","ua":"Ukraine","ae":"United Arab Emirates","gb":"United Kingdom","us":"United States","uy":"Uruguay","uz":"Uzbekistan","vu":"Vanuatu","va":"Vatican","ve":"Venezuela","vn":"Vietnam","wf":"Wallis and Futuna","eh":"Western Sahara","ye":"Yemen","zm":"Zambia","zw":"Zimbabwe","gp":"Guadeloupe","gf":"French Guiana","mq":"Martinique","tf":"French Southern and Antarctic Lands","gs":"South Georgia and the South Sandwich Islands"}'
  );
function cu() {
  let e, t;
  const n = new Promise((n, i) => {
    (e = n), (t = i);
  });
  return (n.resolve = e), (n.reject = t), n;
}
function uu(e, t = 1, n = {}, i) {
  const r = n.bind || null,
    s = null == n.trail || !!n.trail,
    a = null == n.tail || !!n.tail;
  let o,
    l,
    c,
    u = null,
    h = s,
    d = !1;
  function p() {
    (u = null),
      s && !d && (h = !0),
      e.call(r, o, l, c),
      i && d && a && ((d = !1), (u = setTimeout(p, t)));
  }
  return function (n, a, f) {
    i || (clearTimeout(u), (u = null)),
      (o = n),
      (l = a),
      (c = f),
      s && h && ((h = !1), e.call(r, o, l, c)),
      null === u ? (u = setTimeout(p, t)) : i && (d = !0);
  };
}
let hu = !1;
const du = cu();
let pu;
window._onRecaptchaLoaded = () => du.resolve();
var fu = {
  token: async function (e, t) {
    let n = null,
      i = !1;
    pu && document.body.appendChild(pu);
    try {
      !(function (e) {
        if (hu) return;
        hu = !0;
        const t = document,
          n = t.createElement("script");
        (n.src =
          "https://www.recaptcha.net/recaptcha/api.js?onload=_onRecaptchaLoaded&render=" +
          e),
          (n.async = !0),
          t.head.appendChild(n);
      })(e),
        await du,
        await new Promise((e) => grecaptcha.ready(e)),
        grecaptcha.reset(e),
        (n = await grecaptcha.execute(e, t ? { action: t } : {}));
    } catch (r) {
      i = "RecaptchaError";
    }
    return (
      (function () {
        const e = document.querySelectorAll(".grecaptcha-badge");
        for (let t = 0; t < e.length; t++) {
          const n = e[t].parentNode;
          n && n.parentNode && ((pu = n), n.parentNode.removeChild(n));
        }
      })(),
      { token: n, error: i }
    );
  },
};
const mu = (e) => (Ut("data-v-3e708368"), (e = e()), Bt(), e),
  gu = { class: "form__wrapper" },
  vu = { class: "form__best" },
  _u = { class: "pb__text" },
  yu = { class: "form__score" },
  xu = { class: "score__value" },
  bu = { class: "score__unit" },
  wu = { class: "form__title" },
  Su = { class: "form__container" },
  Mu = ["onSubmit"],
  Tu = { class: "form__names" },
  Cu = { class: "form__input" },
  Eu = ["placeholder"],
  Au = { class: "form__input" },
  Pu = ["placeholder"],
  Lu = { class: "form__input" },
  Iu = ["placeholder"],
  Ru = { disabled: "", selected: "", hidden: "", value: "" },
  Du = ["value"],
  ku = ["innerHTML"],
  Nu = mu(() => Mi("span", { class: "checkmark" }, null, -1)),
  Ou = ["innerHTML"],
  Fu = mu(() => Mi("span", { class: "checkmark" }, null, -1)),
  zu = { class: "form__input submitButton" },
  Uu = { class: "form__input recaptcha" };
var Bu = Fl(
  {
    setup(e, { expose: t }) {
      let n;
      const i = Tt(null),
        r = Tt(),
        s = Tt(null),
        a = Tt(),
        o = Tt(null),
        l = Tt(),
        c = Tt(null),
        u = Tt(),
        h = Tt(!1),
        d = Tt(null),
        p = Tt(!1),
        f = Tt(null),
        m = Tt(!1),
        v = Tt(),
        _ = Tt(!1),
        x = Tt("0.00"),
        b = Tt("0.00"),
        w = vc(),
        S = Ga(),
        M = wc(),
        T = Yo.timeline({});
      pn(() => {
        (x.value = (Math.max(0, w.score || 0) / 1e3).toFixed(2)),
          (b.value = (Math.max(0, w.bestTime || 0) / 1e3).toFixed(2)),
          (u.value.children[0].style.textDecoration = "underline"),
          Nl.audio.setBgm("outro"),
          M.pageview({ title: "register", url: "/register" });
      });
      const C = (e, t) => {
        t
          ? e.value.classList.add("fullField")
          : e.value.classList.remove("fullField");
      };
      function E(e) {
        "" !== e.target.value
          ? v.value.classList.add("fullField")
          : v.value.classList.remove("fullField");
      }
      Sr(r, (e) => {
        C(i, e);
      }),
        Sr(a, (e) => {
          C(s, e);
        }),
        Sr(l, (e) => {
          C(o, e);
        });
      const A = async () => {
          try {
            if (_.value) return;
            (_.value = !0),
              (n = {
                firstname: r.value,
                lastname: a.value,
                email: l.value,
                country: v.value.value,
                legals: h.value,
                newsletter: p.value,
                score: x.value || "0.00",
                recaptcha: "",
              }),
              M.event({ name: "validate_form" });
            const e = await fu.token(
              "6Lc1w4IdAAAAANNLPM1DbJPacVMSv0lQTj1uZ3YN",
              "submit"
            );
            n.recaptcha = e.token;
            const t = await (async (e) => {
              const t = await fetch(
                "https://europe-west1-montblanc-race.cloudfunctions.net/register",
                {
                  method: "POST",
                  headers: {
                    Accept: "application/json",
                    "Content-Type": "application/json",
                    Authorization: "Bearer VgDa2q5ZPfcyA+Fal9CtlGXqOb+T",
                  },
                  body: JSON.stringify(e),
                }
              );
              return await t.json();
            })(n);
            if ("saved" !== t.status)
              throw new Error(
                "object" == typeof t ? JSON.stringify(t, void 0, 2) : t
              );
            S.push({ name: "confirmation" });
          } catch (e) {
          } finally {
            _.value = !1;
          }
        },
        { csstween: P } = wl(),
        L = "cubicBezier(0,0,.13,1) ";
      return (
        t({
          enter: function (e) {
            T.add(
              {
                targets: ".form__best",
                translateY: ["-40px", 0],
                opacity: [0, 1],
                duration: 1e3,
                easing: L,
              },
              100
            )
              .add(
                {
                  targets: ".form__score",
                  translateY: ["-40px", 0],
                  opacity: [0, 1],
                  duration: 1e3,
                  easing: L,
                },
                300
              )
              .add(
                {
                  targets: ".form__title",
                  translateY: ["-40px", 0],
                  opacity: [0, 1],
                  duration: 1e3,
                  easing: L,
                },
                400
              )
              .add(
                {
                  targets: ".separator",
                  translateY: ["-20px", 0],
                  opacity: [0, 1],
                  duration: 1e3,
                  easing: L,
                },
                500
              )
              .add(
                {
                  targets: ".form__input",
                  translateY: ["-20px", 0],
                  opacity: [0, 1],
                  duration: 1e3,
                  easing: L,
                  delay: Yo.stagger(80),
                },
                600
              );
          },
          leave: async function (e) {
            return P({
              target: e,
              transform: ["", "scale3d(0.6,0.6,0.6)"],
              duration: 800,
              ease: "cubic-bezier(.87,0,.13,1)",
              opacity: ["", 0],
              autoClear: !1,
            }).finished;
          },
        }),
        (e, t) => (
          pi(),
          vi(
            "section",
            { class: g(["page page-form form", { hidden: At(w).menuOpen }]) },
            [
              Mi("div", gu, [
                Mi("h3", vu, [Mi("span", _u, y(e.$l("game_end.myscore")), 1)]),
                Mi("h1", yu, [
                  Mi("span", xu, y(x.value), 1),
                  Mi("span", bu, y(e.$l("game_end.time")), 1),
                ]),
                Mi("h1", wu, y(e.$l("form.title")), 1),
                Ti(bc),
                Mi("div", Su, [
                  Mi(
                    "form",
                    {
                      action: "",
                      class: "form__content",
                      method: "post",
                      autocomplete: "off",
                      onSubmit: ms(A, ["prevent"]),
                    },
                    [
                      Mi("div", Tu, [
                        Mi("div", Cu, [
                          jn(
                            Mi(
                              "input",
                              {
                                ref: (e, t) => {
                                  (t.firstName = e), (i.value = e);
                                },
                                "onUpdate:modelValue":
                                  t[0] || (t[0] = (e) => (r.value = e)),
                                required: "true",
                                type: "text",
                                name: "firstName",
                                placeholder: e.$l("form.firstname"),
                                class: "form__field",
                                maxlength: "40",
                                autocorrect: "off",
                                autocapitalize: "off",
                                autocomplete: "none",
                              },
                              null,
                              8,
                              Eu
                            ),
                            [[cs, r.value, void 0, { trim: !0 }]]
                          ),
                        ]),
                        Mi("div", Au, [
                          jn(
                            Mi(
                              "input",
                              {
                                ref: (e, t) => {
                                  (t.lastName = e), (s.value = e);
                                },
                                "onUpdate:modelValue":
                                  t[1] || (t[1] = (e) => (a.value = e)),
                                required: "true",
                                type: "text",
                                name: "lastName",
                                placeholder: e.$l("form.lastname"),
                                class: "form__field",
                                maxlength: "40",
                                autocorrect: "off",
                                autocapitalize: "off",
                                autocomplete: "none",
                              },
                              null,
                              8,
                              Pu
                            ),
                            [[cs, a.value, void 0, { trim: !0 }]]
                          ),
                        ]),
                      ]),
                      Mi("div", Lu, [
                        jn(
                          Mi(
                            "input",
                            {
                              ref: (e, t) => {
                                (t.email = e), (o.value = e);
                              },
                              "onUpdate:modelValue":
                                t[2] || (t[2] = (e) => (l.value = e)),
                              required: "true",
                              type: "email",
                              name: "email",
                              placeholder: e.$l("form.email"),
                              class: "form__field",
                              autocorrect: "off",
                              autocapitalize: "off",
                              autocomplete: "none",
                            },
                            null,
                            8,
                            Iu
                          ),
                          [[cs, l.value, void 0, { trim: !0 }]]
                        ),
                      ]),
                      Mi(
                        "div",
                        {
                          ref: (e, t) => {
                            (t.select = e), (f.value = e);
                          },
                          class: "form__input",
                        },
                        [
                          Mi(
                            "select",
                            Di(
                              {
                                ref: (e, t) => {
                                  (t.selectField = e), (v.value = e);
                                },
                              },
                              m.value,
                              {
                                required: "true",
                                name: "countrySelector",
                                class: "form__select",
                                onChange: E,
                              }
                            ),
                            [
                              Mi("option", Ru, y(e.$l("form.country")), 1),
                              (pi(!0),
                              vi(
                                oi,
                                null,
                                ki(
                                  Object.entries(At(lu)),
                                  (e) => (
                                    pi(),
                                    vi(
                                      "option",
                                      { key: e[0], value: e[0] },
                                      y(e[1]),
                                      9,
                                      Du
                                    )
                                  )
                                ),
                                128
                              )),
                            ],
                            16
                          ),
                        ],
                        512
                      ),
                      Mi(
                        "div",
                        {
                          ref: (e, t) => {
                            (t.newsletter = e), (d.value = e);
                          },
                          class: "form__input checkInput",
                        },
                        [
                          Mi(
                            "label",
                            {
                              for: "subscribe-newsletter",
                              innerHTML: e.$l("form.newsletter"),
                            },
                            null,
                            8,
                            ku
                          ),
                          jn(
                            Mi(
                              "input",
                              {
                                id: "subscribe-newsletter",
                                "onUpdate:modelValue":
                                  t[3] || (t[3] = (e) => (p.value = e)),
                                name: "promotionnal",
                                type: "checkbox",
                                class: "checkboxes",
                              },
                              null,
                              512
                            ),
                            [[us, p.value]]
                          ),
                          Nu,
                        ],
                        512
                      ),
                      Mi(
                        "div",
                        {
                          ref: (e, t) => {
                            (t.legals = e), (c.value = e);
                          },
                          class: "form__input checkInput",
                        },
                        [
                          Mi(
                            "label",
                            {
                              ref: (e, t) => {
                                (t.legalsLabel = e), (u.value = e);
                              },
                              for: "accept-conditions",
                              innerHTML: e.$l("form.legals"),
                            },
                            null,
                            8,
                            Ou
                          ),
                          jn(
                            Mi(
                              "input",
                              {
                                id: "accept-conditions",
                                "onUpdate:modelValue":
                                  t[4] || (t[4] = (e) => (h.value = e)),
                                name: "legals",
                                type: "checkbox",
                                class: "checkboxes",
                                required: "",
                              },
                              null,
                              512
                            ),
                            [[us, h.value]]
                          ),
                          Fu,
                        ],
                        512
                      ),
                      Mi("div", zu, [
                        Ti(
                          ql,
                          {
                            text: e.$l("form.cta"),
                            icon: "next",
                            type: "submit",
                            class: g({ loading: _.value }),
                          },
                          null,
                          8,
                          ["text", "class"]
                        ),
                      ]),
                      Mi("div", Uu, y(e.$l("form.recaptcha")), 1),
                    ],
                    40,
                    Mu
                  ),
                ]),
              ]),
            ],
            2
          )
        )
      );
    },
  },
  [["__scopeId", "data-v-3e708368"]]
);
const Vu = { class: "confirmation__title" },
  Hu = { class: "confirmation__text" },
  Gu = { class: "confirmation__again" },
  Wu = { class: "confirmation__frame" },
  qu = { async beforeRouteEnter() {} };
var ju = Fl(
  Object.assign(qu, {
    setup: function (e, { expose: t }) {
      const n = vc(),
        i = wc(),
        { csstween: r } = wl(),
        s = "cubic-bezier(.87,0,.13,1)",
        a = "cubic-bezier(0,0,.13,1) ";
      return (
        pn(() => {
          Nl.audio.setBgm("outro"),
            i.pageview({ title: "confirmation", url: "/confirmation" });
        }),
        t({
          enter: function (e) {
            r({
              target: e,
              selector: ".confirmation__title",
              transform: ["translateY(-40px)", ""],
              duration: 1e3,
              ease: a,
              delay: 400,
              opacity: [0, ""],
            }),
              r({
                target: e,
                selector: ".separator",
                transform: ["translateY(-40px)", ""],
                duration: 800,
                ease: a,
                delay: 550,
                opacity: [0, ""],
              }),
              r({
                target: e,
                selector: ".confirmation__text",
                transform: ["translateY(-40px)", ""],
                duration: 1e3,
                ease: a,
                delay: 850,
                opacity: [0, ""],
              }),
              r({
                target: e,
                selector: ".confirmation__again",
                transform: ["scale3d(0.5,0.5,0.5)", ""],
                duration: 1e3,
                ease: s,
                delay: 950,
                opacity: [0, ""],
              });
          },
          leave: async function (e) {
            return r({
              target: e,
              transform: ["", "scale3d(0.6,0.6,0.6)"],
              duration: 800,
              ease: s,
              opacity: ["", 0],
              autoClear: !1,
            }).finished;
          },
        }),
        (e, t) => (
          pi(),
          vi(
            "section",
            {
              class: g([
                "page page-confirmation confirmation",
                { hidden: At(n).menuOpen },
              ]),
            },
            [
              Mi("h1", Vu, y(e.$l("form.success.title")), 1),
              Ti(bc),
              Mi("p", Hu, y(e.$l("form.success.text")), 1),
              Mi("div", Gu, [
                Mi("div", Wu, [
                  Ti(
                    ql,
                    {
                      to: { name: "game" },
                      text: e.$l("game_end.cta.playagain"),
                      icon: "next",
                      class: "result__again",
                      onClick:
                        t[0] ||
                        (t[0] = (e) => {
                          At(i).event({ name: "click_again_register" });
                        }),
                    },
                    null,
                    8,
                    ["text"]
                  ),
                ]),
              ]),
            ],
            2
          )
        )
      );
    },
  }),
  [["__scopeId", "data-v-64a13b25"]]
);
const Yu = {},
  Xu = {},
  $u = {
    ref: "square",
    viewBox: "0 0 502 502",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    class: "icon__frame",
  },
  Zu = {
    ref: "path",
    x: "2",
    y: "2",
    width: "498",
    height: "498",
    rx: "23",
    fill: "#000",
    "fill-opacity": ".1",
    class: "path",
  },
  Ku = Ai(
    '<rect x="2" y="2" width="498" height="498" rx="23" stroke="url(#a)" stroke-width="4" class="stroke s1"></rect><rect x="2" y="2" width="498" height="498" rx="23" stroke="#fff" stroke-opacity=".2" stroke-width="2" class="stroke s2"></rect><defs><linearGradient id="a" x1="0" y1="251" x2="502" y2="251" gradientUnits="userSpaceOnUse"><stop stop-color="#fff"></stop><stop offset="1" stop-color="#fff" stop-opacity="0"></stop></linearGradient></defs>',
    3
  );
var Ju = Fl(Xu, [
  [
    "render",
    function (e, t) {
      return pi(), vi("svg", $u, [Mi("rect", Zu, null, 512), Ku], 512);
    },
  ],
]);
const Qu = { class: "language-picker" },
  eh = ["textContent"],
  th = ["value", "selected", "textContent"];
var nh = Fl(
  {
    setup(e) {
      const t = Tt(!1),
        n = window.__DATA.site,
        i = n.locales[n.locale],
        r = Object.values(n.locales).map((e) => ({
          id: e.id,
          text: e.name,
          selected: e.id === i.id || null,
        })),
        s = i.name;
      function a() {
        const e = t.value,
          n = e.selectedIndex,
          r = e.options[n].value,
          s = __DATA.site.locales[r];
        if (s.id === i.id) return;
        let a = new Date();
        a.setTime(Date.now() + 12096e5),
          (document.cookie =
            "preferred_language=" +
            s.id +
            ";path=/;expires=" +
            a +
            ";samesite=lax"),
          (window.location.href =
            window.location.origin +
            __DATA.config.basepath +
            (s.default ? "" : s.id + "/"));
      }
      return (e, n) => (
        pi(),
        vi("div", Qu, [
          Mi("div", { class: "current", textContent: y(At(s)) }, null, 8, eh),
          Mi(
            "select",
            {
              ref: (e, n) => {
                (n.selector = e), (t.value = e);
              },
              onInput: a,
              onBlur: a,
            },
            [
              (pi(!0),
              vi(
                oi,
                null,
                ki(
                  At(r),
                  (e) => (
                    pi(),
                    vi(
                      "option",
                      {
                        key: e.id,
                        value: e.id,
                        selected: e.selected,
                        textContent: y(e.text),
                      },
                      null,
                      8,
                      th
                    )
                  )
                ),
                128
              )),
            ],
            544
          ),
        ])
      );
    },
  },
  [["__scopeId", "data-v-36c1e9d0"]]
);
const ih = { class: "title" },
  rh = { class: "qrContainer" };
var sh = Fl(
  {
    setup(e, { expose: t }) {
      t({
        enter: async function () {
          kl() && kl().audio.setBgm("intro");
          const e = Yo.timeline();
          i.value.getBoundingClientRect(),
            i.value.classList.add("visible"),
            e
              .add(
                {
                  targets: ".page-qr .title",
                  translateY: ["-40px", "0px"],
                  opacity: [0, 1],
                  duration: 1e3,
                  easing: "cubicBezier(0,0,.13,1)",
                },
                0
              )
              .add(
                {
                  targets: ".page-qr .separator",
                  translateY: ["-40px", "0px"],
                  opacity: [0, 1],
                  duration: 1e3,
                  easing: "cubicBezier(0,0,.13,1)",
                },
                150
              )
              .add(
                {
                  targets: ".page-qr .qrContainer",
                  scale: [1.3, 1],
                  rotate: [-5, 0],
                  opacity: [0, 1],
                  duration: 1e3,
                  easing: "cubicBezier(0.000, 0.340, 0.405, 0.995)",
                },
                700
              )
              .add(
                {
                  targets: ".page-qr .square",
                  strokeDashoffset: [1970, 0],
                  opacity: [1, 1],
                  duration: 1500,
                  easing: "cubicBezier(0.490, 0.070, 0.080, 1.005)",
                },
                600
              );
        },
        leave: async function (e) {
          return (
            e.classList.add("leave"),
            n({
              target: e,
              transform: ["", "scale3d(0.6,0.6,0.6)"],
              duration: 800,
              ease: "cubic-bezier(.87,0,.13,1)",
              opacity: ["", 0],
              autoClear: !1,
            }).finished
          );
        },
      });
      const { csstween: n } = wl(),
        i = Tt(),
        r = Tt(),
        s = Tt(),
        a = Tt();
      return (
        pn(async () => {
          Pl.$stats.init(), Pl.$rtcDisplay.enable();
          const [e] = await Promise.all([
            ((t = () =>
              import("./qrious.aa93a948274a7243.js").then(function (e) {
                return e.q;
              })),
            (n = []),
            n && 0 !== n.length
              ? Promise.all(
                  n.map((e) => {
                    if ((e = `/${e}`) in Yu) return;
                    Yu[e] = !0;
                    const t = e.endsWith(".css"),
                      n = t ? '[rel="stylesheet"]' : "";
                    if (document.querySelector(`link[href="${e}"]${n}`)) return;
                    const i = document.createElement("link");
                    return (
                      (i.rel = t ? "stylesheet" : "modulepreload"),
                      t || ((i.as = "script"), (i.crossOrigin = "")),
                      (i.href = e),
                      document.head.appendChild(i),
                      t
                        ? new Promise((e, t) => {
                            i.addEventListener("load", e),
                              i.addEventListener("error", t);
                          })
                        : void 0
                    );
                  })
                ).then(() => t())
              : t()),
            Pl.$rtcDisplay.createRoom(),
          ]);
          var t, n;
          i.value &&
            (new e.default({
              element: r.value,
              background: "transparent",
              foreground: "white",
              level: "M",
              size: 200,
              value: Pl.$rtcDisplay.roomURL,
            }),
            i.value.classList.add("qrcode-visible"));
        }),
        (e, t) => (
          pi(),
          vi(
            "section",
            {
              ref: (e, t) => {
                (t.base = e), (i.value = e);
              },
              class: "page page-qr",
            },
            [
              Mi("div", ih, [Mi("h1", null, y(e.$l("webRTC.home")), 1)]),
              Ti(bc),
              Mi("div", rh, [
                Mi(
                  "div",
                  {
                    ref: (e, t) => {
                      (t.qrSpinner = e), (a.value = e);
                    },
                    class: "loading",
                  },
                  null,
                  512
                ),
                Mi(
                  "div",
                  {
                    ref: (e, t) => {
                      (t.qrFrame = e), (s.value = e);
                    },
                    class: "frame",
                  },
                  [Ti(Ju, { class: "square" })],
                  512
                ),
                Mi(
                  "canvas",
                  {
                    ref: (e, t) => {
                      (t.qrCode = e), (r.value = e);
                    },
                    class: "qrcode",
                  },
                  null,
                  512
                ),
              ]),
              Ti(nh),
            ],
            512
          )
        )
      );
    },
  },
  [["__scopeId", "data-v-7edf3d7e"]]
);
function ah(e) {
  const t = new Uint8Array(e);
  for (let n = 0; n < e; n++) t[n] = (256 * Math.random()) | 0;
  return t;
}
function oh() {
  if ("undefined" == typeof globalThis) return null;
  const e = {
    RTCPeerConnection:
      globalThis.RTCPeerConnection ||
      globalThis.mozRTCPeerConnection ||
      globalThis.webkitRTCPeerConnection,
    RTCSessionDescription:
      globalThis.RTCSessionDescription ||
      globalThis.mozRTCSessionDescription ||
      globalThis.webkitRTCSessionDescription,
    RTCIceCandidate:
      globalThis.RTCIceCandidate ||
      globalThis.mozRTCIceCandidate ||
      globalThis.webkitRTCIceCandidate,
  };
  return e.RTCPeerConnection ? e : null;
}
function lh(e, t) {
  return (
    Object.defineProperty(e, "code", {
      value: t,
      enumerable: !0,
      configurable: !0,
    }),
    e
  );
}
function ch(e) {
  return e.replace(/a=ice-options:trickle\s\n/g, "");
}
class uh {
  constructor(e = {}) {
    if (
      ((this._map = new Map()),
      (this._id = ah(4).toString("hex").slice(0, 7)),
      (this._doDebug = e.debug),
      this._debug("new peer %o", e),
      (this.channelName = e.initiator
        ? e.channelName || ah(20).toString("hex")
        : null),
      (this.initiator = e.initiator || !1),
      (this.channelConfig = e.channelConfig || uh.channelConfig),
      (this.channelNegotiated = this.channelConfig.negotiated),
      (this.config = Object.assign({}, uh.config, e.config)),
      (this.offerOptions = e.offerOptions || {}),
      (this.answerOptions = e.answerOptions || {}),
      (this.sdpTransform = e.sdpTransform || ((e) => e)),
      (this.streams = e.streams || (e.stream ? [e.stream] : [])),
      (this.trickle = void 0 === e.trickle || e.trickle),
      (this.allowHalfTrickle =
        void 0 !== e.allowHalfTrickle && e.allowHalfTrickle),
      (this.iceCompleteTimeout = e.iceCompleteTimeout || 5e3),
      (this.destroyed = !1),
      (this.destroying = !1),
      (this._connected = !1),
      (this.remoteAddress = void 0),
      (this.remoteFamily = void 0),
      (this.remotePort = void 0),
      (this.localAddress = void 0),
      (this.localFamily = void 0),
      (this.localPort = void 0),
      (this._wrtc = e.wrtc && "object" == typeof e.wrtc ? e.wrtc : oh()),
      !this._wrtc)
    )
      throw "undefined" == typeof window
        ? lh(
            new Error(
              "No WebRTC support: Specify `opts.wrtc` option in this environment"
            ),
            "ERR_WEBRTC_SUPPORT"
          )
        : lh(
            new Error("No WebRTC support: Not a supported browser"),
            "ERR_WEBRTC_SUPPORT"
          );
    (this._pcReady = !1),
      (this._channelReady = !1),
      (this._iceComplete = !1),
      (this._iceCompleteTimer = null),
      (this._channel = null),
      (this._pendingCandidates = []),
      (this._isNegotiating = !1),
      (this._firstNegotiation = !0),
      (this._batchedNegotiation = !1),
      (this._queuedNegotiation = !1),
      (this._sendersAwaitingStable = []),
      (this._senderMap = new Map()),
      (this._closingInterval = null),
      (this._remoteTracks = []),
      (this._remoteStreams = []),
      (this._chunk = null),
      (this._cb = null),
      (this._interval = null);
    try {
      this._pc = new this._wrtc.RTCPeerConnection(this.config);
    } catch (t) {
      return void this.destroy(lh(t, "ERR_PC_CONSTRUCTOR"));
    }
    (this._isReactNativeWebrtc = "number" == typeof this._pc._peerConnectionId),
      (this._pc.oniceconnectionstatechange = () => {
        this._onIceStateChange();
      }),
      (this._pc.onicegatheringstatechange = () => {
        this._onIceStateChange();
      }),
      (this._pc.onconnectionstatechange = () => {
        this._onConnectionStateChange();
      }),
      (this._pc.onsignalingstatechange = () => {
        this._onSignalingStateChange();
      }),
      (this._pc.onicecandidate = (e) => {
        this._onIceCandidate(e);
      }),
      "object" == typeof this._pc.peerIdentity &&
        this._pc.peerIdentity.catch((e) => {
          this.destroy(lh(e, "ERR_PC_PEER_IDENTITY"));
        }),
      this.initiator || this.channelNegotiated
        ? this._setupData({
            channel: this._pc.createDataChannel(
              this.channelName,
              this.channelConfig
            ),
          })
        : (this._pc.ondatachannel = (e) => {
            this._setupData(e);
          }),
      this.streams &&
        this.streams.forEach((e) => {
          this.addStream(e);
        }),
      (this._pc.ontrack = (e) => {
        this._onTrack(e);
      }),
      this._debug("initial negotiation"),
      this._needsNegotiation();
  }
  get bufferSize() {
    return (this._channel && this._channel.bufferedAmount) || 0;
  }
  get connected() {
    return this._connected && "open" === this._channel.readyState;
  }
  address() {
    return {
      port: this.localPort,
      family: this.localFamily,
      address: this.localAddress,
    };
  }
  signal(e) {
    if (!this.destroying) {
      if (this.destroyed)
        throw lh(
          new Error("cannot signal after peer is destroyed"),
          "ERR_DESTROYED"
        );
      if ("string" == typeof e)
        try {
          e = JSON.parse(e);
        } catch (t) {
          e = {};
        }
      this._debug("signal()"),
        e.renegotiate &&
          this.initiator &&
          (this._debug("got request to renegotiate"), this._needsNegotiation()),
        e.transceiverRequest &&
          this.initiator &&
          (this._debug("got request for transceiver"),
          this.addTransceiver(
            e.transceiverRequest.kind,
            e.transceiverRequest.init
          )),
        e.candidate &&
          (this._pc.remoteDescription && this._pc.remoteDescription.type
            ? this._addIceCandidate(e.candidate)
            : this._pendingCandidates.push(e.candidate)),
        e.sdp &&
          this._pc
            .setRemoteDescription(new this._wrtc.RTCSessionDescription(e))
            .then(() => {
              this.destroyed ||
                (this._pendingCandidates.forEach((e) => {
                  this._addIceCandidate(e);
                }),
                (this._pendingCandidates = []),
                "offer" === this._pc.remoteDescription.type &&
                  this._createAnswer());
            })
            .catch((e) => {
              this.destroy(lh(e, "ERR_SET_REMOTE_DESCRIPTION"));
            }),
        e.sdp ||
          e.candidate ||
          e.renegotiate ||
          e.transceiverRequest ||
          this.destroy(
            lh(
              new Error("signal() called with invalid signal data"),
              "ERR_SIGNALING"
            )
          );
    }
  }
  _addIceCandidate(e) {
    const t = new this._wrtc.RTCIceCandidate(e);
    this._pc.addIceCandidate(t).catch((e) => {
      !t.address ||
        t.address.endsWith(".local") ||
        this.destroy(lh(e, "ERR_ADD_ICE_CANDIDATE"));
    });
  }
  send(e) {
    if (!this.destroying) {
      if (this.destroyed)
        throw lh(
          new Error("cannot send after peer is destroyed"),
          "ERR_DESTROYED"
        );
      this._channel.send(e);
    }
  }
  addTransceiver(e, t) {
    if (!this.destroying) {
      if (this.destroyed)
        throw lh(
          new Error("cannot addTransceiver after peer is destroyed"),
          "ERR_DESTROYED"
        );
      if ((this._debug("addTransceiver()"), this.initiator))
        try {
          this._pc.addTransceiver(e, t), this._needsNegotiation();
        } catch (n) {
          this.destroy(lh(n, "ERR_ADD_TRANSCEIVER"));
        }
      else
        this.emit("signal", {
          type: "transceiverRequest",
          transceiverRequest: { kind: e, init: t },
        });
    }
  }
  addStream(e) {
    if (!this.destroying) {
      if (this.destroyed)
        throw lh(
          new Error("cannot addStream after peer is destroyed"),
          "ERR_DESTROYED"
        );
      this._debug("addStream()"),
        e.getTracks().forEach((t) => {
          this.addTrack(t, e);
        });
    }
  }
  addTrack(e, t) {
    if (this.destroying) return;
    if (this.destroyed)
      throw lh(
        new Error("cannot addTrack after peer is destroyed"),
        "ERR_DESTROYED"
      );
    this._debug("addTrack()");
    const n = this._senderMap.get(e) || new Map();
    let i = n.get(t);
    if (i)
      throw i.removed
        ? lh(
            new Error(
              "Track has been removed. You should enable/disable tracks that you want to re-add."
            ),
            "ERR_SENDER_REMOVED"
          )
        : lh(
            new Error("Track has already been added to that stream."),
            "ERR_SENDER_ALREADY_ADDED"
          );
    (i = this._pc.addTrack(e, t)),
      n.set(t, i),
      this._senderMap.set(e, n),
      this._needsNegotiation();
  }
  replaceTrack(e, t, n) {
    if (this.destroying) return;
    if (this.destroyed)
      throw lh(
        new Error("cannot replaceTrack after peer is destroyed"),
        "ERR_DESTROYED"
      );
    this._debug("replaceTrack()");
    const i = this._senderMap.get(e),
      r = i ? i.get(n) : null;
    if (!r)
      throw lh(
        new Error("Cannot replace track that was never added."),
        "ERR_TRACK_NOT_ADDED"
      );
    t && this._senderMap.set(t, i),
      null != r.replaceTrack
        ? r.replaceTrack(t)
        : this.destroy(
            lh(
              new Error("replaceTrack is not supported in this browser"),
              "ERR_UNSUPPORTED_REPLACETRACK"
            )
          );
  }
  removeTrack(e, t) {
    if (this.destroying) return;
    if (this.destroyed)
      throw lh(
        new Error("cannot removeTrack after peer is destroyed"),
        "ERR_DESTROYED"
      );
    this._debug("removeSender()");
    const n = this._senderMap.get(e),
      i = n ? n.get(t) : null;
    if (!i)
      throw lh(
        new Error("Cannot remove track that was never added."),
        "ERR_TRACK_NOT_ADDED"
      );
    try {
      (i.removed = !0), this._pc.removeTrack(i);
    } catch (r) {
      "NS_ERROR_UNEXPECTED" === r.name
        ? this._sendersAwaitingStable.push(i)
        : this.destroy(lh(r, "ERR_REMOVE_TRACK"));
    }
    this._needsNegotiation();
  }
  removeStream(e) {
    if (!this.destroying) {
      if (this.destroyed)
        throw lh(
          new Error("cannot removeStream after peer is destroyed"),
          "ERR_DESTROYED"
        );
      this._debug("removeSenders()"),
        e.getTracks().forEach((t) => {
          this.removeTrack(t, e);
        });
    }
  }
  _needsNegotiation() {
    this._debug("_needsNegotiation"),
      this._batchedNegotiation ||
        ((this._batchedNegotiation = !0),
        queueMicrotask(() => {
          (this._batchedNegotiation = !1),
            this.initiator || !this._firstNegotiation
              ? (this._debug("starting batched negotiation"), this.negotiate())
              : this._debug(
                  "non-initiator initial negotiation request discarded"
                ),
            (this._firstNegotiation = !1);
        }));
  }
  negotiate() {
    if (!this.destroying) {
      if (this.destroyed)
        throw lh(
          new Error("cannot negotiate after peer is destroyed"),
          "ERR_DESTROYED"
        );
      this.initiator
        ? this._isNegotiating
          ? ((this._queuedNegotiation = !0),
            this._debug("already negotiating, queueing"))
          : (this._debug("start negotiation"),
            setTimeout(() => {
              this._createOffer();
            }, 0))
        : this._isNegotiating
        ? ((this._queuedNegotiation = !0),
          this._debug("already negotiating, queueing"))
        : (this._debug("requesting negotiation from initiator"),
          this.emit("signal", { type: "renegotiate", renegotiate: !0 })),
        (this._isNegotiating = !0);
    }
  }
  destroy(e) {
    this.destroyed ||
      this.destroying ||
      ((this.destroying = !0),
      this._debug("destroying (error: %s)", e && (e.message || e)),
      queueMicrotask(() => {
        if (
          ((this.destroyed = !0),
          (this.destroying = !1),
          this._debug("destroy (error: %s)", e && (e.message || e)),
          (this._connected = !1),
          (this._pcReady = !1),
          (this._channelReady = !1),
          (this._remoteTracks = null),
          (this._remoteStreams = null),
          (this._senderMap = null),
          clearInterval(this._closingInterval),
          (this._closingInterval = null),
          clearInterval(this._interval),
          (this._interval = null),
          (this._chunk = null),
          (this._cb = null),
          this._channel)
        ) {
          try {
            this._channel.close();
          } catch (t) {}
          (this._channel.onmessage = null),
            (this._channel.onopen = null),
            (this._channel.onclose = null),
            (this._channel.onerror = null);
        }
        if (this._pc) {
          try {
            this._pc.close();
          } catch (t) {}
          (this._pc.oniceconnectionstatechange = null),
            (this._pc.onicegatheringstatechange = null),
            (this._pc.onsignalingstatechange = null),
            (this._pc.onicecandidate = null),
            (this._pc.ontrack = null),
            (this._pc.ondatachannel = null);
        }
        (this._pc = null),
          (this._channel = null),
          e && this.emit("error", e),
          this.emit("close");
      }));
  }
  _setupData(e) {
    if (!e.channel)
      return this.destroy(
        lh(
          new Error("Data channel event is missing `channel` property"),
          "ERR_DATA_CHANNEL"
        )
      );
    (this._channel = e.channel),
      (this._channel.binaryType = "arraybuffer"),
      "number" == typeof this._channel.bufferedAmountLowThreshold &&
        (this._channel.bufferedAmountLowThreshold = 65536),
      (this.channelName = this._channel.label),
      (this._channel.onmessage = (e) => {
        this._onChannelMessage(e);
      }),
      (this._channel.onbufferedamountlow = () => {
        this._onChannelBufferedAmountLow();
      }),
      (this._channel.onopen = () => {
        this._onChannelOpen();
      }),
      (this._channel.onclose = () => {
        this._onChannelClose();
      }),
      (this._channel.onerror = (e) => {
        this.destroy(lh(e, "ERR_DATA_CHANNEL"));
      });
    let t = !1;
    this._closingInterval = setInterval(() => {
      this._channel && "closing" === this._channel.readyState
        ? (t && this._onChannelClose(), (t = !0))
        : (t = !1);
    }, 5e3);
  }
  _startIceCompleteTimeout() {
    this.destroyed ||
      this._iceCompleteTimer ||
      (this._debug("started iceComplete timeout"),
      (this._iceCompleteTimer = setTimeout(() => {
        this._iceComplete ||
          ((this._iceComplete = !0),
          this._debug("iceComplete timeout completed"),
          this.emit("iceTimeout"),
          this.emit("_iceComplete"));
      }, this.iceCompleteTimeout)));
  }
  _createOffer() {
    this.destroyed ||
      this._pc
        .createOffer(this.offerOptions)
        .then((e) => {
          if (this.destroyed) return;
          this.trickle || this.allowHalfTrickle || (e.sdp = ch(e.sdp)),
            (e.sdp = this.sdpTransform(e.sdp));
          const t = () => {
            if (this.destroyed) return;
            const t = this._pc.localDescription || e;
            this._debug("signal"),
              this.emit("signal", { type: t.type, sdp: t.sdp });
          };
          this._pc
            .setLocalDescription(e)
            .then(() => {
              this._debug("createOffer success"),
                this.destroyed ||
                  (this.trickle || this._iceComplete
                    ? t()
                    : this.once("_iceComplete", t));
            })
            .catch((e) => {
              this.destroy(lh(e, "ERR_SET_LOCAL_DESCRIPTION"));
            });
        })
        .catch((e) => {
          this.destroy(lh(e, "ERR_CREATE_OFFER"));
        });
  }
  _requestMissingTransceivers() {
    this._pc.getTransceivers &&
      this._pc.getTransceivers().forEach((e) => {
        e.mid ||
          !e.sender.track ||
          e.requested ||
          ((e.requested = !0), this.addTransceiver(e.sender.track.kind));
      });
  }
  _createAnswer() {
    this.destroyed ||
      this._pc
        .createAnswer(this.answerOptions)
        .then((e) => {
          if (this.destroyed) return;
          this.trickle || this.allowHalfTrickle || (e.sdp = ch(e.sdp)),
            (e.sdp = this.sdpTransform(e.sdp));
          const t = () => {
            if (this.destroyed) return;
            const t = this._pc.localDescription || e;
            this._debug("signal"),
              this.emit("signal", { type: t.type, sdp: t.sdp }),
              this.initiator || this._requestMissingTransceivers();
          };
          this._pc
            .setLocalDescription(e)
            .then(() => {
              this.destroyed ||
                (this.trickle || this._iceComplete
                  ? t()
                  : this.once("_iceComplete", t));
            })
            .catch((e) => {
              this.destroy(lh(e, "ERR_SET_LOCAL_DESCRIPTION"));
            });
        })
        .catch((e) => {
          this.destroy(lh(e, "ERR_CREATE_ANSWER"));
        });
  }
  _onConnectionStateChange() {
    this.destroyed ||
      ("failed" === this._pc.connectionState &&
        this.destroy(
          lh(new Error("Connection failed."), "ERR_CONNECTION_FAILURE")
        ));
  }
  _onIceStateChange() {
    if (this.destroyed) return;
    const e = this._pc.iceConnectionState,
      t = this._pc.iceGatheringState;
    this._debug("iceStateChange (connection: %s) (gathering: %s)", e, t),
      this.emit("iceStateChange", e, t),
      ("connected" !== e && "completed" !== e) ||
        ((this._pcReady = !0), this._maybeReady()),
      "failed" === e &&
        this.destroy(
          lh(new Error("Ice connection failed."), "ERR_ICE_CONNECTION_FAILURE")
        ),
      "closed" === e &&
        this.destroy(
          lh(new Error("Ice connection closed."), "ERR_ICE_CONNECTION_CLOSED")
        );
  }
  getStats(e) {
    const t = (e) => (
      "[object Array]" === Object.prototype.toString.call(e.values) &&
        e.values.forEach((t) => {
          Object.assign(e, t);
        }),
      e
    );
    0 === this._pc.getStats.length || this._isReactNativeWebrtc
      ? this._pc.getStats().then(
          (n) => {
            const i = [];
            n.forEach((e) => {
              i.push(t(e));
            }),
              e(null, i);
          },
          (t) => e(t)
        )
      : this._pc.getStats.length > 0
      ? this._pc.getStats(
          (n) => {
            if (this.destroyed) return;
            const i = [];
            n.result().forEach((e) => {
              const n = {};
              e.names().forEach((t) => {
                n[t] = e.stat(t);
              }),
                (n.id = e.id),
                (n.type = e.type),
                (n.timestamp = e.timestamp),
                i.push(t(n));
            }),
              e(null, i);
          },
          (t) => e(t)
        )
      : e(null, []);
  }
  _maybeReady() {
    if (
      (this._debug(
        "maybeReady pc %s channel %s",
        this._pcReady,
        this._channelReady
      ),
      this._connected ||
        this._connecting ||
        !this._pcReady ||
        !this._channelReady)
    )
      return;
    this._connecting = !0;
    const e = () => {
      this.destroyed ||
        this.getStats((t, n) => {
          if (this.destroyed) return;
          t && (n = []);
          const i = {},
            r = {},
            s = {};
          let a = !1;
          n.forEach((e) => {
            ("remotecandidate" !== e.type && "remote-candidate" !== e.type) ||
              (i[e.id] = e),
              ("localcandidate" !== e.type && "local-candidate" !== e.type) ||
                (r[e.id] = e),
              ("candidatepair" !== e.type && "candidate-pair" !== e.type) ||
                (s[e.id] = e);
          });
          const o = (e) => {
            a = !0;
            let t = r[e.localCandidateId];
            t && (t.ip || t.address)
              ? ((this.localAddress = t.ip || t.address),
                (this.localPort = Number(t.port)))
              : t && t.ipAddress
              ? ((this.localAddress = t.ipAddress),
                (this.localPort = Number(t.portNumber)))
              : "string" == typeof e.googLocalAddress &&
                ((t = e.googLocalAddress.split(":")),
                (this.localAddress = t[0]),
                (this.localPort = Number(t[1]))),
              this.localAddress &&
                (this.localFamily = this.localAddress.includes(":")
                  ? "IPv6"
                  : "IPv4");
            let n = i[e.remoteCandidateId];
            n && (n.ip || n.address)
              ? ((this.remoteAddress = n.ip || n.address),
                (this.remotePort = Number(n.port)))
              : n && n.ipAddress
              ? ((this.remoteAddress = n.ipAddress),
                (this.remotePort = Number(n.portNumber)))
              : "string" == typeof e.googRemoteAddress &&
                ((n = e.googRemoteAddress.split(":")),
                (this.remoteAddress = n[0]),
                (this.remotePort = Number(n[1]))),
              this.remoteAddress &&
                (this.remoteFamily = this.remoteAddress.includes(":")
                  ? "IPv6"
                  : "IPv4"),
              this._debug(
                "connect local: %s:%s remote: %s:%s",
                this.localAddress,
                this.localPort,
                this.remoteAddress,
                this.remotePort
              );
          };
          if (
            (n.forEach((e) => {
              "transport" === e.type &&
                e.selectedCandidatePairId &&
                o(s[e.selectedCandidatePairId]),
                (("googCandidatePair" === e.type &&
                  "true" === e.googActiveConnection) ||
                  (("candidatepair" === e.type ||
                    "candidate-pair" === e.type) &&
                    e.selected)) &&
                  o(e);
            }),
            a || (Object.keys(s).length && !Object.keys(r).length))
          ) {
            if (
              ((this._connecting = !1), (this._connected = !0), this._chunk)
            ) {
              try {
                this.send(this._chunk);
              } catch (l) {
                return this.destroy(lh(l, "ERR_DATA_CHANNEL"));
              }
              (this._chunk = null),
                this._debug('sent chunk from "write before connect"');
              const e = this._cb;
              (this._cb = null), e(null);
            }
            "number" != typeof this._channel.bufferedAmountLowThreshold &&
              ((this._interval = setInterval(() => this._onInterval(), 150)),
              this._interval.unref && this._interval.unref()),
              this._debug("connect"),
              this.emit("connect");
          } else setTimeout(e, 100);
        });
    };
    e();
  }
  _onInterval() {
    !this._cb ||
      !this._channel ||
      this._channel.bufferedAmount > 65536 ||
      this._onChannelBufferedAmountLow();
  }
  _onSignalingStateChange() {
    this.destroyed ||
      ("stable" === this._pc.signalingState &&
        ((this._isNegotiating = !1),
        this._debug("flushing sender queue", this._sendersAwaitingStable),
        this._sendersAwaitingStable.forEach((e) => {
          this._pc.removeTrack(e), (this._queuedNegotiation = !0);
        }),
        (this._sendersAwaitingStable = []),
        this._queuedNegotiation
          ? (this._debug("flushing negotiation queue"),
            (this._queuedNegotiation = !1),
            this._needsNegotiation())
          : (this._debug("negotiated"), this.emit("negotiated"))),
      this._debug("signalingStateChange %s", this._pc.signalingState),
      this.emit("signalingStateChange", this._pc.signalingState));
  }
  _onIceCandidate(e) {
    this.destroyed ||
      (e.candidate && this.trickle
        ? this.emit("signal", {
            type: "candidate",
            candidate: {
              candidate: e.candidate.candidate,
              sdpMLineIndex: e.candidate.sdpMLineIndex,
              sdpMid: e.candidate.sdpMid,
            },
          })
        : e.candidate ||
          this._iceComplete ||
          ((this._iceComplete = !0), this.emit("_iceComplete")),
      e.candidate && this._startIceCompleteTimeout());
  }
  _onChannelMessage(e) {
    if (this.destroyed) return;
    let t = e.data;
    t instanceof ArrayBuffer && (t = new Uint8Array(t)), this.emit("data", t);
  }
  _onChannelBufferedAmountLow() {
    if (this.destroyed || !this._cb) return;
    this._debug(
      "ending backpressure: bufferedAmount %d",
      this._channel.bufferedAmount
    );
    const e = this._cb;
    (this._cb = null), e(null);
  }
  _onChannelOpen() {
    this._connected ||
      this.destroyed ||
      (this._debug("on channel open"),
      (this._channelReady = !0),
      this._maybeReady());
  }
  _onChannelClose() {
    this.destroyed || (this._debug("on channel close"), this.destroy());
  }
  _onTrack(e) {
    this.destroyed ||
      e.streams.forEach((t) => {
        this._debug("on track"),
          this.emit("track", e.track, t),
          this._remoteTracks.push({ track: e.track, stream: t }),
          this._remoteStreams.some((e) => e.id === t.id) ||
            (this._remoteStreams.push(t),
            queueMicrotask(() => {
              this._debug("on stream"), this.emit("stream", t);
            }));
      });
  }
  _debug(...e) {
    this._doDebug && (e[0] = "[" + this._id + "] " + e[0]);
  }
  on(e, t) {
    const n = this._map;
    n.has(e) || n.set(e, new Set()), n.get(e).add(t);
  }
  off(e, t) {
    const n = this._map,
      i = n.get(e);
    i && (i.delete(t), 0 === i.size && n.delete(e));
  }
  once(e, t) {
    const n = (...i) => {
      this.off(e, n), t(...i);
    };
    this.on(e, n);
  }
  emit(e, ...t) {
    const n = this._map;
    if (n.has(e))
      for (const r of n.get(e))
        try {
          r(...t);
        } catch (i) {}
  }
}
(uh.WEBRTC_SUPPORT = !!oh()),
  (uh.config = {
    iceServers: [
      {
        urls: [
          "stun:stun.l.google.com:19302",
          "stun:global.stun.twilio.com:3478",
        ],
      },
    ],
    sdpSemantics: "unified-plan",
  }),
  (uh.channelConfig = {});
const hh = !1,
  dh = "${JSCORE_VERSION}",
  ph = function (e, t) {
    if (!e) throw fh(t);
  },
  fh = function (e) {
    return new Error(
      "Firebase Database (" + dh + ") INTERNAL ASSERT FAILED: " + e
    );
  },
  mh = function (e) {
    const t = [];
    let n = 0;
    for (let i = 0; i < e.length; i++) {
      let r = e.charCodeAt(i);
      r < 128
        ? (t[n++] = r)
        : r < 2048
        ? ((t[n++] = (r >> 6) | 192), (t[n++] = (63 & r) | 128))
        : 55296 == (64512 & r) &&
          i + 1 < e.length &&
          56320 == (64512 & e.charCodeAt(i + 1))
        ? ((r = 65536 + ((1023 & r) << 10) + (1023 & e.charCodeAt(++i))),
          (t[n++] = (r >> 18) | 240),
          (t[n++] = ((r >> 12) & 63) | 128),
          (t[n++] = ((r >> 6) & 63) | 128),
          (t[n++] = (63 & r) | 128))
        : ((t[n++] = (r >> 12) | 224),
          (t[n++] = ((r >> 6) & 63) | 128),
          (t[n++] = (63 & r) | 128));
    }
    return t;
  },
  gh = {
    byteToCharMap_: null,
    charToByteMap_: null,
    byteToCharMapWebSafe_: null,
    charToByteMapWebSafe_: null,
    ENCODED_VALS_BASE:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
    get ENCODED_VALS() {
      return this.ENCODED_VALS_BASE + "+/=";
    },
    get ENCODED_VALS_WEBSAFE() {
      return this.ENCODED_VALS_BASE + "-_.";
    },
    HAS_NATIVE_SUPPORT: "function" == typeof atob,
    encodeByteArray(e, t) {
      if (!Array.isArray(e))
        throw Error("encodeByteArray takes an array as a parameter");
      this.init_();
      const n = t ? this.byteToCharMapWebSafe_ : this.byteToCharMap_,
        i = [];
      for (let r = 0; r < e.length; r += 3) {
        const t = e[r],
          s = r + 1 < e.length,
          a = s ? e[r + 1] : 0,
          o = r + 2 < e.length,
          l = o ? e[r + 2] : 0,
          c = t >> 2,
          u = ((3 & t) << 4) | (a >> 4);
        let h = ((15 & a) << 2) | (l >> 6),
          d = 63 & l;
        o || ((d = 64), s || (h = 64)), i.push(n[c], n[u], n[h], n[d]);
      }
      return i.join("");
    },
    encodeString(e, t) {
      return this.HAS_NATIVE_SUPPORT && !t
        ? btoa(e)
        : this.encodeByteArray(mh(e), t);
    },
    decodeString(e, t) {
      return this.HAS_NATIVE_SUPPORT && !t
        ? atob(e)
        : (function (e) {
            const t = [];
            let n = 0,
              i = 0;
            for (; n < e.length; ) {
              const r = e[n++];
              if (r < 128) t[i++] = String.fromCharCode(r);
              else if (r > 191 && r < 224) {
                const s = e[n++];
                t[i++] = String.fromCharCode(((31 & r) << 6) | (63 & s));
              } else if (r > 239 && r < 365) {
                const s =
                  (((7 & r) << 18) |
                    ((63 & e[n++]) << 12) |
                    ((63 & e[n++]) << 6) |
                    (63 & e[n++])) -
                  65536;
                (t[i++] = String.fromCharCode(55296 + (s >> 10))),
                  (t[i++] = String.fromCharCode(56320 + (1023 & s)));
              } else {
                const s = e[n++],
                  a = e[n++];
                t[i++] = String.fromCharCode(
                  ((15 & r) << 12) | ((63 & s) << 6) | (63 & a)
                );
              }
            }
            return t.join("");
          })(this.decodeStringToByteArray(e, t));
    },
    decodeStringToByteArray(e, t) {
      this.init_();
      const n = t ? this.charToByteMapWebSafe_ : this.charToByteMap_,
        i = [];
      for (let r = 0; r < e.length; ) {
        const t = n[e.charAt(r++)],
          s = r < e.length ? n[e.charAt(r)] : 0;
        ++r;
        const a = r < e.length ? n[e.charAt(r)] : 64;
        ++r;
        const o = r < e.length ? n[e.charAt(r)] : 64;
        if ((++r, null == t || null == s || null == a || null == o))
          throw Error();
        const l = (t << 2) | (s >> 4);
        if ((i.push(l), 64 !== a)) {
          const e = ((s << 4) & 240) | (a >> 2);
          if ((i.push(e), 64 !== o)) {
            const e = ((a << 6) & 192) | o;
            i.push(e);
          }
        }
      }
      return i;
    },
    init_() {
      if (!this.byteToCharMap_) {
        (this.byteToCharMap_ = {}),
          (this.charToByteMap_ = {}),
          (this.byteToCharMapWebSafe_ = {}),
          (this.charToByteMapWebSafe_ = {});
        for (let e = 0; e < this.ENCODED_VALS.length; e++)
          (this.byteToCharMap_[e] = this.ENCODED_VALS.charAt(e)),
            (this.charToByteMap_[this.byteToCharMap_[e]] = e),
            (this.byteToCharMapWebSafe_[e] =
              this.ENCODED_VALS_WEBSAFE.charAt(e)),
            (this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[e]] = e),
            e >= this.ENCODED_VALS_BASE.length &&
              ((this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(e)] = e),
              (this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(e)] = e));
      }
    },
  },
  vh = function (e) {
    try {
      return gh.decodeString(e, !0);
    } catch (t) {}
    return null;
  };
function _h(e) {
  return yh(void 0, e);
}
function yh(e, t) {
  if (!(t instanceof Object)) return t;
  switch (t.constructor) {
    case Date:
      return new Date(t.getTime());
    case Object:
      void 0 === e && (e = {});
      break;
    case Array:
      e = [];
      break;
    default:
      return t;
  }
  for (const n in t)
    t.hasOwnProperty(n) && "__proto__" !== n && (e[n] = yh(e[n], t[n]));
  return e;
}
class xh {
  constructor() {
    (this.reject = () => {}),
      (this.resolve = () => {}),
      (this.promise = new Promise((e, t) => {
        (this.resolve = e), (this.reject = t);
      }));
  }
  wrapCallback(e) {
    return (t, n) => {
      t ? this.reject(t) : this.resolve(n),
        "function" == typeof e &&
          (this.promise.catch(() => {}), 1 === e.length ? e(t) : e(t, n));
    };
  }
}
function bh() {
  return (
    "undefined" != typeof window &&
    !!(window.cordova || window.phonegap || window.PhoneGap) &&
    /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(
      "undefined" != typeof navigator && "string" == typeof navigator.userAgent
        ? navigator.userAgent
        : ""
    )
  );
}
function wh() {
  return !0 === hh;
}
class Sh extends Error {
  constructor(e, t, n) {
    super(t),
      (this.code = e),
      (this.customData = n),
      (this.name = "FirebaseError"),
      Object.setPrototypeOf(this, Sh.prototype),
      Error.captureStackTrace &&
        Error.captureStackTrace(this, Mh.prototype.create);
  }
}
class Mh {
  constructor(e, t, n) {
    (this.service = e), (this.serviceName = t), (this.errors = n);
  }
  create(e, ...t) {
    const n = t[0] || {},
      i = `${this.service}/${e}`,
      r = this.errors[e],
      s = r
        ? (function (e, t) {
            return e.replace(Th, (e, n) => {
              const i = t[n];
              return null != i ? String(i) : `<${n}?>`;
            });
          })(r, n)
        : "Error",
      a = `${this.serviceName}: ${s} (${i}).`;
    return new Sh(i, a, n);
  }
}
const Th = /\{\$([^}]+)}/g;
function Ch(e) {
  return JSON.parse(e);
}
function Eh(e) {
  return JSON.stringify(e);
}
const Ah = function (e) {
  let t = {},
    n = {},
    i = {},
    r = "";
  try {
    const s = e.split(".");
    (t = Ch(vh(s[0]) || "")),
      (n = Ch(vh(s[1]) || "")),
      (r = s[2]),
      (i = n.d || {}),
      delete n.d;
  } catch (s) {}
  return { header: t, claims: n, data: i, signature: r };
};
function Ph(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
function Lh(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t) ? e[t] : void 0;
}
function Ih(e) {
  for (const t in e) if (Object.prototype.hasOwnProperty.call(e, t)) return !1;
  return !0;
}
function Rh(e, t, n) {
  const i = {};
  for (const r in e)
    Object.prototype.hasOwnProperty.call(e, r) &&
      (i[r] = t.call(n, e[r], r, e));
  return i;
}
function Dh(e, t) {
  if (e === t) return !0;
  const n = Object.keys(e),
    i = Object.keys(t);
  for (const r of n) {
    if (!i.includes(r)) return !1;
    const n = e[r],
      s = t[r];
    if (kh(n) && kh(s)) {
      if (!Dh(n, s)) return !1;
    } else if (n !== s) return !1;
  }
  for (const r of i) if (!n.includes(r)) return !1;
  return !0;
}
function kh(e) {
  return null !== e && "object" == typeof e;
}
class Nh {
  constructor() {
    (this.chain_ = []),
      (this.buf_ = []),
      (this.W_ = []),
      (this.pad_ = []),
      (this.inbuf_ = 0),
      (this.total_ = 0),
      (this.blockSize = 64),
      (this.pad_[0] = 128);
    for (let e = 1; e < this.blockSize; ++e) this.pad_[e] = 0;
    this.reset();
  }
  reset() {
    (this.chain_[0] = 1732584193),
      (this.chain_[1] = 4023233417),
      (this.chain_[2] = 2562383102),
      (this.chain_[3] = 271733878),
      (this.chain_[4] = 3285377520),
      (this.inbuf_ = 0),
      (this.total_ = 0);
  }
  compress_(e, t) {
    t || (t = 0);
    const n = this.W_;
    if ("string" == typeof e)
      for (let u = 0; u < 16; u++)
        (n[u] =
          (e.charCodeAt(t) << 24) |
          (e.charCodeAt(t + 1) << 16) |
          (e.charCodeAt(t + 2) << 8) |
          e.charCodeAt(t + 3)),
          (t += 4);
    else
      for (let u = 0; u < 16; u++)
        (n[u] = (e[t] << 24) | (e[t + 1] << 16) | (e[t + 2] << 8) | e[t + 3]),
          (t += 4);
    for (let u = 16; u < 80; u++) {
      const e = n[u - 3] ^ n[u - 8] ^ n[u - 14] ^ n[u - 16];
      n[u] = 4294967295 & ((e << 1) | (e >>> 31));
    }
    let i,
      r,
      s = this.chain_[0],
      a = this.chain_[1],
      o = this.chain_[2],
      l = this.chain_[3],
      c = this.chain_[4];
    for (let u = 0; u < 80; u++) {
      u < 40
        ? u < 20
          ? ((i = l ^ (a & (o ^ l))), (r = 1518500249))
          : ((i = a ^ o ^ l), (r = 1859775393))
        : u < 60
        ? ((i = (a & o) | (l & (a | o))), (r = 2400959708))
        : ((i = a ^ o ^ l), (r = 3395469782));
      const e = (((s << 5) | (s >>> 27)) + i + c + r + n[u]) & 4294967295;
      (c = l),
        (l = o),
        (o = 4294967295 & ((a << 30) | (a >>> 2))),
        (a = s),
        (s = e);
    }
    (this.chain_[0] = (this.chain_[0] + s) & 4294967295),
      (this.chain_[1] = (this.chain_[1] + a) & 4294967295),
      (this.chain_[2] = (this.chain_[2] + o) & 4294967295),
      (this.chain_[3] = (this.chain_[3] + l) & 4294967295),
      (this.chain_[4] = (this.chain_[4] + c) & 4294967295);
  }
  update(e, t) {
    if (null == e) return;
    void 0 === t && (t = e.length);
    const n = t - this.blockSize;
    let i = 0;
    const r = this.buf_;
    let s = this.inbuf_;
    for (; i < t; ) {
      if (0 === s) for (; i <= n; ) this.compress_(e, i), (i += this.blockSize);
      if ("string" == typeof e) {
        for (; i < t; )
          if (((r[s] = e.charCodeAt(i)), ++s, ++i, s === this.blockSize)) {
            this.compress_(r), (s = 0);
            break;
          }
      } else
        for (; i < t; )
          if (((r[s] = e[i]), ++s, ++i, s === this.blockSize)) {
            this.compress_(r), (s = 0);
            break;
          }
    }
    (this.inbuf_ = s), (this.total_ += t);
  }
  digest() {
    const e = [];
    let t = 8 * this.total_;
    this.inbuf_ < 56
      ? this.update(this.pad_, 56 - this.inbuf_)
      : this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
    for (let i = this.blockSize - 1; i >= 56; i--)
      (this.buf_[i] = 255 & t), (t /= 256);
    this.compress_(this.buf_);
    let n = 0;
    for (let i = 0; i < 5; i++)
      for (let t = 24; t >= 0; t -= 8)
        (e[n] = (this.chain_[i] >> t) & 255), ++n;
    return e;
  }
}
function Oh(e, t) {
  return `${e} failed: ${t} argument `;
}
const Fh = function (e) {
  let t = 0;
  for (let n = 0; n < e.length; n++) {
    const i = e.charCodeAt(n);
    i < 128
      ? t++
      : i < 2048
      ? (t += 2)
      : i >= 55296 && i <= 56319
      ? ((t += 4), n++)
      : (t += 3);
  }
  return t;
};
function zh(e) {
  return e && e._delegate ? e._delegate : e;
}
class Uh {
  constructor(e, t, n) {
    (this.name = e),
      (this.instanceFactory = t),
      (this.type = n),
      (this.multipleInstances = !1),
      (this.serviceProps = {}),
      (this.instantiationMode = "LAZY"),
      (this.onInstanceCreated = null);
  }
  setInstantiationMode(e) {
    return (this.instantiationMode = e), this;
  }
  setMultipleInstances(e) {
    return (this.multipleInstances = e), this;
  }
  setServiceProps(e) {
    return (this.serviceProps = e), this;
  }
  setInstanceCreatedCallback(e) {
    return (this.onInstanceCreated = e), this;
  }
}
class Bh {
  constructor(e, t) {
    (this.name = e),
      (this.container = t),
      (this.component = null),
      (this.instances = new Map()),
      (this.instancesDeferred = new Map()),
      (this.instancesOptions = new Map()),
      (this.onInitCallbacks = new Map());
  }
  get(e) {
    const t = this.normalizeInstanceIdentifier(e);
    if (!this.instancesDeferred.has(t)) {
      const e = new xh();
      if (
        (this.instancesDeferred.set(t, e),
        this.isInitialized(t) || this.shouldAutoInitialize())
      )
        try {
          const n = this.getOrInitializeService({ instanceIdentifier: t });
          n && e.resolve(n);
        } catch (n) {}
    }
    return this.instancesDeferred.get(t).promise;
  }
  getImmediate(e) {
    var t;
    const n = this.normalizeInstanceIdentifier(
        null == e ? void 0 : e.identifier
      ),
      i = null !== (t = null == e ? void 0 : e.optional) && void 0 !== t && t;
    if (!this.isInitialized(n) && !this.shouldAutoInitialize()) {
      if (i) return null;
      throw Error(`Service ${this.name} is not available`);
    }
    try {
      return this.getOrInitializeService({ instanceIdentifier: n });
    } catch (r) {
      if (i) return null;
      throw r;
    }
  }
  getComponent() {
    return this.component;
  }
  setComponent(e) {
    if (e.name !== this.name)
      throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);
    if (this.component)
      throw Error(`Component for ${this.name} has already been provided`);
    if (((this.component = e), this.shouldAutoInitialize())) {
      if (
        (function (e) {
          return "EAGER" === e.instantiationMode;
        })(e)
      )
        try {
          this.getOrInitializeService({ instanceIdentifier: "[DEFAULT]" });
        } catch (t) {}
      for (const [e, n] of this.instancesDeferred.entries()) {
        const i = this.normalizeInstanceIdentifier(e);
        try {
          const e = this.getOrInitializeService({ instanceIdentifier: i });
          n.resolve(e);
        } catch (t) {}
      }
    }
  }
  clearInstance(e = "[DEFAULT]") {
    this.instancesDeferred.delete(e),
      this.instancesOptions.delete(e),
      this.instances.delete(e);
  }
  async delete() {
    const e = Array.from(this.instances.values());
    await Promise.all([
      ...e.filter((e) => "INTERNAL" in e).map((e) => e.INTERNAL.delete()),
      ...e.filter((e) => "_delete" in e).map((e) => e._delete()),
    ]);
  }
  isComponentSet() {
    return null != this.component;
  }
  isInitialized(e = "[DEFAULT]") {
    return this.instances.has(e);
  }
  getOptions(e = "[DEFAULT]") {
    return this.instancesOptions.get(e) || {};
  }
  initialize(e = {}) {
    const { options: t = {} } = e,
      n = this.normalizeInstanceIdentifier(e.instanceIdentifier);
    if (this.isInitialized(n))
      throw Error(`${this.name}(${n}) has already been initialized`);
    if (!this.isComponentSet())
      throw Error(`Component ${this.name} has not been registered yet`);
    const i = this.getOrInitializeService({
      instanceIdentifier: n,
      options: t,
    });
    for (const [r, s] of this.instancesDeferred.entries()) {
      n === this.normalizeInstanceIdentifier(r) && s.resolve(i);
    }
    return i;
  }
  onInit(e, t) {
    var n;
    const i = this.normalizeInstanceIdentifier(t),
      r =
        null !== (n = this.onInitCallbacks.get(i)) && void 0 !== n
          ? n
          : new Set();
    r.add(e), this.onInitCallbacks.set(i, r);
    const s = this.instances.get(i);
    return (
      s && e(s, i),
      () => {
        r.delete(e);
      }
    );
  }
  invokeOnInitCallbacks(e, t) {
    const n = this.onInitCallbacks.get(t);
    if (n)
      for (const r of n)
        try {
          r(e, t);
        } catch (i) {}
  }
  getOrInitializeService({ instanceIdentifier: e, options: t = {} }) {
    let n = this.instances.get(e);
    if (
      !n &&
      this.component &&
      ((n = this.component.instanceFactory(this.container, {
        instanceIdentifier: ((i = e), "[DEFAULT]" === i ? void 0 : i),
        options: t,
      })),
      this.instances.set(e, n),
      this.instancesOptions.set(e, t),
      this.invokeOnInitCallbacks(n, e),
      this.component.onInstanceCreated)
    )
      try {
        this.component.onInstanceCreated(this.container, e, n);
      } catch (r) {}
    var i;
    return n || null;
  }
  normalizeInstanceIdentifier(e = "[DEFAULT]") {
    return this.component
      ? this.component.multipleInstances
        ? e
        : "[DEFAULT]"
      : e;
  }
  shouldAutoInitialize() {
    return !!this.component && "EXPLICIT" !== this.component.instantiationMode;
  }
}
class Vh {
  constructor(e) {
    (this.name = e), (this.providers = new Map());
  }
  addComponent(e) {
    const t = this.getProvider(e.name);
    if (t.isComponentSet())
      throw new Error(
        `Component ${e.name} has already been registered with ${this.name}`
      );
    t.setComponent(e);
  }
  addOrOverwriteComponent(e) {
    this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name),
      this.addComponent(e);
  }
  getProvider(e) {
    if (this.providers.has(e)) return this.providers.get(e);
    const t = new Bh(e, this);
    return this.providers.set(e, t), t;
  }
  getProviders() {
    return Array.from(this.providers.values());
  }
}
var Hh, Gh;
((Gh = Hh || (Hh = {}))[(Gh.false = 0)] = "false"),
  (Gh[(Gh.VERBOSE = 1)] = "VERBOSE"),
  (Gh[(Gh.INFO = 2)] = "INFO"),
  (Gh[(Gh.WARN = 3)] = "WARN"),
  (Gh[(Gh.ERROR = 4)] = "ERROR"),
  (Gh[(Gh.SILENT = 5)] = "SILENT");
const Wh = {
    debug: Hh.DEBUG,
    verbose: Hh.VERBOSE,
    info: Hh.INFO,
    warn: Hh.WARN,
    error: Hh.ERROR,
    silent: Hh.SILENT,
  },
  qh = Hh.INFO,
  jh = {
    [Hh.DEBUG]: "log",
    [Hh.VERBOSE]: "log",
    [Hh.INFO]: "info",
    [Hh.WARN]: "warn",
    [Hh.ERROR]: "error",
  },
  Yh = (e, t, ...n) => {
    if (t < e.logLevel) return;
    new Date().toISOString();
    if (!jh[t])
      throw new Error(
        `Attempted to log a message with an invalid logType (value: ${t})`
      );
  };
class Xh {
  constructor(e) {
    (this.name = e),
      (this._logLevel = qh),
      (this._logHandler = Yh),
      (this._userLogHandler = null);
  }
  get logLevel() {
    return this._logLevel;
  }
  set logLevel(e) {
    if (!(e in Hh))
      throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);
    this._logLevel = e;
  }
  setLogLevel(e) {
    this._logLevel = "string" == typeof e ? Wh[e] : e;
  }
  get logHandler() {
    return this._logHandler;
  }
  set logHandler(e) {
    if ("function" != typeof e)
      throw new TypeError("Value assigned to `logHandler` must be a function");
    this._logHandler = e;
  }
  get userLogHandler() {
    return this._userLogHandler;
  }
  set userLogHandler(e) {
    this._userLogHandler = e;
  }
  debug(...e) {
    this._userLogHandler && this._userLogHandler(this, Hh.DEBUG, ...e),
      this._logHandler(this, Hh.DEBUG, ...e);
  }
  log(...e) {
    this._userLogHandler && this._userLogHandler(this, Hh.VERBOSE, ...e),
      this._logHandler(this, Hh.VERBOSE, ...e);
  }
  info(...e) {
    this._userLogHandler && this._userLogHandler(this, Hh.INFO, ...e),
      this._logHandler(this, Hh.INFO, ...e);
  }
  warn(...e) {
    this._userLogHandler && this._userLogHandler(this, Hh.WARN, ...e),
      this._logHandler(this, Hh.WARN, ...e);
  }
  error(...e) {
    this._userLogHandler && this._userLogHandler(this, Hh.ERROR, ...e),
      this._logHandler(this, Hh.ERROR, ...e);
  }
}
class $h {
  constructor(e) {
    this.container = e;
  }
  getPlatformInfoString() {
    return this.container
      .getProviders()
      .map((e) => {
        if (
          (function (e) {
            const t = e.getComponent();
            return "VERSION" === (null == t ? void 0 : t.type);
          })(e)
        ) {
          const t = e.getImmediate();
          return `${t.library}/${t.version}`;
        }
        return null;
      })
      .filter((e) => e)
      .join(" ");
  }
}
const Zh = "@firebase/app",
  Kh = new Xh("@firebase/app"),
  Jh = {
    [Zh]: "fire-core",
    "@firebase/app-compat": "fire-core-compat",
    "@firebase/analytics": "fire-analytics",
    "@firebase/analytics-compat": "fire-analytics-compat",
    "@firebase/app-check": "fire-app-check",
    "@firebase/app-check-compat": "fire-app-check-compat",
    "@firebase/auth": "fire-auth",
    "@firebase/auth-compat": "fire-auth-compat",
    "@firebase/database": "fire-rtdb",
    "@firebase/database-compat": "fire-rtdb-compat",
    "@firebase/functions": "fire-fn",
    "@firebase/functions-compat": "fire-fn-compat",
    "@firebase/installations": "fire-iid",
    "@firebase/installations-compat": "fire-iid-compat",
    "@firebase/messaging": "fire-fcm",
    "@firebase/messaging-compat": "fire-fcm-compat",
    "@firebase/performance": "fire-perf",
    "@firebase/performance-compat": "fire-perf-compat",
    "@firebase/remote-config": "fire-rc",
    "@firebase/remote-config-compat": "fire-rc-compat",
    "@firebase/storage": "fire-gcs",
    "@firebase/storage-compat": "fire-gcs-compat",
    "@firebase/firestore": "fire-fst",
    "@firebase/firestore-compat": "fire-fst-compat",
    "fire-js": "fire-js",
    firebase: "fire-js-all",
  },
  Qh = new Map(),
  ed = new Map();
function td(e, t) {
  try {
    e.container.addComponent(t);
  } catch (n) {
    Kh.debug(
      `Component ${t.name} failed to register with FirebaseApp ${e.name}`,
      n
    );
  }
}
function nd(e) {
  const t = e.name;
  if (ed.has(t))
    return (
      Kh.debug(`There were multiple attempts to register component ${t}.`), !1
    );
  ed.set(t, e);
  for (const n of Qh.values()) td(n, e);
  return !0;
}
const id = new Mh("app", "Firebase", {
  "no-app":
    "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()",
  "bad-app-name": "Illegal App name: '{$appName}",
  "duplicate-app":
    "Firebase App named '{$appName}' already exists with different options or config",
  "app-deleted": "Firebase App named '{$appName}' already deleted",
  "invalid-app-argument":
    "firebase.{$appName}() takes either no argument or a Firebase App instance.",
  "invalid-log-argument":
    "First argument to `onLog` must be null or a function.",
});
class rd {
  constructor(e, t, n) {
    (this._isDeleted = !1),
      (this._options = Object.assign({}, e)),
      (this._config = Object.assign({}, t)),
      (this._name = t.name),
      (this._automaticDataCollectionEnabled = t.automaticDataCollectionEnabled),
      (this._container = n),
      this.container.addComponent(new Uh("app", () => this, "PUBLIC"));
  }
  get automaticDataCollectionEnabled() {
    return this.checkDestroyed(), this._automaticDataCollectionEnabled;
  }
  set automaticDataCollectionEnabled(e) {
    this.checkDestroyed(), (this._automaticDataCollectionEnabled = e);
  }
  get name() {
    return this.checkDestroyed(), this._name;
  }
  get options() {
    return this.checkDestroyed(), this._options;
  }
  get config() {
    return this.checkDestroyed(), this._config;
  }
  get container() {
    return this._container;
  }
  get isDeleted() {
    return this._isDeleted;
  }
  set isDeleted(e) {
    this._isDeleted = e;
  }
  checkDestroyed() {
    if (this.isDeleted) throw id.create("app-deleted", { appName: this._name });
  }
}
function sd(e, t, n) {
  var i;
  let r = null !== (i = Jh[e]) && void 0 !== i ? i : e;
  n && (r += `-${n}`);
  const s = r.match(/\s|\//),
    a = t.match(/\s|\//);
  if (s || a) {
    const e = [`Unable to register library "${r}" with version "${t}":`];
    return (
      s &&
        e.push(
          `library name "${r}" contains illegal characters (whitespace or "/")`
        ),
      s && a && e.push("and"),
      a &&
        e.push(
          `version name "${t}" contains illegal characters (whitespace or "/")`
        ),
      void Kh.warn(e.join(" "))
    );
  }
  nd(new Uh(`${r}-version`, () => ({ library: r, version: t }), "VERSION"));
}
var ad;
(ad = ""),
  nd(new Uh("platform-logger", (e) => new $h(e), "PRIVATE")),
  sd(Zh, "0.7.8", ad),
  sd(Zh, "0.7.8", "esm2017"),
  sd("fire-js", "");
function od(e, t, n, i) {
  (this.fn = t), (this.ctx = n || null), (this.owner = e), (this.once = !!i);
}
function ld(e, t) {
  t.prev && (t.prev.next = t.next),
    t.next && (t.next.prev = t.prev),
    (t.ctx = t.fn = t.owner = null),
    t === e._first && (e._first = t.next),
    t === e._last && (e._last = t.prev);
}
sd("firebase", "9.4.1", "app");
class cd {
  constructor() {
    (this._first = this._last = null), (this._isStoreSignal = !0);
  }
  emit(e, t, n) {
    let i = this._first;
    for (; i; )
      i.fn.call(i.ctx, e, t, n), i.once && this.unwatch(i), (i = i.next);
  }
  watch(e, t, n) {
    const i = new od(this, e, t, n);
    return (
      this._first
        ? ((this._last.next = i), (i.prev = this._last), (this._last = i))
        : ((this._first = i), (this._last = i)),
      i
    );
  }
  watchOnce(e, t) {
    return this.watch(e, t, !0);
  }
  unwatch(e, t) {
    if (e instanceof od) return ld(this, e);
    t || (t = null);
    let n = this._first;
    for (; n; ) n.fn === e && n.ctx === t && ld(this, n), (n = n.next);
  }
  unwatchAll() {
    let e = this._first;
    for (this._first = this._last = null; e; ) ld(this, e), (e = e.next);
  }
}
function ud() {
  return new cd();
}
class hd extends cd {
  constructor(e) {
    super(), (this.value = e);
  }
  get() {
    return this.value;
  }
  watchImmediate(e, t) {
    const n = this.watch(e, t);
    return e.call(t, this.value, this.previous), n;
  }
}
const dd = new Set(),
  pd = {
    stack: dd,
    held: !1,
    holdEmits: fd,
    releaseEmits: md,
    batchUpdates: function (e) {
      return function (t, n, i) {
        fd(), e(t, n, i), md();
      };
    },
  };
function fd() {
  pd.held = !0;
}
function md() {
  (pd.held = !1), dd.forEach(gd), dd.clear();
}
function gd(e) {
  e._emit();
}
class vd extends hd {
  set(e, t) {
    if (t || this.value !== e) {
      if (((this.previous = this.value), (this.value = e), pd.held))
        return pd.stack.add(this);
      this._emit();
    }
  }
  _emit() {
    let e = this._first;
    for (; e; )
      e.fn.call(e.ctx, this.value, this.previous),
        e.once && this.unwatch(e),
        (e = e.next);
    this.previous = null;
  }
  update(e, t) {
    const n = e(this.value);
    this.set(void 0 !== n ? n : this.value, t);
  }
}
function _d(e) {
  return new vd(e);
}
function yd(e, t, n = {}) {
  if (!e._isStoreSignal || !t) return;
  const i = n.session ? sessionStorage : localStorage,
    r = n.type,
    s = n.boolean || r === Boolean,
    a = n.number || r === Number;
  let o = i.getItem(t);
  return (
    null == o ? (o = e.value) : s ? (o = !!+o) : a && (o = isNaN(+o) ? 0 : +o),
    (e.value = o),
    e.watch((e) => {
      let n = e;
      s ? (n = n ? 1 : 0) : a && (n = isNaN(+n) ? 0 : +n), i.setItem(t, n);
    }),
    e
  );
}
const xd = pd.holdEmits,
  bd = pd.releaseEmits,
  wd = "@firebase/database";
let Sd = "";
class Md {
  constructor(e) {
    (this.domStorage_ = e), (this.prefix_ = "firebase:");
  }
  set(e, t) {
    null == t
      ? this.domStorage_.removeItem(this.prefixedName_(e))
      : this.domStorage_.setItem(this.prefixedName_(e), Eh(t));
  }
  get(e) {
    const t = this.domStorage_.getItem(this.prefixedName_(e));
    return null == t ? null : Ch(t);
  }
  remove(e) {
    this.domStorage_.removeItem(this.prefixedName_(e));
  }
  prefixedName_(e) {
    return this.prefix_ + e;
  }
  toString() {
    return this.domStorage_.toString();
  }
}
class Td {
  constructor() {
    (this.cache_ = {}), (this.isInMemoryStorage = !0);
  }
  set(e, t) {
    null == t ? delete this.cache_[e] : (this.cache_[e] = t);
  }
  get(e) {
    return Ph(this.cache_, e) ? this.cache_[e] : null;
  }
  remove(e) {
    delete this.cache_[e];
  }
}
const Cd = function (e) {
    try {
      if ("undefined" != typeof window && void 0 !== window[e]) {
        const t = window[e];
        return (
          t.setItem("firebase:sentinel", "cache"),
          t.removeItem("firebase:sentinel"),
          new Md(t)
        );
      }
    } catch (t) {}
    return new Td();
  },
  Ed = Cd("localStorage"),
  Ad = Cd("sessionStorage"),
  Pd = new Xh("@firebase/database"),
  Ld = (function () {
    let e = 1;
    return function () {
      return e++;
    };
  })(),
  Id = function (e) {
    const t = (function (e) {
        const t = [];
        let n = 0;
        for (let i = 0; i < e.length; i++) {
          let r = e.charCodeAt(i);
          if (r >= 55296 && r <= 56319) {
            const t = r - 55296;
            i++,
              ph(i < e.length, "Surrogate pair missing trail surrogate."),
              (r = 65536 + (t << 10) + (e.charCodeAt(i) - 56320));
          }
          r < 128
            ? (t[n++] = r)
            : r < 2048
            ? ((t[n++] = (r >> 6) | 192), (t[n++] = (63 & r) | 128))
            : r < 65536
            ? ((t[n++] = (r >> 12) | 224),
              (t[n++] = ((r >> 6) & 63) | 128),
              (t[n++] = (63 & r) | 128))
            : ((t[n++] = (r >> 18) | 240),
              (t[n++] = ((r >> 12) & 63) | 128),
              (t[n++] = ((r >> 6) & 63) | 128),
              (t[n++] = (63 & r) | 128));
        }
        return t;
      })(e),
      n = new Nh();
    n.update(t);
    const i = n.digest();
    return gh.encodeByteArray(i);
  },
  Rd = function (...e) {
    let t = "";
    for (let n = 0; n < e.length; n++) {
      const i = e[n];
      Array.isArray(i) ||
      (i && "object" == typeof i && "number" == typeof i.length)
        ? (t += Rd.apply(null, i))
        : (t += "object" == typeof i ? Eh(i) : i),
        (t += " ");
    }
    return t;
  };
let Dd = null,
  kd = !0;
const Nd = function (...e) {
    var t, n;
    if (
      (!0 === kd &&
        ((kd = !1),
        null === Dd &&
          !0 === Ad.get("logging_enabled") &&
          ((t = !0),
          ph(
            !n || !0 === t || !1 === t,
            "Can't turn on custom loggers persistently."
          ),
          !0 === t
            ? ((Pd.logLevel = Hh.VERBOSE),
              (Dd = Pd.log.bind(Pd)),
              n && Ad.set("logging_enabled", !0))
            : "function" == typeof t
            ? (Dd = t)
            : ((Dd = null), Ad.remove("logging_enabled")))),
      Dd)
    ) {
      const t = Rd.apply(null, e);
      Dd(t);
    }
  },
  Od = function (e) {
    return function (...t) {
      Nd(e, ...t);
    };
  },
  Fd = function (...e) {
    const t = "FIREBASE INTERNAL ERROR: " + Rd(...e);
    Pd.error(t);
  },
  zd = function (...e) {
    const t = `FIREBASE FATAL ERROR: ${Rd(...e)}`;
    throw (Pd.error(t), new Error(t));
  },
  Ud = function (...e) {
    const t = "FIREBASE WARNING: " + Rd(...e);
    Pd.warn(t);
  },
  Bd = function (e) {
    return (
      "number" == typeof e &&
      (e != e ||
        e === Number.POSITIVE_INFINITY ||
        e === Number.NEGATIVE_INFINITY)
    );
  },
  Vd = "[MIN_NAME]",
  Hd = "[MAX_NAME]",
  Gd = function (e, t) {
    if (e === t) return 0;
    if (e === Vd || t === Hd) return -1;
    if (t === Vd || e === Hd) return 1;
    {
      const n = Kd(e),
        i = Kd(t);
      return null !== n
        ? null !== i
          ? n - i == 0
            ? e.length - t.length
            : n - i
          : -1
        : null !== i
        ? 1
        : e < t
        ? -1
        : 1;
    }
  },
  Wd = function (e, t) {
    return e === t ? 0 : e < t ? -1 : 1;
  },
  qd = function (e, t) {
    if (t && e in t) return t[e];
    throw new Error("Missing required key (" + e + ") in object: " + Eh(t));
  },
  jd = function (e) {
    if ("object" != typeof e || null === e) return Eh(e);
    const t = [];
    for (const i in e) t.push(i);
    t.sort();
    let n = "{";
    for (let i = 0; i < t.length; i++)
      0 !== i && (n += ","), (n += Eh(t[i])), (n += ":"), (n += jd(e[t[i]]));
    return (n += "}"), n;
  },
  Yd = function (e, t) {
    const n = e.length;
    if (n <= t) return [e];
    const i = [];
    for (let r = 0; r < n; r += t)
      r + t > n ? i.push(e.substring(r, n)) : i.push(e.substring(r, r + t));
    return i;
  };
function Xd(e, t) {
  for (const n in e) e.hasOwnProperty(n) && t(n, e[n]);
}
const $d = function (e) {
  ph(!Bd(e), "Invalid JSON number");
  const t = 1023;
  let n, i, r, s, a;
  0 === e
    ? ((i = 0), (r = 0), (n = 1 / e == -Infinity ? 1 : 0))
    : ((n = e < 0),
      (e = Math.abs(e)) >= Math.pow(2, -1022)
        ? ((s = Math.min(Math.floor(Math.log(e) / Math.LN2), t)),
          (i = s + t),
          (r = Math.round(e * Math.pow(2, 52 - s) - Math.pow(2, 52))))
        : ((i = 0), (r = Math.round(e / Math.pow(2, -1074)))));
  const o = [];
  for (a = 52; a; a -= 1) o.push(r % 2 ? 1 : 0), (r = Math.floor(r / 2));
  for (a = 11; a; a -= 1) o.push(i % 2 ? 1 : 0), (i = Math.floor(i / 2));
  o.push(n ? 1 : 0), o.reverse();
  const l = o.join("");
  let c = "";
  for (a = 0; a < 64; a += 8) {
    let e = parseInt(l.substr(a, 8), 2).toString(16);
    1 === e.length && (e = "0" + e), (c += e);
  }
  return c.toLowerCase();
};
const Zd = new RegExp("^-?(0*)\\d{1,10}$"),
  Kd = function (e) {
    if (Zd.test(e)) {
      const t = Number(e);
      if (t >= -2147483648 && t <= 2147483647) return t;
    }
    return null;
  },
  Jd = function (e) {
    try {
      e();
    } catch (t) {
      setTimeout(() => {
        const e = t.stack || "";
        throw (Ud("Exception was thrown by user callback.", e), t);
      }, Math.floor(0));
    }
  },
  Qd = function (e, t) {
    const n = setTimeout(e, t);
    return "object" == typeof n && n.unref && n.unref(), n;
  };
class ep {
  constructor(e, t) {
    (this.appName_ = e),
      (this.appCheckProvider = t),
      (this.appCheck = null == t ? void 0 : t.getImmediate({ optional: !0 })),
      this.appCheck || null == t || t.get().then((e) => (this.appCheck = e));
  }
  getToken(e) {
    return this.appCheck
      ? this.appCheck.getToken(e)
      : new Promise((t, n) => {
          setTimeout(() => {
            this.appCheck ? this.getToken(e).then(t, n) : t(null);
          }, 0);
        });
  }
  addTokenChangeListener(e) {
    var t;
    null === (t = this.appCheckProvider) ||
      void 0 === t ||
      t.get().then((t) => t.addTokenListener(e));
  }
  notifyForInvalidToken() {
    Ud(
      `Provided AppCheck credentials for the app named "${this.appName_}" are invalid. This usually indicates your app was not initialized correctly.`
    );
  }
}
class tp {
  constructor(e, t, n) {
    (this.appName_ = e),
      (this.firebaseOptions_ = t),
      (this.authProvider_ = n),
      (this.auth_ = null),
      (this.auth_ = n.getImmediate({ optional: !0 })),
      this.auth_ || n.onInit((e) => (this.auth_ = e));
  }
  getToken(e) {
    return this.auth_
      ? this.auth_
          .getToken(e)
          .catch((e) =>
            e && "auth/token-not-initialized" === e.code
              ? (Nd(
                  "Got auth/token-not-initialized error.  Treating as null token."
                ),
                null)
              : Promise.reject(e)
          )
      : new Promise((t, n) => {
          setTimeout(() => {
            this.auth_ ? this.getToken(e).then(t, n) : t(null);
          }, 0);
        });
  }
  addTokenChangeListener(e) {
    this.auth_
      ? this.auth_.addAuthTokenListener(e)
      : this.authProvider_.get().then((t) => t.addAuthTokenListener(e));
  }
  removeTokenChangeListener(e) {
    this.authProvider_.get().then((t) => t.removeAuthTokenListener(e));
  }
  notifyForInvalidToken() {
    let e =
      'Provided authentication credentials for the app named "' +
      this.appName_ +
      '" are invalid. This usually indicates your app was not initialized correctly. ';
    "credential" in this.firebaseOptions_
      ? (e +=
          'Make sure the "credential" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.')
      : "serviceAccount" in this.firebaseOptions_
      ? (e +=
          'Make sure the "serviceAccount" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.')
      : (e +=
          'Make sure the "apiKey" and "databaseURL" properties provided to initializeApp() match the values provided for your app at https://console.firebase.google.com/.'),
      Ud(e);
  }
}
class np {
  constructor(e) {
    this.accessToken = e;
  }
  getToken(e) {
    return Promise.resolve({ accessToken: this.accessToken });
  }
  addTokenChangeListener(e) {
    e(this.accessToken);
  }
  removeTokenChangeListener(e) {}
  notifyForInvalidToken() {}
}
np.OWNER = "owner";
const ip =
  /(console\.firebase|firebase-console-\w+\.corp|firebase\.corp)\.google\.com/;
class rp {
  constructor(e, t, n, i, r = !1, s = "", a = !1) {
    (this.secure = t),
      (this.namespace = n),
      (this.webSocketOnly = i),
      (this.nodeAdmin = r),
      (this.persistenceKey = s),
      (this.includeNamespaceInQueryParams = a),
      (this._host = e.toLowerCase()),
      (this._domain = this._host.substr(this._host.indexOf(".") + 1)),
      (this.internalHost = Ed.get("host:" + e) || this._host);
  }
  isCacheableHost() {
    return "s-" === this.internalHost.substr(0, 2);
  }
  isCustomHost() {
    return (
      "firebaseio.com" !== this._domain &&
      "firebaseio-demo.com" !== this._domain
    );
  }
  get host() {
    return this._host;
  }
  set host(e) {
    e !== this.internalHost &&
      ((this.internalHost = e),
      this.isCacheableHost() &&
        Ed.set("host:" + this._host, this.internalHost));
  }
  toString() {
    let e = this.toURLString();
    return this.persistenceKey && (e += "<" + this.persistenceKey + ">"), e;
  }
  toURLString() {
    const e = this.secure ? "https://" : "http://",
      t = this.includeNamespaceInQueryParams ? `?ns=${this.namespace}` : "";
    return `${e}${this.host}/${t}`;
  }
}
function sp(e, t, n) {
  let i;
  if (
    (ph("string" == typeof t, "typeof type must == string"),
    ph("object" == typeof n, "typeof params must == object"),
    "websocket" === t)
  )
    i = (e.secure ? "wss://" : "ws://") + e.internalHost + "/.ws?";
  else {
    if ("long_polling" !== t) throw new Error("Unknown connection type: " + t);
    i = (e.secure ? "https://" : "http://") + e.internalHost + "/.lp?";
  }
  (function (e) {
    return (
      e.host !== e.internalHost ||
      e.isCustomHost() ||
      e.includeNamespaceInQueryParams
    );
  })(e) && (n.ns = e.namespace);
  const r = [];
  return (
    Xd(n, (e, t) => {
      r.push(e + "=" + t);
    }),
    i + r.join("&")
  );
}
class ap {
  constructor() {
    this.counters_ = {};
  }
  incrementCounter(e, t = 1) {
    Ph(this.counters_, e) || (this.counters_[e] = 0), (this.counters_[e] += t);
  }
  get() {
    return _h(this.counters_);
  }
}
const op = {},
  lp = {};
function cp(e) {
  const t = e.toString();
  return op[t] || (op[t] = new ap()), op[t];
}
class up {
  constructor(e) {
    (this.onMessage_ = e),
      (this.pendingResponses = []),
      (this.currentResponseNum = 0),
      (this.closeAfterResponse = -1),
      (this.onClose = null);
  }
  closeAfter(e, t) {
    (this.closeAfterResponse = e),
      (this.onClose = t),
      this.closeAfterResponse < this.currentResponseNum &&
        (this.onClose(), (this.onClose = null));
  }
  handleResponse(e, t) {
    for (
      this.pendingResponses[e] = t;
      this.pendingResponses[this.currentResponseNum];

    ) {
      const e = this.pendingResponses[this.currentResponseNum];
      delete this.pendingResponses[this.currentResponseNum];
      for (let t = 0; t < e.length; ++t)
        e[t] &&
          Jd(() => {
            this.onMessage_(e[t]);
          });
      if (this.currentResponseNum === this.closeAfterResponse) {
        this.onClose && (this.onClose(), (this.onClose = null));
        break;
      }
      this.currentResponseNum++;
    }
  }
}
class hp {
  constructor(e, t, n, i, r, s, a) {
    (this.connId = e),
      (this.repoInfo = t),
      (this.applicationId = n),
      (this.appCheckToken = i),
      (this.authToken = r),
      (this.transportSessionId = s),
      (this.lastSessionId = a),
      (this.bytesSent = 0),
      (this.bytesReceived = 0),
      (this.everConnected_ = !1),
      (this.log_ = Od(e)),
      (this.stats_ = cp(t)),
      (this.urlFn = (e) => (
        this.appCheckToken && (e.ac = this.appCheckToken),
        sp(t, "long_polling", e)
      ));
  }
  open(e, t) {
    (this.curSegmentNum = 0),
      (this.onDisconnect_ = t),
      (this.myPacketOrderer = new up(e)),
      (this.isClosed_ = !1),
      (this.connectTimeoutTimer_ = setTimeout(() => {
        this.log_("Timed out trying to connect."),
          this.onClosed_(),
          (this.connectTimeoutTimer_ = null);
      }, Math.floor(3e4))),
      (function (e) {
        if ("complete" === document.readyState) e();
        else {
          let t = !1;
          const n = function () {
            document.body
              ? t || ((t = !0), e())
              : setTimeout(n, Math.floor(10));
          };
          document.addEventListener
            ? (document.addEventListener("DOMContentLoaded", n, !1),
              window.addEventListener("load", n, !1))
            : document.attachEvent &&
              (document.attachEvent("onreadystatechange", () => {
                "complete" === document.readyState && n();
              }),
              window.attachEvent("onload", n));
        }
      })(() => {
        if (this.isClosed_) return;
        this.scriptTagHolder = new dp(
          (...e) => {
            const [t, n, i, r, s] = e;
            if ((this.incrementIncomingBytes_(e), this.scriptTagHolder))
              if (
                (this.connectTimeoutTimer_ &&
                  (clearTimeout(this.connectTimeoutTimer_),
                  (this.connectTimeoutTimer_ = null)),
                (this.everConnected_ = !0),
                "start" === t)
              )
                (this.id = n), (this.password = i);
              else {
                if ("close" !== t)
                  throw new Error("Unrecognized command received: " + t);
                n
                  ? ((this.scriptTagHolder.sendNewPolls = !1),
                    this.myPacketOrderer.closeAfter(n, () => {
                      this.onClosed_();
                    }))
                  : this.onClosed_();
              }
          },
          (...e) => {
            const [t, n] = e;
            this.incrementIncomingBytes_(e),
              this.myPacketOrderer.handleResponse(t, n);
          },
          () => {
            this.onClosed_();
          },
          this.urlFn
        );
        const e = { start: "t" };
        (e.ser = Math.floor(1e8 * Math.random())),
          this.scriptTagHolder.uniqueCallbackIdentifier &&
            (e.cb = this.scriptTagHolder.uniqueCallbackIdentifier),
          (e.v = "5"),
          this.transportSessionId && (e.s = this.transportSessionId),
          this.lastSessionId && (e.ls = this.lastSessionId),
          this.applicationId && (e.p = this.applicationId),
          this.appCheckToken && (e.ac = this.appCheckToken),
          "undefined" != typeof location &&
            location.hostname &&
            ip.test(location.hostname) &&
            (e.r = "f");
        const t = this.urlFn(e);
        this.log_("Connecting via long-poll to " + t),
          this.scriptTagHolder.addTag(t, () => {});
      });
  }
  start() {
    this.scriptTagHolder.startLongPoll(this.id, this.password),
      this.addDisconnectPingFrame(this.id, this.password);
  }
  static forceAllow() {
    hp.forceAllow_ = !0;
  }
  static forceDisallow() {
    hp.forceDisallow_ = !0;
  }
  static isAvailable() {
    return (
      !!hp.forceAllow_ ||
      !(
        hp.forceDisallow_ ||
        "undefined" == typeof document ||
        null == document.createElement ||
        ("object" == typeof window &&
          window.chrome &&
          window.chrome.extension &&
          !/^chrome/.test(window.location.href)) ||
        ("object" == typeof Windows && "object" == typeof Windows.UI)
      )
    );
  }
  markConnectionHealthy() {}
  shutdown_() {
    (this.isClosed_ = !0),
      this.scriptTagHolder &&
        (this.scriptTagHolder.close(), (this.scriptTagHolder = null)),
      this.myDisconnFrame &&
        (document.body.removeChild(this.myDisconnFrame),
        (this.myDisconnFrame = null)),
      this.connectTimeoutTimer_ &&
        (clearTimeout(this.connectTimeoutTimer_),
        (this.connectTimeoutTimer_ = null));
  }
  onClosed_() {
    this.isClosed_ ||
      (this.log_("Longpoll is closing itself"),
      this.shutdown_(),
      this.onDisconnect_ &&
        (this.onDisconnect_(this.everConnected_), (this.onDisconnect_ = null)));
  }
  close() {
    this.isClosed_ ||
      (this.log_("Longpoll is being closed."), this.shutdown_());
  }
  send(e) {
    const t = Eh(e);
    (this.bytesSent += t.length),
      this.stats_.incrementCounter("bytes_sent", t.length);
    const n = (function (e) {
        const t = mh(e);
        return gh.encodeByteArray(t, !0);
      })(t),
      i = Yd(n, 1840);
    for (let r = 0; r < i.length; r++)
      this.scriptTagHolder.enqueueSegment(this.curSegmentNum, i.length, i[r]),
        this.curSegmentNum++;
  }
  addDisconnectPingFrame(e, t) {
    this.myDisconnFrame = document.createElement("iframe");
    const n = { dframe: "t" };
    (n.id = e),
      (n.pw = t),
      (this.myDisconnFrame.src = this.urlFn(n)),
      (this.myDisconnFrame.style.display = "none"),
      document.body.appendChild(this.myDisconnFrame);
  }
  incrementIncomingBytes_(e) {
    const t = Eh(e).length;
    (this.bytesReceived += t),
      this.stats_.incrementCounter("bytes_received", t);
  }
}
class dp {
  constructor(e, t, n, i) {
    (this.onDisconnect = n),
      (this.urlFn = i),
      (this.outstandingRequests = new Set()),
      (this.pendingSegs = []),
      (this.currentSerial = Math.floor(1e8 * Math.random())),
      (this.sendNewPolls = !0);
    {
      (this.uniqueCallbackIdentifier = Ld()),
        (window["pLPCommand" + this.uniqueCallbackIdentifier] = e),
        (window["pRTLPCB" + this.uniqueCallbackIdentifier] = t),
        (this.myIFrame = dp.createIFrame_());
      let n = "";
      if (
        this.myIFrame.src &&
        "javascript:" === this.myIFrame.src.substr(0, "javascript:".length)
      ) {
        n = '<script>document.domain="' + document.domain + '";</script>';
      }
      const i = "<html><body>" + n + "</body></html>";
      try {
        this.myIFrame.doc.open(),
          this.myIFrame.doc.write(i),
          this.myIFrame.doc.close();
      } catch (r) {
        Nd("frame writing exception"), r.stack && Nd(r.stack), Nd(r);
      }
    }
  }
  static createIFrame_() {
    const e = document.createElement("iframe");
    if (((e.style.display = "none"), !document.body))
      throw "Document body has not initialized. Wait to initialize Firebase until after the document is ready.";
    document.body.appendChild(e);
    try {
      e.contentWindow.document || Nd("No IE domain setting required");
    } catch (t) {
      const n = document.domain;
      e.src =
        "javascript:void((function(){document.open();document.domain='" +
        n +
        "';document.close();})())";
    }
    return (
      e.contentDocument
        ? (e.doc = e.contentDocument)
        : e.contentWindow
        ? (e.doc = e.contentWindow.document)
        : e.document && (e.doc = e.document),
      e
    );
  }
  close() {
    (this.alive = !1),
      this.myIFrame &&
        ((this.myIFrame.doc.body.innerHTML = ""),
        setTimeout(() => {
          null !== this.myIFrame &&
            (document.body.removeChild(this.myIFrame), (this.myIFrame = null));
        }, Math.floor(0)));
    const e = this.onDisconnect;
    e && ((this.onDisconnect = null), e());
  }
  startLongPoll(e, t) {
    for (this.myID = e, this.myPW = t, this.alive = !0; this.newRequest_(); );
  }
  newRequest_() {
    if (
      this.alive &&
      this.sendNewPolls &&
      this.outstandingRequests.size < (this.pendingSegs.length > 0 ? 2 : 1)
    ) {
      this.currentSerial++;
      const e = {};
      (e.id = this.myID), (e.pw = this.myPW), (e.ser = this.currentSerial);
      let t = this.urlFn(e),
        n = "",
        i = 0;
      for (; this.pendingSegs.length > 0; ) {
        if (!(this.pendingSegs[0].d.length + 30 + n.length <= 1870)) break;
        {
          const e = this.pendingSegs.shift();
          (n =
            n +
            "&seg" +
            i +
            "=" +
            e.seg +
            "&ts" +
            i +
            "=" +
            e.ts +
            "&d" +
            i +
            "=" +
            e.d),
            i++;
        }
      }
      return (t += n), this.addLongPollTag_(t, this.currentSerial), !0;
    }
    return !1;
  }
  enqueueSegment(e, t, n) {
    this.pendingSegs.push({ seg: e, ts: t, d: n }),
      this.alive && this.newRequest_();
  }
  addLongPollTag_(e, t) {
    this.outstandingRequests.add(t);
    const n = () => {
        this.outstandingRequests.delete(t), this.newRequest_();
      },
      i = setTimeout(n, Math.floor(25e3));
    this.addTag(e, () => {
      clearTimeout(i), n();
    });
  }
  addTag(e, t) {
    setTimeout(() => {
      try {
        if (!this.sendNewPolls) return;
        const n = this.myIFrame.doc.createElement("script");
        (n.type = "text/javascript"),
          (n.async = !0),
          (n.src = e),
          (n.onload = n.onreadystatechange =
            function () {
              const e = n.readyState;
              (e && "loaded" !== e && "complete" !== e) ||
                ((n.onload = n.onreadystatechange = null),
                n.parentNode && n.parentNode.removeChild(n),
                t());
            }),
          (n.onerror = () => {
            Nd("Long-poll script failed to load: " + e),
              (this.sendNewPolls = !1),
              this.close();
          }),
          this.myIFrame.doc.body.appendChild(n);
      } catch (n) {}
    }, Math.floor(1));
  }
}
let pp = null;
"undefined" != typeof MozWebSocket
  ? (pp = MozWebSocket)
  : "undefined" != typeof WebSocket && (pp = WebSocket);
class fp {
  constructor(e, t, n, i, r, s, a) {
    (this.connId = e),
      (this.applicationId = n),
      (this.appCheckToken = i),
      (this.authToken = r),
      (this.keepaliveTimer = null),
      (this.frames = null),
      (this.totalFrames = 0),
      (this.bytesSent = 0),
      (this.bytesReceived = 0),
      (this.log_ = Od(this.connId)),
      (this.stats_ = cp(t)),
      (this.connURL = fp.connectionURL_(t, s, a, i)),
      (this.nodeAdmin = t.nodeAdmin);
  }
  static connectionURL_(e, t, n, i) {
    const r = { v: "5" };
    return (
      "undefined" != typeof location &&
        location.hostname &&
        ip.test(location.hostname) &&
        (r.r = "f"),
      t && (r.s = t),
      n && (r.ls = n),
      i && (r.ac = i),
      sp(e, "websocket", r)
    );
  }
  open(e, t) {
    (this.onDisconnect = t),
      (this.onMessage = e),
      this.log_("Websocket connecting to " + this.connURL),
      (this.everConnected_ = !1),
      Ed.set("previous_websocket_failure", !0);
    try {
      if (wh());
      else {
        const e = {
          headers: {
            "X-Firebase-GMPID": this.applicationId || "",
            "X-Firebase-AppCheck": this.appCheckToken || "",
          },
        };
        this.mySock = new pp(this.connURL, [], e);
      }
    } catch (n) {
      this.log_("Error instantiating WebSocket.");
      const e = n.message || n.data;
      return e && this.log_(e), void this.onClosed_();
    }
    (this.mySock.onopen = () => {
      this.log_("Websocket connected."), (this.everConnected_ = !0);
    }),
      (this.mySock.onclose = () => {
        this.log_("Websocket connection was disconnected."),
          (this.mySock = null),
          this.onClosed_();
      }),
      (this.mySock.onmessage = (e) => {
        this.handleIncomingFrame(e);
      }),
      (this.mySock.onerror = (e) => {
        this.log_("WebSocket error.  Closing connection.");
        const t = e.message || e.data;
        t && this.log_(t), this.onClosed_();
      });
  }
  start() {}
  static forceDisallow() {
    fp.forceDisallow_ = !0;
  }
  static isAvailable() {
    let e = !1;
    if ("undefined" != typeof navigator && navigator.userAgent) {
      const t = /Android ([0-9]{0,}\.[0-9]{0,})/,
        n = navigator.userAgent.match(t);
      n && n.length > 1 && parseFloat(n[1]) < 4.4 && (e = !0);
    }
    return !e && null !== pp && !fp.forceDisallow_;
  }
  static previouslyFailed() {
    return Ed.isInMemoryStorage || !0 === Ed.get("previous_websocket_failure");
  }
  markConnectionHealthy() {
    Ed.remove("previous_websocket_failure");
  }
  appendFrame_(e) {
    if ((this.frames.push(e), this.frames.length === this.totalFrames)) {
      const e = this.frames.join("");
      this.frames = null;
      const t = Ch(e);
      this.onMessage(t);
    }
  }
  handleNewFrameCount_(e) {
    (this.totalFrames = e), (this.frames = []);
  }
  extractFrameCount_(e) {
    if (
      (ph(null === this.frames, "We already have a frame buffer"),
      e.length <= 6)
    ) {
      const t = Number(e);
      if (!isNaN(t)) return this.handleNewFrameCount_(t), null;
    }
    return this.handleNewFrameCount_(1), e;
  }
  handleIncomingFrame(e) {
    if (null === this.mySock) return;
    const t = e.data;
    if (
      ((this.bytesReceived += t.length),
      this.stats_.incrementCounter("bytes_received", t.length),
      this.resetKeepAlive(),
      null !== this.frames)
    )
      this.appendFrame_(t);
    else {
      const e = this.extractFrameCount_(t);
      null !== e && this.appendFrame_(e);
    }
  }
  send(e) {
    this.resetKeepAlive();
    const t = Eh(e);
    (this.bytesSent += t.length),
      this.stats_.incrementCounter("bytes_sent", t.length);
    const n = Yd(t, 16384);
    n.length > 1 && this.sendString_(String(n.length));
    for (let i = 0; i < n.length; i++) this.sendString_(n[i]);
  }
  shutdown_() {
    (this.isClosed_ = !0),
      this.keepaliveTimer &&
        (clearInterval(this.keepaliveTimer), (this.keepaliveTimer = null)),
      this.mySock && (this.mySock.close(), (this.mySock = null));
  }
  onClosed_() {
    this.isClosed_ ||
      (this.log_("WebSocket is closing itself"),
      this.shutdown_(),
      this.onDisconnect &&
        (this.onDisconnect(this.everConnected_), (this.onDisconnect = null)));
  }
  close() {
    this.isClosed_ ||
      (this.log_("WebSocket is being closed"), this.shutdown_());
  }
  resetKeepAlive() {
    clearInterval(this.keepaliveTimer),
      (this.keepaliveTimer = setInterval(() => {
        this.mySock && this.sendString_("0"), this.resetKeepAlive();
      }, Math.floor(45e3)));
  }
  sendString_(e) {
    try {
      this.mySock.send(e);
    } catch (t) {
      this.log_(
        "Exception thrown from WebSocket.send():",
        t.message || t.data,
        "Closing connection."
      ),
        setTimeout(this.onClosed_.bind(this), 0);
    }
  }
}
(fp.responsesRequiredToBeHealthy = 2), (fp.healthyTimeout = 3e4);
class mp {
  constructor(e) {
    this.initTransports_(e);
  }
  static get ALL_TRANSPORTS() {
    return [hp, fp];
  }
  initTransports_(e) {
    const t = fp && fp.isAvailable();
    let n = t && !fp.previouslyFailed();
    if (
      (e.webSocketOnly &&
        (t ||
          Ud(
            "wss:// URL used, but browser isn't known to support websockets.  Trying anyway."
          ),
        (n = !0)),
      n)
    )
      this.transports_ = [fp];
    else {
      const e = (this.transports_ = []);
      for (const t of mp.ALL_TRANSPORTS) t && t.isAvailable() && e.push(t);
    }
  }
  initialTransport() {
    if (this.transports_.length > 0) return this.transports_[0];
    throw new Error("No transports available");
  }
  upgradeTransport() {
    return this.transports_.length > 1 ? this.transports_[1] : null;
  }
}
class gp {
  constructor(e, t, n, i, r, s, a, o, l, c) {
    (this.id = e),
      (this.repoInfo_ = t),
      (this.applicationId_ = n),
      (this.appCheckToken_ = i),
      (this.authToken_ = r),
      (this.onMessage_ = s),
      (this.onReady_ = a),
      (this.onDisconnect_ = o),
      (this.onKill_ = l),
      (this.lastSessionId = c),
      (this.connectionCount = 0),
      (this.pendingDataMessages = []),
      (this.state_ = 0),
      (this.log_ = Od("c:" + this.id + ":")),
      (this.transportManager_ = new mp(t)),
      this.log_("Connection created"),
      this.start_();
  }
  start_() {
    const e = this.transportManager_.initialTransport();
    (this.conn_ = new e(
      this.nextTransportId_(),
      this.repoInfo_,
      this.applicationId_,
      this.appCheckToken_,
      this.authToken_,
      null,
      this.lastSessionId
    )),
      (this.primaryResponsesRequired_ = e.responsesRequiredToBeHealthy || 0);
    const t = this.connReceiver_(this.conn_),
      n = this.disconnReceiver_(this.conn_);
    (this.tx_ = this.conn_),
      (this.rx_ = this.conn_),
      (this.secondaryConn_ = null),
      (this.isHealthy_ = !1),
      setTimeout(() => {
        this.conn_ && this.conn_.open(t, n);
      }, Math.floor(0));
    const i = e.healthyTimeout || 0;
    i > 0 &&
      (this.healthyTimeout_ = Qd(() => {
        (this.healthyTimeout_ = null),
          this.isHealthy_ ||
            (this.conn_ && this.conn_.bytesReceived > 102400
              ? (this.log_(
                  "Connection exceeded healthy timeout but has received " +
                    this.conn_.bytesReceived +
                    " bytes.  Marking connection healthy."
                ),
                (this.isHealthy_ = !0),
                this.conn_.markConnectionHealthy())
              : this.conn_ && this.conn_.bytesSent > 10240
              ? this.log_(
                  "Connection exceeded healthy timeout but has sent " +
                    this.conn_.bytesSent +
                    " bytes.  Leaving connection alive."
                )
              : (this.log_("Closing unhealthy connection after timeout."),
                this.close()));
      }, Math.floor(i)));
  }
  nextTransportId_() {
    return "c:" + this.id + ":" + this.connectionCount++;
  }
  disconnReceiver_(e) {
    return (t) => {
      e === this.conn_
        ? this.onConnectionLost_(t)
        : e === this.secondaryConn_
        ? (this.log_("Secondary connection lost."),
          this.onSecondaryConnectionLost_())
        : this.log_("closing an old connection");
    };
  }
  connReceiver_(e) {
    return (t) => {
      2 !== this.state_ &&
        (e === this.rx_
          ? this.onPrimaryMessageReceived_(t)
          : e === this.secondaryConn_
          ? this.onSecondaryMessageReceived_(t)
          : this.log_("message on old connection"));
    };
  }
  sendRequest(e) {
    const t = { t: "d", d: e };
    this.sendData_(t);
  }
  tryCleanupConnection() {
    this.tx_ === this.secondaryConn_ &&
      this.rx_ === this.secondaryConn_ &&
      (this.log_(
        "cleaning up and promoting a connection: " + this.secondaryConn_.connId
      ),
      (this.conn_ = this.secondaryConn_),
      (this.secondaryConn_ = null));
  }
  onSecondaryControl_(e) {
    if ("t" in e) {
      const t = e.t;
      "a" === t
        ? this.upgradeIfSecondaryHealthy_()
        : "r" === t
        ? (this.log_("Got a reset on secondary, closing it"),
          this.secondaryConn_.close(),
          (this.tx_ !== this.secondaryConn_ &&
            this.rx_ !== this.secondaryConn_) ||
            this.close())
        : "o" === t &&
          (this.log_("got pong on secondary."),
          this.secondaryResponsesRequired_--,
          this.upgradeIfSecondaryHealthy_());
    }
  }
  onSecondaryMessageReceived_(e) {
    const t = qd("t", e),
      n = qd("d", e);
    if ("c" === t) this.onSecondaryControl_(n);
    else {
      if ("d" !== t) throw new Error("Unknown protocol layer: " + t);
      this.pendingDataMessages.push(n);
    }
  }
  upgradeIfSecondaryHealthy_() {
    this.secondaryResponsesRequired_ <= 0
      ? (this.log_("Secondary connection is healthy."),
        (this.isHealthy_ = !0),
        this.secondaryConn_.markConnectionHealthy(),
        this.proceedWithUpgrade_())
      : (this.log_("sending ping on secondary."),
        this.secondaryConn_.send({ t: "c", d: { t: "p", d: {} } }));
  }
  proceedWithUpgrade_() {
    this.secondaryConn_.start(),
      this.log_("sending client ack on secondary"),
      this.secondaryConn_.send({ t: "c", d: { t: "a", d: {} } }),
      this.log_("Ending transmission on primary"),
      this.conn_.send({ t: "c", d: { t: "n", d: {} } }),
      (this.tx_ = this.secondaryConn_),
      this.tryCleanupConnection();
  }
  onPrimaryMessageReceived_(e) {
    const t = qd("t", e),
      n = qd("d", e);
    "c" === t ? this.onControl_(n) : "d" === t && this.onDataMessage_(n);
  }
  onDataMessage_(e) {
    this.onPrimaryResponse_(), this.onMessage_(e);
  }
  onPrimaryResponse_() {
    this.isHealthy_ ||
      (this.primaryResponsesRequired_--,
      this.primaryResponsesRequired_ <= 0 &&
        (this.log_("Primary connection is healthy."),
        (this.isHealthy_ = !0),
        this.conn_.markConnectionHealthy()));
  }
  onControl_(e) {
    const t = qd("t", e);
    if ("d" in e) {
      const n = e.d;
      if ("h" === t) this.onHandshake_(n);
      else if ("n" === t) {
        this.log_("recvd end transmission on primary"),
          (this.rx_ = this.secondaryConn_);
        for (let e = 0; e < this.pendingDataMessages.length; ++e)
          this.onDataMessage_(this.pendingDataMessages[e]);
        (this.pendingDataMessages = []), this.tryCleanupConnection();
      } else
        "s" === t
          ? this.onConnectionShutdown_(n)
          : "r" === t
          ? this.onReset_(n)
          : "e" === t
          ? Fd("Server Error: " + n)
          : "o" === t
          ? (this.log_("got pong on primary."),
            this.onPrimaryResponse_(),
            this.sendPingOnPrimaryIfNecessary_())
          : Fd("Unknown control packet command: " + t);
    }
  }
  onHandshake_(e) {
    const t = e.ts,
      n = e.v,
      i = e.h;
    (this.sessionId = e.s),
      (this.repoInfo_.host = i),
      0 === this.state_ &&
        (this.conn_.start(),
        this.onConnectionEstablished_(this.conn_, t),
        "5" !== n && Ud("Protocol version mismatch detected"),
        this.tryStartUpgrade_());
  }
  tryStartUpgrade_() {
    const e = this.transportManager_.upgradeTransport();
    e && this.startUpgrade_(e);
  }
  startUpgrade_(e) {
    (this.secondaryConn_ = new e(
      this.nextTransportId_(),
      this.repoInfo_,
      this.applicationId_,
      this.appCheckToken_,
      this.authToken_,
      this.sessionId
    )),
      (this.secondaryResponsesRequired_ = e.responsesRequiredToBeHealthy || 0);
    const t = this.connReceiver_(this.secondaryConn_),
      n = this.disconnReceiver_(this.secondaryConn_);
    this.secondaryConn_.open(t, n),
      Qd(() => {
        this.secondaryConn_ &&
          (this.log_("Timed out trying to upgrade."),
          this.secondaryConn_.close());
      }, Math.floor(6e4));
  }
  onReset_(e) {
    this.log_("Reset packet received.  New host: " + e),
      (this.repoInfo_.host = e),
      1 === this.state_
        ? this.close()
        : (this.closeConnections_(), this.start_());
  }
  onConnectionEstablished_(e, t) {
    this.log_("Realtime connection established."),
      (this.conn_ = e),
      (this.state_ = 1),
      this.onReady_ &&
        (this.onReady_(t, this.sessionId), (this.onReady_ = null)),
      0 === this.primaryResponsesRequired_
        ? (this.log_("Primary connection is healthy."), (this.isHealthy_ = !0))
        : Qd(() => {
            this.sendPingOnPrimaryIfNecessary_();
          }, Math.floor(5e3));
  }
  sendPingOnPrimaryIfNecessary_() {
    this.isHealthy_ ||
      1 !== this.state_ ||
      (this.log_("sending ping on primary."),
      this.sendData_({ t: "c", d: { t: "p", d: {} } }));
  }
  onSecondaryConnectionLost_() {
    const e = this.secondaryConn_;
    (this.secondaryConn_ = null),
      (this.tx_ !== e && this.rx_ !== e) || this.close();
  }
  onConnectionLost_(e) {
    (this.conn_ = null),
      e || 0 !== this.state_
        ? 1 === this.state_ && this.log_("Realtime connection lost.")
        : (this.log_("Realtime connection failed."),
          this.repoInfo_.isCacheableHost() &&
            (Ed.remove("host:" + this.repoInfo_.host),
            (this.repoInfo_.internalHost = this.repoInfo_.host))),
      this.close();
  }
  onConnectionShutdown_(e) {
    this.log_("Connection shutdown command received. Shutting down..."),
      this.onKill_ && (this.onKill_(e), (this.onKill_ = null)),
      (this.onDisconnect_ = null),
      this.close();
  }
  sendData_(e) {
    if (1 !== this.state_) throw "Connection is not connected";
    this.tx_.send(e);
  }
  close() {
    2 !== this.state_ &&
      (this.log_("Closing realtime connection."),
      (this.state_ = 2),
      this.closeConnections_(),
      this.onDisconnect_ &&
        (this.onDisconnect_(), (this.onDisconnect_ = null)));
  }
  closeConnections_() {
    this.log_("Shutting down all connections"),
      this.conn_ && (this.conn_.close(), (this.conn_ = null)),
      this.secondaryConn_ &&
        (this.secondaryConn_.close(), (this.secondaryConn_ = null)),
      this.healthyTimeout_ &&
        (clearTimeout(this.healthyTimeout_), (this.healthyTimeout_ = null));
  }
}
class vp {
  put(e, t, n, i) {}
  merge(e, t, n, i) {}
  refreshAuthToken(e) {}
  refreshAppCheckToken(e) {}
  onDisconnectPut(e, t, n) {}
  onDisconnectMerge(e, t, n) {}
  onDisconnectCancel(e, t) {}
  reportStats(e) {}
}
class _p {
  constructor(e) {
    (this.allowedEvents_ = e),
      (this.listeners_ = {}),
      ph(Array.isArray(e) && e.length > 0, "Requires a non-empty array");
  }
  trigger(e, ...t) {
    if (Array.isArray(this.listeners_[e])) {
      const n = [...this.listeners_[e]];
      for (let e = 0; e < n.length; e++) n[e].callback.apply(n[e].context, t);
    }
  }
  on(e, t, n) {
    this.validateEventType_(e),
      (this.listeners_[e] = this.listeners_[e] || []),
      this.listeners_[e].push({ callback: t, context: n });
    const i = this.getInitialEvent(e);
    i && t.apply(n, i);
  }
  off(e, t, n) {
    this.validateEventType_(e);
    const i = this.listeners_[e] || [];
    for (let r = 0; r < i.length; r++)
      if (i[r].callback === t && (!n || n === i[r].context))
        return void i.splice(r, 1);
  }
  validateEventType_(e) {
    ph(
      this.allowedEvents_.find((t) => t === e),
      "Unknown event: " + e
    );
  }
}
class yp extends _p {
  constructor() {
    super(["online"]),
      (this.online_ = !0),
      "undefined" == typeof window ||
        void 0 === window.addEventListener ||
        bh() ||
        (window.addEventListener(
          "online",
          () => {
            this.online_ || ((this.online_ = !0), this.trigger("online", !0));
          },
          !1
        ),
        window.addEventListener(
          "offline",
          () => {
            this.online_ && ((this.online_ = !1), this.trigger("online", !1));
          },
          !1
        ));
  }
  static getInstance() {
    return new yp();
  }
  getInitialEvent(e) {
    return ph("online" === e, "Unknown event type: " + e), [this.online_];
  }
  currentlyOnline() {
    return this.online_;
  }
}
class xp {
  constructor(e, t) {
    if (void 0 === t) {
      this.pieces_ = e.split("/");
      let t = 0;
      for (let e = 0; e < this.pieces_.length; e++)
        this.pieces_[e].length > 0 &&
          ((this.pieces_[t] = this.pieces_[e]), t++);
      (this.pieces_.length = t), (this.pieceNum_ = 0);
    } else (this.pieces_ = e), (this.pieceNum_ = t);
  }
  toString() {
    let e = "";
    for (let t = this.pieceNum_; t < this.pieces_.length; t++)
      "" !== this.pieces_[t] && (e += "/" + this.pieces_[t]);
    return e || "/";
  }
}
function bp() {
  return new xp("");
}
function wp(e) {
  return e.pieceNum_ >= e.pieces_.length ? null : e.pieces_[e.pieceNum_];
}
function Sp(e) {
  return e.pieces_.length - e.pieceNum_;
}
function Mp(e) {
  let t = e.pieceNum_;
  return t < e.pieces_.length && t++, new xp(e.pieces_, t);
}
function Tp(e) {
  return e.pieceNum_ < e.pieces_.length
    ? e.pieces_[e.pieces_.length - 1]
    : null;
}
function Cp(e, t = 0) {
  return e.pieces_.slice(e.pieceNum_ + t);
}
function Ep(e) {
  if (e.pieceNum_ >= e.pieces_.length) return null;
  const t = [];
  for (let n = e.pieceNum_; n < e.pieces_.length - 1; n++) t.push(e.pieces_[n]);
  return new xp(t, 0);
}
function Ap(e, t) {
  const n = [];
  for (let i = e.pieceNum_; i < e.pieces_.length; i++) n.push(e.pieces_[i]);
  if (t instanceof xp)
    for (let i = t.pieceNum_; i < t.pieces_.length; i++) n.push(t.pieces_[i]);
  else {
    const e = t.split("/");
    for (let t = 0; t < e.length; t++) e[t].length > 0 && n.push(e[t]);
  }
  return new xp(n, 0);
}
function Pp(e) {
  return e.pieceNum_ >= e.pieces_.length;
}
function Lp(e, t) {
  const n = wp(e),
    i = wp(t);
  if (null === n) return t;
  if (n === i) return Lp(Mp(e), Mp(t));
  throw new Error(
    "INTERNAL ERROR: innerPath (" + t + ") is not within outerPath (" + e + ")"
  );
}
function Ip(e, t) {
  if (Sp(e) !== Sp(t)) return !1;
  for (let n = e.pieceNum_, i = t.pieceNum_; n <= e.pieces_.length; n++, i++)
    if (e.pieces_[n] !== t.pieces_[i]) return !1;
  return !0;
}
function Rp(e, t) {
  let n = e.pieceNum_,
    i = t.pieceNum_;
  if (Sp(e) > Sp(t)) return !1;
  for (; n < e.pieces_.length; ) {
    if (e.pieces_[n] !== t.pieces_[i]) return !1;
    ++n, ++i;
  }
  return !0;
}
class Dp {
  constructor(e, t) {
    (this.errorPrefix_ = t),
      (this.parts_ = Cp(e, 0)),
      (this.byteLength_ = Math.max(1, this.parts_.length));
    for (let n = 0; n < this.parts_.length; n++)
      this.byteLength_ += Fh(this.parts_[n]);
    kp(this);
  }
}
function kp(e) {
  if (e.byteLength_ > 768)
    throw new Error(
      e.errorPrefix_ +
        "has a key path longer than 768 bytes (" +
        e.byteLength_ +
        ")."
    );
  if (e.parts_.length > 32)
    throw new Error(
      e.errorPrefix_ +
        "path specified exceeds the maximum depth that can be written (32) or object contains a cycle " +
        Np(e)
    );
}
function Np(e) {
  return 0 === e.parts_.length
    ? ""
    : "in property '" + e.parts_.join(".") + "'";
}
class Op extends _p {
  constructor() {
    let e, t;
    super(["visible"]),
      "undefined" != typeof document &&
        void 0 !== document.addEventListener &&
        (void 0 !== document.hidden
          ? ((t = "visibilitychange"), (e = "hidden"))
          : void 0 !== document.mozHidden
          ? ((t = "mozvisibilitychange"), (e = "mozHidden"))
          : void 0 !== document.msHidden
          ? ((t = "msvisibilitychange"), (e = "msHidden"))
          : void 0 !== document.webkitHidden &&
            ((t = "webkitvisibilitychange"), (e = "webkitHidden"))),
      (this.visible_ = !0),
      t &&
        document.addEventListener(
          t,
          () => {
            const t = !document[e];
            t !== this.visible_ &&
              ((this.visible_ = t), this.trigger("visible", t));
          },
          !1
        );
  }
  static getInstance() {
    return new Op();
  }
  getInitialEvent(e) {
    return ph("visible" === e, "Unknown event type: " + e), [this.visible_];
  }
}
class Fp extends vp {
  constructor(e, t, n, i, r, s, a, o) {
    if (
      (super(),
      (this.repoInfo_ = e),
      (this.applicationId_ = t),
      (this.onDataUpdate_ = n),
      (this.onConnectStatus_ = i),
      (this.onServerInfoUpdate_ = r),
      (this.authTokenProvider_ = s),
      (this.appCheckTokenProvider_ = a),
      (this.authOverride_ = o),
      (this.id = Fp.nextPersistentConnectionId_++),
      (this.log_ = Od("p:" + this.id + ":")),
      (this.interruptReasons_ = {}),
      (this.listens = new Map()),
      (this.outstandingPuts_ = []),
      (this.outstandingGets_ = []),
      (this.outstandingPutCount_ = 0),
      (this.outstandingGetCount_ = 0),
      (this.onDisconnectRequestQueue_ = []),
      (this.connected_ = !1),
      (this.reconnectDelay_ = 1e3),
      (this.maxReconnectDelay_ = 3e5),
      (this.securityDebugCallback_ = null),
      (this.lastSessionId = null),
      (this.establishConnectionTimer_ = null),
      (this.visible_ = !1),
      (this.requestCBHash_ = {}),
      (this.requestNumber_ = 0),
      (this.realtime_ = null),
      (this.authToken_ = null),
      (this.appCheckToken_ = null),
      (this.forceTokenRefresh_ = !1),
      (this.invalidAuthTokenCount_ = 0),
      (this.invalidAppCheckTokenCount_ = 0),
      (this.firstConnection_ = !0),
      (this.lastConnectionAttemptTime_ = null),
      (this.lastConnectionEstablishedTime_ = null),
      o && !wh())
    )
      throw new Error(
        "Auth override specified in options, but not supported on non Node.js platforms"
      );
    Op.getInstance().on("visible", this.onVisible_, this),
      -1 === e.host.indexOf("fblocal") &&
        yp.getInstance().on("online", this.onOnline_, this);
  }
  sendRequest(e, t, n) {
    const i = ++this.requestNumber_,
      r = { r: i, a: e, b: t };
    this.log_(Eh(r)),
      ph(
        this.connected_,
        "sendRequest call when we're not connected not allowed."
      ),
      this.realtime_.sendRequest(r),
      n && (this.requestCBHash_[i] = n);
  }
  get(e) {
    this.initConnection_();
    const t = new xh(),
      n = { p: e._path.toString(), q: e._queryObject },
      i = {
        action: "g",
        request: n,
        onComplete: (e) => {
          const i = e.d;
          "ok" === e.s
            ? (this.onDataUpdate_(n.p, i, !1, null), t.resolve(i))
            : t.reject(i);
        },
      };
    this.outstandingGets_.push(i), this.outstandingGetCount_++;
    const r = this.outstandingGets_.length - 1;
    return (
      this.connected_ ||
        setTimeout(() => {
          const e = this.outstandingGets_[r];
          void 0 !== e &&
            i === e &&
            (delete this.outstandingGets_[r],
            this.outstandingGetCount_--,
            0 === this.outstandingGetCount_ && (this.outstandingGets_ = []),
            this.log_("get " + r + " timed out on connection"),
            t.reject(new Error("Client is offline.")));
        }, 3e3),
      this.connected_ && this.sendGet_(r),
      t.promise
    );
  }
  listen(e, t, n, i) {
    this.initConnection_();
    const r = e._queryIdentifier,
      s = e._path.toString();
    this.log_("Listen called for " + s + " " + r),
      this.listens.has(s) || this.listens.set(s, new Map()),
      ph(
        e._queryParams.isDefault() || !e._queryParams.loadsAllData(),
        "listen() called for non-default but complete query"
      ),
      ph(
        !this.listens.get(s).has(r),
        "listen() called twice for same path/queryId."
      );
    const a = { onComplete: i, hashFn: t, query: e, tag: n };
    this.listens.get(s).set(r, a), this.connected_ && this.sendListen_(a);
  }
  sendGet_(e) {
    const t = this.outstandingGets_[e];
    this.sendRequest("g", t.request, (n) => {
      delete this.outstandingGets_[e],
        this.outstandingGetCount_--,
        0 === this.outstandingGetCount_ && (this.outstandingGets_ = []),
        t.onComplete && t.onComplete(n);
    });
  }
  sendListen_(e) {
    const t = e.query,
      n = t._path.toString(),
      i = t._queryIdentifier;
    this.log_("Listen on " + n + " for " + i);
    const r = { p: n };
    e.tag && ((r.q = t._queryObject), (r.t = e.tag)),
      (r.h = e.hashFn()),
      this.sendRequest("q", r, (r) => {
        const s = r.d,
          a = r.s;
        Fp.warnOnListenWarnings_(s, t);
        (this.listens.get(n) && this.listens.get(n).get(i)) === e &&
          (this.log_("listen response", r),
          "ok" !== a && this.removeListen_(n, i),
          e.onComplete && e.onComplete(a, s));
      });
  }
  static warnOnListenWarnings_(e, t) {
    if (e && "object" == typeof e && Ph(e, "w")) {
      const n = Lh(e, "w");
      if (Array.isArray(n) && ~n.indexOf("no_index")) {
        const e = '".indexOn": "' + t._queryParams.getIndex().toString() + '"',
          n = t._path.toString();
        Ud(
          `Using an unspecified index. Your data will be downloaded and filtered on the client. Consider adding ${e} at ${n} to your security rules for better performance.`
        );
      }
    }
  }
  refreshAuthToken(e) {
    (this.authToken_ = e),
      this.log_("Auth token refreshed"),
      this.authToken_
        ? this.tryAuth()
        : this.connected_ && this.sendRequest("unauth", {}, () => {}),
      this.reduceReconnectDelayIfAdminCredential_(e);
  }
  reduceReconnectDelayIfAdminCredential_(e) {
    ((e && 40 === e.length) ||
      (function (e) {
        const t = Ah(e).claims;
        return "object" == typeof t && !0 === t.admin;
      })(e)) &&
      (this.log_(
        "Admin auth credential detected.  Reducing max reconnect time."
      ),
      (this.maxReconnectDelay_ = 3e4));
  }
  refreshAppCheckToken(e) {
    (this.appCheckToken_ = e),
      this.log_("App check token refreshed"),
      this.appCheckToken_
        ? this.tryAppCheck()
        : this.connected_ && this.sendRequest("unappeck", {}, () => {});
  }
  tryAuth() {
    if (this.connected_ && this.authToken_) {
      const e = this.authToken_,
        t = (function (e) {
          const t = Ah(e).claims;
          return !!t && "object" == typeof t && t.hasOwnProperty("iat");
        })(e)
          ? "auth"
          : "gauth",
        n = { cred: e };
      null === this.authOverride_
        ? (n.noauth = !0)
        : "object" == typeof this.authOverride_ &&
          (n.authvar = this.authOverride_),
        this.sendRequest(t, n, (t) => {
          const n = t.s,
            i = t.d || "error";
          this.authToken_ === e &&
            ("ok" === n
              ? (this.invalidAuthTokenCount_ = 0)
              : this.onAuthRevoked_(n, i));
        });
    }
  }
  tryAppCheck() {
    this.connected_ &&
      this.appCheckToken_ &&
      this.sendRequest("appcheck", { token: this.appCheckToken_ }, (e) => {
        const t = e.s,
          n = e.d || "error";
        "ok" === t
          ? (this.invalidAppCheckTokenCount_ = 0)
          : this.onAppCheckRevoked_(t, n);
      });
  }
  unlisten(e, t) {
    const n = e._path.toString(),
      i = e._queryIdentifier;
    this.log_("Unlisten called for " + n + " " + i),
      ph(
        e._queryParams.isDefault() || !e._queryParams.loadsAllData(),
        "unlisten() called for non-default but complete query"
      );
    this.removeListen_(n, i) &&
      this.connected_ &&
      this.sendUnlisten_(n, i, e._queryObject, t);
  }
  sendUnlisten_(e, t, n, i) {
    this.log_("Unlisten on " + e + " for " + t);
    const r = { p: e };
    i && ((r.q = n), (r.t = i)), this.sendRequest("n", r);
  }
  onDisconnectPut(e, t, n) {
    this.initConnection_(),
      this.connected_
        ? this.sendOnDisconnect_("o", e, t, n)
        : this.onDisconnectRequestQueue_.push({
            pathString: e,
            action: "o",
            data: t,
            onComplete: n,
          });
  }
  onDisconnectMerge(e, t, n) {
    this.initConnection_(),
      this.connected_
        ? this.sendOnDisconnect_("om", e, t, n)
        : this.onDisconnectRequestQueue_.push({
            pathString: e,
            action: "om",
            data: t,
            onComplete: n,
          });
  }
  onDisconnectCancel(e, t) {
    this.initConnection_(),
      this.connected_
        ? this.sendOnDisconnect_("oc", e, null, t)
        : this.onDisconnectRequestQueue_.push({
            pathString: e,
            action: "oc",
            data: null,
            onComplete: t,
          });
  }
  sendOnDisconnect_(e, t, n, i) {
    const r = { p: t, d: n };
    this.log_("onDisconnect " + e, r),
      this.sendRequest(e, r, (e) => {
        i &&
          setTimeout(() => {
            i(e.s, e.d);
          }, Math.floor(0));
      });
  }
  put(e, t, n, i) {
    this.putInternal("p", e, t, n, i);
  }
  merge(e, t, n, i) {
    this.putInternal("m", e, t, n, i);
  }
  putInternal(e, t, n, i, r) {
    this.initConnection_();
    const s = { p: t, d: n };
    void 0 !== r && (s.h = r),
      this.outstandingPuts_.push({ action: e, request: s, onComplete: i }),
      this.outstandingPutCount_++;
    const a = this.outstandingPuts_.length - 1;
    this.connected_ ? this.sendPut_(a) : this.log_("Buffering put: " + t);
  }
  sendPut_(e) {
    const t = this.outstandingPuts_[e].action,
      n = this.outstandingPuts_[e].request,
      i = this.outstandingPuts_[e].onComplete;
    (this.outstandingPuts_[e].queued = this.connected_),
      this.sendRequest(t, n, (n) => {
        this.log_(t + " response", n),
          delete this.outstandingPuts_[e],
          this.outstandingPutCount_--,
          0 === this.outstandingPutCount_ && (this.outstandingPuts_ = []),
          i && i(n.s, n.d);
      });
  }
  reportStats(e) {
    if (this.connected_) {
      const t = { c: e };
      this.log_("reportStats", t),
        this.sendRequest("s", t, (e) => {
          if ("ok" !== e.s) {
            const t = e.d;
            this.log_("reportStats", "Error sending stats: " + t);
          }
        });
    }
  }
  onDataMessage_(e) {
    if ("r" in e) {
      this.log_("from server: " + Eh(e));
      const t = e.r,
        n = this.requestCBHash_[t];
      n && (delete this.requestCBHash_[t], n(e.b));
    } else {
      if ("error" in e) throw "A server-side error has occurred: " + e.error;
      "a" in e && this.onDataPush_(e.a, e.b);
    }
  }
  onDataPush_(e, t) {
    this.log_("handleServerMessage", e, t),
      "d" === e
        ? this.onDataUpdate_(t.p, t.d, !1, t.t)
        : "m" === e
        ? this.onDataUpdate_(t.p, t.d, !0, t.t)
        : "c" === e
        ? this.onListenRevoked_(t.p, t.q)
        : "ac" === e
        ? this.onAuthRevoked_(t.s, t.d)
        : "apc" === e
        ? this.onAppCheckRevoked_(t.s, t.d)
        : "sd" === e
        ? this.onSecurityDebugPacket_(t)
        : Fd(
            "Unrecognized action received from server: " +
              Eh(e) +
              "\nAre you using the latest client?"
          );
  }
  onReady_(e, t) {
    this.log_("connection ready"),
      (this.connected_ = !0),
      (this.lastConnectionEstablishedTime_ = new Date().getTime()),
      this.handleTimestamp_(e),
      (this.lastSessionId = t),
      this.firstConnection_ && this.sendConnectStats_(),
      this.restoreState_(),
      (this.firstConnection_ = !1),
      this.onConnectStatus_(!0);
  }
  scheduleConnect_(e) {
    ph(
      !this.realtime_,
      "Scheduling a connect when we're already connected/ing?"
    ),
      this.establishConnectionTimer_ &&
        clearTimeout(this.establishConnectionTimer_),
      (this.establishConnectionTimer_ = setTimeout(() => {
        (this.establishConnectionTimer_ = null), this.establishConnection_();
      }, Math.floor(e)));
  }
  initConnection_() {
    !this.realtime_ && this.firstConnection_ && this.scheduleConnect_(0);
  }
  onVisible_(e) {
    e &&
      !this.visible_ &&
      this.reconnectDelay_ === this.maxReconnectDelay_ &&
      (this.log_("Window became visible.  Reducing delay."),
      (this.reconnectDelay_ = 1e3),
      this.realtime_ || this.scheduleConnect_(0)),
      (this.visible_ = e);
  }
  onOnline_(e) {
    e
      ? (this.log_("Browser went online."),
        (this.reconnectDelay_ = 1e3),
        this.realtime_ || this.scheduleConnect_(0))
      : (this.log_("Browser went offline.  Killing connection."),
        this.realtime_ && this.realtime_.close());
  }
  onRealtimeDisconnect_() {
    if (
      (this.log_("data client disconnected"),
      (this.connected_ = !1),
      (this.realtime_ = null),
      this.cancelSentTransactions_(),
      (this.requestCBHash_ = {}),
      this.shouldReconnect_())
    ) {
      if (this.visible_) {
        if (this.lastConnectionEstablishedTime_) {
          new Date().getTime() - this.lastConnectionEstablishedTime_ > 3e4 &&
            (this.reconnectDelay_ = 1e3),
            (this.lastConnectionEstablishedTime_ = null);
        }
      } else
        this.log_("Window isn't visible.  Delaying reconnect."),
          (this.reconnectDelay_ = this.maxReconnectDelay_),
          (this.lastConnectionAttemptTime_ = new Date().getTime());
      const e = new Date().getTime() - this.lastConnectionAttemptTime_;
      let t = Math.max(0, this.reconnectDelay_ - e);
      (t = Math.random() * t),
        this.log_("Trying to reconnect in " + t + "ms"),
        this.scheduleConnect_(t),
        (this.reconnectDelay_ = Math.min(
          this.maxReconnectDelay_,
          1.3 * this.reconnectDelay_
        ));
    }
    this.onConnectStatus_(!1);
  }
  async establishConnection_() {
    if (this.shouldReconnect_()) {
      this.log_("Making a connection attempt"),
        (this.lastConnectionAttemptTime_ = new Date().getTime()),
        (this.lastConnectionEstablishedTime_ = null);
      const t = this.onDataMessage_.bind(this),
        n = this.onReady_.bind(this),
        i = this.onRealtimeDisconnect_.bind(this),
        r = this.id + ":" + Fp.nextConnectionId_++,
        s = this.lastSessionId;
      let a = !1,
        o = null;
      const l = function () {
          o ? o.close() : ((a = !0), i());
        },
        c = function (e) {
          ph(o, "sendRequest call when we're not connected not allowed."),
            o.sendRequest(e);
        };
      this.realtime_ = { close: l, sendRequest: c };
      const u = this.forceTokenRefresh_;
      this.forceTokenRefresh_ = !1;
      try {
        const [e, l] = await Promise.all([
          this.authTokenProvider_.getToken(u),
          this.appCheckTokenProvider_.getToken(u),
        ]);
        a
          ? Nd("getToken() completed but was canceled")
          : (Nd("getToken() completed. Creating connection."),
            (this.authToken_ = e && e.accessToken),
            (this.appCheckToken_ = l && l.token),
            (o = new gp(
              r,
              this.repoInfo_,
              this.applicationId_,
              this.appCheckToken_,
              this.authToken_,
              t,
              n,
              i,
              (e) => {
                Ud(e + " (" + this.repoInfo_.toString() + ")"),
                  this.interrupt("server_kill");
              },
              s
            )));
      } catch (e) {
        this.log_("Failed to get token: " + e),
          a || (this.repoInfo_.nodeAdmin && Ud(e), l());
      }
    }
  }
  interrupt(e) {
    Nd("Interrupting connection for reason: " + e),
      (this.interruptReasons_[e] = !0),
      this.realtime_
        ? this.realtime_.close()
        : (this.establishConnectionTimer_ &&
            (clearTimeout(this.establishConnectionTimer_),
            (this.establishConnectionTimer_ = null)),
          this.connected_ && this.onRealtimeDisconnect_());
  }
  resume(e) {
    Nd("Resuming connection for reason: " + e),
      delete this.interruptReasons_[e],
      Ih(this.interruptReasons_) &&
        ((this.reconnectDelay_ = 1e3),
        this.realtime_ || this.scheduleConnect_(0));
  }
  handleTimestamp_(e) {
    const t = e - new Date().getTime();
    this.onServerInfoUpdate_({ serverTimeOffset: t });
  }
  cancelSentTransactions_() {
    for (let e = 0; e < this.outstandingPuts_.length; e++) {
      const t = this.outstandingPuts_[e];
      t &&
        "h" in t.request &&
        t.queued &&
        (t.onComplete && t.onComplete("disconnect"),
        delete this.outstandingPuts_[e],
        this.outstandingPutCount_--);
    }
    0 === this.outstandingPutCount_ && (this.outstandingPuts_ = []);
  }
  onListenRevoked_(e, t) {
    let n;
    n = t ? t.map((e) => jd(e)).join("$") : "default";
    const i = this.removeListen_(e, n);
    i && i.onComplete && i.onComplete("permission_denied");
  }
  removeListen_(e, t) {
    const n = new xp(e).toString();
    let i;
    if (this.listens.has(n)) {
      const e = this.listens.get(n);
      (i = e.get(t)), e.delete(t), 0 === e.size && this.listens.delete(n);
    } else i = void 0;
    return i;
  }
  onAuthRevoked_(e, t) {
    Nd("Auth token revoked: " + e + "/" + t),
      (this.authToken_ = null),
      (this.forceTokenRefresh_ = !0),
      this.realtime_.close(),
      ("invalid_token" !== e && "permission_denied" !== e) ||
        (this.invalidAuthTokenCount_++,
        this.invalidAuthTokenCount_ >= 3 &&
          ((this.reconnectDelay_ = 3e4),
          this.authTokenProvider_.notifyForInvalidToken()));
  }
  onAppCheckRevoked_(e, t) {
    Nd("App check token revoked: " + e + "/" + t),
      (this.appCheckToken_ = null),
      (this.forceTokenRefresh_ = !0),
      ("invalid_token" !== e && "permission_denied" !== e) ||
        (this.invalidAppCheckTokenCount_++,
        this.invalidAppCheckTokenCount_ >= 3 &&
          this.appCheckTokenProvider_.notifyForInvalidToken());
  }
  onSecurityDebugPacket_(e) {
    this.securityDebugCallback_ && this.securityDebugCallback_(e);
  }
  restoreState_() {
    this.tryAuth(), this.tryAppCheck();
    for (const e of this.listens.values())
      for (const t of e.values()) this.sendListen_(t);
    for (let e = 0; e < this.outstandingPuts_.length; e++)
      this.outstandingPuts_[e] && this.sendPut_(e);
    for (; this.onDisconnectRequestQueue_.length; ) {
      const e = this.onDisconnectRequestQueue_.shift();
      this.sendOnDisconnect_(e.action, e.pathString, e.data, e.onComplete);
    }
    for (let e = 0; e < this.outstandingGets_.length; e++)
      this.outstandingGets_[e] && this.sendGet_(e);
  }
  sendConnectStats_() {
    const e = {};
    (e["sdk.js." + Sd.replace(/\./g, "-")] = 1),
      bh()
        ? (e["framework.cordova"] = 1)
        : "object" == typeof navigator &&
          "ReactNative" === navigator.product &&
          (e["framework.reactnative"] = 1),
      this.reportStats(e);
  }
  shouldReconnect_() {
    const e = yp.getInstance().currentlyOnline();
    return Ih(this.interruptReasons_) && e;
  }
}
(Fp.nextPersistentConnectionId_ = 0), (Fp.nextConnectionId_ = 0);
class zp {
  constructor(e, t) {
    (this.name = e), (this.node = t);
  }
  static Wrap(e, t) {
    return new zp(e, t);
  }
}
class Up {
  getCompare() {
    return this.compare.bind(this);
  }
  indexedValueChanged(e, t) {
    const n = new zp(Vd, e),
      i = new zp(Vd, t);
    return 0 !== this.compare(n, i);
  }
  minPost() {
    return zp.MIN;
  }
}
let Bp;
class Vp extends Up {
  static get __EMPTY_NODE() {
    return Bp;
  }
  static set __EMPTY_NODE(e) {
    Bp = e;
  }
  compare(e, t) {
    return Gd(e.name, t.name);
  }
  isDefinedOn(e) {
    throw fh("KeyIndex.isDefinedOn not expected to be called.");
  }
  indexedValueChanged(e, t) {
    return !1;
  }
  minPost() {
    return zp.MIN;
  }
  maxPost() {
    return new zp(Hd, Bp);
  }
  makePost(e, t) {
    return (
      ph("string" == typeof e, "KeyIndex indexValue must always be a string."),
      new zp(e, Bp)
    );
  }
  toString() {
    return ".key";
  }
}
const Hp = new Vp();
class Gp {
  constructor(e, t, n, i, r = null) {
    (this.isReverse_ = i), (this.resultGenerator_ = r), (this.nodeStack_ = []);
    let s = 1;
    for (; !e.isEmpty(); )
      if (((e = e), (s = t ? n(e.key, t) : 1), i && (s *= -1), s < 0))
        e = this.isReverse_ ? e.left : e.right;
      else {
        if (0 === s) {
          this.nodeStack_.push(e);
          break;
        }
        this.nodeStack_.push(e), (e = this.isReverse_ ? e.right : e.left);
      }
  }
  getNext() {
    if (0 === this.nodeStack_.length) return null;
    let e,
      t = this.nodeStack_.pop();
    if (
      ((e = this.resultGenerator_
        ? this.resultGenerator_(t.key, t.value)
        : { key: t.key, value: t.value }),
      this.isReverse_)
    )
      for (t = t.left; !t.isEmpty(); ) this.nodeStack_.push(t), (t = t.right);
    else
      for (t = t.right; !t.isEmpty(); ) this.nodeStack_.push(t), (t = t.left);
    return e;
  }
  hasNext() {
    return this.nodeStack_.length > 0;
  }
  peek() {
    if (0 === this.nodeStack_.length) return null;
    const e = this.nodeStack_[this.nodeStack_.length - 1];
    return this.resultGenerator_
      ? this.resultGenerator_(e.key, e.value)
      : { key: e.key, value: e.value };
  }
}
class Wp {
  constructor(e, t, n, i, r) {
    (this.key = e),
      (this.value = t),
      (this.color = null != n ? n : Wp.RED),
      (this.left = null != i ? i : qp.EMPTY_NODE),
      (this.right = null != r ? r : qp.EMPTY_NODE);
  }
  copy(e, t, n, i, r) {
    return new Wp(
      null != e ? e : this.key,
      null != t ? t : this.value,
      null != n ? n : this.color,
      null != i ? i : this.left,
      null != r ? r : this.right
    );
  }
  count() {
    return this.left.count() + 1 + this.right.count();
  }
  isEmpty() {
    return !1;
  }
  inorderTraversal(e) {
    return (
      this.left.inorderTraversal(e) ||
      !!e(this.key, this.value) ||
      this.right.inorderTraversal(e)
    );
  }
  reverseTraversal(e) {
    return (
      this.right.reverseTraversal(e) ||
      e(this.key, this.value) ||
      this.left.reverseTraversal(e)
    );
  }
  min_() {
    return this.left.isEmpty() ? this : this.left.min_();
  }
  minKey() {
    return this.min_().key;
  }
  maxKey() {
    return this.right.isEmpty() ? this.key : this.right.maxKey();
  }
  insert(e, t, n) {
    let i = this;
    const r = n(e, i.key);
    return (
      (i =
        r < 0
          ? i.copy(null, null, null, i.left.insert(e, t, n), null)
          : 0 === r
          ? i.copy(null, t, null, null, null)
          : i.copy(null, null, null, null, i.right.insert(e, t, n))),
      i.fixUp_()
    );
  }
  removeMin_() {
    if (this.left.isEmpty()) return qp.EMPTY_NODE;
    let e = this;
    return (
      e.left.isRed_() || e.left.left.isRed_() || (e = e.moveRedLeft_()),
      (e = e.copy(null, null, null, e.left.removeMin_(), null)),
      e.fixUp_()
    );
  }
  remove(e, t) {
    let n, i;
    if (((n = this), t(e, n.key) < 0))
      n.left.isEmpty() ||
        n.left.isRed_() ||
        n.left.left.isRed_() ||
        (n = n.moveRedLeft_()),
        (n = n.copy(null, null, null, n.left.remove(e, t), null));
    else {
      if (
        (n.left.isRed_() && (n = n.rotateRight_()),
        n.right.isEmpty() ||
          n.right.isRed_() ||
          n.right.left.isRed_() ||
          (n = n.moveRedRight_()),
        0 === t(e, n.key))
      ) {
        if (n.right.isEmpty()) return qp.EMPTY_NODE;
        (i = n.right.min_()),
          (n = n.copy(i.key, i.value, null, null, n.right.removeMin_()));
      }
      n = n.copy(null, null, null, null, n.right.remove(e, t));
    }
    return n.fixUp_();
  }
  isRed_() {
    return this.color;
  }
  fixUp_() {
    let e = this;
    return (
      e.right.isRed_() && !e.left.isRed_() && (e = e.rotateLeft_()),
      e.left.isRed_() && e.left.left.isRed_() && (e = e.rotateRight_()),
      e.left.isRed_() && e.right.isRed_() && (e = e.colorFlip_()),
      e
    );
  }
  moveRedLeft_() {
    let e = this.colorFlip_();
    return (
      e.right.left.isRed_() &&
        ((e = e.copy(null, null, null, null, e.right.rotateRight_())),
        (e = e.rotateLeft_()),
        (e = e.colorFlip_())),
      e
    );
  }
  moveRedRight_() {
    let e = this.colorFlip_();
    return (
      e.left.left.isRed_() && ((e = e.rotateRight_()), (e = e.colorFlip_())), e
    );
  }
  rotateLeft_() {
    const e = this.copy(null, null, Wp.RED, null, this.right.left);
    return this.right.copy(null, null, this.color, e, null);
  }
  rotateRight_() {
    const e = this.copy(null, null, Wp.RED, this.left.right, null);
    return this.left.copy(null, null, this.color, null, e);
  }
  colorFlip_() {
    const e = this.left.copy(null, null, !this.left.color, null, null),
      t = this.right.copy(null, null, !this.right.color, null, null);
    return this.copy(null, null, !this.color, e, t);
  }
  checkMaxDepth_() {
    const e = this.check_();
    return Math.pow(2, e) <= this.count() + 1;
  }
  check_() {
    if (this.isRed_() && this.left.isRed_())
      throw new Error(
        "Red node has red child(" + this.key + "," + this.value + ")"
      );
    if (this.right.isRed_())
      throw new Error(
        "Right child of (" + this.key + "," + this.value + ") is red"
      );
    const e = this.left.check_();
    if (e !== this.right.check_()) throw new Error("Black depths differ");
    return e + (this.isRed_() ? 0 : 1);
  }
}
(Wp.RED = !0), (Wp.BLACK = !1);
class qp {
  constructor(e, t = qp.EMPTY_NODE) {
    (this.comparator_ = e), (this.root_ = t);
  }
  insert(e, t) {
    return new qp(
      this.comparator_,
      this.root_
        .insert(e, t, this.comparator_)
        .copy(null, null, Wp.BLACK, null, null)
    );
  }
  remove(e) {
    return new qp(
      this.comparator_,
      this.root_
        .remove(e, this.comparator_)
        .copy(null, null, Wp.BLACK, null, null)
    );
  }
  get(e) {
    let t,
      n = this.root_;
    for (; !n.isEmpty(); ) {
      if (((t = this.comparator_(e, n.key)), 0 === t)) return n.value;
      t < 0 ? (n = n.left) : t > 0 && (n = n.right);
    }
    return null;
  }
  getPredecessorKey(e) {
    let t,
      n = this.root_,
      i = null;
    for (; !n.isEmpty(); ) {
      if (((t = this.comparator_(e, n.key)), 0 === t)) {
        if (n.left.isEmpty()) return i ? i.key : null;
        for (n = n.left; !n.right.isEmpty(); ) n = n.right;
        return n.key;
      }
      t < 0 ? (n = n.left) : t > 0 && ((i = n), (n = n.right));
    }
    throw new Error(
      "Attempted to find predecessor key for a nonexistent key.  What gives?"
    );
  }
  isEmpty() {
    return this.root_.isEmpty();
  }
  count() {
    return this.root_.count();
  }
  minKey() {
    return this.root_.minKey();
  }
  maxKey() {
    return this.root_.maxKey();
  }
  inorderTraversal(e) {
    return this.root_.inorderTraversal(e);
  }
  reverseTraversal(e) {
    return this.root_.reverseTraversal(e);
  }
  getIterator(e) {
    return new Gp(this.root_, null, this.comparator_, !1, e);
  }
  getIteratorFrom(e, t) {
    return new Gp(this.root_, e, this.comparator_, !1, t);
  }
  getReverseIteratorFrom(e, t) {
    return new Gp(this.root_, e, this.comparator_, !0, t);
  }
  getReverseIterator(e) {
    return new Gp(this.root_, null, this.comparator_, !0, e);
  }
}
function jp(e, t) {
  return Gd(e.name, t.name);
}
function Yp(e, t) {
  return Gd(e, t);
}
let Xp;
qp.EMPTY_NODE = new (class {
  copy(e, t, n, i, r) {
    return this;
  }
  insert(e, t, n) {
    return new Wp(e, t, null);
  }
  remove(e, t) {
    return this;
  }
  count() {
    return 0;
  }
  isEmpty() {
    return !0;
  }
  inorderTraversal(e) {
    return !1;
  }
  reverseTraversal(e) {
    return !1;
  }
  minKey() {
    return null;
  }
  maxKey() {
    return null;
  }
  check_() {
    return 0;
  }
  isRed_() {
    return !1;
  }
})();
const $p = function (e) {
    return "number" == typeof e ? "number:" + $d(e) : "string:" + e;
  },
  Zp = function (e) {
    if (e.isLeafNode()) {
      const t = e.val();
      ph(
        "string" == typeof t ||
          "number" == typeof t ||
          ("object" == typeof t && Ph(t, ".sv")),
        "Priority must be a string or number."
      );
    } else ph(e === Xp || e.isEmpty(), "priority of unexpected type.");
    ph(
      e === Xp || e.getPriority().isEmpty(),
      "Priority nodes can't have a priority of their own."
    );
  };
let Kp, Jp, Qp;
class ef {
  constructor(e, t = ef.__childrenNodeConstructor.EMPTY_NODE) {
    (this.value_ = e),
      (this.priorityNode_ = t),
      (this.lazyHash_ = null),
      ph(
        void 0 !== this.value_ && null !== this.value_,
        "LeafNode shouldn't be created with null/undefined value."
      ),
      Zp(this.priorityNode_);
  }
  static set __childrenNodeConstructor(e) {
    Kp = e;
  }
  static get __childrenNodeConstructor() {
    return Kp;
  }
  isLeafNode() {
    return !0;
  }
  getPriority() {
    return this.priorityNode_;
  }
  updatePriority(e) {
    return new ef(this.value_, e);
  }
  getImmediateChild(e) {
    return ".priority" === e
      ? this.priorityNode_
      : ef.__childrenNodeConstructor.EMPTY_NODE;
  }
  getChild(e) {
    return Pp(e)
      ? this
      : ".priority" === wp(e)
      ? this.priorityNode_
      : ef.__childrenNodeConstructor.EMPTY_NODE;
  }
  hasChild() {
    return !1;
  }
  getPredecessorChildName(e, t) {
    return null;
  }
  updateImmediateChild(e, t) {
    return ".priority" === e
      ? this.updatePriority(t)
      : t.isEmpty() && ".priority" !== e
      ? this
      : ef.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(
          e,
          t
        ).updatePriority(this.priorityNode_);
  }
  updateChild(e, t) {
    const n = wp(e);
    return null === n
      ? t
      : t.isEmpty() && ".priority" !== n
      ? this
      : (ph(
          ".priority" !== n || 1 === Sp(e),
          ".priority must be the last token in a path"
        ),
        this.updateImmediateChild(
          n,
          ef.__childrenNodeConstructor.EMPTY_NODE.updateChild(Mp(e), t)
        ));
  }
  isEmpty() {
    return !1;
  }
  numChildren() {
    return 0;
  }
  forEachChild(e, t) {
    return !1;
  }
  val(e) {
    return e && !this.getPriority().isEmpty()
      ? { ".value": this.getValue(), ".priority": this.getPriority().val() }
      : this.getValue();
  }
  hash() {
    if (null === this.lazyHash_) {
      let e = "";
      this.priorityNode_.isEmpty() ||
        (e += "priority:" + $p(this.priorityNode_.val()) + ":");
      const t = typeof this.value_;
      (e += t + ":"),
        (e += "number" === t ? $d(this.value_) : this.value_),
        (this.lazyHash_ = Id(e));
    }
    return this.lazyHash_;
  }
  getValue() {
    return this.value_;
  }
  compareTo(e) {
    return e === ef.__childrenNodeConstructor.EMPTY_NODE
      ? 1
      : e instanceof ef.__childrenNodeConstructor
      ? -1
      : (ph(e.isLeafNode(), "Unknown node type"), this.compareToLeafNode_(e));
  }
  compareToLeafNode_(e) {
    const t = typeof e.value_,
      n = typeof this.value_,
      i = ef.VALUE_TYPE_ORDER.indexOf(t),
      r = ef.VALUE_TYPE_ORDER.indexOf(n);
    return (
      ph(i >= 0, "Unknown leaf type: " + t),
      ph(r >= 0, "Unknown leaf type: " + n),
      i === r
        ? "object" === n
          ? 0
          : this.value_ < e.value_
          ? -1
          : this.value_ === e.value_
          ? 0
          : 1
        : r - i
    );
  }
  withIndex() {
    return this;
  }
  isIndexed() {
    return !0;
  }
  equals(e) {
    if (e === this) return !0;
    if (e.isLeafNode()) {
      const t = e;
      return (
        this.value_ === t.value_ && this.priorityNode_.equals(t.priorityNode_)
      );
    }
    return !1;
  }
}
ef.VALUE_TYPE_ORDER = ["object", "boolean", "number", "string"];
const tf = new (class extends Up {
    compare(e, t) {
      const n = e.node.getPriority(),
        i = t.node.getPriority(),
        r = n.compareTo(i);
      return 0 === r ? Gd(e.name, t.name) : r;
    }
    isDefinedOn(e) {
      return !e.getPriority().isEmpty();
    }
    indexedValueChanged(e, t) {
      return !e.getPriority().equals(t.getPriority());
    }
    minPost() {
      return zp.MIN;
    }
    maxPost() {
      return new zp(Hd, new ef("[PRIORITY-POST]", Qp));
    }
    makePost(e, t) {
      const n = Jp(e);
      return new zp(t, new ef("[PRIORITY-POST]", n));
    }
    toString() {
      return ".priority";
    }
  })(),
  nf = Math.log(2);
class rf {
  constructor(e) {
    var t;
    (this.count = ((t = e + 1), parseInt(Math.log(t) / nf, 10))),
      (this.current_ = this.count - 1);
    const n = ((i = this.count), parseInt(Array(i + 1).join("1"), 2));
    var i;
    this.bits_ = (e + 1) & n;
  }
  nextBitIsOne() {
    const e = !(this.bits_ & (1 << this.current_));
    return this.current_--, e;
  }
}
const sf = function (e, t, n, i) {
  e.sort(t);
  const r = function (t, i) {
      const s = i - t;
      let a, o;
      if (0 === s) return null;
      if (1 === s)
        return (
          (a = e[t]),
          (o = n ? n(a) : a),
          new Wp(o, a.node, Wp.BLACK, null, null)
        );
      {
        const l = parseInt(s / 2, 10) + t,
          c = r(t, l),
          u = r(l + 1, i);
        return (
          (a = e[l]), (o = n ? n(a) : a), new Wp(o, a.node, Wp.BLACK, c, u)
        );
      }
    },
    s = (function (t) {
      let i = null,
        s = null,
        a = e.length;
      const o = function (t, i) {
          const s = a - t,
            o = a;
          a -= t;
          const c = r(s + 1, o),
            u = e[s],
            h = n ? n(u) : u;
          l(new Wp(h, u.node, i, null, c));
        },
        l = function (e) {
          i ? ((i.left = e), (i = e)) : ((s = e), (i = e));
        };
      for (let e = 0; e < t.count; ++e) {
        const n = t.nextBitIsOne(),
          i = Math.pow(2, t.count - (e + 1));
        n ? o(i, Wp.BLACK) : (o(i, Wp.BLACK), o(i, Wp.RED));
      }
      return s;
    })(new rf(e.length));
  return new qp(i || t, s);
};
let af;
const of = {};
class lf {
  constructor(e, t) {
    (this.indexes_ = e), (this.indexSet_ = t);
  }
  static get Default() {
    return (
      ph(of && tf, "ChildrenNode.ts has not been loaded"),
      (af = af || new lf({ ".priority": of }, { ".priority": tf })),
      af
    );
  }
  get(e) {
    const t = Lh(this.indexes_, e);
    if (!t) throw new Error("No index defined for " + e);
    return t instanceof qp ? t : null;
  }
  hasIndex(e) {
    return Ph(this.indexSet_, e.toString());
  }
  addIndex(e, t) {
    ph(
      e !== Hp,
      "KeyIndex always exists and isn't meant to be added to the IndexMap."
    );
    const n = [];
    let i = !1;
    const r = t.getIterator(zp.Wrap);
    let s,
      a = r.getNext();
    for (; a; ) (i = i || e.isDefinedOn(a.node)), n.push(a), (a = r.getNext());
    s = i ? sf(n, e.getCompare()) : of;
    const o = e.toString(),
      l = Object.assign({}, this.indexSet_);
    l[o] = e;
    const c = Object.assign({}, this.indexes_);
    return (c[o] = s), new lf(c, l);
  }
  addToIndexes(e, t) {
    const n = Rh(this.indexes_, (n, i) => {
      const r = Lh(this.indexSet_, i);
      if ((ph(r, "Missing index implementation for " + i), n === of)) {
        if (r.isDefinedOn(e.node)) {
          const n = [],
            i = t.getIterator(zp.Wrap);
          let s = i.getNext();
          for (; s; ) s.name !== e.name && n.push(s), (s = i.getNext());
          return n.push(e), sf(n, r.getCompare());
        }
        return of;
      }
      {
        const i = t.get(e.name);
        let r = n;
        return i && (r = r.remove(new zp(e.name, i))), r.insert(e, e.node);
      }
    });
    return new lf(n, this.indexSet_);
  }
  removeFromIndexes(e, t) {
    const n = Rh(this.indexes_, (n) => {
      if (n === of) return n;
      {
        const i = t.get(e.name);
        return i ? n.remove(new zp(e.name, i)) : n;
      }
    });
    return new lf(n, this.indexSet_);
  }
}
let cf;
class uf {
  constructor(e, t, n) {
    (this.children_ = e),
      (this.priorityNode_ = t),
      (this.indexMap_ = n),
      (this.lazyHash_ = null),
      this.priorityNode_ && Zp(this.priorityNode_),
      this.children_.isEmpty() &&
        ph(
          !this.priorityNode_ || this.priorityNode_.isEmpty(),
          "An empty node cannot have a priority"
        );
  }
  static get EMPTY_NODE() {
    return cf || (cf = new uf(new qp(Yp), null, lf.Default));
  }
  isLeafNode() {
    return !1;
  }
  getPriority() {
    return this.priorityNode_ || cf;
  }
  updatePriority(e) {
    return this.children_.isEmpty()
      ? this
      : new uf(this.children_, e, this.indexMap_);
  }
  getImmediateChild(e) {
    if (".priority" === e) return this.getPriority();
    {
      const t = this.children_.get(e);
      return null === t ? cf : t;
    }
  }
  getChild(e) {
    const t = wp(e);
    return null === t ? this : this.getImmediateChild(t).getChild(Mp(e));
  }
  hasChild(e) {
    return null !== this.children_.get(e);
  }
  updateImmediateChild(e, t) {
    if (
      (ph(t, "We should always be passing snapshot nodes"), ".priority" === e)
    )
      return this.updatePriority(t);
    {
      const n = new zp(e, t);
      let i, r;
      t.isEmpty()
        ? ((i = this.children_.remove(e)),
          (r = this.indexMap_.removeFromIndexes(n, this.children_)))
        : ((i = this.children_.insert(e, t)),
          (r = this.indexMap_.addToIndexes(n, this.children_)));
      const s = i.isEmpty() ? cf : this.priorityNode_;
      return new uf(i, s, r);
    }
  }
  updateChild(e, t) {
    const n = wp(e);
    if (null === n) return t;
    {
      ph(
        ".priority" !== wp(e) || 1 === Sp(e),
        ".priority must be the last token in a path"
      );
      const i = this.getImmediateChild(n).updateChild(Mp(e), t);
      return this.updateImmediateChild(n, i);
    }
  }
  isEmpty() {
    return this.children_.isEmpty();
  }
  numChildren() {
    return this.children_.count();
  }
  val(e) {
    if (this.isEmpty()) return null;
    const t = {};
    let n = 0,
      i = 0,
      r = !0;
    if (
      (this.forEachChild(tf, (s, a) => {
        (t[s] = a.val(e)),
          n++,
          r && uf.INTEGER_REGEXP_.test(s)
            ? (i = Math.max(i, Number(s)))
            : (r = !1);
      }),
      !e && r && i < 2 * n)
    ) {
      const e = [];
      for (const n in t) e[n] = t[n];
      return e;
    }
    return (
      e &&
        !this.getPriority().isEmpty() &&
        (t[".priority"] = this.getPriority().val()),
      t
    );
  }
  hash() {
    if (null === this.lazyHash_) {
      let e = "";
      this.getPriority().isEmpty() ||
        (e += "priority:" + $p(this.getPriority().val()) + ":"),
        this.forEachChild(tf, (t, n) => {
          const i = n.hash();
          "" !== i && (e += ":" + t + ":" + i);
        }),
        (this.lazyHash_ = "" === e ? "" : Id(e));
    }
    return this.lazyHash_;
  }
  getPredecessorChildName(e, t, n) {
    const i = this.resolveIndex_(n);
    if (i) {
      const n = i.getPredecessorKey(new zp(e, t));
      return n ? n.name : null;
    }
    return this.children_.getPredecessorKey(e);
  }
  getFirstChildName(e) {
    const t = this.resolveIndex_(e);
    if (t) {
      const e = t.minKey();
      return e && e.name;
    }
    return this.children_.minKey();
  }
  getFirstChild(e) {
    const t = this.getFirstChildName(e);
    return t ? new zp(t, this.children_.get(t)) : null;
  }
  getLastChildName(e) {
    const t = this.resolveIndex_(e);
    if (t) {
      const e = t.maxKey();
      return e && e.name;
    }
    return this.children_.maxKey();
  }
  getLastChild(e) {
    const t = this.getLastChildName(e);
    return t ? new zp(t, this.children_.get(t)) : null;
  }
  forEachChild(e, t) {
    const n = this.resolveIndex_(e);
    return n
      ? n.inorderTraversal((e) => t(e.name, e.node))
      : this.children_.inorderTraversal(t);
  }
  getIterator(e) {
    return this.getIteratorFrom(e.minPost(), e);
  }
  getIteratorFrom(e, t) {
    const n = this.resolveIndex_(t);
    if (n) return n.getIteratorFrom(e, (e) => e);
    {
      const n = this.children_.getIteratorFrom(e.name, zp.Wrap);
      let i = n.peek();
      for (; null != i && t.compare(i, e) < 0; ) n.getNext(), (i = n.peek());
      return n;
    }
  }
  getReverseIterator(e) {
    return this.getReverseIteratorFrom(e.maxPost(), e);
  }
  getReverseIteratorFrom(e, t) {
    const n = this.resolveIndex_(t);
    if (n) return n.getReverseIteratorFrom(e, (e) => e);
    {
      const n = this.children_.getReverseIteratorFrom(e.name, zp.Wrap);
      let i = n.peek();
      for (; null != i && t.compare(i, e) > 0; ) n.getNext(), (i = n.peek());
      return n;
    }
  }
  compareTo(e) {
    return this.isEmpty()
      ? e.isEmpty()
        ? 0
        : -1
      : e.isLeafNode() || e.isEmpty()
      ? 1
      : e === hf
      ? -1
      : 0;
  }
  withIndex(e) {
    if (e === Hp || this.indexMap_.hasIndex(e)) return this;
    {
      const t = this.indexMap_.addIndex(e, this.children_);
      return new uf(this.children_, this.priorityNode_, t);
    }
  }
  isIndexed(e) {
    return e === Hp || this.indexMap_.hasIndex(e);
  }
  equals(e) {
    if (e === this) return !0;
    if (e.isLeafNode()) return !1;
    {
      const t = e;
      if (this.getPriority().equals(t.getPriority())) {
        if (this.children_.count() === t.children_.count()) {
          const e = this.getIterator(tf),
            n = t.getIterator(tf);
          let i = e.getNext(),
            r = n.getNext();
          for (; i && r; ) {
            if (i.name !== r.name || !i.node.equals(r.node)) return !1;
            (i = e.getNext()), (r = n.getNext());
          }
          return null === i && null === r;
        }
        return !1;
      }
      return !1;
    }
  }
  resolveIndex_(e) {
    return e === Hp ? null : this.indexMap_.get(e.toString());
  }
}
uf.INTEGER_REGEXP_ = /^(0|[1-9]\d*)$/;
const hf = new (class extends uf {
  constructor() {
    super(new qp(Yp), uf.EMPTY_NODE, lf.Default);
  }
  compareTo(e) {
    return e === this ? 0 : 1;
  }
  equals(e) {
    return e === this;
  }
  getPriority() {
    return this;
  }
  getImmediateChild(e) {
    return uf.EMPTY_NODE;
  }
  isEmpty() {
    return !1;
  }
})();
Object.defineProperties(zp, {
  MIN: { value: new zp(Vd, uf.EMPTY_NODE) },
  MAX: { value: new zp(Hd, hf) },
}),
  (Vp.__EMPTY_NODE = uf.EMPTY_NODE),
  (ef.__childrenNodeConstructor = uf),
  (Xp = hf),
  (function (e) {
    Qp = e;
  })(hf);
function df(e, t = null) {
  if (null === e) return uf.EMPTY_NODE;
  if (
    ("object" == typeof e && ".priority" in e && (t = e[".priority"]),
    ph(
      null === t ||
        "string" == typeof t ||
        "number" == typeof t ||
        ("object" == typeof t && ".sv" in t),
      "Invalid priority type found: " + typeof t
    ),
    "object" == typeof e &&
      ".value" in e &&
      null !== e[".value"] &&
      (e = e[".value"]),
    "object" != typeof e || ".sv" in e)
  ) {
    return new ef(e, df(t));
  }
  if (e instanceof Array) {
    let n = uf.EMPTY_NODE;
    return (
      Xd(e, (t, i) => {
        if (Ph(e, t) && "." !== t.substring(0, 1)) {
          const e = df(i);
          (!e.isLeafNode() && e.isEmpty()) ||
            (n = n.updateImmediateChild(t, e));
        }
      }),
      n.updatePriority(df(t))
    );
  }
  {
    const n = [];
    let i = !1;
    if (
      (Xd(e, (e, t) => {
        if ("." !== e.substring(0, 1)) {
          const r = df(t);
          r.isEmpty() ||
            ((i = i || !r.getPriority().isEmpty()), n.push(new zp(e, r)));
        }
      }),
      0 === n.length)
    )
      return uf.EMPTY_NODE;
    const r = sf(n, jp, (e) => e.name, Yp);
    if (i) {
      const e = sf(n, tf.getCompare());
      return new uf(r, df(t), new lf({ ".priority": e }, { ".priority": tf }));
    }
    return new uf(r, df(t), lf.Default);
  }
}
!(function (e) {
  Jp = e;
})(df);
class pf extends Up {
  constructor(e) {
    super(),
      (this.indexPath_ = e),
      ph(
        !Pp(e) && ".priority" !== wp(e),
        "Can't create PathIndex with empty path or .priority key"
      );
  }
  extractChild(e) {
    return e.getChild(this.indexPath_);
  }
  isDefinedOn(e) {
    return !e.getChild(this.indexPath_).isEmpty();
  }
  compare(e, t) {
    const n = this.extractChild(e.node),
      i = this.extractChild(t.node),
      r = n.compareTo(i);
    return 0 === r ? Gd(e.name, t.name) : r;
  }
  makePost(e, t) {
    const n = df(e),
      i = uf.EMPTY_NODE.updateChild(this.indexPath_, n);
    return new zp(t, i);
  }
  maxPost() {
    const e = uf.EMPTY_NODE.updateChild(this.indexPath_, hf);
    return new zp(Hd, e);
  }
  toString() {
    return Cp(this.indexPath_, 0).join("/");
  }
}
const ff = new (class extends Up {
    compare(e, t) {
      const n = e.node.compareTo(t.node);
      return 0 === n ? Gd(e.name, t.name) : n;
    }
    isDefinedOn(e) {
      return !0;
    }
    indexedValueChanged(e, t) {
      return !e.equals(t);
    }
    minPost() {
      return zp.MIN;
    }
    maxPost() {
      return zp.MAX;
    }
    makePost(e, t) {
      const n = df(e);
      return new zp(t, n);
    }
    toString() {
      return ".value";
    }
  })(),
  mf = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz",
  gf = (function () {
    let e = 0;
    const t = [];
    return function (n) {
      const i = n === e;
      let r;
      e = n;
      const s = new Array(8);
      for (r = 7; r >= 0; r--)
        (s[r] = mf.charAt(n % 64)), (n = Math.floor(n / 64));
      ph(0 === n, "Cannot push at time == 0");
      let a = s.join("");
      if (i) {
        for (r = 11; r >= 0 && 63 === t[r]; r--) t[r] = 0;
        t[r]++;
      } else for (r = 0; r < 12; r++) t[r] = Math.floor(64 * Math.random());
      for (r = 0; r < 12; r++) a += mf.charAt(t[r]);
      return ph(20 === a.length, "nextPushId: Length should be 20."), a;
    };
  })();
function vf(e) {
  return { type: "value", snapshotNode: e };
}
function _f(e, t) {
  return { type: "child_added", snapshotNode: t, childName: e };
}
function yf(e, t) {
  return { type: "child_removed", snapshotNode: t, childName: e };
}
function xf(e, t, n) {
  return { type: "child_changed", snapshotNode: t, childName: e, oldSnap: n };
}
class bf {
  constructor(e) {
    this.index_ = e;
  }
  updateChild(e, t, n, i, r, s) {
    ph(
      e.isIndexed(this.index_),
      "A node must be indexed if only a child is updated"
    );
    const a = e.getImmediateChild(t);
    return a.getChild(i).equals(n.getChild(i)) && a.isEmpty() === n.isEmpty()
      ? e
      : (null != s &&
          (n.isEmpty()
            ? e.hasChild(t)
              ? s.trackChildChange(yf(t, a))
              : ph(
                  e.isLeafNode(),
                  "A child remove without an old child only makes sense on a leaf node"
                )
            : a.isEmpty()
            ? s.trackChildChange(_f(t, n))
            : s.trackChildChange(xf(t, n, a))),
        e.isLeafNode() && n.isEmpty()
          ? e
          : e.updateImmediateChild(t, n).withIndex(this.index_));
  }
  updateFullNode(e, t, n) {
    return (
      null != n &&
        (e.isLeafNode() ||
          e.forEachChild(tf, (e, i) => {
            t.hasChild(e) || n.trackChildChange(yf(e, i));
          }),
        t.isLeafNode() ||
          t.forEachChild(tf, (t, i) => {
            if (e.hasChild(t)) {
              const r = e.getImmediateChild(t);
              r.equals(i) || n.trackChildChange(xf(t, i, r));
            } else n.trackChildChange(_f(t, i));
          })),
      t.withIndex(this.index_)
    );
  }
  updatePriority(e, t) {
    return e.isEmpty() ? uf.EMPTY_NODE : e.updatePriority(t);
  }
  filtersNodes() {
    return !1;
  }
  getIndexedFilter() {
    return this;
  }
  getIndex() {
    return this.index_;
  }
}
class wf {
  constructor(e) {
    (this.indexedFilter_ = new bf(e.getIndex())),
      (this.index_ = e.getIndex()),
      (this.startPost_ = wf.getStartPost_(e)),
      (this.endPost_ = wf.getEndPost_(e));
  }
  getStartPost() {
    return this.startPost_;
  }
  getEndPost() {
    return this.endPost_;
  }
  matches(e) {
    return (
      this.index_.compare(this.getStartPost(), e) <= 0 &&
      this.index_.compare(e, this.getEndPost()) <= 0
    );
  }
  updateChild(e, t, n, i, r, s) {
    return (
      this.matches(new zp(t, n)) || (n = uf.EMPTY_NODE),
      this.indexedFilter_.updateChild(e, t, n, i, r, s)
    );
  }
  updateFullNode(e, t, n) {
    t.isLeafNode() && (t = uf.EMPTY_NODE);
    let i = t.withIndex(this.index_);
    i = i.updatePriority(uf.EMPTY_NODE);
    const r = this;
    return (
      t.forEachChild(tf, (e, t) => {
        r.matches(new zp(e, t)) ||
          (i = i.updateImmediateChild(e, uf.EMPTY_NODE));
      }),
      this.indexedFilter_.updateFullNode(e, i, n)
    );
  }
  updatePriority(e, t) {
    return e;
  }
  filtersNodes() {
    return !0;
  }
  getIndexedFilter() {
    return this.indexedFilter_;
  }
  getIndex() {
    return this.index_;
  }
  static getStartPost_(e) {
    if (e.hasStart()) {
      const t = e.getIndexStartName();
      return e.getIndex().makePost(e.getIndexStartValue(), t);
    }
    return e.getIndex().minPost();
  }
  static getEndPost_(e) {
    if (e.hasEnd()) {
      const t = e.getIndexEndName();
      return e.getIndex().makePost(e.getIndexEndValue(), t);
    }
    return e.getIndex().maxPost();
  }
}
class Sf {
  constructor(e) {
    (this.rangedFilter_ = new wf(e)),
      (this.index_ = e.getIndex()),
      (this.limit_ = e.getLimit()),
      (this.reverse_ = !e.isViewFromLeft());
  }
  updateChild(e, t, n, i, r, s) {
    return (
      this.rangedFilter_.matches(new zp(t, n)) || (n = uf.EMPTY_NODE),
      e.getImmediateChild(t).equals(n)
        ? e
        : e.numChildren() < this.limit_
        ? this.rangedFilter_.getIndexedFilter().updateChild(e, t, n, i, r, s)
        : this.fullLimitUpdateChild_(e, t, n, r, s)
    );
  }
  updateFullNode(e, t, n) {
    let i;
    if (t.isLeafNode() || t.isEmpty()) i = uf.EMPTY_NODE.withIndex(this.index_);
    else if (2 * this.limit_ < t.numChildren() && t.isIndexed(this.index_)) {
      let e;
      (i = uf.EMPTY_NODE.withIndex(this.index_)),
        (e = this.reverse_
          ? t.getReverseIteratorFrom(
              this.rangedFilter_.getEndPost(),
              this.index_
            )
          : t.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_));
      let n = 0;
      for (; e.hasNext() && n < this.limit_; ) {
        const t = e.getNext();
        let r;
        if (
          ((r = this.reverse_
            ? this.index_.compare(this.rangedFilter_.getStartPost(), t) <= 0
            : this.index_.compare(t, this.rangedFilter_.getEndPost()) <= 0),
          !r)
        )
          break;
        (i = i.updateImmediateChild(t.name, t.node)), n++;
      }
    } else {
      let e, n, r, s;
      if (
        ((i = t.withIndex(this.index_)),
        (i = i.updatePriority(uf.EMPTY_NODE)),
        this.reverse_)
      ) {
        (s = i.getReverseIterator(this.index_)),
          (e = this.rangedFilter_.getEndPost()),
          (n = this.rangedFilter_.getStartPost());
        const t = this.index_.getCompare();
        r = (e, n) => t(n, e);
      } else
        (s = i.getIterator(this.index_)),
          (e = this.rangedFilter_.getStartPost()),
          (n = this.rangedFilter_.getEndPost()),
          (r = this.index_.getCompare());
      let a = 0,
        o = !1;
      for (; s.hasNext(); ) {
        const t = s.getNext();
        !o && r(e, t) <= 0 && (o = !0);
        o && a < this.limit_ && r(t, n) <= 0
          ? a++
          : (i = i.updateImmediateChild(t.name, uf.EMPTY_NODE));
      }
    }
    return this.rangedFilter_.getIndexedFilter().updateFullNode(e, i, n);
  }
  updatePriority(e, t) {
    return e;
  }
  filtersNodes() {
    return !0;
  }
  getIndexedFilter() {
    return this.rangedFilter_.getIndexedFilter();
  }
  getIndex() {
    return this.index_;
  }
  fullLimitUpdateChild_(e, t, n, i, r) {
    let s;
    if (this.reverse_) {
      const e = this.index_.getCompare();
      s = (t, n) => e(n, t);
    } else s = this.index_.getCompare();
    const a = e;
    ph(a.numChildren() === this.limit_, "");
    const o = new zp(t, n),
      l = this.reverse_
        ? a.getFirstChild(this.index_)
        : a.getLastChild(this.index_),
      c = this.rangedFilter_.matches(o);
    if (a.hasChild(t)) {
      const e = a.getImmediateChild(t);
      let u = i.getChildAfterChild(this.index_, l, this.reverse_);
      for (; null != u && (u.name === t || a.hasChild(u.name)); )
        u = i.getChildAfterChild(this.index_, u, this.reverse_);
      const h = null == u ? 1 : s(u, o);
      if (c && !n.isEmpty() && h >= 0)
        return (
          null != r && r.trackChildChange(xf(t, n, e)),
          a.updateImmediateChild(t, n)
        );
      {
        null != r && r.trackChildChange(yf(t, e));
        const n = a.updateImmediateChild(t, uf.EMPTY_NODE);
        return null != u && this.rangedFilter_.matches(u)
          ? (null != r && r.trackChildChange(_f(u.name, u.node)),
            n.updateImmediateChild(u.name, u.node))
          : n;
      }
    }
    return n.isEmpty()
      ? e
      : c && s(l, o) >= 0
      ? (null != r &&
          (r.trackChildChange(yf(l.name, l.node)),
          r.trackChildChange(_f(t, n))),
        a
          .updateImmediateChild(t, n)
          .updateImmediateChild(l.name, uf.EMPTY_NODE))
      : e;
  }
}
class Mf {
  constructor() {
    (this.limitSet_ = !1),
      (this.startSet_ = !1),
      (this.startNameSet_ = !1),
      (this.startAfterSet_ = !1),
      (this.endSet_ = !1),
      (this.endNameSet_ = !1),
      (this.endBeforeSet_ = !1),
      (this.limit_ = 0),
      (this.viewFrom_ = ""),
      (this.indexStartValue_ = null),
      (this.indexStartName_ = ""),
      (this.indexEndValue_ = null),
      (this.indexEndName_ = ""),
      (this.index_ = tf);
  }
  hasStart() {
    return this.startSet_;
  }
  hasStartAfter() {
    return this.startAfterSet_;
  }
  hasEndBefore() {
    return this.endBeforeSet_;
  }
  isViewFromLeft() {
    return "" === this.viewFrom_ ? this.startSet_ : "l" === this.viewFrom_;
  }
  getIndexStartValue() {
    return (
      ph(this.startSet_, "Only valid if start has been set"),
      this.indexStartValue_
    );
  }
  getIndexStartName() {
    return (
      ph(this.startSet_, "Only valid if start has been set"),
      this.startNameSet_ ? this.indexStartName_ : Vd
    );
  }
  hasEnd() {
    return this.endSet_;
  }
  getIndexEndValue() {
    return (
      ph(this.endSet_, "Only valid if end has been set"), this.indexEndValue_
    );
  }
  getIndexEndName() {
    return (
      ph(this.endSet_, "Only valid if end has been set"),
      this.endNameSet_ ? this.indexEndName_ : Hd
    );
  }
  hasLimit() {
    return this.limitSet_;
  }
  hasAnchoredLimit() {
    return this.limitSet_ && "" !== this.viewFrom_;
  }
  getLimit() {
    return ph(this.limitSet_, "Only valid if limit has been set"), this.limit_;
  }
  getIndex() {
    return this.index_;
  }
  loadsAllData() {
    return !(this.startSet_ || this.endSet_ || this.limitSet_);
  }
  isDefault() {
    return this.loadsAllData() && this.index_ === tf;
  }
  copy() {
    const e = new Mf();
    return (
      (e.limitSet_ = this.limitSet_),
      (e.limit_ = this.limit_),
      (e.startSet_ = this.startSet_),
      (e.indexStartValue_ = this.indexStartValue_),
      (e.startNameSet_ = this.startNameSet_),
      (e.indexStartName_ = this.indexStartName_),
      (e.endSet_ = this.endSet_),
      (e.indexEndValue_ = this.indexEndValue_),
      (e.endNameSet_ = this.endNameSet_),
      (e.indexEndName_ = this.indexEndName_),
      (e.index_ = this.index_),
      (e.viewFrom_ = this.viewFrom_),
      e
    );
  }
}
function Tf(e) {
  const t = {};
  if (e.isDefault()) return t;
  let n;
  return (
    e.index_ === tf
      ? (n = "$priority")
      : e.index_ === ff
      ? (n = "$value")
      : e.index_ === Hp
      ? (n = "$key")
      : (ph(e.index_ instanceof pf, "Unrecognized index type!"),
        (n = e.index_.toString())),
    (t.orderBy = Eh(n)),
    e.startSet_ &&
      ((t.startAt = Eh(e.indexStartValue_)),
      e.startNameSet_ && (t.startAt += "," + Eh(e.indexStartName_))),
    e.endSet_ &&
      ((t.endAt = Eh(e.indexEndValue_)),
      e.endNameSet_ && (t.endAt += "," + Eh(e.indexEndName_))),
    e.limitSet_ &&
      (e.isViewFromLeft()
        ? (t.limitToFirst = e.limit_)
        : (t.limitToLast = e.limit_)),
    t
  );
}
function Cf(e) {
  const t = {};
  if (
    (e.startSet_ &&
      ((t.sp = e.indexStartValue_),
      e.startNameSet_ && (t.sn = e.indexStartName_)),
    e.endSet_ &&
      ((t.ep = e.indexEndValue_), e.endNameSet_ && (t.en = e.indexEndName_)),
    e.limitSet_)
  ) {
    t.l = e.limit_;
    let n = e.viewFrom_;
    "" === n && (n = e.isViewFromLeft() ? "l" : "r"), (t.vf = n);
  }
  return e.index_ !== tf && (t.i = e.index_.toString()), t;
}
class Ef extends vp {
  constructor(e, t, n, i) {
    super(),
      (this.repoInfo_ = e),
      (this.onDataUpdate_ = t),
      (this.authTokenProvider_ = n),
      (this.appCheckTokenProvider_ = i),
      (this.log_ = Od("p:rest:")),
      (this.listens_ = {});
  }
  reportStats(e) {
    throw new Error("Method not implemented.");
  }
  static getListenId_(e, t) {
    return void 0 !== t
      ? "tag$" + t
      : (ph(
          e._queryParams.isDefault(),
          "should have a tag if it's not a default query."
        ),
        e._path.toString());
  }
  listen(e, t, n, i) {
    const r = e._path.toString();
    this.log_("Listen called for " + r + " " + e._queryIdentifier);
    const s = Ef.getListenId_(e, n),
      a = {};
    this.listens_[s] = a;
    const o = Tf(e._queryParams);
    this.restRequest_(r + ".json", o, (e, t) => {
      let o = t;
      if (
        (404 === e && ((o = null), (e = null)),
        null === e && this.onDataUpdate_(r, o, !1, n),
        Lh(this.listens_, s) === a)
      ) {
        let t;
        (t = e ? (401 === e ? "permission_denied" : "rest_error:" + e) : "ok"),
          i(t, null);
      }
    });
  }
  unlisten(e, t) {
    const n = Ef.getListenId_(e, t);
    delete this.listens_[n];
  }
  get(e) {
    const t = Tf(e._queryParams),
      n = e._path.toString(),
      i = new xh();
    return (
      this.restRequest_(n + ".json", t, (e, t) => {
        let r = t;
        404 === e && ((r = null), (e = null)),
          null === e
            ? (this.onDataUpdate_(n, r, !1, null), i.resolve(r))
            : i.reject(new Error(r));
      }),
      i.promise
    );
  }
  refreshAuthToken(e) {}
  restRequest_(e, t = {}, n) {
    return (
      (t.format = "export"),
      Promise.all([
        this.authTokenProvider_.getToken(!1),
        this.appCheckTokenProvider_.getToken(!1),
      ]).then(([i, r]) => {
        i && i.accessToken && (t.auth = i.accessToken),
          r && r.token && (t.ac = r.token);
        const s =
          (this.repoInfo_.secure ? "https://" : "http://") +
          this.repoInfo_.host +
          e +
          "?ns=" +
          this.repoInfo_.namespace +
          (function (e) {
            const t = [];
            for (const [n, i] of Object.entries(e))
              Array.isArray(i)
                ? i.forEach((e) => {
                    t.push(encodeURIComponent(n) + "=" + encodeURIComponent(e));
                  })
                : t.push(encodeURIComponent(n) + "=" + encodeURIComponent(i));
            return t.length ? "&" + t.join("&") : "";
          })(t);
        this.log_("Sending REST request for " + s);
        const a = new XMLHttpRequest();
        (a.onreadystatechange = () => {
          if (n && 4 === a.readyState) {
            this.log_(
              "REST Response for " + s + " received. status:",
              a.status,
              "response:",
              a.responseText
            );
            let t = null;
            if (a.status >= 200 && a.status < 300) {
              try {
                t = Ch(a.responseText);
              } catch (e) {
                Ud(
                  "Failed to parse JSON response for " +
                    s +
                    ": " +
                    a.responseText
                );
              }
              n(null, t);
            } else
              401 !== a.status &&
                404 !== a.status &&
                Ud(
                  "Got unsuccessful REST response for " +
                    s +
                    " Status: " +
                    a.status
                ),
                n(a.status);
            n = null;
          }
        }),
          a.open("GET", s, !0),
          a.send();
      })
    );
  }
}
class Af {
  constructor() {
    this.rootNode_ = uf.EMPTY_NODE;
  }
  getNode(e) {
    return this.rootNode_.getChild(e);
  }
  updateSnapshot(e, t) {
    this.rootNode_ = this.rootNode_.updateChild(e, t);
  }
}
function Pf() {
  return { value: null, children: new Map() };
}
function Lf(e, t, n) {
  if (Pp(t)) (e.value = n), e.children.clear();
  else if (null !== e.value) e.value = e.value.updateChild(t, n);
  else {
    const i = wp(t);
    e.children.has(i) || e.children.set(i, Pf());
    Lf(e.children.get(i), (t = Mp(t)), n);
  }
}
function If(e, t, n) {
  null !== e.value
    ? n(t, e.value)
    : (function (e, t) {
        e.children.forEach((e, n) => {
          t(n, e);
        });
      })(e, (e, i) => {
        If(i, new xp(t.toString() + "/" + e), n);
      });
}
class Rf {
  constructor(e) {
    (this.collection_ = e), (this.last_ = null);
  }
  get() {
    const e = this.collection_.get(),
      t = Object.assign({}, e);
    return (
      this.last_ &&
        Xd(this.last_, (e, n) => {
          t[e] = t[e] - n;
        }),
      (this.last_ = e),
      t
    );
  }
}
class Df {
  constructor(e, t) {
    (this.server_ = t),
      (this.statsToReport_ = {}),
      (this.statsListener_ = new Rf(e));
    const n = 1e4 + 2e4 * Math.random();
    Qd(this.reportStats_.bind(this), Math.floor(n));
  }
  reportStats_() {
    const e = this.statsListener_.get(),
      t = {};
    let n = !1;
    Xd(e, (e, i) => {
      i > 0 && Ph(this.statsToReport_, e) && ((t[e] = i), (n = !0));
    }),
      n && this.server_.reportStats(t),
      Qd(this.reportStats_.bind(this), Math.floor(2 * Math.random() * 3e5));
  }
}
var kf, Nf;
function Of(e) {
  return { fromUser: !1, fromServer: !0, queryId: e, tagged: !0 };
}
((Nf = kf || (kf = {}))[(Nf.OVERWRITE = 0)] = "OVERWRITE"),
  (Nf[(Nf.MERGE = 1)] = "MERGE"),
  (Nf[(Nf.ACK_USER_WRITE = 2)] = "ACK_USER_WRITE"),
  (Nf[(Nf.LISTEN_COMPLETE = 3)] = "LISTEN_COMPLETE");
class Ff {
  constructor(e, t, n) {
    (this.path = e),
      (this.affectedTree = t),
      (this.revert = n),
      (this.type = kf.ACK_USER_WRITE),
      (this.source = {
        fromUser: !0,
        fromServer: !1,
        queryId: null,
        tagged: !1,
      });
  }
  operationForChild(e) {
    if (Pp(this.path)) {
      if (null != this.affectedTree.value)
        return (
          ph(
            this.affectedTree.children.isEmpty(),
            "affectedTree should not have overlapping affected paths."
          ),
          this
        );
      {
        const t = this.affectedTree.subtree(new xp(e));
        return new Ff(bp(), t, this.revert);
      }
    }
    return (
      ph(wp(this.path) === e, "operationForChild called for unrelated child."),
      new Ff(Mp(this.path), this.affectedTree, this.revert)
    );
  }
}
class zf {
  constructor(e, t) {
    (this.source = e), (this.path = t), (this.type = kf.LISTEN_COMPLETE);
  }
  operationForChild(e) {
    return Pp(this.path)
      ? new zf(this.source, bp())
      : new zf(this.source, Mp(this.path));
  }
}
class Uf {
  constructor(e, t, n) {
    (this.source = e),
      (this.path = t),
      (this.snap = n),
      (this.type = kf.OVERWRITE);
  }
  operationForChild(e) {
    return Pp(this.path)
      ? new Uf(this.source, bp(), this.snap.getImmediateChild(e))
      : new Uf(this.source, Mp(this.path), this.snap);
  }
}
class Bf {
  constructor(e, t, n) {
    (this.source = e),
      (this.path = t),
      (this.children = n),
      (this.type = kf.MERGE);
  }
  operationForChild(e) {
    if (Pp(this.path)) {
      const t = this.children.subtree(new xp(e));
      return t.isEmpty()
        ? null
        : t.value
        ? new Uf(this.source, bp(), t.value)
        : new Bf(this.source, bp(), t);
    }
    return (
      ph(
        wp(this.path) === e,
        "Can't get a merge for a child not on the path of the operation"
      ),
      new Bf(this.source, Mp(this.path), this.children)
    );
  }
  toString() {
    return (
      "Operation(" +
      this.path +
      ": " +
      this.source.toString() +
      " merge: " +
      this.children.toString() +
      ")"
    );
  }
}
class Vf {
  constructor(e, t, n) {
    (this.node_ = e), (this.fullyInitialized_ = t), (this.filtered_ = n);
  }
  isFullyInitialized() {
    return this.fullyInitialized_;
  }
  isFiltered() {
    return this.filtered_;
  }
  isCompleteForPath(e) {
    if (Pp(e)) return this.isFullyInitialized() && !this.filtered_;
    const t = wp(e);
    return this.isCompleteForChild(t);
  }
  isCompleteForChild(e) {
    return (
      (this.isFullyInitialized() && !this.filtered_) || this.node_.hasChild(e)
    );
  }
  getNode() {
    return this.node_;
  }
}
class Hf {
  constructor(e) {
    (this.query_ = e), (this.index_ = this.query_._queryParams.getIndex());
  }
}
function Gf(e, t, n, i, r, s) {
  const a = i.filter((e) => e.type === n);
  a.sort((t, n) =>
    (function (e, t, n) {
      if (null == t.childName || null == n.childName)
        throw fh("Should only compare child_ events.");
      const i = new zp(t.childName, t.snapshotNode),
        r = new zp(n.childName, n.snapshotNode);
      return e.index_.compare(i, r);
    })(e, t, n)
  ),
    a.forEach((n) => {
      const i = (function (e, t, n) {
        return (
          "value" === t.type ||
            "child_removed" === t.type ||
            (t.prevName = n.getPredecessorChildName(
              t.childName,
              t.snapshotNode,
              e.index_
            )),
          t
        );
      })(e, n, s);
      r.forEach((r) => {
        r.respondsTo(n.type) && t.push(r.createEvent(i, e.query_));
      });
    });
}
function Wf(e, t) {
  return { eventCache: e, serverCache: t };
}
function qf(e, t, n, i) {
  return Wf(new Vf(t, n, i), e.serverCache);
}
function jf(e, t, n, i) {
  return Wf(e.eventCache, new Vf(t, n, i));
}
function Yf(e) {
  return e.eventCache.isFullyInitialized() ? e.eventCache.getNode() : null;
}
function Xf(e) {
  return e.serverCache.isFullyInitialized() ? e.serverCache.getNode() : null;
}
let $f;
class Zf {
  constructor(e, t = (() => ($f || ($f = new qp(Wd)), $f))()) {
    (this.value = e), (this.children = t);
  }
  static fromObject(e) {
    let t = new Zf(null);
    return (
      Xd(e, (e, n) => {
        t = t.set(new xp(e), n);
      }),
      t
    );
  }
  isEmpty() {
    return null === this.value && this.children.isEmpty();
  }
  findRootMostMatchingPathAndValue(e, t) {
    if (null != this.value && t(this.value))
      return { path: bp(), value: this.value };
    if (Pp(e)) return null;
    {
      const n = wp(e),
        i = this.children.get(n);
      if (null !== i) {
        const r = i.findRootMostMatchingPathAndValue(Mp(e), t);
        if (null != r) {
          return { path: Ap(new xp(n), r.path), value: r.value };
        }
        return null;
      }
      return null;
    }
  }
  findRootMostValueAndPath(e) {
    return this.findRootMostMatchingPathAndValue(e, () => !0);
  }
  subtree(e) {
    if (Pp(e)) return this;
    {
      const t = wp(e),
        n = this.children.get(t);
      return null !== n ? n.subtree(Mp(e)) : new Zf(null);
    }
  }
  set(e, t) {
    if (Pp(e)) return new Zf(t, this.children);
    {
      const n = wp(e),
        i = (this.children.get(n) || new Zf(null)).set(Mp(e), t),
        r = this.children.insert(n, i);
      return new Zf(this.value, r);
    }
  }
  remove(e) {
    if (Pp(e))
      return this.children.isEmpty()
        ? new Zf(null)
        : new Zf(null, this.children);
    {
      const t = wp(e),
        n = this.children.get(t);
      if (n) {
        const i = n.remove(Mp(e));
        let r;
        return (
          (r = i.isEmpty()
            ? this.children.remove(t)
            : this.children.insert(t, i)),
          null === this.value && r.isEmpty()
            ? new Zf(null)
            : new Zf(this.value, r)
        );
      }
      return this;
    }
  }
  get(e) {
    if (Pp(e)) return this.value;
    {
      const t = wp(e),
        n = this.children.get(t);
      return n ? n.get(Mp(e)) : null;
    }
  }
  setTree(e, t) {
    if (Pp(e)) return t;
    {
      const n = wp(e),
        i = (this.children.get(n) || new Zf(null)).setTree(Mp(e), t);
      let r;
      return (
        (r = i.isEmpty()
          ? this.children.remove(n)
          : this.children.insert(n, i)),
        new Zf(this.value, r)
      );
    }
  }
  fold(e) {
    return this.fold_(bp(), e);
  }
  fold_(e, t) {
    const n = {};
    return (
      this.children.inorderTraversal((i, r) => {
        n[i] = r.fold_(Ap(e, i), t);
      }),
      t(e, this.value, n)
    );
  }
  findOnPath(e, t) {
    return this.findOnPath_(e, bp(), t);
  }
  findOnPath_(e, t, n) {
    const i = !!this.value && n(t, this.value);
    if (i) return i;
    if (Pp(e)) return null;
    {
      const i = wp(e),
        r = this.children.get(i);
      return r ? r.findOnPath_(Mp(e), Ap(t, i), n) : null;
    }
  }
  foreachOnPath(e, t) {
    return this.foreachOnPath_(e, bp(), t);
  }
  foreachOnPath_(e, t, n) {
    if (Pp(e)) return this;
    {
      this.value && n(t, this.value);
      const i = wp(e),
        r = this.children.get(i);
      return r ? r.foreachOnPath_(Mp(e), Ap(t, i), n) : new Zf(null);
    }
  }
  foreach(e) {
    this.foreach_(bp(), e);
  }
  foreach_(e, t) {
    this.children.inorderTraversal((n, i) => {
      i.foreach_(Ap(e, n), t);
    }),
      this.value && t(e, this.value);
  }
  foreachChild(e) {
    this.children.inorderTraversal((t, n) => {
      n.value && e(t, n.value);
    });
  }
}
class Kf {
  constructor(e) {
    this.writeTree_ = e;
  }
  static empty() {
    return new Kf(new Zf(null));
  }
}
function Jf(e, t, n) {
  if (Pp(t)) return new Kf(new Zf(n));
  {
    const i = e.writeTree_.findRootMostValueAndPath(t);
    if (null != i) {
      const r = i.path;
      let s = i.value;
      const a = Lp(r, t);
      return (s = s.updateChild(a, n)), new Kf(e.writeTree_.set(r, s));
    }
    {
      const i = new Zf(n),
        r = e.writeTree_.setTree(t, i);
      return new Kf(r);
    }
  }
}
function Qf(e, t, n) {
  let i = e;
  return (
    Xd(n, (e, n) => {
      i = Jf(i, Ap(t, e), n);
    }),
    i
  );
}
function em(e, t) {
  if (Pp(t)) return Kf.empty();
  {
    const n = e.writeTree_.setTree(t, new Zf(null));
    return new Kf(n);
  }
}
function tm(e, t) {
  return null != nm(e, t);
}
function nm(e, t) {
  const n = e.writeTree_.findRootMostValueAndPath(t);
  return null != n ? e.writeTree_.get(n.path).getChild(Lp(n.path, t)) : null;
}
function im(e) {
  const t = [],
    n = e.writeTree_.value;
  return (
    null != n
      ? n.isLeafNode() ||
        n.forEachChild(tf, (e, n) => {
          t.push(new zp(e, n));
        })
      : e.writeTree_.children.inorderTraversal((e, n) => {
          null != n.value && t.push(new zp(e, n.value));
        }),
    t
  );
}
function rm(e, t) {
  if (Pp(t)) return e;
  {
    const n = nm(e, t);
    return new Kf(null != n ? new Zf(n) : e.writeTree_.subtree(t));
  }
}
function sm(e) {
  return e.writeTree_.isEmpty();
}
function am(e, t) {
  return om(bp(), e.writeTree_, t);
}
function om(e, t, n) {
  if (null != t.value) return n.updateChild(e, t.value);
  {
    let i = null;
    return (
      t.children.inorderTraversal((t, r) => {
        ".priority" === t
          ? (ph(null !== r.value, "Priority writes must always be leaf nodes"),
            (i = r.value))
          : (n = om(Ap(e, t), r, n));
      }),
      n.getChild(e).isEmpty() ||
        null === i ||
        (n = n.updateChild(Ap(e, ".priority"), i)),
      n
    );
  }
}
function lm(e, t) {
  return bm(t, e);
}
function cm(e, t) {
  const n = e.allWrites.findIndex((e) => e.writeId === t);
  ph(n >= 0, "removeWrite called with nonexistent writeId.");
  const i = e.allWrites[n];
  e.allWrites.splice(n, 1);
  let r = i.visible,
    s = !1,
    a = e.allWrites.length - 1;
  for (; r && a >= 0; ) {
    const t = e.allWrites[a];
    t.visible &&
      (a >= n && um(t, i.path) ? (r = !1) : Rp(i.path, t.path) && (s = !0)),
      a--;
  }
  if (r) {
    if (s)
      return (
        (function (e) {
          (e.visibleWrites = dm(e.allWrites, hm, bp())),
            e.allWrites.length > 0
              ? (e.lastWriteId = e.allWrites[e.allWrites.length - 1].writeId)
              : (e.lastWriteId = -1);
        })(e),
        !0
      );
    if (i.snap) e.visibleWrites = em(e.visibleWrites, i.path);
    else {
      Xd(i.children, (t) => {
        e.visibleWrites = em(e.visibleWrites, Ap(i.path, t));
      });
    }
    return !0;
  }
  return !1;
}
function um(e, t) {
  if (e.snap) return Rp(e.path, t);
  for (const n in e.children)
    if (e.children.hasOwnProperty(n) && Rp(Ap(e.path, n), t)) return !0;
  return !1;
}
function hm(e) {
  return e.visible;
}
function dm(e, t, n) {
  let i = Kf.empty();
  for (let r = 0; r < e.length; ++r) {
    const s = e[r];
    if (t(s)) {
      const e = s.path;
      let t;
      if (s.snap)
        Rp(n, e)
          ? ((t = Lp(n, e)), (i = Jf(i, t, s.snap)))
          : Rp(e, n) && ((t = Lp(e, n)), (i = Jf(i, bp(), s.snap.getChild(t))));
      else {
        if (!s.children) throw fh("WriteRecord should have .snap or .children");
        if (Rp(n, e)) (t = Lp(n, e)), (i = Qf(i, t, s.children));
        else if (Rp(e, n))
          if (((t = Lp(e, n)), Pp(t))) i = Qf(i, bp(), s.children);
          else {
            const e = Lh(s.children, wp(t));
            if (e) {
              const n = e.getChild(Mp(t));
              i = Jf(i, bp(), n);
            }
          }
      }
    }
  }
  return i;
}
function pm(e, t, n, i, r) {
  if (i || r) {
    const s = rm(e.visibleWrites, t);
    if (!r && sm(s)) return n;
    if (r || null != n || tm(s, bp())) {
      const s = function (e) {
        return (
          (e.visible || r) &&
          (!i || !~i.indexOf(e.writeId)) &&
          (Rp(e.path, t) || Rp(t, e.path))
        );
      };
      return am(dm(e.allWrites, s, t), n || uf.EMPTY_NODE);
    }
    return null;
  }
  {
    const i = nm(e.visibleWrites, t);
    if (null != i) return i;
    {
      const i = rm(e.visibleWrites, t);
      if (sm(i)) return n;
      if (null != n || tm(i, bp())) {
        return am(i, n || uf.EMPTY_NODE);
      }
      return null;
    }
  }
}
function fm(e, t, n, i) {
  return pm(e.writeTree, e.treePath, t, n, i);
}
function mm(e, t) {
  return (function (e, t, n) {
    let i = uf.EMPTY_NODE;
    const r = nm(e.visibleWrites, t);
    if (r)
      return (
        r.isLeafNode() ||
          r.forEachChild(tf, (e, t) => {
            i = i.updateImmediateChild(e, t);
          }),
        i
      );
    if (n) {
      const r = rm(e.visibleWrites, t);
      return (
        n.forEachChild(tf, (e, t) => {
          const n = am(rm(r, new xp(e)), t);
          i = i.updateImmediateChild(e, n);
        }),
        im(r).forEach((e) => {
          i = i.updateImmediateChild(e.name, e.node);
        }),
        i
      );
    }
    return (
      im(rm(e.visibleWrites, t)).forEach((e) => {
        i = i.updateImmediateChild(e.name, e.node);
      }),
      i
    );
  })(e.writeTree, e.treePath, t);
}
function gm(e, t, n, i) {
  return (function (e, t, n, i, r) {
    ph(i || r, "Either existingEventSnap or existingServerSnap must exist");
    const s = Ap(t, n);
    if (tm(e.visibleWrites, s)) return null;
    {
      const t = rm(e.visibleWrites, s);
      return sm(t) ? r.getChild(n) : am(t, r.getChild(n));
    }
  })(e.writeTree, e.treePath, t, n, i);
}
function vm(e, t) {
  return (function (e, t) {
    return nm(e.visibleWrites, t);
  })(e.writeTree, Ap(e.treePath, t));
}
function _m(e, t, n, i, r, s) {
  return (function (e, t, n, i, r, s, a) {
    let o;
    const l = rm(e.visibleWrites, t),
      c = nm(l, bp());
    if (null != c) o = c;
    else {
      if (null == n) return [];
      o = am(l, n);
    }
    if (((o = o.withIndex(a)), o.isEmpty() || o.isLeafNode())) return [];
    {
      const e = [],
        t = a.getCompare(),
        n = s ? o.getReverseIteratorFrom(i, a) : o.getIteratorFrom(i, a);
      let l = n.getNext();
      for (; l && e.length < r; ) 0 !== t(l, i) && e.push(l), (l = n.getNext());
      return e;
    }
  })(e.writeTree, e.treePath, t, n, i, r, s);
}
function ym(e, t, n) {
  return (function (e, t, n, i) {
    const r = Ap(t, n),
      s = nm(e.visibleWrites, r);
    if (null != s) return s;
    if (i.isCompleteForChild(n))
      return am(rm(e.visibleWrites, r), i.getNode().getImmediateChild(n));
    return null;
  })(e.writeTree, e.treePath, t, n);
}
function xm(e, t) {
  return bm(Ap(e.treePath, t), e.writeTree);
}
function bm(e, t) {
  return { treePath: e, writeTree: t };
}
class wm {
  constructor() {
    this.changeMap = new Map();
  }
  trackChildChange(e) {
    const t = e.type,
      n = e.childName;
    ph(
      "child_added" === t || "child_changed" === t || "child_removed" === t,
      "Only child changes supported for tracking"
    ),
      ph(".priority" !== n, "Only non-priority child changes can be tracked.");
    const i = this.changeMap.get(n);
    if (i) {
      const r = i.type;
      if ("child_added" === t && "child_removed" === r)
        this.changeMap.set(n, xf(n, e.snapshotNode, i.snapshotNode));
      else if ("child_removed" === t && "child_added" === r)
        this.changeMap.delete(n);
      else if ("child_removed" === t && "child_changed" === r)
        this.changeMap.set(n, yf(n, i.oldSnap));
      else if ("child_changed" === t && "child_added" === r)
        this.changeMap.set(n, _f(n, e.snapshotNode));
      else {
        if ("child_changed" !== t || "child_changed" !== r)
          throw fh(
            "Illegal combination of changes: " + e + " occurred after " + i
          );
        this.changeMap.set(n, xf(n, e.snapshotNode, i.oldSnap));
      }
    } else this.changeMap.set(n, e);
  }
  getChanges() {
    return Array.from(this.changeMap.values());
  }
}
const Sm = new (class {
  getCompleteChild(e) {
    return null;
  }
  getChildAfterChild(e, t, n) {
    return null;
  }
})();
class Mm {
  constructor(e, t, n = null) {
    (this.writes_ = e),
      (this.viewCache_ = t),
      (this.optCompleteServerCache_ = n);
  }
  getCompleteChild(e) {
    const t = this.viewCache_.eventCache;
    if (t.isCompleteForChild(e)) return t.getNode().getImmediateChild(e);
    {
      const t =
        null != this.optCompleteServerCache_
          ? new Vf(this.optCompleteServerCache_, !0, !1)
          : this.viewCache_.serverCache;
      return ym(this.writes_, e, t);
    }
  }
  getChildAfterChild(e, t, n) {
    const i =
        null != this.optCompleteServerCache_
          ? this.optCompleteServerCache_
          : Xf(this.viewCache_),
      r = _m(this.writes_, i, t, 1, n, e);
    return 0 === r.length ? null : r[0];
  }
}
function Tm(e, t, n, i, r) {
  const s = new wm();
  let a, o;
  if (n.type === kf.OVERWRITE) {
    const l = n;
    l.source.fromUser
      ? (a = Am(e, t, l.path, l.snap, i, r, s))
      : (ph(l.source.fromServer, "Unknown source."),
        (o = l.source.tagged || (t.serverCache.isFiltered() && !Pp(l.path))),
        (a = Em(e, t, l.path, l.snap, i, r, o, s)));
  } else if (n.type === kf.MERGE) {
    const l = n;
    l.source.fromUser
      ? (a = (function (e, t, n, i, r, s, a) {
          let o = t;
          return (
            i.foreach((i, l) => {
              const c = Ap(n, i);
              Pm(t, wp(c)) && (o = Am(e, o, c, l, r, s, a));
            }),
            i.foreach((i, l) => {
              const c = Ap(n, i);
              Pm(t, wp(c)) || (o = Am(e, o, c, l, r, s, a));
            }),
            o
          );
        })(e, t, l.path, l.children, i, r, s))
      : (ph(l.source.fromServer, "Unknown source."),
        (o = l.source.tagged || t.serverCache.isFiltered()),
        (a = Im(e, t, l.path, l.children, i, r, o, s)));
  } else if (n.type === kf.ACK_USER_WRITE) {
    const o = n;
    a = o.revert
      ? (function (e, t, n, i, r, s) {
          let a;
          if (null != vm(i, n)) return t;
          {
            const o = new Mm(i, t, r),
              l = t.eventCache.getNode();
            let c;
            if (Pp(n) || ".priority" === wp(n)) {
              let n;
              if (t.serverCache.isFullyInitialized()) n = fm(i, Xf(t));
              else {
                const e = t.serverCache.getNode();
                ph(
                  e instanceof uf,
                  "serverChildren would be complete if leaf node"
                ),
                  (n = mm(i, e));
              }
              (n = n), (c = e.filter.updateFullNode(l, n, s));
            } else {
              const r = wp(n);
              let u = ym(i, r, t.serverCache);
              null == u &&
                t.serverCache.isCompleteForChild(r) &&
                (u = l.getImmediateChild(r)),
                (c =
                  null != u
                    ? e.filter.updateChild(l, r, u, Mp(n), o, s)
                    : t.eventCache.getNode().hasChild(r)
                    ? e.filter.updateChild(l, r, uf.EMPTY_NODE, Mp(n), o, s)
                    : l),
                c.isEmpty() &&
                  t.serverCache.isFullyInitialized() &&
                  ((a = fm(i, Xf(t))),
                  a.isLeafNode() && (c = e.filter.updateFullNode(c, a, s)));
            }
            return (
              (a = t.serverCache.isFullyInitialized() || null != vm(i, bp())),
              qf(t, c, a, e.filter.filtersNodes())
            );
          }
        })(e, t, o.path, i, r, s)
      : (function (e, t, n, i, r, s, a) {
          if (null != vm(r, n)) return t;
          const o = t.serverCache.isFiltered(),
            l = t.serverCache;
          if (null != i.value) {
            if ((Pp(n) && l.isFullyInitialized()) || l.isCompleteForPath(n))
              return Em(e, t, n, l.getNode().getChild(n), r, s, o, a);
            if (Pp(n)) {
              let i = new Zf(null);
              return (
                l.getNode().forEachChild(Hp, (e, t) => {
                  i = i.set(new xp(e), t);
                }),
                Im(e, t, n, i, r, s, o, a)
              );
            }
            return t;
          }
          {
            let c = new Zf(null);
            return (
              i.foreach((e, t) => {
                const i = Ap(n, e);
                l.isCompleteForPath(i) &&
                  (c = c.set(e, l.getNode().getChild(i)));
              }),
              Im(e, t, n, c, r, s, o, a)
            );
          }
        })(e, t, o.path, o.affectedTree, i, r, s);
  } else {
    if (n.type !== kf.LISTEN_COMPLETE)
      throw fh("Unknown operation type: " + n.type);
    a = (function (e, t, n, i, r) {
      const s = t.serverCache,
        a = jf(t, s.getNode(), s.isFullyInitialized() || Pp(n), s.isFiltered());
      return Cm(e, a, n, i, Sm, r);
    })(e, t, n.path, i, s);
  }
  const l = s.getChanges();
  return (
    (function (e, t, n) {
      const i = t.eventCache;
      if (i.isFullyInitialized()) {
        const r = i.getNode().isLeafNode() || i.getNode().isEmpty(),
          s = Yf(e);
        (n.length > 0 ||
          !e.eventCache.isFullyInitialized() ||
          (r && !i.getNode().equals(s)) ||
          !i.getNode().getPriority().equals(s.getPriority())) &&
          n.push(vf(Yf(t)));
      }
    })(t, a, l),
    { viewCache: a, changes: l }
  );
}
function Cm(e, t, n, i, r, s) {
  const a = t.eventCache;
  if (null != vm(i, n)) return t;
  {
    let o, l;
    if (Pp(n))
      if (
        (ph(
          t.serverCache.isFullyInitialized(),
          "If change path is empty, we must have complete server data"
        ),
        t.serverCache.isFiltered())
      ) {
        const n = Xf(t),
          r = mm(i, n instanceof uf ? n : uf.EMPTY_NODE);
        o = e.filter.updateFullNode(t.eventCache.getNode(), r, s);
      } else {
        const n = fm(i, Xf(t));
        o = e.filter.updateFullNode(t.eventCache.getNode(), n, s);
      }
    else {
      const c = wp(n);
      if (".priority" === c) {
        ph(
          1 === Sp(n),
          "Can't have a priority with additional path components"
        );
        const r = a.getNode();
        l = t.serverCache.getNode();
        const s = gm(i, n, r, l);
        o = null != s ? e.filter.updatePriority(r, s) : a.getNode();
      } else {
        const u = Mp(n);
        let h;
        if (a.isCompleteForChild(c)) {
          l = t.serverCache.getNode();
          const e = gm(i, n, a.getNode(), l);
          h =
            null != e
              ? a.getNode().getImmediateChild(c).updateChild(u, e)
              : a.getNode().getImmediateChild(c);
        } else h = ym(i, c, t.serverCache);
        o =
          null != h
            ? e.filter.updateChild(a.getNode(), c, h, u, r, s)
            : a.getNode();
      }
    }
    return qf(t, o, a.isFullyInitialized() || Pp(n), e.filter.filtersNodes());
  }
}
function Em(e, t, n, i, r, s, a, o) {
  const l = t.serverCache;
  let c;
  const u = a ? e.filter : e.filter.getIndexedFilter();
  if (Pp(n)) c = u.updateFullNode(l.getNode(), i, null);
  else if (u.filtersNodes() && !l.isFiltered()) {
    const e = l.getNode().updateChild(n, i);
    c = u.updateFullNode(l.getNode(), e, null);
  } else {
    const e = wp(n);
    if (!l.isCompleteForPath(n) && Sp(n) > 1) return t;
    const r = Mp(n),
      s = l.getNode().getImmediateChild(e).updateChild(r, i);
    c =
      ".priority" === e
        ? u.updatePriority(l.getNode(), s)
        : u.updateChild(l.getNode(), e, s, r, Sm, null);
  }
  const h = jf(t, c, l.isFullyInitialized() || Pp(n), u.filtersNodes());
  return Cm(e, h, n, r, new Mm(r, h, s), o);
}
function Am(e, t, n, i, r, s, a) {
  const o = t.eventCache;
  let l, c;
  const u = new Mm(r, t, s);
  if (Pp(n))
    (c = e.filter.updateFullNode(t.eventCache.getNode(), i, a)),
      (l = qf(t, c, !0, e.filter.filtersNodes()));
  else {
    const r = wp(n);
    if (".priority" === r)
      (c = e.filter.updatePriority(t.eventCache.getNode(), i)),
        (l = qf(t, c, o.isFullyInitialized(), o.isFiltered()));
    else {
      const s = Mp(n),
        c = o.getNode().getImmediateChild(r);
      let h;
      if (Pp(s)) h = i;
      else {
        const e = u.getCompleteChild(r);
        h =
          null != e
            ? ".priority" === Tp(s) && e.getChild(Ep(s)).isEmpty()
              ? e
              : e.updateChild(s, i)
            : uf.EMPTY_NODE;
      }
      if (c.equals(h)) l = t;
      else {
        l = qf(
          t,
          e.filter.updateChild(o.getNode(), r, h, s, u, a),
          o.isFullyInitialized(),
          e.filter.filtersNodes()
        );
      }
    }
  }
  return l;
}
function Pm(e, t) {
  return e.eventCache.isCompleteForChild(t);
}
function Lm(e, t, n) {
  return (
    n.foreach((e, n) => {
      t = t.updateChild(e, n);
    }),
    t
  );
}
function Im(e, t, n, i, r, s, a, o) {
  if (t.serverCache.getNode().isEmpty() && !t.serverCache.isFullyInitialized())
    return t;
  let l,
    c = t;
  l = Pp(n) ? i : new Zf(null).setTree(n, i);
  const u = t.serverCache.getNode();
  return (
    l.children.inorderTraversal((n, i) => {
      if (u.hasChild(n)) {
        const l = Lm(0, t.serverCache.getNode().getImmediateChild(n), i);
        c = Em(e, c, new xp(n), l, r, s, a, o);
      }
    }),
    l.children.inorderTraversal((n, i) => {
      const l = !t.serverCache.isCompleteForChild(n) && void 0 === i.value;
      if (!u.hasChild(n) && !l) {
        const l = Lm(0, t.serverCache.getNode().getImmediateChild(n), i);
        c = Em(e, c, new xp(n), l, r, s, a, o);
      }
    }),
    c
  );
}
class Rm {
  constructor(e, t) {
    (this.query_ = e), (this.eventRegistrations_ = []);
    const n = this.query_._queryParams,
      i = new bf(n.getIndex()),
      r = (s = n).loadsAllData()
        ? new bf(s.getIndex())
        : s.hasLimit()
        ? new Sf(s)
        : new wf(s);
    var s;
    this.processor_ = (function (e) {
      return { filter: e };
    })(r);
    const a = t.serverCache,
      o = t.eventCache,
      l = i.updateFullNode(uf.EMPTY_NODE, a.getNode(), null),
      c = r.updateFullNode(uf.EMPTY_NODE, o.getNode(), null),
      u = new Vf(l, a.isFullyInitialized(), i.filtersNodes()),
      h = new Vf(c, o.isFullyInitialized(), r.filtersNodes());
    (this.viewCache_ = Wf(h, u)), (this.eventGenerator_ = new Hf(this.query_));
  }
  get query() {
    return this.query_;
  }
}
function Dm(e, t) {
  const n = Xf(e.viewCache_);
  return n &&
    (e.query._queryParams.loadsAllData() ||
      (!Pp(t) && !n.getImmediateChild(wp(t)).isEmpty()))
    ? n.getChild(t)
    : null;
}
function km(e) {
  return 0 === e.eventRegistrations_.length;
}
function Nm(e, t, n) {
  const i = [];
  if (n) {
    ph(null == t, "A cancel should cancel all event registrations.");
    const r = e.query._path;
    e.eventRegistrations_.forEach((e) => {
      const t = e.createCancelEvent(n, r);
      t && i.push(t);
    });
  }
  if (t) {
    let n = [];
    for (let i = 0; i < e.eventRegistrations_.length; ++i) {
      const r = e.eventRegistrations_[i];
      if (r.matches(t)) {
        if (t.hasAnyCallback()) {
          n = n.concat(e.eventRegistrations_.slice(i + 1));
          break;
        }
      } else n.push(r);
    }
    e.eventRegistrations_ = n;
  } else e.eventRegistrations_ = [];
  return i;
}
function Om(e, t, n, i) {
  t.type === kf.MERGE &&
    null !== t.source.queryId &&
    (ph(
      Xf(e.viewCache_),
      "We should always have a full cache before handling merges"
    ),
    ph(
      Yf(e.viewCache_),
      "Missing event cache, even though we have a server cache"
    ));
  const r = e.viewCache_,
    s = Tm(e.processor_, r, t, n, i);
  var a, o;
  return (
    (a = e.processor_),
    (o = s.viewCache),
    ph(
      o.eventCache.getNode().isIndexed(a.filter.getIndex()),
      "Event snap not indexed"
    ),
    ph(
      o.serverCache.getNode().isIndexed(a.filter.getIndex()),
      "Server snap not indexed"
    ),
    ph(
      s.viewCache.serverCache.isFullyInitialized() ||
        !r.serverCache.isFullyInitialized(),
      "Once a server snap is complete, it should never go back"
    ),
    (e.viewCache_ = s.viewCache),
    Fm(e, s.changes, s.viewCache.eventCache.getNode(), null)
  );
}
function Fm(e, t, n, i) {
  const r = i ? [i] : e.eventRegistrations_;
  return (function (e, t, n, i) {
    const r = [],
      s = [];
    return (
      t.forEach((t) => {
        var n;
        "child_changed" === t.type &&
          e.index_.indexedValueChanged(t.oldSnap, t.snapshotNode) &&
          s.push(
            ((n = t.childName),
            { type: "child_moved", snapshotNode: t.snapshotNode, childName: n })
          );
      }),
      Gf(e, r, "child_removed", t, i, n),
      Gf(e, r, "child_added", t, i, n),
      Gf(e, r, "child_moved", s, i, n),
      Gf(e, r, "child_changed", t, i, n),
      Gf(e, r, "value", t, i, n),
      r
    );
  })(e.eventGenerator_, t, n, r);
}
let zm, Um;
class Bm {
  constructor() {
    this.views = new Map();
  }
}
function Vm(e, t, n, i) {
  const r = t.source.queryId;
  if (null !== r) {
    const s = e.views.get(r);
    return (
      ph(null != s, "SyncTree gave us an op for an invalid query."),
      Om(s, t, n, i)
    );
  }
  {
    let r = [];
    for (const s of e.views.values()) r = r.concat(Om(s, t, n, i));
    return r;
  }
}
function Hm(e, t, n, i, r) {
  const s = t._queryIdentifier,
    a = e.views.get(s);
  if (!a) {
    let e = fm(n, r ? i : null),
      s = !1;
    e
      ? (s = !0)
      : i instanceof uf
      ? ((e = mm(n, i)), (s = !1))
      : ((e = uf.EMPTY_NODE), (s = !1));
    const a = Wf(new Vf(e, s, !1), new Vf(i, r, !1));
    return new Rm(t, a);
  }
  return a;
}
function Gm(e, t, n, i, r, s) {
  const a = Hm(e, t, i, r, s);
  return (
    e.views.has(t._queryIdentifier) || e.views.set(t._queryIdentifier, a),
    (function (e, t) {
      e.eventRegistrations_.push(t);
    })(a, n),
    (function (e, t) {
      const n = e.viewCache_.eventCache,
        i = [];
      n.getNode().isLeafNode() ||
        n.getNode().forEachChild(tf, (e, t) => {
          i.push(_f(e, t));
        });
      return (
        n.isFullyInitialized() && i.push(vf(n.getNode())),
        Fm(e, i, n.getNode(), t)
      );
    })(a, n)
  );
}
function Wm(e, t, n, i) {
  const r = t._queryIdentifier,
    s = [];
  let a = [];
  const o = $m(e);
  if ("default" === r)
    for (const [l, c] of e.views.entries())
      (a = a.concat(Nm(c, n, i))),
        km(c) &&
          (e.views.delete(l),
          c.query._queryParams.loadsAllData() || s.push(c.query));
  else {
    const t = e.views.get(r);
    t &&
      ((a = a.concat(Nm(t, n, i))),
      km(t) &&
        (e.views.delete(r),
        t.query._queryParams.loadsAllData() || s.push(t.query)));
  }
  return (
    o &&
      !$m(e) &&
      s.push(
        new (ph(zm, "Reference.ts has not been loaded"), zm)(t._repo, t._path)
      ),
    { removed: s, events: a }
  );
}
function qm(e) {
  const t = [];
  for (const n of e.views.values())
    n.query._queryParams.loadsAllData() || t.push(n);
  return t;
}
function jm(e, t) {
  let n = null;
  for (const i of e.views.values()) n = n || Dm(i, t);
  return n;
}
function Ym(e, t) {
  if (t._queryParams.loadsAllData()) return Zm(e);
  {
    const n = t._queryIdentifier;
    return e.views.get(n);
  }
}
function Xm(e, t) {
  return null != Ym(e, t);
}
function $m(e) {
  return null != Zm(e);
}
function Zm(e) {
  for (const t of e.views.values())
    if (t.query._queryParams.loadsAllData()) return t;
  return null;
}
let Km = 1;
class Jm {
  constructor(e) {
    (this.listenProvider_ = e),
      (this.syncPointTree_ = new Zf(null)),
      (this.pendingWriteTree_ = {
        visibleWrites: Kf.empty(),
        allWrites: [],
        lastWriteId: -1,
      }),
      (this.tagToQueryMap = new Map()),
      (this.queryToTagMap = new Map());
  }
}
function Qm(e, t, n, i, r) {
  return (
    (function (e, t, n, i, r) {
      ph(i > e.lastWriteId, "Stacking an older write on top of newer ones"),
        void 0 === r && (r = !0),
        e.allWrites.push({ path: t, snap: n, writeId: i, visible: r }),
        r && (e.visibleWrites = Jf(e.visibleWrites, t, n)),
        (e.lastWriteId = i);
    })(e.pendingWriteTree_, t, n, i, r),
    r
      ? ag(
          e,
          new Uf(
            { fromUser: !0, fromServer: !1, queryId: null, tagged: !1 },
            t,
            n
          )
        )
      : []
  );
}
function eg(e, t, n = !1) {
  const i = (function (e, t) {
    for (let n = 0; n < e.allWrites.length; n++) {
      const i = e.allWrites[n];
      if (i.writeId === t) return i;
    }
    return null;
  })(e.pendingWriteTree_, t);
  if (cm(e.pendingWriteTree_, t)) {
    let t = new Zf(null);
    return (
      null != i.snap
        ? (t = t.set(bp(), !0))
        : Xd(i.children, (e) => {
            t = t.set(new xp(e), !0);
          }),
      ag(e, new Ff(i.path, t, n))
    );
  }
  return [];
}
function tg(e, t, n) {
  return ag(
    e,
    new Uf({ fromUser: !1, fromServer: !0, queryId: null, tagged: !1 }, t, n)
  );
}
function ng(e, t, n, i) {
  const r = t._path,
    s = e.syncPointTree_.get(r);
  let a = [];
  if (s && ("default" === t._queryIdentifier || Xm(s, t))) {
    const o = Wm(s, t, n, i);
    0 === s.views.size && (e.syncPointTree_ = e.syncPointTree_.remove(r));
    const l = o.removed;
    a = o.events;
    const c = -1 !== l.findIndex((e) => e._queryParams.loadsAllData()),
      u = e.syncPointTree_.findOnPath(r, (e, t) => $m(t));
    if (c && !u) {
      const t = e.syncPointTree_.subtree(r);
      if (!t.isEmpty()) {
        const n = (function (e) {
          return e.fold((e, t, n) => {
            if (t && $m(t)) {
              return [Zm(t)];
            }
            {
              let e = [];
              return (
                t && (e = qm(t)),
                Xd(n, (t, n) => {
                  e = e.concat(n);
                }),
                e
              );
            }
          });
        })(t);
        for (let t = 0; t < n.length; ++t) {
          const i = n[t],
            r = i.query,
            s = cg(e, i);
          e.listenProvider_.startListening(
            mg(r),
            ug(e, r),
            s.hashFn,
            s.onComplete
          );
        }
      }
    }
    if (!u && l.length > 0 && !i)
      if (c) {
        const n = null;
        e.listenProvider_.stopListening(mg(t), n);
      } else
        l.forEach((t) => {
          const n = e.queryToTagMap.get(hg(t));
          e.listenProvider_.stopListening(mg(t), n);
        });
    !(function (e, t) {
      for (let n = 0; n < t.length; ++n) {
        const i = t[n];
        if (!i._queryParams.loadsAllData()) {
          const t = hg(i),
            n = e.queryToTagMap.get(t);
          e.queryToTagMap.delete(t), e.tagToQueryMap.delete(n);
        }
      }
    })(e, l);
  }
  return a;
}
function ig(e, t, n) {
  const i = t._path;
  let r = null,
    s = !1;
  e.syncPointTree_.foreachOnPath(i, (e, t) => {
    const n = Lp(e, i);
    (r = r || jm(t, n)), (s = s || $m(t));
  });
  let a,
    o = e.syncPointTree_.get(i);
  if (
    (o
      ? ((s = s || $m(o)), (r = r || jm(o, bp())))
      : ((o = new Bm()), (e.syncPointTree_ = e.syncPointTree_.set(i, o))),
    null != r)
  )
    a = !0;
  else {
    (a = !1), (r = uf.EMPTY_NODE);
    e.syncPointTree_.subtree(i).foreachChild((e, t) => {
      const n = jm(t, bp());
      n && (r = r.updateImmediateChild(e, n));
    });
  }
  const l = Xm(o, t);
  if (!l && !t._queryParams.loadsAllData()) {
    const n = hg(t);
    ph(!e.queryToTagMap.has(n), "View does not exist, but we have a tag");
    const i = Km++;
    e.queryToTagMap.set(n, i), e.tagToQueryMap.set(i, n);
  }
  let c = Gm(o, t, n, lm(e.pendingWriteTree_, i), r, a);
  if (!l && !s) {
    const n = Ym(o, t);
    c = c.concat(
      (function (e, t, n) {
        const i = t._path,
          r = ug(e, t),
          s = cg(e, n),
          a = e.listenProvider_.startListening(
            mg(t),
            r,
            s.hashFn,
            s.onComplete
          ),
          o = e.syncPointTree_.subtree(i);
        if (r)
          ph(!$m(o.value), "If we're adding a query, it shouldn't be shadowed");
        else {
          const t = o.fold((e, t, n) => {
            if (!Pp(e) && t && $m(t)) return [Zm(t).query];
            {
              let e = [];
              return (
                t && (e = e.concat(qm(t).map((e) => e.query))),
                Xd(n, (t, n) => {
                  e = e.concat(n);
                }),
                e
              );
            }
          });
          for (let n = 0; n < t.length; ++n) {
            const i = t[n];
            e.listenProvider_.stopListening(mg(i), ug(e, i));
          }
        }
        return a;
      })(e, t, n)
    );
  }
  return c;
}
function rg(e, t, n) {
  const i = e.pendingWriteTree_,
    r = e.syncPointTree_.findOnPath(t, (e, n) => {
      const i = jm(n, Lp(e, t));
      if (i) return i;
    });
  return pm(i, t, r, n, !0);
}
function sg(e, t) {
  const n = t._path;
  let i = null;
  e.syncPointTree_.foreachOnPath(n, (e, t) => {
    const r = Lp(e, n);
    i = i || jm(t, r);
  });
  let r = e.syncPointTree_.get(n);
  r
    ? (i = i || jm(r, bp()))
    : ((r = new Bm()), (e.syncPointTree_ = e.syncPointTree_.set(n, r)));
  const s = null != i,
    a = s ? new Vf(i, !0, !1) : null;
  return (function (e) {
    return Yf(e.viewCache_);
  })(
    Hm(
      r,
      t,
      lm(e.pendingWriteTree_, t._path),
      s ? a.getNode() : uf.EMPTY_NODE,
      s
    )
  );
}
function ag(e, t) {
  return og(t, e.syncPointTree_, null, lm(e.pendingWriteTree_, bp()));
}
function og(e, t, n, i) {
  if (Pp(e.path)) return lg(e, t, n, i);
  {
    const r = t.get(bp());
    null == n && null != r && (n = jm(r, bp()));
    let s = [];
    const a = wp(e.path),
      o = e.operationForChild(a),
      l = t.children.get(a);
    if (l && o) {
      const e = n ? n.getImmediateChild(a) : null,
        t = xm(i, a);
      s = s.concat(og(o, l, e, t));
    }
    return r && (s = s.concat(Vm(r, e, i, n))), s;
  }
}
function lg(e, t, n, i) {
  const r = t.get(bp());
  null == n && null != r && (n = jm(r, bp()));
  let s = [];
  return (
    t.children.inorderTraversal((t, r) => {
      const a = n ? n.getImmediateChild(t) : null,
        o = xm(i, t),
        l = e.operationForChild(t);
      l && (s = s.concat(lg(l, r, a, o)));
    }),
    r && (s = s.concat(Vm(r, e, i, n))),
    s
  );
}
function cg(e, t) {
  const n = t.query,
    i = ug(e, n);
  return {
    hashFn: () => {
      const e =
        (function (e) {
          return e.viewCache_.serverCache.getNode();
        })(t) || uf.EMPTY_NODE;
      return e.hash();
    },
    onComplete: (t) => {
      if ("ok" === t)
        return i
          ? (function (e, t, n) {
              const i = dg(e, n);
              if (i) {
                const n = pg(i),
                  r = n.path,
                  s = n.queryId,
                  a = Lp(r, t);
                return fg(e, r, new zf(Of(s), a));
              }
              return [];
            })(e, n._path, i)
          : (function (e, t) {
              return ag(
                e,
                new zf(
                  { fromUser: !1, fromServer: !0, queryId: null, tagged: !1 },
                  t
                )
              );
            })(e, n._path);
      {
        const i = (function (e, t) {
          let n = "Unknown Error";
          "too_big" === e
            ? (n =
                "The data requested exceeds the maximum size that can be accessed with a single request.")
            : "permission_denied" === e
            ? (n = "Client doesn't have permission to access the desired data.")
            : "unavailable" === e && (n = "The service is unavailable");
          const i = new Error(e + " at " + t._path.toString() + ": " + n);
          return (i.code = e.toUpperCase()), i;
        })(t, n);
        return ng(e, n, null, i);
      }
    },
  };
}
function ug(e, t) {
  const n = hg(t);
  return e.queryToTagMap.get(n);
}
function hg(e) {
  return e._path.toString() + "$" + e._queryIdentifier;
}
function dg(e, t) {
  return e.tagToQueryMap.get(t);
}
function pg(e) {
  const t = e.indexOf("$");
  return (
    ph(-1 !== t && t < e.length - 1, "Bad queryKey."),
    { queryId: e.substr(t + 1), path: new xp(e.substr(0, t)) }
  );
}
function fg(e, t, n) {
  const i = e.syncPointTree_.get(t);
  ph(i, "Missing sync point for query tag that we're tracking");
  return Vm(i, n, lm(e.pendingWriteTree_, t), null);
}
function mg(e) {
  return e._queryParams.loadsAllData() && !e._queryParams.isDefault()
    ? new (ph(Um, "Reference.ts has not been loaded"), Um)(e._repo, e._path)
    : e;
}
class gg {
  constructor(e) {
    this.node_ = e;
  }
  getImmediateChild(e) {
    const t = this.node_.getImmediateChild(e);
    return new gg(t);
  }
  node() {
    return this.node_;
  }
}
class vg {
  constructor(e, t) {
    (this.syncTree_ = e), (this.path_ = t);
  }
  getImmediateChild(e) {
    const t = Ap(this.path_, e);
    return new vg(this.syncTree_, t);
  }
  node() {
    return rg(this.syncTree_, this.path_);
  }
}
const _g = function (e, t, n) {
    return e && "object" == typeof e
      ? (ph(".sv" in e, "Unexpected leaf node or priority contents"),
        "string" == typeof e[".sv"]
          ? yg(e[".sv"], t, n)
          : "object" == typeof e[".sv"]
          ? xg(e[".sv"], t)
          : void ph(
              !1,
              "Unexpected server value: " + JSON.stringify(e, null, 2)
            ))
      : e;
  },
  yg = function (e, t, n) {
    if ("timestamp" === e) return n.timestamp;
    ph(!1, "Unexpected server value: " + e);
  },
  xg = function (e, t, n) {
    e.hasOwnProperty("increment") ||
      ph(!1, "Unexpected server value: " + JSON.stringify(e, null, 2));
    const i = e.increment;
    "number" != typeof i && ph(!1, "Unexpected increment value: " + i);
    const r = t.node();
    if (
      (ph(null != r, "Expected ChildrenNode.EMPTY_NODE for nulls"),
      !r.isLeafNode())
    )
      return i;
    const s = r.getValue();
    return "number" != typeof s ? i : s + i;
  },
  bg = function (e, t, n) {
    return wg(e, new gg(t), n);
  };
function wg(e, t, n) {
  const i = e.getPriority().val(),
    r = _g(i, t.getImmediateChild(".priority"), n);
  let s;
  if (e.isLeafNode()) {
    const i = e,
      s = _g(i.getValue(), t, n);
    return s !== i.getValue() || r !== i.getPriority().val()
      ? new ef(s, df(r))
      : e;
  }
  {
    const i = e;
    return (
      (s = i),
      r !== i.getPriority().val() && (s = s.updatePriority(new ef(r))),
      i.forEachChild(tf, (e, i) => {
        const r = wg(i, t.getImmediateChild(e), n);
        r !== i && (s = s.updateImmediateChild(e, r));
      }),
      s
    );
  }
}
class Sg {
  constructor(e = "", t = null, n = { children: {}, childCount: 0 }) {
    (this.name = e), (this.parent = t), (this.node = n);
  }
}
function Mg(e, t) {
  let n = t instanceof xp ? t : new xp(t),
    i = e,
    r = wp(n);
  for (; null !== r; ) {
    const e = Lh(i.node.children, r) || { children: {}, childCount: 0 };
    (i = new Sg(r, i, e)), (n = Mp(n)), (r = wp(n));
  }
  return i;
}
function Tg(e) {
  return e.node.value;
}
function Cg(e, t) {
  (e.node.value = t), Ig(e);
}
function Eg(e) {
  return e.node.childCount > 0;
}
function Ag(e, t) {
  Xd(e.node.children, (n, i) => {
    t(new Sg(n, e, i));
  });
}
function Pg(e, t, n, i) {
  n && !i && t(e),
    Ag(e, (e) => {
      Pg(e, t, !0, i);
    }),
    n && i && t(e);
}
function Lg(e) {
  return new xp(null === e.parent ? e.name : Lg(e.parent) + "/" + e.name);
}
function Ig(e) {
  null !== e.parent &&
    (function (e, t, n) {
      const i = (function (e) {
          return void 0 === Tg(e) && !Eg(e);
        })(n),
        r = Ph(e.node.children, t);
      i && r
        ? (delete e.node.children[t], e.node.childCount--, Ig(e))
        : i || r || ((e.node.children[t] = n.node), e.node.childCount++, Ig(e));
    })(e.parent, e.name, e);
}
const Rg = /[\[\].#$\/\u0000-\u001F\u007F]/,
  Dg = /[\[\].#$\u0000-\u001F\u007F]/,
  kg = function (e) {
    return "string" == typeof e && 0 !== e.length && !Rg.test(e);
  },
  Ng = function (e) {
    return "string" == typeof e && 0 !== e.length && !Dg.test(e);
  },
  Og = function (e, t, n, i) {
    (i && void 0 === t) || Fg(Oh(e, "value"), t, n);
  },
  Fg = function (e, t, n) {
    const i = n instanceof xp ? new Dp(n, e) : n;
    if (void 0 === t) throw new Error(e + "contains undefined " + Np(i));
    if ("function" == typeof t)
      throw new Error(
        e + "contains a function " + Np(i) + " with contents = " + t.toString()
      );
    if (Bd(t)) throw new Error(e + "contains " + t.toString() + " " + Np(i));
    if ("string" == typeof t && t.length > 10485760 / 3 && Fh(t) > 10485760)
      throw new Error(
        e +
          "contains a string greater than 10485760 utf8 bytes " +
          Np(i) +
          " ('" +
          t.substring(0, 50) +
          "...')"
      );
    if (t && "object" == typeof t) {
      let n = !1,
        r = !1;
      if (
        (Xd(t, (t, s) => {
          if (".value" === t) n = !0;
          else if (".priority" !== t && ".sv" !== t && ((r = !0), !kg(t)))
            throw new Error(
              e +
                " contains an invalid key (" +
                t +
                ") " +
                Np(i) +
                '.  Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"'
            );
          var a, o;
          (o = t),
            (a = i).parts_.length > 0 && (a.byteLength_ += 1),
            a.parts_.push(o),
            (a.byteLength_ += Fh(o)),
            kp(a),
            Fg(e, s, i),
            (function (e) {
              const t = e.parts_.pop();
              (e.byteLength_ -= Fh(t)),
                e.parts_.length > 0 && (e.byteLength_ -= 1);
            })(i);
        }),
        n && r)
      )
        throw new Error(
          e +
            ' contains ".value" child ' +
            Np(i) +
            " in addition to actual children."
        );
    }
  },
  zg = function (e, t, n, i) {
    if (!((i && void 0 === n) || Ng(n)))
      throw new Error(
        Oh(e, t) +
          'was an invalid path = "' +
          n +
          '". Paths must be non-empty strings and can\'t contain ".", "#", "$", "[", or "]"'
      );
  },
  Ug = function (e, t) {
    if (".info" === wp(t))
      throw new Error(e + " failed = Can't modify data under /.info/");
  },
  Bg = function (e, t) {
    const n = t.path.toString();
    if (
      "string" != typeof t.repoInfo.host ||
      0 === t.repoInfo.host.length ||
      (!kg(t.repoInfo.namespace) &&
        "localhost" !== t.repoInfo.host.split(":")[0]) ||
      (0 !== n.length &&
        !(function (e) {
          return e && (e = e.replace(/^\/*\.info(\/|$)/, "/")), Ng(e);
        })(n))
    )
      throw new Error(
        Oh(e, "url") +
          'must be a valid firebase URL and the path can\'t contain ".", "#", "$", "[", or "]".'
      );
  };
class Vg {
  constructor() {
    (this.eventLists_ = []), (this.recursionDepth_ = 0);
  }
}
function Hg(e, t) {
  let n = null;
  for (let i = 0; i < t.length; i++) {
    const r = t[i],
      s = r.getPath();
    null === n || Ip(s, n.path) || (e.eventLists_.push(n), (n = null)),
      null === n && (n = { events: [], path: s }),
      n.events.push(r);
  }
  n && e.eventLists_.push(n);
}
function Gg(e, t, n) {
  Hg(e, n), qg(e, (e) => Ip(e, t));
}
function Wg(e, t, n) {
  Hg(e, n), qg(e, (e) => Rp(e, t) || Rp(t, e));
}
function qg(e, t) {
  e.recursionDepth_++;
  let n = !0;
  for (let i = 0; i < e.eventLists_.length; i++) {
    const r = e.eventLists_[i];
    if (r) {
      t(r.path) ? (jg(e.eventLists_[i]), (e.eventLists_[i] = null)) : (n = !1);
    }
  }
  n && (e.eventLists_ = []), e.recursionDepth_--;
}
function jg(e) {
  for (let t = 0; t < e.events.length; t++) {
    const n = e.events[t];
    if (null !== n) {
      e.events[t] = null;
      const i = n.getEventRunner();
      Dd && Nd("event: " + n.toString()), Jd(i);
    }
  }
}
class Yg {
  constructor(e, t, n, i) {
    (this.repoInfo_ = e),
      (this.forceRestClient_ = t),
      (this.authTokenProvider_ = n),
      (this.appCheckProvider_ = i),
      (this.dataUpdateCount = 0),
      (this.statsListener_ = null),
      (this.eventQueue_ = new Vg()),
      (this.nextWriteId_ = 1),
      (this.interceptServerDataCallback_ = null),
      (this.onDisconnect_ = Pf()),
      (this.transactionQueueTree_ = new Sg()),
      (this.persistentConnection_ = null),
      (this.key = this.repoInfo_.toURLString());
  }
  toString() {
    return (
      (this.repoInfo_.secure ? "https://" : "http://") + this.repoInfo_.host
    );
  }
}
function Xg(e, t, n) {
  if (
    ((e.stats_ = cp(e.repoInfo_)),
    e.forceRestClient_ ||
      (
        ("object" == typeof window &&
          window.navigator &&
          window.navigator.userAgent) ||
        ""
      ).search(
        /googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i
      ) >= 0)
  )
    (e.server_ = new Ef(
      e.repoInfo_,
      (t, n, i, r) => {
        Kg(e, t, n, i, r);
      },
      e.authTokenProvider_,
      e.appCheckProvider_
    )),
      setTimeout(() => Jg(e, !0), 0);
  else {
    if (null != n) {
      if ("object" != typeof n)
        throw new Error(
          "Only objects are supported for option databaseAuthVariableOverride"
        );
      try {
        Eh(n);
      } catch (i) {
        throw new Error("Invalid authOverride provided: " + i);
      }
    }
    (e.persistentConnection_ = new Fp(
      e.repoInfo_,
      t,
      (t, n, i, r) => {
        Kg(e, t, n, i, r);
      },
      (t) => {
        Jg(e, t);
      },
      (t) => {
        !(function (e, t) {
          Xd(t, (t, n) => {
            Qg(e, t, n);
          });
        })(e, t);
      },
      e.authTokenProvider_,
      e.appCheckProvider_,
      n
    )),
      (e.server_ = e.persistentConnection_);
  }
  e.authTokenProvider_.addTokenChangeListener((t) => {
    e.server_.refreshAuthToken(t);
  }),
    e.appCheckProvider_.addTokenChangeListener((t) => {
      e.server_.refreshAppCheckToken(t.token);
    }),
    (e.statsReporter_ = (function (e, t) {
      const n = e.toString();
      return lp[n] || (lp[n] = t()), lp[n];
    })(e.repoInfo_, () => new Df(e.stats_, e.server_))),
    (e.infoData_ = new Af()),
    (e.infoSyncTree_ = new Jm({
      startListening: (t, n, i, r) => {
        let s = [];
        const a = e.infoData_.getNode(t._path);
        return (
          a.isEmpty() ||
            ((s = tg(e.infoSyncTree_, t._path, a)),
            setTimeout(() => {
              r("ok");
            }, 0)),
          s
        );
      },
      stopListening: () => {},
    })),
    Qg(e, "connected", !1),
    (e.serverSyncTree_ = new Jm({
      startListening: (t, n, i, r) => (
        e.server_.listen(t, i, n, (n, i) => {
          const s = r(n, i);
          Wg(e.eventQueue_, t._path, s);
        }),
        []
      ),
      stopListening: (t, n) => {
        e.server_.unlisten(t, n);
      },
    }));
}
function $g(e) {
  const t = e.infoData_.getNode(new xp(".info/serverTimeOffset")).val() || 0;
  return new Date().getTime() + t;
}
function Zg(e) {
  return (
    ((t = (t = { timestamp: $g(e) }) || {}).timestamp =
      t.timestamp || new Date().getTime()),
    t
  );
  var t;
}
function Kg(e, t, n, i, r) {
  e.dataUpdateCount++;
  const s = new xp(t);
  n = e.interceptServerDataCallback_ ? e.interceptServerDataCallback_(t, n) : n;
  let a = [];
  if (r)
    if (i) {
      const t = Rh(n, (e) => df(e));
      a = (function (e, t, n, i) {
        const r = dg(e, i);
        if (r) {
          const i = pg(r),
            s = i.path,
            a = i.queryId,
            o = Lp(s, t),
            l = Zf.fromObject(n);
          return fg(e, s, new Bf(Of(a), o, l));
        }
        return [];
      })(e.serverSyncTree_, s, t, r);
    } else {
      const t = df(n);
      a = (function (e, t, n, i) {
        const r = dg(e, i);
        if (null != r) {
          const i = pg(r),
            s = i.path,
            a = i.queryId,
            o = Lp(s, t);
          return fg(e, s, new Uf(Of(a), o, n));
        }
        return [];
      })(e.serverSyncTree_, s, t, r);
    }
  else if (i) {
    const t = Rh(n, (e) => df(e));
    a = (function (e, t, n) {
      const i = Zf.fromObject(n);
      return ag(
        e,
        new Bf(
          { fromUser: !1, fromServer: !0, queryId: null, tagged: !1 },
          t,
          i
        )
      );
    })(e.serverSyncTree_, s, t);
  } else {
    const t = df(n);
    a = tg(e.serverSyncTree_, s, t);
  }
  let o = s;
  a.length > 0 && (o = av(e, s)), Wg(e.eventQueue_, o, a);
}
function Jg(e, t) {
  Qg(e, "connected", t),
    !1 === t &&
      (function (e) {
        iv(e, "onDisconnectEvents");
        const t = Zg(e),
          n = Pf();
        If(e.onDisconnect_, bp(), (i, r) => {
          const s = (function (e, t, n, i) {
            return wg(t, new vg(n, e), i);
          })(i, r, e.serverSyncTree_, t);
          Lf(n, i, s);
        });
        let i = [];
        If(n, bp(), (t, n) => {
          i = i.concat(tg(e.serverSyncTree_, t, n));
          const r = hv(e, t);
          av(e, r);
        }),
          (e.onDisconnect_ = Pf()),
          Wg(e.eventQueue_, bp(), i);
      })(e);
}
function Qg(e, t, n) {
  const i = new xp("/.info/" + t),
    r = df(n);
  e.infoData_.updateSnapshot(i, r);
  const s = tg(e.infoSyncTree_, i, r);
  Wg(e.eventQueue_, i, s);
}
function ev(e) {
  return e.nextWriteId_++;
}
function tv(e, t, n, i, r) {
  iv(e, "set", { path: t.toString(), value: n, priority: i });
  const s = Zg(e),
    a = df(n, i),
    o = rg(e.serverSyncTree_, t),
    l = bg(a, o, s),
    c = ev(e),
    u = Qm(e.serverSyncTree_, t, l, c, !0);
  Hg(e.eventQueue_, u),
    e.server_.put(t.toString(), a.val(!0), (n, i) => {
      const s = "ok" === n;
      s || Ud("set at " + t + " failed: " + n);
      const a = eg(e.serverSyncTree_, c, !s);
      Wg(e.eventQueue_, t, a),
        (function (e, t, n, i) {
          t &&
            Jd(() => {
              if ("ok" === n) t(null);
              else {
                const e = (n || "error").toUpperCase();
                let r = e;
                i && (r += ": " + i);
                const s = new Error(r);
                (s.code = e), t(s);
              }
            });
        })(0, r, n, i);
    });
  const h = hv(e, t);
  av(e, h), Wg(e.eventQueue_, h, []);
}
function nv(e, t, n) {
  let i;
  (i =
    ".info" === wp(t._path)
      ? ng(e.infoSyncTree_, t, n)
      : ng(e.serverSyncTree_, t, n)),
    Gg(e.eventQueue_, t._path, i);
}
function iv(e, ...t) {
  let n = "";
  e.persistentConnection_ && (n = e.persistentConnection_.id + ":"),
    Nd(n, ...t);
}
function rv(e, t, n) {
  return rg(e.serverSyncTree_, t, n) || uf.EMPTY_NODE;
}
function sv(e, t = e.transactionQueueTree_) {
  if ((t || uv(e, t), Tg(t))) {
    const n = lv(e, t);
    ph(n.length > 0, "Sending zero length transaction queue");
    n.every((e) => 0 === e.status) &&
      (function (e, t, n) {
        const i = n.map((e) => e.currentWriteId),
          r = rv(e, t, i);
        let s = r;
        const a = r.hash();
        for (let c = 0; c < n.length; c++) {
          const e = n[c];
          ph(
            0 === e.status,
            "tryToSendTransactionQueue_: items in queue should all be run."
          ),
            (e.status = 1),
            e.retryCount++;
          const i = Lp(t, e.path);
          s = s.updateChild(i, e.currentOutputSnapshotRaw);
        }
        const o = s.val(!0),
          l = t;
        e.server_.put(
          l.toString(),
          o,
          (i) => {
            iv(e, "transaction put response", {
              path: l.toString(),
              status: i,
            });
            let r = [];
            if ("ok" === i) {
              const i = [];
              for (let t = 0; t < n.length; t++)
                (n[t].status = 2),
                  (r = r.concat(eg(e.serverSyncTree_, n[t].currentWriteId))),
                  n[t].onComplete &&
                    i.push(() =>
                      n[t].onComplete(
                        null,
                        !0,
                        n[t].currentOutputSnapshotResolved
                      )
                    ),
                  n[t].unwatcher();
              uv(e, Mg(e.transactionQueueTree_, t)),
                sv(e, e.transactionQueueTree_),
                Wg(e.eventQueue_, t, r);
              for (let e = 0; e < i.length; e++) Jd(i[e]);
            } else {
              if ("datastale" === i)
                for (let e = 0; e < n.length; e++)
                  3 === n[e].status ? (n[e].status = 4) : (n[e].status = 0);
              else {
                Ud("transaction at " + l.toString() + " failed: " + i);
                for (let e = 0; e < n.length; e++)
                  (n[e].status = 4), (n[e].abortReason = i);
              }
              av(e, t);
            }
          },
          a
        );
      })(e, Lg(t), n);
  } else
    Eg(t) &&
      Ag(t, (t) => {
        sv(e, t);
      });
}
function av(e, t) {
  const n = ov(e, t),
    i = Lg(n);
  return (
    (function (e, t, n) {
      if (0 === t.length) return;
      const i = [];
      let r = [];
      const s = t.filter((e) => 0 === e.status).map((e) => e.currentWriteId);
      for (let o = 0; o < t.length; o++) {
        const l = t[o],
          c = Lp(n, l.path);
        let u,
          h = !1;
        if (
          (ph(
            null !== c,
            "rerunTransactionsUnderNode_: relativePath should not be null."
          ),
          4 === l.status)
        )
          (h = !0),
            (u = l.abortReason),
            (r = r.concat(eg(e.serverSyncTree_, l.currentWriteId, !0)));
        else if (0 === l.status)
          if (l.retryCount >= 25)
            (h = !0),
              (u = "maxretry"),
              (r = r.concat(eg(e.serverSyncTree_, l.currentWriteId, !0)));
          else {
            const n = rv(e, l.path, s);
            l.currentInputSnapshot = n;
            const i = t[o].update(n.val());
            if (void 0 !== i) {
              Fg("transaction failed: Data returned ", i, l.path);
              let t = df(i);
              ("object" == typeof i && null != i && Ph(i, ".priority")) ||
                (t = t.updatePriority(n.getPriority()));
              const a = l.currentWriteId,
                o = Zg(e),
                c = bg(t, n, o);
              (l.currentOutputSnapshotRaw = t),
                (l.currentOutputSnapshotResolved = c),
                (l.currentWriteId = ev(e)),
                s.splice(s.indexOf(a), 1),
                (r = r.concat(
                  Qm(
                    e.serverSyncTree_,
                    l.path,
                    c,
                    l.currentWriteId,
                    l.applyLocally
                  )
                )),
                (r = r.concat(eg(e.serverSyncTree_, a, !0)));
            } else
              (h = !0),
                (u = "nodata"),
                (r = r.concat(eg(e.serverSyncTree_, l.currentWriteId, !0)));
          }
        Wg(e.eventQueue_, n, r),
          (r = []),
          h &&
            ((t[o].status = 2),
            (a = t[o].unwatcher),
            setTimeout(a, Math.floor(0)),
            t[o].onComplete &&
              ("nodata" === u
                ? i.push(() =>
                    t[o].onComplete(null, !1, t[o].currentInputSnapshot)
                  )
                : i.push(() => t[o].onComplete(new Error(u), !1, null))));
      }
      var a;
      uv(e, e.transactionQueueTree_);
      for (let o = 0; o < i.length; o++) Jd(i[o]);
      sv(e, e.transactionQueueTree_);
    })(e, lv(e, n), i),
    i
  );
}
function ov(e, t) {
  let n,
    i = e.transactionQueueTree_;
  for (n = wp(t); null !== n && void 0 === Tg(i); )
    (i = Mg(i, n)), (n = wp((t = Mp(t))));
  return i;
}
function lv(e, t) {
  const n = [];
  return cv(e, t, n), n.sort((e, t) => e.order - t.order), n;
}
function cv(e, t, n) {
  const i = Tg(t);
  if (i) for (let r = 0; r < i.length; r++) n.push(i[r]);
  Ag(t, (t) => {
    cv(e, t, n);
  });
}
function uv(e, t) {
  const n = Tg(t);
  if (n) {
    let e = 0;
    for (let t = 0; t < n.length; t++)
      2 !== n[t].status && ((n[e] = n[t]), e++);
    (n.length = e), Cg(t, n.length > 0 ? n : void 0);
  }
  Ag(t, (t) => {
    uv(e, t);
  });
}
function hv(e, t) {
  const n = Lg(ov(e, t)),
    i = Mg(e.transactionQueueTree_, t);
  return (
    (function (e, t, n) {
      let i = n ? e : e.parent;
      for (; null !== i; ) {
        if (t(i)) return !0;
        i = i.parent;
      }
    })(i, (t) => {
      dv(e, t);
    }),
    dv(e, i),
    Pg(i, (t) => {
      dv(e, t);
    }),
    n
  );
}
function dv(e, t) {
  const n = Tg(t);
  if (n) {
    const i = [];
    let r = [],
      s = -1;
    for (let t = 0; t < n.length; t++)
      3 === n[t].status ||
        (1 === n[t].status
          ? (ph(s === t - 1, "All SENT items should be at beginning of queue."),
            (s = t),
            (n[t].status = 3),
            (n[t].abortReason = "set"))
          : (ph(0 === n[t].status, "Unexpected transaction status in abort"),
            n[t].unwatcher(),
            (r = r.concat(eg(e.serverSyncTree_, n[t].currentWriteId, !0))),
            n[t].onComplete &&
              i.push(n[t].onComplete.bind(null, new Error("set"), !1, null))));
    -1 === s ? Cg(t, void 0) : (n.length = s + 1), Wg(e.eventQueue_, Lg(t), r);
    for (let e = 0; e < i.length; e++) Jd(i[e]);
  }
}
const pv = function (e, t) {
    const n = fv(e),
      i = n.namespace;
    "firebase.com" === n.domain &&
      zd(
        n.host +
          " is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead"
      ),
      (i && "undefined" !== i) ||
        "localhost" === n.domain ||
        zd(
          "Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com"
        ),
      n.secure ||
        ("undefined" != typeof window &&
          window.location &&
          window.location.protocol &&
          -1 !== window.location.protocol.indexOf("https:") &&
          Ud(
            "Insecure Firebase access from a secure page. Please use https in calls to new Firebase()."
          ));
    const r = "ws" === n.scheme || "wss" === n.scheme;
    return {
      repoInfo: new rp(n.host, n.secure, i, t, r, "", i !== n.subdomain),
      path: new xp(n.pathString),
    };
  },
  fv = function (e) {
    let t = "",
      n = "",
      i = "",
      r = "",
      s = "",
      a = !0,
      o = "https",
      l = 443;
    if ("string" == typeof e) {
      let c = e.indexOf("//");
      c >= 0 && ((o = e.substring(0, c - 1)), (e = e.substring(c + 2)));
      let u = e.indexOf("/");
      -1 === u && (u = e.length);
      let h = e.indexOf("?");
      -1 === h && (h = e.length),
        (t = e.substring(0, Math.min(u, h))),
        u < h &&
          (r = (function (e) {
            let t = "";
            const n = e.split("/");
            for (let r = 0; r < n.length; r++)
              if (n[r].length > 0) {
                let e = n[r];
                try {
                  e = decodeURIComponent(e.replace(/\+/g, " "));
                } catch (i) {}
                t += "/" + e;
              }
            return t;
          })(e.substring(u, h)));
      const d = (function (e) {
        const t = {};
        "?" === e.charAt(0) && (e = e.substring(1));
        for (const n of e.split("&")) {
          if (0 === n.length) continue;
          const i = n.split("=");
          2 === i.length
            ? (t[decodeURIComponent(i[0])] = decodeURIComponent(i[1]))
            : Ud(`Invalid query segment '${n}' in query '${e}'`);
        }
        return t;
      })(e.substring(Math.min(e.length, h)));
      (c = t.indexOf(":")),
        c >= 0
          ? ((a = "https" === o || "wss" === o),
            (l = parseInt(t.substring(c + 1), 10)))
          : (c = t.length);
      const p = t.slice(0, c);
      if ("localhost" === p.toLowerCase()) n = "localhost";
      else if (p.split(".").length <= 2) n = p;
      else {
        const e = t.indexOf(".");
        (i = t.substring(0, e).toLowerCase()),
          (n = t.substring(e + 1)),
          (s = i);
      }
      "ns" in d && (s = d.ns);
    }
    return {
      host: t,
      port: l,
      domain: n,
      subdomain: i,
      secure: a,
      scheme: o,
      pathString: r,
      namespace: s,
    };
  };
class mv {
  constructor(e, t, n, i) {
    (this.eventType = e),
      (this.eventRegistration = t),
      (this.snapshot = n),
      (this.prevName = i);
  }
  getPath() {
    const e = this.snapshot.ref;
    return "value" === this.eventType ? e._path : e.parent._path;
  }
  getEventType() {
    return this.eventType;
  }
  getEventRunner() {
    return this.eventRegistration.getEventRunner(this);
  }
  toString() {
    return (
      this.getPath().toString() +
      ":" +
      this.eventType +
      ":" +
      Eh(this.snapshot.exportVal())
    );
  }
}
class gv {
  constructor(e, t, n) {
    (this.eventRegistration = e), (this.error = t), (this.path = n);
  }
  getPath() {
    return this.path;
  }
  getEventType() {
    return "cancel";
  }
  getEventRunner() {
    return this.eventRegistration.getEventRunner(this);
  }
  toString() {
    return this.path.toString() + ":cancel";
  }
}
class vv {
  constructor(e, t) {
    (this.snapshotCallback = e), (this.cancelCallback = t);
  }
  onValue(e, t) {
    this.snapshotCallback.call(null, e, t);
  }
  onCancel(e) {
    return (
      ph(
        this.hasCancelCallback,
        "Raising a cancel event on a listener with no cancel callback"
      ),
      this.cancelCallback.call(null, e)
    );
  }
  get hasCancelCallback() {
    return !!this.cancelCallback;
  }
  matches(e) {
    return (
      this.snapshotCallback === e.snapshotCallback ||
      (void 0 !== this.snapshotCallback.userCallback &&
        this.snapshotCallback.userCallback ===
          e.snapshotCallback.userCallback &&
        this.snapshotCallback.context === e.snapshotCallback.context)
    );
  }
}
class _v {
  constructor(e, t, n, i) {
    (this._repo = e),
      (this._path = t),
      (this._queryParams = n),
      (this._orderByCalled = i);
  }
  get key() {
    return Pp(this._path) ? null : Tp(this._path);
  }
  get ref() {
    return new yv(this._repo, this._path);
  }
  get _queryIdentifier() {
    const e = Cf(this._queryParams),
      t = jd(e);
    return "{}" === t ? "default" : t;
  }
  get _queryObject() {
    return Cf(this._queryParams);
  }
  isEqual(e) {
    if (!((e = zh(e)) instanceof _v)) return !1;
    const t = this._repo === e._repo,
      n = Ip(this._path, e._path),
      i = this._queryIdentifier === e._queryIdentifier;
    return t && n && i;
  }
  toJSON() {
    return this.toString();
  }
  toString() {
    return (
      this._repo.toString() +
      (function (e) {
        let t = "";
        for (let n = e.pieceNum_; n < e.pieces_.length; n++)
          "" !== e.pieces_[n] &&
            (t += "/" + encodeURIComponent(String(e.pieces_[n])));
        return t || "/";
      })(this._path)
    );
  }
}
class yv extends _v {
  constructor(e, t) {
    super(e, t, new Mf(), !1);
  }
  get parent() {
    const e = Ep(this._path);
    return null === e ? null : new yv(this._repo, e);
  }
  get root() {
    let e = this;
    for (; null !== e.parent; ) e = e.parent;
    return e;
  }
}
class xv {
  constructor(e, t, n) {
    (this._node = e), (this.ref = t), (this._index = n);
  }
  get priority() {
    return this._node.getPriority().val();
  }
  get key() {
    return this.ref.key;
  }
  get size() {
    return this._node.numChildren();
  }
  child(e) {
    const t = new xp(e),
      n = wv(this.ref, e);
    return new xv(this._node.getChild(t), n, tf);
  }
  exists() {
    return !this._node.isEmpty();
  }
  exportVal() {
    return this._node.val(!0);
  }
  forEach(e) {
    if (this._node.isLeafNode()) return !1;
    return !!this._node.forEachChild(this._index, (t, n) =>
      e(new xv(n, wv(this.ref, t), tf))
    );
  }
  hasChild(e) {
    const t = new xp(e);
    return !this._node.getChild(t).isEmpty();
  }
  hasChildren() {
    return !this._node.isLeafNode() && !this._node.isEmpty();
  }
  toJSON() {
    return this.exportVal();
  }
  val() {
    return this._node.val();
  }
}
function bv(e, t) {
  return (
    (e = zh(e))._checkNotDeleted("ref"), void 0 !== t ? wv(e._root, t) : e._root
  );
}
function wv(e, t) {
  var n, i, r, s;
  return (
    null === wp((e = zh(e))._path)
      ? ((n = "child"),
        (i = "path"),
        (s = !1),
        (r = t) && (r = r.replace(/^\/*\.info(\/|$)/, "/")),
        zg(n, i, r, s))
      : zg("child", "path", t, !1),
    new yv(e._repo, Ap(e._path, t))
  );
}
function Sv(e, t) {
  (e = zh(e)), Ug("push", e._path), Og("push", t, e._path, !0);
  const n = $g(e._repo),
    i = gf(n),
    r = wv(e, i),
    s = wv(e, i);
  let a;
  return (
    (a = null != t ? Mv(s, t).then(() => s) : Promise.resolve(s)),
    (r.then = a.then.bind(a)),
    (r.catch = a.then.bind(a, void 0)),
    r
  );
}
function Mv(e, t) {
  (e = zh(e)), Ug("set", e._path), Og("set", t, e._path, !1);
  const n = new xh();
  return (
    tv(
      e._repo,
      e._path,
      t,
      null,
      n.wrapCallback(() => {})
    ),
    n.promise
  );
}
function Tv(e) {
  return (function (e, t) {
    const n = sg(e.serverSyncTree_, t);
    return null != n
      ? Promise.resolve(n)
      : e.server_.get(t).then(
          (n) => {
            const i = df(n).withIndex(t._queryParams.getIndex()),
              r = tg(e.serverSyncTree_, t._path, i);
            return Gg(e.eventQueue_, t._path, r), Promise.resolve(i);
          },
          (n) => (
            iv(e, "get for query " + Eh(t) + " failed: " + n),
            Promise.reject(new Error(n))
          )
        );
  })((e = zh(e))._repo, e).then(
    (t) => new xv(t, new yv(e._repo, e._path), e._queryParams.getIndex())
  );
}
class Cv {
  constructor(e) {
    this.callbackContext = e;
  }
  respondsTo(e) {
    return "value" === e;
  }
  createEvent(e, t) {
    const n = t._queryParams.getIndex();
    return new mv(
      "value",
      this,
      new xv(e.snapshotNode, new yv(t._repo, t._path), n)
    );
  }
  getEventRunner(e) {
    return "cancel" === e.getEventType()
      ? () => this.callbackContext.onCancel(e.error)
      : () => this.callbackContext.onValue(e.snapshot, null);
  }
  createCancelEvent(e, t) {
    return this.callbackContext.hasCancelCallback ? new gv(this, e, t) : null;
  }
  matches(e) {
    return (
      e instanceof Cv &&
      (!e.callbackContext ||
        !this.callbackContext ||
        e.callbackContext.matches(this.callbackContext))
    );
  }
  hasAnyCallback() {
    return null !== this.callbackContext;
  }
}
class Ev {
  constructor(e, t) {
    (this.eventType = e), (this.callbackContext = t);
  }
  respondsTo(e) {
    let t = "children_added" === e ? "child_added" : e;
    return (
      (t = "children_removed" === t ? "child_removed" : t), this.eventType === t
    );
  }
  createCancelEvent(e, t) {
    return this.callbackContext.hasCancelCallback ? new gv(this, e, t) : null;
  }
  createEvent(e, t) {
    ph(null != e.childName, "Child events should have a childName.");
    const n = wv(new yv(t._repo, t._path), e.childName),
      i = t._queryParams.getIndex();
    return new mv(e.type, this, new xv(e.snapshotNode, n, i), e.prevName);
  }
  getEventRunner(e) {
    return "cancel" === e.getEventType()
      ? () => this.callbackContext.onCancel(e.error)
      : () => this.callbackContext.onValue(e.snapshot, e.prevName);
  }
  matches(e) {
    return (
      e instanceof Ev &&
      this.eventType === e.eventType &&
      (!this.callbackContext ||
        !e.callbackContext ||
        this.callbackContext.matches(e.callbackContext))
    );
  }
  hasAnyCallback() {
    return !!this.callbackContext;
  }
}
function Av(e, t, n, i, r) {
  let s;
  if (
    ("object" == typeof i && ((s = void 0), (r = i)),
    "function" == typeof i && (s = i),
    r && r.onlyOnce)
  ) {
    const t = n,
      i = (n, i) => {
        nv(e._repo, e, o), t(n, i);
      };
    (i.userCallback = n.userCallback), (i.context = n.context), (n = i);
  }
  const a = new vv(n, s || void 0),
    o = "value" === t ? new Cv(a) : new Ev(t, a);
  return (
    (function (e, t, n) {
      let i;
      (i =
        ".info" === wp(t._path)
          ? ig(e.infoSyncTree_, t, n)
          : ig(e.serverSyncTree_, t, n)),
        Gg(e.eventQueue_, t._path, i);
    })(e._repo, e, o),
    () => nv(e._repo, e, o)
  );
}
function Pv(e, t, n, i) {
  return Av(e, "value", t, n, i);
}
!(function (e) {
  ph(!zm, "__referenceConstructor has already been defined"), (zm = e);
})(yv),
  (function (e) {
    ph(!Um, "__referenceConstructor has already been defined"), (Um = e);
  })(yv);
const Lv = {};
function Iv(e, t, n, i, r) {
  let s = i || e.options.databaseURL;
  void 0 === s &&
    (e.options.projectId ||
      zd(
        "Can't determine Firebase Database URL. Be sure to include  a Project ID when calling firebase.initializeApp()."
      ),
    Nd("Using default host for project ", e.options.projectId),
    (s = `${e.options.projectId}-default-rtdb.firebaseio.com`));
  let a,
    o,
    l = pv(s, r),
    c = l.repoInfo;
  "undefined" != typeof process &&
    (o = process.env.FIREBASE_DATABASE_EMULATOR_HOST),
    o
      ? ((a = !0),
        (s = `http://${o}?ns=${c.namespace}`),
        (l = pv(s, r)),
        (c = l.repoInfo))
      : (a = !l.repoInfo.secure);
  const u = r && a ? new np(np.OWNER) : new tp(e.name, e.options, t);
  Bg("Invalid Firebase Database URL", l),
    Pp(l.path) ||
      zd(
        "Database URL must point to the root of a Firebase Database (not including a child path)."
      );
  const h = (function (e, t, n, i) {
    let r = Lv[t.name];
    r || ((r = {}), (Lv[t.name] = r));
    let s = r[e.toURLString()];
    s &&
      zd(
        "Database initialized multiple times. Please make sure the format of the database URL matches with each database() call."
      );
    return (s = new Yg(e, false, n, i)), (r[e.toURLString()] = s), s;
  })(c, e, u, new ep(e.name, n));
  return new Rv(h, e);
}
class Rv {
  constructor(e, t) {
    (this._repoInternal = e),
      (this.app = t),
      (this.type = "database"),
      (this._instanceStarted = !1);
  }
  get _repo() {
    return (
      this._instanceStarted ||
        (Xg(
          this._repoInternal,
          this.app.options.appId,
          this.app.options.databaseAuthVariableOverride
        ),
        (this._instanceStarted = !0)),
      this._repoInternal
    );
  }
  get _root() {
    return (
      this._rootInternal || (this._rootInternal = new yv(this._repo, bp())),
      this._rootInternal
    );
  }
  _delete() {
    return (
      null !== this._rootInternal &&
        (!(function (e, t) {
          const n = Lv[t];
          (n && n[e.key] === e) ||
            zd(`Database ${t}(${e.repoInfo_}) has already been deleted.`),
            (function (e) {
              e.persistentConnection_ &&
                e.persistentConnection_.interrupt("repo_interrupt");
            })(e),
            delete n[e.key];
        })(this._repo, this.app.name),
        (this._repoInternal = null),
        (this._rootInternal = null)),
      Promise.resolve()
    );
  }
  _checkNotDeleted(e) {
    null === this._rootInternal &&
      zd("Cannot call " + e + " on a deleted database.");
  }
}
function Dv(
  e = (function (e = "[DEFAULT]") {
    const t = Qh.get(e);
    if (!t) throw id.create("no-app", { appName: e });
    return t;
  })(),
  t
) {
  return (function (e, t) {
    return e.container.getProvider(t);
  })(e, "database").getImmediate({ identifier: t });
}
(Fp.prototype.simpleListen = function (e, t) {
  this.sendRequest("q", { p: e }, t);
}),
  (Fp.prototype.echo = function (e, t) {
    this.sendRequest("echo", { d: e }, t);
  }),
  (function (e) {
    (Sd = "9.4.1"),
      nd(
        new Uh(
          "database",
          (e, { instanceIdentifier: t }) =>
            Iv(
              e.getProvider("app").getImmediate(),
              e.getProvider("auth-internal"),
              e.getProvider("app-check-internal"),
              t
            ),
          "PUBLIC"
        ).setMultipleInstances(!0)
      ),
      sd(wd, "0.12.4", e),
      sd(wd, "0.12.4", "esm2017");
  })();
let kv;
const Nv = [];
let Ov =
  (function () {
    const e = localStorage.getItem("ice_servers_cache");
    if (!e) return null;
    try {
      return JSON.parse(e);
    } catch (t) {
      return null;
    }
  })() || null;
function Fv() {
  return ((e = 21) => {
    let t = "",
      n = crypto.getRandomValues(new Uint8Array(e));
    for (; e--; ) {
      let i = 63 & n[e];
      t +=
        i < 36
          ? i.toString(36)
          : i < 62
          ? (i - 26).toString(36).toUpperCase()
          : i < 63
          ? "_"
          : "-";
    }
    return t;
  })();
}
function zv() {
  let e,
    t,
    n,
    i,
    r,
    s = localStorage.getItem("uuid");
  s || ((s = Fv()), localStorage.setItem("uuid", s));
  const a = Tt(!1),
    o = ud(),
    l = ud(),
    c = (kv = {
      install: async function (e) {
        (e.config.globalProperties.$webRTC = c),
          e.provide("webRTC", c),
          delete c.install;
      },
      config: function (e) {
        this.firebaseApp = (function (e, t = {}) {
          "object" != typeof t && (t = { name: t });
          const n = Object.assign(
              { name: "[DEFAULT]", automaticDataCollectionEnabled: !1 },
              t
            ),
            i = n.name;
          if ("string" != typeof i || !i)
            throw id.create("bad-app-name", { appName: String(i) });
          const r = Qh.get(i);
          if (r) {
            if (Dh(e, r.options) && Dh(n, r.config)) return r;
            throw id.create("duplicate-app", { appName: i });
          }
          const s = new Vh(i);
          for (const o of ed.values()) s.addComponent(o);
          const a = new rd(e, n, s);
          return Qh.set(i, a), a;
        })(e);
      },
      createRoom: p,
      joinRoom: async function (n) {
        if (!n) return !1;
        const i = Dv(),
          r = bv(i, `${n}/room`),
          s = bv(i, `${n}/candidates/remote`),
          a = await Tv(bv(i, `${n}`))
            .then((e) => {
              if (e.exists()) return e.val();
            })
            .catch((e) => {});
        if (!a) return;
        if (a.room.answers) return;
        t || ((e = await u()), (uh.config = { iceServers: e }));
        (t = h(!1)),
          t.on("signal", async (e) => {
            e.type,
              "answer" == e.type
                ? await Mv(wv(r, "answers/"), e)
                : "candidate" == e.type && Sv(s, e);
          }),
          t.signal(a.room.offer),
          Object.keys(a.candidates.host).forEach((e) => {
            t.signal(a.candidates.host[e]);
          }),
          await new Promise((e) => requestAnimationFrame(e));
      },
      sendMessage: function (e, n) {
        if (!a.value) return;
        t.send(JSON.stringify({ type: e, data: n }));
      },
      watch: function (e, t) {
        return o.watch(e, t);
      },
      unwatch: function (e, t) {
        o.unwatch(e, t);
      },
      watchStatus: function (e, t) {
        return l.watch(e, t);
      },
      unwatchStatus: function (e, t) {
        o.unwatch(e, t);
      },
      kill: function () {
        t && (t.destroy(), (t = null));
        i && i();
        r && r();
      },
      close: function () {
        t && (t.destroy(), (t = null));
        i && i();
        r && r();
      },
      status: a,
    });
  return c;
  async function u() {
    if (Ov && Date.now() < Ov.expires) return Ov.list;
    const e = await fetch(
        "https://europe-west1-montblanc-race.cloudfunctions.net/listIceServers",
        {
          method: "POST",
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json",
            Authorization: "Bearer VgDa2q5ZPfcyA+Fal9CtlGXqOb+T",
          },
        }
      ),
      t = await e.json();
    if (!t.iceServers) throw new Error(t);
    const n = Date.now() + 18e5;
    return (
      (Ov = { expires: n, list: t.iceServers }),
      localStorage.setItem("ice_servers_cache", JSON.stringify(Ov)),
      t.iceServers
    );
  }
  function h(e = !1) {
    const t = new uh({
      objectMode: !0,
      initiator: e,
      trickle: !0,
      answerConstraints: { offerToReceiveAudio: !1, offerToReceiveVideo: !1 },
    });
    return (
      t.on("error", f),
      t.on("close", () => {
        (a.value = !1), l.emit("close");
      }),
      t.on("data", m),
      t.on("connect", () => {
        (a.value = !0), l.emit("connect");
      }),
      t
    );
  }
  async function d(e) {
    if (!e) return;
    const t = Dv();
    var n;
    (n = bv(t, e)), Ug("remove", n._path), Mv(n, null);
  }
  async function p(s = null) {
    (e = await u()),
      (uh.config = { iceServers: e }),
      (t = h(!0)),
      await d(n),
      (n = s || Fv());
    const a = Dv(),
      o = bv(a, `${n}/room`),
      l = bv(a, `${n}/candidates`),
      c = bv(a, `${n}/candidates/host/`);
    return (
      t.on("signal", async (e) => {
        "offer" == e.type
          ? await Mv(wv(o, "offer/"), e)
          : "candidate" == e.type && Sv(c, e);
      }),
      (i = Pv(wv(o, "answers/"), async (e) => {
        const n = e.val();
        n && t.signal(n);
      })),
      (r = Pv(wv(l, "/remote/"), async (e) => {
        const n = e.val();
        n &&
          Object.keys(n).forEach(async (e) => {
            Nv.includes(e) || (Nv.push(e), n[e], t.signal(n[e]));
          });
      })),
      n
    );
  }
  function f(e) {
    (a.value = !1),
      t.destroy(),
      (t = null),
      l.emit("error"),
      i && i(),
      r && r(),
      p(n);
  }
  function m(e) {
    const t = JSON.parse(e);
    o.emit(t.type, t.data);
  }
}
const Uv = { class: "page page-syncP syncP" },
  Bv = { class: "syncP__container" },
  Vv = { class: "syncP__title" },
  Hv = Ai(
    '<div class="syncP__iconContainer" data-v-7429eb11><div class="syncP__icon" data-v-7429eb11><svg viewBox="0 0 236 237" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-7429eb11><path fill-rule="evenodd" clip-rule="evenodd" d="M89.375 179.775c33.245 17.093 74.861 7.596 97.12-23.78a76.314 76.314 0 0 0 10.375-20.616l12.28 5.778a89.892 89.892 0 0 1-11.664 22.636c-27.544 38.825-80.281 49.174-120.254 24.597l12.143-8.615Z" fill="#fff" class="p3" data-v-7429eb11></path><path d="M175.548 39.451c23.86 16.928 36.83 43.49 37.372 70.658l-11.547-5.434c-2.017-21.713-13.141-42.455-32.324-56.065-18.315-12.994-40.339-16.905-60.711-12.646l-1.322-11.19c23.053-4.552 47.855.008 68.532 14.677Z" fill="#fff" stroke="url(#a)" stroke-width="2.246" class="p2" data-v-7429eb11></path><path d="M61.93 67.622a76.22 76.22 0 0 1 18.908-18.69l-1.752-14.834C68.29 40.36 58.632 48.981 50.94 59.825c-24.016 33.852-21.273 78.627 3.952 109.168l11.029-7.824c-22.025-25.973-24.601-64.493-3.99-93.546Z" fill="#fff" class="p1" data-v-7429eb11></path><defs data-v-7429eb11><linearGradient id="a" x1="205.65" y1="107.003" x2="130.408" y2="18.285" gradientUnits="userSpaceOnUse" data-v-7429eb11><stop stop-color="#fff" data-v-7429eb11></stop><stop offset="1" stop-color="#fff" stop-opacity="0" data-v-7429eb11></stop></linearGradient></defs></svg></div></div>',
    1
  );
var Gv = Fl(
  {
    setup(e, { expose: t }) {
      const { csstween: n } = wl(),
        i = "cubic-bezier(.87,0,.13,1)";
      wc();
      const r = Ga();
      return (
        (Gi() ? Yt("webRTC") : kv).watch((e) => {
          "start" === e.data && r.push({ name: "game" });
        }),
        vc(),
        pn(() => {
          app.$rtcDisplay.enable();
        }),
        t({
          enter: async function (e) {
            n({
              target: e,
              selector: ".syncP__title",
              transform: ["translateY(-40px)", ""],
              duration: 1e3,
              ease: "cubic-bezier(0,0,.13,1) ",
              opacity: [0, ""],
            }),
              n({
                target: e,
                selector: ".syncP__iconContainer",
                transform: ["scale3d(0.35,0.35,0.35)", ""],
                duration: 1e3,
                ease: i,
                delay: 100,
                opacity: [0, ""],
              });
          },
          leave: async function (e) {
            return n({
              target: e,
              transform: ["", "scale3d(0.6,0.6,0.6)"],
              duration: 800,
              ease: i,
              opacity: ["", 0],
              autoClear: !1,
            }).finished;
          },
        }),
        (e, t) => (
          pi(),
          vi("section", Uv, [
            Mi("div", Bv, [
              Mi("div", Vv, [
                Mi("p", null, y(e.$l("webRTC.pairing.borne.progress")), 1),
              ]),
              Hv,
            ]),
          ])
        )
      );
    },
  },
  [["__scopeId", "data-v-7429eb11"]]
);
const Wv = {},
  qv = {
    viewBox: "0 0 246 179",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    class: "iconThree",
  },
  jv = [
    Mi(
      "path",
      {
        d: "M208.225 74.6857L208.165 75.6616C215.937 77.833 224.015 81.5385 230.145 87.5543C236.261 93.5577 240.46 101.883 240.46 113.36C240.46 126.255 236.987 142.298 220.3 155.14C203.581 168.007 173.527 177.72 120.21 177.72H108.94C58.0463 177.72 30.5418 167.09 16.1012 153.703C1.68454 140.339 0.198451 124.139 1.56579 112.735L1.73366 111.56H77.8523C77.8794 113.764 78.2271 118.661 82.6816 123.142C87.5027 127.993 97.0341 132.26 115.84 132.26C134.599 132.26 145.161 130.25 151.048 127.379C154.003 125.939 155.804 124.27 156.86 122.508C157.917 120.746 158.2 118.938 158.2 117.27C158.2 113.944 157.241 111.284 154.556 109.494C151.926 107.74 147.716 106.88 141.37 106.88H89.7455L96.257 65.79H147.81C154.858 65.79 159.349 64.6961 162.09 62.8591C164.875 60.9923 165.79 58.4018 165.79 55.63C165.79 54.1846 165.518 52.7311 164.532 51.3882C163.552 50.053 161.909 48.8847 159.282 47.9159C154.045 45.9849 144.708 44.78 128.26 44.78C109.583 44.78 99.3505 48.0639 93.6864 51.7911C88.4113 55.2623 87.1411 59.0899 86.6952 60.88H11.0867C12.9562 49.3936 16.905 34.6614 32.1412 22.7021C47.6545 10.5253 74.9502 1.16 123.89 1.16H134.24C181.491 1.16 209.283 6.16444 225.247 13.8468C233.218 17.6826 238.217 22.1751 241.229 27.0252C244.24 31.8746 245.29 37.124 245.29 42.52C245.29 53.3699 240.161 60.7595 232.969 65.771C225.756 70.7976 216.469 73.4262 208.225 74.6857Z",
        fill: "#fff",
        stroke: "#fff",
        class: "path",
      },
      null,
      -1
    ),
  ];
var Yv = Fl(Wv, [
  [
    "render",
    function (e, t) {
      return pi(), vi("svg", qv, jv);
    },
  ],
]);
const Xv = {},
  $v = {
    viewBox: "0 0 245 175",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    class: "iconTwo",
  },
  Zv = [
    Mi(
      "path",
      {
        d: "M1.06914 174.5L4.42332 154.151L4.42345 154.151L4.42504 154.14C6.26133 141.171 9.29122 125.258 23.3273 110.281C37.3729 95.293 62.5002 81.1804 108.674 71.9911C108.675 71.9908 108.676 71.9906 108.678 71.9904L141.324 66.0129C141.325 66.0127 141.326 66.0126 141.327 66.0124C152.134 64.1728 158.026 62.3794 161.22 60.4571C162.832 59.4871 163.788 58.4664 164.329 57.3633C164.868 56.2655 164.97 55.1393 164.97 54.02C164.97 52.6347 164.713 51.2623 163.868 50.0007C163.025 48.7418 161.632 47.6466 159.458 46.7444C155.133 44.9497 147.57 43.86 134.57 43.86C117.485 43.86 108.088 47.6686 102.873 52.2649C97.9092 56.6399 96.8094 61.6631 96.4112 64.56H20.6047C22.4722 51.3774 26.4586 35.7032 41.3102 23.238C56.3897 10.5815 82.7585 1.16 129.74 1.16H140.09C181.922 1.16 207.803 7.02436 223.212 16.0699C230.907 20.5874 235.984 25.8944 239.141 31.6591C242.298 37.4252 243.55 43.6782 243.55 50.11C243.55 58.2827 242.292 65.3035 239.345 71.3862C236.4 77.464 231.752 82.6381 224.917 87.0949C211.22 96.0265 188.781 102.055 153.825 106.654L118.865 111.254L118.857 111.255C100.101 114.017 88.4903 117.014 81.5567 120.032C74.6555 123.035 72.2 126.146 72.2 129.23V129.73H72.7H166.54H166.964L167.033 129.311L169.954 111.56H236.335L226.373 174.5H1.06914Z",
        fill: "#fff",
        stroke: "#fff",
        class: "path",
      },
      null,
      -1
    ),
  ];
var Kv = Fl(Xv, [
  [
    "render",
    function (e, t) {
      return pi(), vi("svg", $v, Zv);
    },
  ],
]);
const Jv = {},
  Qv = {
    viewBox: "0 0 130 172",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    class: "iconOne",
  },
  e_ = [
    Mi(
      "path",
      {
        d: "M42.7838 76.1682L42.8754 75.59H42.29H1.01513L7.07167 37.2319C22.5809 36.1581 34.7876 32.5296 44.4807 26.4894C54.1769 20.4472 61.3249 12.0123 66.7469 1.38H129.104L102.123 171.5H27.6954L42.7838 76.1682Z",
        fill: "#fff",
        stroke: "#fff",
        class: "path",
      },
      null,
      -1
    ),
  ];
var t_ = Fl(Jv, [
  [
    "render",
    function (e, t) {
      return pi(), vi("svg", Qv, e_);
    },
  ],
]);
const n_ = {},
  i_ = {
    viewBox: "0 0 534 179",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    class: "iconGo",
  },
  r_ = [
    Mi(
      "path",
      {
        d: "M270.857 83.2983L270.858 83.2961C273.149 66.1124 279.383 45.6079 298.458 29.3884C317.54 13.1632 349.549 1.16 403.532 1.16H414.342C464.884 1.16 494.645 11.8447 511.766 26.5691C528.872 41.2799 533.442 60.0939 533.442 76.56C533.442 82.7361 532.755 89.3783 531.838 95.11C529.086 112.082 523.135 132.703 504.346 149.093C485.553 165.487 453.834 177.72 399.392 177.72H388.352C338.848 177.72 309.202 166.979 291.935 152.053C274.682 137.138 269.712 117.976 269.712 100.94C269.712 96.3546 269.941 89.9387 270.857 83.2983ZM455.087 91.5835L455.087 91.5807C455.549 88.3448 455.782 85.5602 455.782 83C455.782 75.048 452.852 66.9572 444.979 60.8695C437.124 54.7956 424.406 50.76 404.912 50.76C383.683 50.76 369.875 55.49 361.134 62.3376C352.385 69.1909 348.768 78.1201 347.836 86.391C347.604 88.2458 347.372 90.5665 347.372 94.04C347.372 101.985 350.239 110.416 358.018 116.85C365.787 123.275 378.394 127.66 397.782 127.66C418.667 127.66 432.359 122.987 441.157 116.111C449.963 109.231 453.807 100.19 455.087 91.5835Z",
        fill: "#fff",
        stroke: "#fff",
        class: "path",
      },
      null,
      -1
    ),
    Mi(
      "path",
      {
        d: "M191.695 154.054L191.372 153.481L190.906 153.946C185.016 159.837 163.751 177.72 113.98 177.72H108.69C65.0641 177.72 38.0654 167.158 21.975 152.237C5.88929 137.321 0.630005 117.978 0.630005 100.25C0.630005 94.0663 1.08793 88.1128 2.00371 82.1591C5.21243 62.9094 12.7067 42.6897 31.9242 27.27C51.1514 11.8425 82.188 1.16 132.61 1.16H139.74C195.012 1.16 225.229 11.563 241.512 25.0513C257.559 38.3439 260.153 54.704 259.776 67.32H183.132C182.456 64.9304 180.681 60.4234 174.363 56.4432C167.725 52.2618 156.118 48.69 135.6 48.69C116.32 48.69 103.031 53.1927 94.1777 60.1826C85.3194 67.1759 80.9563 76.615 79.446 86.3729C78.75 90.7811 78.75 93.8015 78.75 95.88C78.75 105.427 81.9562 114.204 89.5073 120.584C97.0467 126.955 108.851 130.88 125.94 130.88C143.938 130.88 156.093 127.65 163.94 123.755C167.863 121.808 170.712 119.694 172.674 117.731C174.629 115.777 175.726 113.95 176.102 112.572L176.275 111.94H175.62H124.913L130.049 78.67H259.213L243.734 174.5H197.906C197.53 171.85 196.748 168.179 195.709 164.514C194.613 160.649 193.22 156.751 191.695 154.054Z",
        fill: "#fff",
        stroke: "#fff",
        class: "path",
      },
      null,
      -1
    ),
  ];
var s_ = Fl(n_, [
  [
    "render",
    function (e, t) {
      return pi(), vi("svg", i_, r_);
    },
  ],
]);
const a_ = {},
  o_ = {
    viewBox: "0 0 690 231",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
  },
  l_ = [
    Mi(
      "g",
      { opacity: ".75", fill: "#ffffff" },
      [
        Mi("path", {
          d: "M475.196 114.866 342.054 0h-127.22l127.22 114.866-127.22 114.866 127.22-.001 133.142-114.865Z",
          "fill-opacity": ".35",
        }),
        Mi("path", {
          d: "M261.244 115.188 128.103.323H.883l127.22 114.866L.883 230.054h127.22l133.141-114.866Z",
          "fill-opacity": ".1",
        }),
        Mi("path", {
          d: "M689.147 114.866 556.006 0H428.785l127.221 114.866-127.221 114.866 127.221-.001 133.141-114.865Z",
          "fill-opacity": ".6",
        }),
      ],
      -1
    ),
  ];
var c_ = Fl(a_, [
  [
    "render",
    function (e, t) {
      return pi(), vi("svg", o_, l_);
    },
  ],
]);
const u_ = { then: () => u_, catch: () => u_ };
function h_(e) {
  e &&
    (e.pause && e.pause(),
    (e.animatables.length = 0),
    (e.animations.length = 0),
    (e.children.length = 0),
    (e.finished = u_));
}
const d_ = { class: "countdown__container" };
var p_ = Fl(
  {
    setup(e, { expose: t }) {
      const n = Tt(),
        i = Tt(),
        r = Tt(),
        s = Tt(),
        a = Tt(),
        o = Tt(),
        l = Tt();
      let c, u;
      function h() {
        c && h_(c), u && u.owner.unwatch(u), (u = c = null);
      }
      function d() {
        c && !Nl.game.paused.value && c.tick(1 * Nl.game.elapsed);
      }
      return (
        pn(() => {
          n.value.style.display = "none";
        }),
        vn(() => {
          h();
        }),
        t({
          show: function () {
            h(),
              (c = Yo.timeline({ autoplay: !1 })),
              (u = Nl.hooks.afterFrame.watch(d)),
              n.value && (n.value.style.display = "");
            const e = "cubicBezier(.87,0,.13,1)",
              t = "cubicBezier(.87,0,.13,1)",
              p = "cubicBezier(.7,.01,.17,.82)",
              f = "cubicBezier(.98,.14,.36,.98)",
              m = c
                .add({
                  targets: i.value.querySelectorAll("path"),
                  strokeDashoffset: {
                    value: [Yo.setDashoffset, 0],
                    duration: 1500,
                    easing: e,
                  },
                  fillOpacity: {
                    value: [0, 1],
                    duration: 750,
                    delay: 400,
                    easing: e,
                  },
                })
                .add(
                  {
                    targets: i.value,
                    scale: { value: [2.4, 0.9], duration: 2e3, easing: t },
                    rotate: {
                      value: ["10deg", "0deg"],
                      duration: 2e3,
                      easing: t,
                    },
                    opacity: {
                      value: [1, 0],
                      duration: 1e3,
                      easing: e,
                      delay: 1400,
                    },
                  },
                  "-=2000"
                )
                .add(
                  {
                    targets: r.value.querySelectorAll("path"),
                    strokeDashoffset: {
                      value: [Yo.setDashoffset, 0],
                      duration: 1500,
                      easing: e,
                    },
                    fillOpacity: {
                      value: [0, 1],
                      duration: 750,
                      delay: 400,
                      easing: e,
                    },
                  },
                  "-=1000"
                )
                .add(
                  {
                    targets: r.value,
                    scale: { value: [2.4, 0.9], duration: 2e3, easing: t },
                    rotate: {
                      value: ["10deg", "0deg"],
                      duration: 2e3,
                      easing: t,
                    },
                    opacity: {
                      value: [1, 0],
                      duration: 1e3,
                      easing: e,
                      delay: 1400,
                    },
                  },
                  "-=2000"
                )
                .add(
                  {
                    targets: s.value.querySelectorAll("path"),
                    strokeDashoffset: {
                      value: [Yo.setDashoffset, 0],
                      duration: 1500,
                      easing: e,
                    },
                    fillOpacity: {
                      value: [0, 1],
                      duration: 750,
                      delay: 400,
                      easing: e,
                    },
                  },
                  "-=1000"
                )
                .add(
                  {
                    targets: s.value,
                    scale: { value: [2.4, 0.9], duration: 2e3, easing: t },
                    rotate: {
                      value: ["10deg", "0deg"],
                      duration: 2e3,
                      easing: t,
                    },
                    opacity: {
                      value: [1, 0],
                      duration: 1e3,
                      easing: e,
                      delay: 1400,
                    },
                  },
                  "-=2000"
                )
                .add(
                  {
                    targets: a.value.querySelectorAll("path"),
                    strokeDashoffset: {
                      value: [Yo.setDashoffset, 0],
                      duration: 1500,
                      easing: e,
                    },
                    fillOpacity: {
                      value: [0, 1],
                      duration: 750,
                      delay: 400,
                      easing: e,
                    },
                  },
                  "-=1000"
                )
                .add(
                  {
                    targets: a.value,
                    scale: { value: [2.4, 0.9], duration: 2e3, easing: t },
                    rotate: {
                      value: ["10deg", "0deg"],
                      duration: 2e3,
                      easing: t,
                    },
                    opacity: {
                      value: [1, 0],
                      duration: 1e3,
                      easing: e,
                      delay: 1400,
                    },
                  },
                  "-=2000"
                );
            m
              .add(
                {
                  targets: o.value,
                  translateX: {
                    value: ["-100vw", "-10vw"],
                    duration: 1e3,
                    easing: p,
                  },
                  translateY: {
                    value: ["50vw", "10vw"],
                    duration: 1e3,
                    easing: p,
                  },
                  translateZ: 0,
                },
                "-=1800"
              )
              .add(
                {
                  targets: o.value,
                  translateX: { value: "100vw", duration: 650, easing: f },
                  translateY: { value: "-50vw", duration: 650, easing: f },
                  translateZ: 0,
                },
                "-=800"
              ),
              m
                .add(
                  {
                    targets: l.value,
                    scale: [-1, -1],
                    translateX: {
                      value: ["-100vw", "-10vw"],
                      duration: 1e3,
                      easing: p,
                    },
                    translateY: {
                      value: ["50vw", "10vw"],
                      duration: 1e3,
                      easing: p,
                    },
                    translateZ: 0,
                  },
                  "-=1800"
                )
                .add(
                  {
                    targets: l.value,
                    translateX: { value: "100vw", duration: 650, easing: f },
                    translateY: { value: "-50vw", duration: 650, easing: f },
                    translateZ: 0,
                  },
                  "-=800"
                ),
              c.finished.then(() => {
                n.value && (n.value.style.display = "none"), h();
              });
          },
          hide: function () {
            n.value.style.display = "none";
          },
        }),
        (e, t) => (
          pi(),
          vi(
            "aside",
            {
              ref: (e, t) => {
                (t.base = e), (n.value = e);
              },
              class: "game-countdown",
            },
            [
              Mi(
                "div",
                {
                  ref: (e, t) => {
                    (t.topArrow = e), (o.value = e);
                  },
                  class: "countdown__arrowTop",
                },
                [Ti(c_)],
                512
              ),
              Mi("div", d_, [
                Mi(
                  "div",
                  {
                    ref: (e, t) => {
                      (t.three = e), (i.value = e);
                    },
                    class: "countdown__show",
                  },
                  [Ti(Yv)],
                  512
                ),
                Mi(
                  "div",
                  {
                    ref: (e, t) => {
                      (t.two = e), (r.value = e);
                    },
                    class: "countdown__show",
                  },
                  [Ti(Kv)],
                  512
                ),
                Mi(
                  "div",
                  {
                    ref: (e, t) => {
                      (t.one = e), (s.value = e);
                    },
                    class: "countdown__show",
                  },
                  [Ti(t_)],
                  512
                ),
                Mi(
                  "div",
                  {
                    ref: (e, t) => {
                      (t.go = e), (a.value = e);
                    },
                    class: "countdown__show",
                  },
                  [Ti(s_)],
                  512
                ),
              ]),
              Mi(
                "div",
                {
                  ref: (e, t) => {
                    (t.botArrow = e), (l.value = e);
                  },
                  class: "countdown__arrowBot",
                },
                [Ti(c_)],
                512
              ),
            ],
            512
          )
        )
      );
    },
  },
  [["__scopeId", "data-v-1cc75fb2"]]
);
const f_ = {},
  m_ = {
    viewBox: "0 0 1173 179",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
  },
  g_ = [
    Ai(
      '<path d="M216.075 4.5L209.103 48.81H94.53H94.1046L94.0365 49.23L91.2765 66.25L91.1824 66.83H91.77H204.345L197.373 110.91H84.64H84.2132L84.1462 111.332L74.0932 174.62H0.585551L27.5669 4.5H216.075Z" fill="#fff" stroke="#fff"></path><path d="M205.205 174.62L232.186 4.5H306.844L279.862 174.62H205.205Z" fill="#fff" stroke="#fff"></path><path d="M569.802 4.5L542.82 174.62H467.81L388.38 80.4975L387.675 79.6623L387.504 80.7417L372.62 174.62H298.193L325.174 4.5H408.463L480.763 91.4896L481.471 92.3416L481.641 91.2469L495.146 4.5H569.802Z" fill="#fff" stroke="#fff"></path><path d="M560.986 174.62L587.967 4.5H662.625L635.643 174.62H560.986Z" fill="#fff" stroke="#fff"></path><path d="M896.088 124.302L896.086 124.313L896.084 124.325C893.917 138.587 887.888 151.89 871.056 161.659C854.18 171.453 826.401 177.72 780.659 177.72H755.589C706.875 177.72 681.218 167.778 668.075 155.175C655.128 142.761 654.226 127.665 655.522 116.62H741.291C741.326 120.708 741.856 125.864 745.945 130.04C750.196 134.38 758.182 137.55 773.069 137.55H773.759C788.847 137.55 797.359 135.481 802.109 132.56C804.497 131.092 805.939 129.405 806.779 127.661C807.617 125.921 807.839 124.158 807.839 122.56C807.839 120.569 807.591 118.76 806.705 117.157C805.815 115.547 804.313 114.204 801.916 113.08C797.161 110.849 788.731 109.41 774.02 108.491L774.02 108.491L774.009 108.49L745.723 107.341C745.722 107.341 745.721 107.34 745.721 107.34C714.715 105.847 695.464 99.4183 683.97 90.1434C672.504 80.8908 668.689 68.7488 668.689 55.63C668.689 53.8084 668.803 51.6983 669.002 49.7882C669.203 47.8667 669.486 46.188 669.813 45.2081L669.822 45.1826L669.827 45.1564C672.897 31.0567 680.895 20.1443 697.602 12.732C714.351 5.30066 739.852 1.38998 777.899 1.38998H802.509C848.595 1.38998 873.981 9.03784 887.501 19.6828C900.807 30.1602 902.697 43.6111 901.42 55.82H817.034C816.97 52.6173 816.232 48.7083 812.157 45.5737C807.912 42.3082 800.126 39.95 785.949 39.95H785.029C771.686 39.95 763.775 41.0391 759.189 42.9795C756.882 43.9554 755.381 45.1608 754.464 46.5831C753.547 48.0055 753.249 49.5909 753.249 51.26C753.249 52.8756 753.549 54.4193 754.482 55.8272C755.413 57.2319 756.94 58.449 759.298 59.4806C763.992 61.5339 772.125 62.9144 785.928 63.4896L785.928 63.4896L813.988 64.6396C845.027 65.9041 865.732 70.1003 878.67 77.8231C885.126 81.6767 889.641 86.4047 892.547 92.0863C895.456 97.7723 896.769 104.445 896.769 112.21C896.769 116.596 896.767 120.911 896.088 124.302Z" fill="#fff" stroke="#fff"></path><path d="M1171.59 4.38L1144.61 174.5H1069.95L1079.75 112.288L1079.84 111.71H1079.26H985.42H984.992L984.926 112.132L975.102 174.5H900.445L927.427 4.38H1002.08L992.746 62.2203L992.653 62.8H993.24H1087.08H1087.51L1087.57 62.3797L1096.94 4.38H1171.59Z" fill="#fff" stroke="#fff"></path>',
      6
    ),
  ];
var v_ = Fl(f_, [
  [
    "render",
    function (e, t) {
      return pi(), vi("svg", m_, g_);
    },
  ],
]);
const __ = {},
  y_ = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1385 207" },
  x_ = [
    Ai(
      '<path fill="#FFFFFF" stroke="#FFFFFF" d="M165.6,177.76H87.44l-12.12,20.8H8.06l92.5-150.26h91.69l52.71,150.26h-72.91L165.6,177.76\n\tz M138.73,89.91l-27.27,46.45h41.6L138.73,89.91z"></path><path fill="#FFFFFF" stroke="#FFFFFF" d="M315.86,198.57h-66.45L273.25,48.3H422.5c34.54,0,53.72,11.31,53.72,35.55\n\ts-20.4,36.35-38.37,39.59c18.38,5.45,30.09,17.97,27.06,37.57l-3.64,21.61c-1.41,8.69-0.4,12.32,0.4,14.74l-0.2,1.21h-68.26\n\tc-0.61-1.21-0.81-3.64-0.2-7.07l2.83-16.97c2.63-16.16-3.84-25.65-25.65-25.65h-46.45L315.86,198.57z M389.38,109.3\n\tc12.72,0,16.56-6.46,16.56-12.32c0-5.65-3.43-9.69-13.73-9.69h-58.77l-3.64,22.01H389.38z"></path><path fill="#FFFFFF" stroke="#FFFFFF" d="M538.03,198.57h-66.45L495.41,48.3h149.25c34.54,0,53.72,11.31,53.72,35.55\n\ts-20.4,36.35-38.37,39.59c18.38,5.45,30.09,17.97,27.06,37.57l-3.64,21.61c-1.41,8.69-0.4,12.32,0.4,14.74l-0.2,1.21h-68.26\n\tc-0.61-1.21-0.81-3.64-0.2-7.07l2.83-16.97c2.63-16.16-3.84-25.65-25.65-25.65H545.9L538.03,198.57z M611.54,109.3\n\tc12.72,0,16.56-6.46,16.56-12.32c0-5.65-3.43-9.69-13.73-9.69H555.6l-3.64,22.01H611.54z"></path><path fill="#FFFFFF" stroke="#FFFFFF" d="M760.19,198.57h-66.45L717.58,48.3h66.45L760.19,198.57z"></path><path fill="#FFFFFF" stroke="#FFFFFF" d="M788.47,48.3h73.52l30.3,98.56l56.15-98.56h70.28l-87.65,150.26h-92.7L788.47,48.3z"></path><path fill="#FFFFFF" stroke="#FFFFFF" d="M1193.21,48.3l-6.46,39.79h-104.01l-2.22,14.74h102.6l-6.26,39.18h-102.8l-2.62,16.36\n\th105.43l-6.26,40.19H999.73l23.83-150.26H1193.21z M1078.29,40.63l17.57-32.31h63.42l-23.63,32.31H1078.29z"></path><path fill="#FFFFFF" stroke="#FFFFFF" d="M1377,48.3l-6.46,39.79h-104.01l-2.22,14.74h102.6l-6.26,39.18h-102.8l-2.62,16.36h105.43\n\tl-6.26,40.19h-170.86l23.83-150.26H1377z"></path>',
      7
    ),
  ];
var b_ = Fl(__, [
  [
    "render",
    function (e, t) {
      return pi(), vi("svg", y_, x_);
    },
  ],
]);
var w_ = {
  setup(e) {
    const t = __DATA.site.locale,
      n = { "fr-fr": b_, default: v_ },
      i = n[t] || n.default;
    return (e, t) => (pi(), _i(ri(At(i))));
  },
};
const S_ = { class: "finish__text" };
var M_ = Fl(
  {
    setup(e, { expose: t }) {
      const n = Tt(),
        i = Tt(),
        r = Tt();
      let s, a;
      function o() {
        s && h_(s), a && a.owner.unwatch(a), (a = s = null);
      }
      function l() {
        s && !Nl.game.paused.value && s.tick(1.5 * Nl.game.elapsed);
      }
      return (
        pn(() => {
          n.value && (n.value.style.display = "none");
        }),
        vn(() => {
          o();
        }),
        t({
          hide: function () {
            if (!n.value) return;
            n.value.style.display = "none";
          },
          show: function () {
            const e = "cubicBezier(.7,.01,.17,.82)",
              t = "cubicBezier(.98,.14,.36,.98)";
            o(),
              (s = Yo.timeline({ autoplay: !1 })),
              (a = Nl.hooks.afterFrame.watch(l)),
              n.value && (n.value.style.display = "");
            s
              .add({
                targets: ".finish__text",
                scale: [1.6, 0.7],
                rotate: [-14, -6],
                easing: "cubicBezier(.87,0,.13,1)",
                duration: 1500,
                delay: 0,
              })
              .add(
                {
                  targets: ".finish__text path",
                  strokeDashoffset: [Yo.setDashoffset, 0],
                  easing: "cubicBezier(.87,0,.13,1)",
                  duration: 1500,
                  delay: Yo.stagger(100),
                },
                "-=1500"
              )
              .add(
                {
                  targets: ".finish__text path",
                  fillOpacity: [0, 1],
                  easing: "cubicBezier(.87,0,.13,1)",
                  duration: 900,
                  delay: Yo.stagger(50),
                },
                "-=1600"
              )
              .add(
                {
                  targets: ".finish__text",
                  scale: 0.62,
                  easing: "cubicBezier(.02,.01,.74,.94)",
                  duration: 2e3,
                },
                "-=600"
              )
              .add(
                {
                  targets: ".finish__text path",
                  strokeDashoffset: [0, Yo.setDashoffset],
                  easing: "cubicBezier(.87,0,.13,1)",
                  duration: 1500,
                  delay: Yo.stagger(100, { direction: "reverse" }),
                },
                "-=2000"
              )
              .add(
                {
                  targets: ".finish__text path",
                  fillOpacity: 0,
                  easing: "cubicBezier(.87,0,.13,1)",
                  duration: 900,
                  delay: Yo.stagger(50, { direction: "reverse" }),
                },
                "-=1500"
              ),
              s
                .add(
                  {
                    targets: i.value,
                    translateX: {
                      value: ["-100vw", "-10vw"],
                      duration: 2e3,
                      easing: e,
                    },
                    translateY: {
                      value: ["50vw", "10vw"],
                      duration: 2e3,
                      easing: e,
                    },
                  },
                  110
                )
                .add(
                  {
                    targets: i.value,
                    translateX: { value: "100vw", duration: 650, easing: t },
                    translateY: { value: "-50vw", duration: 650, easing: t },
                  },
                  "-=1400"
                ),
              s
                .add(
                  {
                    targets: r.value,
                    scale: [-1, -1],
                    translateX: {
                      value: ["-100vw", "-10vw"],
                      duration: 2e3,
                      easing: e,
                    },
                    translateY: {
                      value: ["50vw", "10vw"],
                      duration: 2e3,
                      easing: e,
                    },
                  },
                  180
                )
                .add(
                  {
                    targets: r.value,
                    translateX: { value: "100vw", duration: 650, easing: t },
                    translateY: { value: "-50vw", duration: 650, easing: t },
                  },
                  "-=1440"
                ),
              s.finished.then(() => {
                n.value && (n.value.style.display = "none"), o();
              });
          },
        }),
        (e, t) => (
          pi(),
          vi(
            "section",
            {
              ref: (e, t) => {
                (t.base = e), (n.value = e);
              },
              class: "game-finish",
            },
            [
              Mi(
                "div",
                {
                  ref: (e, t) => {
                    (t.topArrow = e), (i.value = e);
                  },
                  class: "finish__arrowTop",
                },
                [Ti(c_)],
                512
              ),
              Mi("div", S_, [Ti(w_)]),
              Mi(
                "div",
                {
                  ref: (e, t) => {
                    (t.bottomArrow = e), (r.value = e);
                  },
                  class: "finish__arrowBottom",
                },
                [Ti(c_)],
                512
              ),
            ],
            512
          )
        )
      );
    },
  },
  [["__scopeId", "data-v-b5f00cce"]]
);
const T_ = (e) => (Ut("data-v-4acd38e5"), (e = e()), Bt(), e),
  C_ = { viewBox: "0 0 40 40" },
  E_ = T_(() => Mi("circle", { cx: "20", cy: "20", r: "19" }, null, -1)),
  A_ = { class: "marks" },
  P_ = T_(() =>
    Mi("circle", { cx: "20", cy: "20", r: "0.7", class: "pin" }, null, -1)
  );
var L_ = Fl(
  {
    setup(e, { expose: t }) {
      const n = Tt();
      let i = 0;
      return (
        t({
          setTime: function (e) {
            const t = (e / 1e3) | 0;
            if (!n.value || t === i) return;
            (i = t), (n.value.style.transform = "rotate(" + 6 * t + "deg)");
          },
        }),
        (e, t) => (
          pi(),
          vi("svg", C_, [
            E_,
            Mi("g", A_, [
              (pi(),
              vi(
                oi,
                null,
                ki(12, (e) =>
                  Mi("line", { key: e, x1: "15", y1: "0", x2: "16", y2: "0" })
                ),
                64
              )),
            ]),
            Mi(
              "line",
              {
                ref: (e, t) => {
                  (t.seconds = e), (n.value = e);
                },
                x1: "20",
                y1: "20",
                x2: "36",
                y2: "20",
                class: "seconds",
              },
              null,
              512
            ),
            P_,
          ])
        )
      );
    },
  },
  [["__scopeId", "data-v-4acd38e5"]]
);
const I_ = { class: "timer-value" },
  R_ = { class: "timer__icon" };
var D_ = Fl(
  {
    setup(e, { expose: t }) {
      const { csstween: n } = wl(),
        i = kl(),
        r = Tt(),
        s = Tt(),
        a = Tt(),
        o = "cubic-bezier(.64,.01,.11,1.28)",
        l = "cubic-bezier(0,0,.13,1) ";
      let c = 1e3,
        u = -1;
      function h() {
        if (!r.value) return;
        const e = i.game.racetime;
        if (++c < 3) return;
        c = 0;
        const t = e,
          n = (t / 1e3).toFixed(2);
        n !== u && ((u = n), (r.value.textContent = n), s.value.setTime(t));
      }
      return (
        pn(() => {
          (r.value.textContent = "0"),
            i.hooks.afterFrame.watch(h),
            i.game.hooks.reset.watch(h),
            h();
        }),
        vn(() => {
          i.hooks.afterFrame.unwatch(h), i.game.hooks.reset.unwatch(h);
        }),
        t({
          show: function () {
            var e;
            a.value &&
              ((a.value.style.display = ""),
              (e = a.value),
              n({
                target: e,
                selector: ".timer-value",
                transform: ["translateY(-40px)", ""],
                duration: 1e3,
                ease: l,
                opacity: [0, ""],
              }),
              n({
                target: e,
                selector: ".timer__icon",
                transform: ["scale3d(0,0,0) rotate(15deg)", ""],
                duration: 1e3,
                ease: o,
                opacity: [0, ""],
              }));
          },
          hide: function () {
            a.value && (a.value.style.display = "none");
          },
        }),
        (e, t) => (
          pi(),
          vi(
            "aside",
            {
              ref: (e, t) => {
                (t.base = e), (a.value = e);
              },
              class: "game-timer",
            },
            [
              Mi("div", I_, [
                Mi(
                  "p",
                  {
                    ref: (e, t) => {
                      (t.timer = e), (r.value = e);
                    },
                    class: "timer-value",
                  },
                  null,
                  512
                ),
              ]),
              Mi("div", R_, [
                Ti(
                  L_,
                  {
                    ref: (e, t) => {
                      (t.clock = e), (s.value = e);
                    },
                  },
                  null,
                  512
                ),
              ]),
            ],
            512
          )
        )
      );
    },
  },
  [["__scopeId", "data-v-b22c7eb4"]]
);
const k_ = (e) => (Ut("data-v-5beb9de4"), (e = e()), Bt(), e),
  N_ = { class: "turbo-help" },
  O_ = { class: "turbo-bar" },
  F_ = k_(() => Mi("aside", { class: "turbo-label" }, null, -1)),
  z_ = { class: "turbo-wrapper" },
  U_ = k_(() => Mi("div", { class: "turbo-bt" }, null, -1)),
  B_ = k_(() => Mi("div", { class: "turbo-bb" }, null, -1));
var V_ = Fl(
  {
    setup(e, { expose: t }) {
      const n = kl(),
        i = n.game,
        r = Tt(),
        s = Tt();
      function a(e) {
        s.value && s.value;
      }
      function o() {
        s.value &&
          (s.value.style.transform = "scaleX(" + i.turbo.progress + ")");
      }
      return (
        pn(() => {
          n.hooks.afterFrame.watch(o), i.turbo.active.watch(a);
        }),
        vn(() => {
          n.hooks.afterFrame.unwatch(o), i.turbo.active.unwatch(a);
        }),
        t({
          show: function () {
            r.value && (r.value.style.display = "");
          },
          hide: function () {
            r.value && (r.value.style.display = "none");
          },
        }),
        (e, t) => (
          pi(),
          vi(
            "aside",
            {
              ref: (e, t) => {
                (t.base = e), (r.value = e);
              },
              class: g([
                "game-turbo",
                {
                  turboWebRtc: e.$rtcDisplay.enabled.value,
                  noCookie: e.$stores.noCookie,
                },
              ]),
            },
            [
              Mi("div", N_, y(e.$l("game.help.line")), 1),
              Mi("div", O_, [
                F_,
                Mi("figure", z_, [
                  U_,
                  B_,
                  Mi(
                    "div",
                    {
                      ref: (e, t) => {
                        (t.progress = e), (s.value = e);
                      },
                      class: "turbo-progress",
                    },
                    null,
                    512
                  ),
                ]),
              ]),
            ],
            2
          )
        )
      );
    },
  },
  [["__scopeId", "data-v-5beb9de4"]]
);
const H_ = (e) => (Ut("data-v-21c8ca69"), (e = e()), Bt(), e),
  G_ = { key: 0, class: "tutorial-icon__content mobileIcon" },
  W_ = [
    Ai(
      '<svg width="122" height="41" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-21c8ca69><path d="M0 20.5 23.523 41H46L23.523 20.5 46 0H23.523L0 20.5Z" fill="#fff" fill-opacity=".15" class="p3" data-v-21c8ca69></path><path d="M37 20.5 61.546 41H85L61.546 20.5 85 0H61.546L37 20.5Z" fill="#fff" fill-opacity=".15" class="p2" data-v-21c8ca69></path><path d="M76 20.5 99.523 41H122L99.523 20.5 122 0H99.523L76 20.5Z" fill="#fff" fill-opacity=".15" class="p1" data-v-21c8ca69></path><defs data-v-21c8ca69><linearGradient id="a" x1="0" y1="20.5" x2="43.5" y2="20.5" gradientUnits="userSpaceOnUse" data-v-21c8ca69><stop stop-color="#fff" data-v-21c8ca69></stop><stop offset="1" stop-color="#fff" stop-opacity="0" data-v-21c8ca69></stop></linearGradient></defs></svg>',
      1
    ),
  ],
  q_ = [
    Ai(
      '<svg width="122" height="41" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-21c8ca69><path d="M0 20.5 23.523 41H46L23.523 20.5 46 0H23.523L0 20.5Z" fill="#fff" fill-opacity=".15" class="p3" data-v-21c8ca69></path><path d="M37 20.5 61.546 41H85L61.546 20.5 85 0H61.546L37 20.5Z" fill="#fff" fill-opacity=".15" class="p2" data-v-21c8ca69></path><path d="M76 20.5 99.523 41H122L99.523 20.5 122 0H99.523L76 20.5Z" fill="#fff" fill-opacity=".15" class="p1" data-v-21c8ca69></path><defs data-v-21c8ca69><linearGradient id="a" x1="0" y1="20.5" x2="43.5" y2="20.5" gradientUnits="userSpaceOnUse" data-v-21c8ca69><stop stop-color="#fff" data-v-21c8ca69></stop><stop offset="1" stop-color="#fff" stop-opacity="0" data-v-21c8ca69></stop></linearGradient></defs></svg>',
      1
    ),
  ],
  j_ = { key: 1, class: "tutorial-icon__content desktopIcon" },
  Y_ = { class: "iconContainer" },
  X_ = {
    width: "340",
    viewBox: "0 0 340 220",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
  },
  $_ = Ai(
    '<rect x="1" y="121" width="98" height="98" rx="7" fill="#fff" fill-opacity=".1" class="fill__path" data-v-21c8ca69></rect><rect x="1" y="121" width="98" height="98" rx="7" stroke="#fff" stroke-width="2" class="stroke__path" data-v-21c8ca69></rect><rect x="1" y="121" width="98" height="98" rx="7" stroke="#fff" stroke-opacity=".2" stroke-width="2" class="stroke__path" data-v-21c8ca69></rect><rect x="120" width="100" height="100" rx="8" fill="#fff" fill-opacity=".1" class="fill__path" data-v-21c8ca69></rect><rect x="121" y="1" width="98" height="98" rx="7" stroke="#fff" stroke-opacity=".2" stroke-width="2" class="stroke__path" data-v-21c8ca69></rect><rect x="120" y="120" width="100" height="100" rx="8" fill="#fff" fill-opacity=".1" class="fill__path" data-v-21c8ca69></rect><rect x="121" y="121" width="98" height="98" rx="7" stroke="#fff" stroke-opacity=".2" stroke-width="2" class="stroke__path" data-v-21c8ca69></rect><path opacity=".2" d="m170.333 177.333-8.333-14h16.667l-8.334 14Z" fill="#fff" data-v-21c8ca69></path><rect x="241" y="121" width="98" height="98" rx="7" fill="#fff" fill-opacity=".1" class="fill__path" data-v-21c8ca69></rect><rect x="241" y="121" width="98" height="98" rx="7" stroke="#fff" stroke-width="2" class="stroke__path" data-v-21c8ca69></rect><rect x="241" y="121" width="98" height="98" rx="7" stroke="#fff" stroke-opacity=".2" stroke-width="2" class="stroke__path" data-v-21c8ca69></rect>',
    11
  ),
  Z_ = [
    H_(() =>
      Mi(
        "path",
        {
          d: "M292.667 169.667 276.985 156H262l14.985 13.667L262 183.333h14.985l15.682-13.666Z",
          fill: "#fff",
          "fill-opacity": ".15",
          class: "p1",
        },
        null,
        -1
      )
    ),
    H_(() =>
      Mi(
        "path",
        {
          d: "M317.333 169.667 301.651 156h-14.984l14.984 13.667-14.984 13.666h14.984l15.682-13.666Z",
          fill: "#fff",
          "fill-opacity": ".15",
          class: "p2",
        },
        null,
        -1
      )
    ),
  ],
  K_ = [
    H_(() =>
      Mi(
        "path",
        {
          d: "m46.667 169.666 15.682 13.667h14.984L62.35 169.666 77.333 156H62.35l-15.682 13.666Z",
          fill: "#fff",
          "fill-opacity": ".15",
          class: "p1",
        },
        null,
        -1
      )
    ),
    H_(() =>
      Mi(
        "path",
        {
          d: "m22 169.666 15.682 13.667h14.985l-14.985-13.667L52.667 156H37.682L22 169.666Z",
          fill: "#fff",
          "fill-opacity": ".15",
          class: "p2",
        },
        null,
        -1
      )
    ),
  ],
  J_ = H_(() =>
    Mi(
      "path",
      {
        opacity: ".2",
        d: "m169.667 42.667 8.333 14h-16.667l8.334-14Z",
        fill: "#fff",
      },
      null,
      -1
    )
  );
var Q_ = Fl(
  {
    setup(e, { expose: t }) {
      const { wait: n } = Gc(),
        i = Tt();
      let r, s;
      return (
        t({
          show: async function (e = 0) {
            e > 0 && (await n(e));
            for (let t = 0; t < r.length; t++)
              r[t] && r[t].classList.remove("animated"),
                s[t] && s[t].classList.remove("animated");
            i.value.getBoundingClientRect();
            for (let t = 0; t < r.length; t++)
              r[t] && r[t].classList.add("animated"),
                s[t] && s[t].classList.add("animated"),
                await n(100);
          },
        }),
        pn(() => {
          (r = [...i.value.querySelectorAll(".stroke__path")]),
            (s = [...i.value.querySelectorAll(".fill__path")]);
        }),
        vn(() => {
          r = s = null;
        }),
        (e, t) => (
          pi(),
          vi(
            "div",
            {
              ref: (e, t) => {
                (t.parent = e), (i.value = e);
              },
              class: "tutorial-icon",
            },
            [
              e.$device.hasTouch
                ? (pi(),
                  vi("div", G_, [
                    Mi(
                      "div",
                      {
                        ref: (e, t) => {
                          t.leftArrow = e;
                        },
                        class: "iconContainer leftArrow",
                      },
                      W_,
                      512
                    ),
                    Mi(
                      "div",
                      {
                        ref: (e, t) => {
                          t.rightArrow = e;
                        },
                        class: "iconContainer rightArrow",
                      },
                      q_,
                      512
                    ),
                  ]))
                : Pi("", !0),
              !e.$device.hasTouch ||
              (e.$device.hasTouch && e.$device.type.desktop)
                ? (pi(),
                  vi("div", j_, [
                    Mi("div", Y_, [
                      (pi(),
                      vi("svg", X_, [
                        $_,
                        Mi(
                          "g",
                          {
                            ref: (e, t) => {
                              t.rightArrowDesk = e;
                            },
                            class: "rightArrowDesk",
                          },
                          Z_,
                          512
                        ),
                        Mi(
                          "g",
                          {
                            ref: (e, t) => {
                              t.leftArrowDesk = e;
                            },
                            class: "leftArrowDesk",
                          },
                          K_,
                          512
                        ),
                        J_,
                      ])),
                    ]),
                  ]))
                : Pi("", !0),
            ],
            512
          )
        )
      );
    },
  },
  [["__scopeId", "data-v-21c8ca69"]]
);
const ey = {},
  ty = {
    id: "Calque_1",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink",
    x: "0px",
    y: "0px",
    viewBox: "0 0 124.8 124.8",
    style: { "enable-background": "new 0 0 124.8 124.8" },
    "xml:space": "preserve",
  },
  ny = [
    Ai(
      '<g id="Calque_2_00000012470279984753687110000009903509704728823700_" data-v-1346bdf8><g id="Calque_1-2" data-v-1346bdf8><path class="st0" d="M16.4,57.1l40.7-40.7c2.9-2.9,7.7-2.9,10.6,0l40.7,40.7c2.9,2.9,2.9,7.7,0,10.6l-40.7,40.7\n\t\t\tc-2.9,2.9-7.7,2.9-10.6,0L16.4,67.7C13.5,64.8,13.5,60,16.4,57.1z" data-v-1346bdf8></path><linearGradient id="SVGID_1_" gradientUnits="userSpaceOnUse" x1="-658.5411" y1="-1101.5081" x2="-729.8611" y2="-1173.198" gradientTransform="matrix(-0.7071 0.7071 -0.7071 -0.7071 -1234.0486 -250.9608)" data-v-1346bdf8><stop offset="0" style="stop-color:#fff;stop-opacity:0.7;" data-v-1346bdf8></stop><stop offset="1" style="stop-color:#fff;stop-opacity:0;" data-v-1346bdf8></stop></linearGradient><path class="st1" d="M16.4,57.1l40.7-40.7c2.9-2.9,7.7-2.9,10.6,0l40.7,40.7c2.9,2.9,2.9,7.7,0,10.6l-40.7,40.7\n\t\t\tc-2.9,2.9-7.7,2.9-10.6,0L16.4,67.7C13.5,64.8,13.5,60,16.4,57.1z" data-v-1346bdf8></path><path class="st2" d="M16.4,57.1l40.7-40.7c2.9-2.9,7.7-2.9,10.6,0l40.7,40.7c2.9,2.9,2.9,7.7,0,10.6l-40.7,40.7\n\t\t\tc-2.9,2.9-7.7,2.9-10.6,0L16.4,67.7C13.5,64.8,13.5,60,16.4,57.1z" data-v-1346bdf8></path><g class="st3" data-v-1346bdf8><linearGradient id="SVGID_00000024693049670814976720000014288652510690531007_" gradientUnits="userSpaceOnUse" x1="-620.7462" y1="-1079.4329" x2="-713.7062" y2="-1172.8829" gradientTransform="matrix(-0.7071 0.7071 -0.7071 -0.7071 -1207.0938 -262.119)" data-v-1346bdf8><stop offset="0" style="stop-color:#fff;" data-v-1346bdf8></stop><stop offset="1" style="stop-color:#fff;stop-opacity:0;" data-v-1346bdf8></stop></linearGradient><path style="fill:none;stroke:url(#SVGID_00000024693049670814976720000014288652510690531007_);" d="M4.2,53.6L53.6,4.2\n\t\t\t\tc4.9-4.9,12.8-4.9,17.7,0l49.4,49.4c4.9,4.9,4.9,12.8,0,17.7l-49.4,49.4c-4.9,4.9-12.8,4.9-17.7,0L4.2,71.2\n\t\t\t\tC-0.7,66.4-0.7,58.4,4.2,53.6z" data-v-1346bdf8></path><path class="st2" d="M4.2,53.6L53.6,4.2c4.9-4.9,12.8-4.9,17.7,0l49.4,49.4c4.9,4.9,4.9,12.8,0,17.7l-49.4,49.4\n\t\t\t\tc-4.9,4.9-12.8,4.9-17.7,0L4.2,71.2C-0.7,66.4-0.7,58.4,4.2,53.6z" data-v-1346bdf8></path></g><path class="st5" d="M51.4,61.9l10.2,8.5h9.8l-9.8-8.5l9.8-8.5h-9.8L51.4,61.9z" data-v-1346bdf8></path></g></g>',
      1
    ),
  ];
var iy = Fl(ey, [
  [
    "render",
    function (e, t) {
      return pi(), vi("svg", ty, ny);
    },
  ],
  ["__scopeId", "data-v-1346bdf8"],
]);
const ry = { class: "tutorial__topLine" },
  sy = { key: 0, class: "tutorial__content" },
  ay = ["innerHTML"],
  oy = { key: 1, class: "tutorial__content" },
  ly = { class: "keys__left keys" },
  cy = { class: "keys__right keys" },
  uy = { class: "tutorial__botLine" };
var hy = Fl(
  {
    setup(e, { expose: t }) {
      const n = Cl(),
        i = n.$device.hasTouch,
        { csstween: r } = wl(),
        { wait: s } = Gc(),
        a = n.$l(`tutorial.${i ? "mobile" : "desktop"}.desc`),
        o = Tt(),
        l = Tt(),
        c = Tt(),
        u = Tt(),
        h = Tt(),
        d = Tt(),
        p = Tt(),
        f = [];
      function m() {
        for (const e of f) e && e.destroy();
        f.length = 0;
      }
      return (
        t({
          show: async function () {
            if (((n.$stores.gameTutorialVisible = !0), !o.value)) return;
            const e = "cubic-bezier(0,0,.13,1) ";
            let t = 20;
            (o.value.style.display = ""),
              (o.value.style.opacity = ""),
              m(),
              f.push(
                r({
                  target: d.value,
                  transform: ["scaleY(0)", "scaleY(1)"],
                  duration: 1e3,
                  ease: e,
                  delay: (t += 0),
                })
              ),
              f.push(
                r({
                  target: p.value,
                  transform: ["scaleY(0)", "scaleY(1)"],
                  duration: 800,
                  ease: e,
                  delay: (t += 0),
                })
              ),
              f.push(
                r({
                  target: l.value,
                  transform: ["translateY(-40px)", ""],
                  duration: 1e3,
                  ease: e,
                  delay: (t += 0),
                  opacity: [0, ""],
                })
              ),
              f.push(
                r({
                  target: c.value,
                  transform: ["translateY(-40px)", ""],
                  duration: 1e3,
                  ease: e,
                  delay: i ? t : (t += 150),
                  opacity: [0, ""],
                })
              ),
              f.push(
                r({
                  target: u.value,
                  duration: 800,
                  ease: e,
                  delay: (t += i ? 350 : 20),
                  opacity: [0, ""],
                  transform: i ? "" : ["scale3d(0,0,0) rotate(15deg)", ""],
                })
              ),
              h.value && h.value.show((t += 10));
            await s(t + (i ? 100 : 300));
          },
          hide: async function () {
            if (((n.$stores.gameTutorialVisible = !1), !o.value)) return;
            m();
            const e = r({ target: o.value, opacity: 0, duration: 700 });
            f.push(e), await e.finished, (o.value.style.display = "none");
          },
        }),
        pn(() => {
          o.value.style.display = "none";
        }),
        vn(() => {
          m(), (n.$stores.gameTutorialVisible = !1);
        }),
        (e, t) => (
          pi(),
          vi(
            "div",
            {
              ref: (e, t) => {
                (t.base = e), (o.value = e);
              },
              class: g([
                "game-tutorial",
                { tutoWebRtc: e.$rtcDisplay.enabled.value },
              ]),
            },
            [
              Mi("div", ry, [
                Mi(
                  "div",
                  {
                    ref: (e, t) => {
                      (t.topLineEl = e), (d.value = e);
                    },
                    class: "line",
                  },
                  null,
                  512
                ),
              ]),
              e.$rtcDisplay.enabled.value
                ? Pi("", !0)
                : (pi(),
                  vi("div", sy, [
                    Mi(
                      "p",
                      {
                        ref: (e, t) => {
                          (t.titleEl = e), (l.value = e);
                        },
                        class: "tutorial__title",
                      },
                      y(e.$l("tutorial.title")),
                      513
                    ),
                    Mi(
                      "p",
                      {
                        ref: (e, t) => {
                          (t.textEl = e), (c.value = e);
                        },
                        class: "tutorial__text",
                        innerHTML: At(a),
                      },
                      null,
                      8,
                      ay
                    ),
                    Mi(
                      "div",
                      {
                        ref: (e, t) => {
                          (t.iconEl = e), (u.value = e);
                        },
                        class: "tutorial__icon",
                      },
                      [
                        Ti(
                          Q_,
                          {
                            ref: (e, t) => {
                              (t.iconInstance = e), (h.value = e);
                            },
                          },
                          null,
                          512
                        ),
                      ],
                      512
                    ),
                  ])),
              e.$rtcDisplay.enabled.value
                ? (pi(),
                  vi("div", oy, [
                    Mi(
                      "p",
                      {
                        ref: (e, t) => {
                          (t.titleEl = e), (l.value = e);
                        },
                        class: "tutorial__title",
                      },
                      y(e.$l("tutorial.title")),
                      513
                    ),
                    Mi(
                      "p",
                      {
                        ref: (e, t) => {
                          (t.textEl = e), (c.value = e);
                        },
                        class: "tutorial__text",
                      },
                      y(e.$l("webRTC.tutorial.borne.desc")),
                      513
                    ),
                    Mi(
                      "div",
                      {
                        ref: (e, t) => {
                          (t.iconEl = e), (u.value = e);
                        },
                        class: "tutorial__icons",
                      },
                      [Mi("div", ly, [Ti(iy)]), Mi("div", cy, [Ti(iy)])],
                      512
                    ),
                  ]))
                : Pi("", !0),
              Mi("div", uy, [
                Mi(
                  "div",
                  {
                    ref: (e, t) => {
                      (t.botLineEl = e), (p.value = e);
                    },
                    class: "line",
                  },
                  null,
                  512
                ),
              ]),
            ],
            2
          )
        )
      );
    },
  },
  [["__scopeId", "data-v-356cc4a0"]]
);
const dy = { class: "page page-game" };
var py =
  '<svg viewBox="0 0 86 86" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="42.954" y="1.414" width="58.746" height="58.746" rx="4" transform="rotate(45 42.954 1.414)" fill="#fff" stroke="url(#a)" stroke-width="2"/><path d="m38.93 31.68 1.05 14.7h5.82l5.73-14.7h-12.6Zm8.52 15.87h-9.48L36.92 54h9.51l1.02-6.45Z" fill="#DD2526"/><defs><linearGradient id="a" x1="43.654" y1="60.775" x2="100.114" y2="4.315" gradientUnits="userSpaceOnUse"><stop stop-color="#E1E1E1"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient></defs></svg>\n';
const fy = { class: "page syncF" },
  my = { class: "syncF__container" },
  gy = ["innerHTML"],
  vy = { class: "syncF__title" };
const _y = [
  { path: "/", name: "home", component: dc },
  { path: "/result", name: "result", component: ou },
  { path: "/register", name: "register", component: Bu },
  { path: "/confirmation", name: "confirmation", component: ju },
  {
    path: "/game",
    name: "game",
    component: Fl(
      {
        setup(e) {
          Pl.$device.hasTouch;
          const t = hy,
            n = wc(),
            i = Tt(),
            r = Tt(),
            s = Tt(),
            a = Tt(),
            o = Tt(),
            l = {
              hideAll: function () {
                i.value && i.value.hide();
                r.value && r.value.hide();
                s.value && s.value.hide();
                a.value && a.value.hide();
                o.value && o.value.hide();
              },
              countdown: i,
              finish: r,
              timer: s,
              turbo: a,
              tuto: o,
            };
          return (
            pn(() => {
              Nl.game.setView(l), n.pageview({ title: "game", url: "/game" });
            }),
            vn(() => {
              Nl.game.removeView(l);
            }),
            (e, n) => (
              pi(),
              vi("section", dy, [
                Ti(
                  p_,
                  {
                    ref: (e, t) => {
                      (t.countdown = e), (i.value = e);
                    },
                  },
                  null,
                  512
                ),
                Ti(
                  M_,
                  {
                    ref: (e, t) => {
                      (t.finish = e), (r.value = e);
                    },
                  },
                  null,
                  512
                ),
                Ti(
                  D_,
                  {
                    ref: (e, t) => {
                      (t.timer = e), (s.value = e);
                    },
                  },
                  null,
                  512
                ),
                Ti(
                  V_,
                  {
                    ref: (e, t) => {
                      (t.turbo = e), (a.value = e);
                    },
                  },
                  null,
                  512
                ),
                (pi(),
                _i(
                  ri(At(t)),
                  {
                    ref: (e, t) => {
                      (t.tuto = e), (o.value = e);
                    },
                  },
                  null,
                  512
                )),
                Ei(" " + y(), 1),
              ])
            )
          );
        },
      },
      [["__scopeId", "data-v-664552d6"]]
    ),
  },
  { path: "/qrcode-home", name: "qrcode-home", component: sh },
  { path: "/qrcode-pairing", name: "qrcode-pairing", component: Gv },
  {
    path: "/qrcode-error",
    name: "qrcode-error",
    component: Fl(
      {
        setup(e, { expose: t }) {
          const { csstween: n } = wl(),
            i = "cubic-bezier(.87,0,.13,1)";
          return (
            pn(() => {
              kl() && kl().audio.setBgm("intro"), Pl.$rtcDisplay.enable();
            }),
            t({
              enter: async function (e) {
                n({
                  target: e,
                  selector: ".syncF__icon",
                  transform: ["scale3d(0,0,0) rotate(15deg)", ""],
                  duration: 1e3,
                  ease: i,
                  opacity: [0, ""],
                }),
                  n({
                    target: e,
                    selector: ".syncF__title",
                    transform: ["translateY(-40px)", ""],
                    duration: 1e3,
                    ease: "cubic-bezier(0,0,.13,1) ",
                    delay: 300,
                    opacity: [0, ""],
                  });
              },
              leave: async function (e) {
                return n({
                  target: e,
                  transform: ["", "scale3d(0.6,0.6,0.6)"],
                  duration: 800,
                  ease: i,
                  opacity: ["", 0],
                  autoClear: !1,
                }).finished;
              },
            }),
            (e, t) => (
              pi(),
              vi("section", fy, [
                Mi("div", my, [
                  Mi(
                    "div",
                    { class: "syncF__icon", innerHTML: At(py) },
                    null,
                    8,
                    gy
                  ),
                  Mi("div", vy, [
                    Mi("p", null, y(e.$l("webRTC.pairing.borne.fail")), 1),
                  ]),
                ]),
              ])
            )
          );
        },
      },
      [["__scopeId", "data-v-ec20fb1c"]]
    ),
  },
];
function yy() {
  const e = window.__DATA,
    t = e.site.locales[e.site.locale];
  let n = e.config.basepath;
  return (
    t.default || (n += e.site.locale),
    n.endsWith("/") && (n = n.slice(0, -1)),
    n
  );
}
const xy = {
  props: ["mode", "routeKey"],
  setup(e) {
    const t = e,
      n = "_transitionState",
      i = Ga(),
      r = Tt();
    let s,
      a,
      o = 1,
      l = null,
      c = null,
      u = null,
      h = null;
    const d = i.beforeResolve((e, t) => {
      (s = t), (a = e);
    });
    async function p(e, t) {
      l = c;
      const i = (c = r.value);
      i[n] || (i[n] = {});
      const d = i[n];
      d.uid || (d.uid = o++),
        g(),
        i === h && v(),
        (u = i),
        (d.entering = !0),
        (d.leaving = !1),
        i.enter && (await i.enter(e, s, a, d)),
        u === i && (u = null),
        d.entering && ((d.entering = !1), t());
    }
    function f() {
      const e = c,
        t = e[n];
      u === e && (u = null),
        t.entering &&
          ((t.entering = !1), e.enterCancelled && e.enterCancelled(t));
    }
    async function m(e, i) {
      const r = "in-out" === t.mode ? l : c,
        o = r[n];
      if (
        (v(),
        r === u && g(),
        (h = r),
        (o.entering = !1),
        (o.leaving = !0),
        r.leave && (await r.leave(e, s, a, o)),
        h === r && (h = null),
        !o.leaving)
      )
        return i();
      (o.leaving = !1), i();
    }
    function g() {
      if (!u) return;
      const e = u,
        t = e[n];
      t.entering &&
        ((t.entering = !1), e.enteringCancelled && e.enterCancelled(t)),
        (u = null);
    }
    function v() {
      if (!h) return;
      const e = h,
        t = e[n];
      t.leaving && ((t.leaving = !1), e.leaveCancelled && e.leaveCancelled(t)),
        (h = null);
    }
    return (
      gn(() => {
        d();
      }),
      (n, i) => {
        const s = ni("RouterView");
        return (
          pi(),
          _i(s, null, {
            default: Vt(({ Component: n }) => [
              Ti(
                Xr,
                {
                  ref: (e, t) => {
                    t.tr = e;
                  },
                  css: !1,
                  mode: e.mode,
                  appear: "",
                  onEnter: p,
                  onEnterCancelled: f,
                  onLeave: m,
                },
                {
                  default: Vt(() => [
                    (pi(),
                    _i(
                      ri(n),
                      {
                        key: t.routeKey,
                        ref: (e, t) => {
                          (t.component = e), (r.value = e);
                        },
                      },
                      null,
                      512
                    )),
                  ]),
                  _: 2,
                },
                1032,
                ["mode"]
              ),
            ]),
            _: 1,
          })
        );
      }
    );
  },
};
function by(e = {}) {
  e.notFoundComponent
    ? _y.push({
        path: "/:pathMatch(.*)*",
        name: "404",
        component: e.notFoundComponent,
      })
    : _y.push({ path: "/:pathMatch(.*)*", redirect: "/" });
  const t = e.historyMode(yy()),
    n = Va(Object.assign({ routes: _y, history: t }, e)),
    i = n.install.bind(n);
  return (
    (n.install = function (e) {
      e.component("AnimatedRouterView", xy), i.call(this, e);
    }),
    n
  );
}
function wy(e, t = 0, n = 1) {
  return Math.min(Math.max(e, t), n);
}
function Sy(e, t = 0, n = 1) {
  return (e - t) / (n - t);
}
function My(e, t, n, i, r) {
  return i + ((e - t) / (n - t)) * (r - i);
}
function Ty(e, t, n) {
  const i = wy((n - e) / (t - e), 0, 1);
  return i * i * (3 - 2 * i);
}
function Cy(e, t, n) {
  return e * (1 - n) + t * n;
}
function Ey(e, t, n, i = 0.001) {
  const r = e * (1 - n) + t * n;
  return Math.abs(t - r) < i ? t : r;
}
function Ay(e, t, n, i) {
  return Cy(e, t, 1 - Math.exp(0.05 * -n * i));
}
function Py(e, t, n, i, r) {
  return Ey(e, t, 1 - Math.exp(0.05 * -n * i), r);
}
const Ly = (e) => new Promise((t) => setTimeout(t, e));
let Iy = null;
function Ry() {
  let e,
    t,
    n,
    i,
    r,
    s,
    a,
    o = !1,
    l = 2,
    c = 0,
    u = !1;
  const h = [],
    d = new Promise((e) => (s = e)),
    p = (Iy = dt({
      progress: 0,
      taskCount: 0,
      taskFinished: 0,
      hidden: !1,
      destroyed: !1,
      task: function (e, { weight: t = 1, graceful: n = !0 } = {}) {
        "function" == typeof e && (e = e());
        return (
          y(t),
          Promise.resolve()
            .then(() => e)
            .then(() => _(t))
            .catch((e) => {
              n && _(t);
            })
        );
      },
      createTask: x,
      setMinimumTaskCount: function (e) {
        (l = e), (p.taskCount = Math.max(l, c));
      },
      beforeExit: function (e) {
        u ? e() : h.push(e);
      },
    }));
  return function (s) {
    (i = x()),
      (n = s),
      n.config.globalProperties.$router.beforeEach(g),
      (n.config.globalProperties.$preloader = p),
      n.provide("preloader", p),
      (t = document.getElementById("preloader")),
      (e = (function (e, t) {
        const n = t.querySelector(".preloader-counter"),
          i = t.querySelector(".preloader-background"),
          r = t.querySelector(".preloader-text"),
          s = cu();
        let a = 0,
          o = 0;
        function l(e) {
          e = wy(e, 5, 300);
          let t = Ay(o, a, 0.17, e);
          if ((t > 0.99 && (t = 1), t === o)) return;
          o = t;
          const i = Math.floor(100 * o)
            .toString()
            .padStart(2, "0");
          (n.textContent = Math.min(99, i)), o >= 1 && s.resolve();
        }
        return {
          enter: function () {
            Uc.add(l);
          },
          onProgress: function (e) {
            a = e;
          },
          exit: async function (e) {
            await s,
              (i.style.transition =
                "transform 1000ms cubic-bezier(0.910, 0.000, 0.195, 0.990)"),
              (i.style.transform = "scaleY(0)"),
              await Ly(400),
              (n.style.transition = "opacity 200ms"),
              (n.style.opacity = 0),
              await Ly(100),
              (r.style.transition = "opacity 200ms"),
              (r.style.opacity = 0),
              await Ly(100),
              e(),
              await Ly(1e3);
          },
          beforeDestroy: function () {
            Uc.remove(l);
          },
        };
      })(0, t)),
      e.init && e.init();
    e.enter && (a = e.enter());
    (o = () =>
      (function () {
        const t = p.progress;
        e.onProgress && e.onProgress(t),
          t >= 1 &&
            (u ||
              ((u = !0),
              Promise.resolve()
                .then(() => a)
                .then(() => h.reduce((e, t) => e.then(t), Promise.resolve()))
                .then(() => (h.length = 0))
                .then(() => e.exit && e.exit(f))
                .then(m)
                .catch((e) => {
                  m();
                })));
      })(p.progress)),
      (r = Mr(o, null, { flush: "post" }));
    var o;
  };
  function f() {
    p.hidden || p.destroyed || ((p.hidden = !0), r && r(), (r = null), s());
  }
  function m() {
    p.destroyed ||
      (f(),
      t.parentNode && t.parentNode.removeChild(t),
      e.beforeDestroy && e.beforeDestroy(),
      (t = null),
      (e = null),
      (p.destroyed = !0));
  }
  function g(e, t, i) {
    o || (n.config.globalProperties.$router.beforeResolve(v), (o = !0)), i();
  }
  async function v(e, t, n) {
    i.finish(), await d, n();
  }
  function _(e) {
    p.taskFinished += e;
    const t = p.taskFinished / p.taskCount;
    p.progress = Math.max(0, Math.min(1, Math.max(p.progress, t)));
  }
  function y(e) {
    (c += e), (p.taskCount = Math.max(l, c));
  }
  function x({ weight: e = 1 } = {}) {
    let t = !1;
    return (
      y(e),
      {
        get finished() {
          return t;
        },
        finish() {
          t || ((t = !0), _(e));
        },
      }
    );
  }
}
function Dy(e, t, n, i, r) {
  for (t = t.split ? t.split(".") : t, i = 0; i < t.length; i++)
    e = e ? e[t[i]] : r;
  return e === r ? n : e;
}
const ky = {};
function Ny(e, t = !1) {
  const n = window.__DATA || ky;
  return Dy(n, e) || Dy(n.site, e) || Dy(n.page, e) || (t ? e : "");
}
function Oy(e) {
  const t = e.tag || e.tagName || "span";
  let n = e.debug;
  "string" != typeof n || n.length || (n = !0);
  return Ar(t, { innerHTML: Ny(e.id || "", !!n) });
}
function Fy() {
  return {
    install: function (e) {
      (e.config.globalProperties.$l = Ny),
        (e.config.globalProperties.$translation = Ny),
        e.provide("translation", Ny),
        e.component("Translation", Oy),
        e.component("L", Oy);
    },
  };
}
const zy = "unknown",
  Uy = (e, t) => t.reduce((t, n) => t || !!e.match(n), !1),
  By = (e, t) => {
    for (const n in t) if (Uy(e, t[n])) return n;
  },
  Vy = {
    edge: ["edge"],
    chrome: ["chrome", "crios"],
    firefox: ["firefox", "fxios"],
    ie: ["msie", "trident", "rv:"],
    ucbrowser: ["ucbrowser"],
    safari: ["safari", "ios"],
    opera: ["opera", "opios"],
  },
  Hy = {
    0: "verylow",
    1: "low",
    2: "medium",
    3: "high",
    4: "veryhigh",
    5: "ultra",
  };
function Gy(e, t = !1) {
  const n = {};
  if (t)
    return Object.assign(n, {
      type: { desktop: !0 },
      os: "windows",
      browser: "chrome",
      browserVersion: "77",
      gpu: Yy("low"),
    });
  (n.userAgent = "string" == typeof e ? e : navigator.userAgent.toLowerCase()),
    (n.hasTouch = "ontouchstart" in window || navigator.maxTouchPoints > 1),
    (n.type = (function ({ hasTouch: e, userAgent: t }) {
      const n = ["ios", "iphone", "ipad", "phone", "android", "blackberry"],
        i = Math.max(screen.width, screen.height) > 900,
        r = Wy(t, e),
        s = !!(r || (e && Uy(t, n))),
        a = !(!s || (!r && !i)),
        o = !s;
      return { desktop: o, mobile: s, tablet: a, phone: !o && !a };
    })(n)),
    (n.os = (function ({ hasTouch: e, type: t, userAgent: n }) {
      if (Wy(n, e)) return "ios";
      const i = {
          desktop: {
            windows: ["windows", "iemobile"],
            linux: ["linux"],
            macos: ["mac os"],
          },
          mobile: {
            android: ["android"],
            ios: ["ipad", "iphone"],
            blackberry: ["blackberry"],
          },
        },
        r = t.desktop ? i.desktop : i.mobile;
      return By(n, r) || "unknown";
    })(n)),
    (n.browser = (function ({ userAgent: e, os: t }) {
      const n = By(e, Vy);
      return n || ("ios" === t ? "safari" : zy);
    })(n)),
    (n.browserVersion = (function ({ userAgent: e, browser: t }) {
      const n = (t) => {
        const n = e.split(t)[1];
        if (!n || n.length <= 0) return;
        const i = parseFloat(
          n
            .split(" ")[0]
            .split(".")[0]
            .replace(/[^.0-9]/g, "")
        );
        return isNaN(i) ? void 0 : i;
      };
      switch (t) {
        case "chrome":
        case "firefox":
          return void Vy[t].forEach((e) => {
            const t = n(e);
            if (null !== t || void 0 !== t) return t;
          });
        case "safari":
          let i = e.match(/version\/([.\d]+)/i);
          return i && i[1]
            ? parseFloat(i[1])
            : ((i = e.match(/os ([0-9_]+)/i)),
              i && i[1] ? parseFloat(i[1].split("_")[0]) : void 0);
        case "ie":
        case "edge":
          return Uy(e, ["msie"])
            ? n("msie")
            : Uy(e, ["rv:"])
            ? n("rv:")
            : n("edge/");
        default:
          return;
      }
    })(n));
  let i = qy(n, !0);
  const r = !i;
  return (
    jy(),
    (i = qy(n, !1)),
    (n.majorPerformanceCaveat = i && r),
    (n.webgl = i
      ? (function (e, t) {
          const n = ["WEBKIT_", "MOZ_"];
          let i = t.getSupportedExtensions() || [];
          i = i.reduce((e, t) => {
            for (let i = 0; i < n.length; i++)
              if (!t.indexOf(n[i])) return (e[t.substring(n[i].length)] = t), e;
            return (e[t] = t), e;
          }, {});
          const r = "WEBGL_compressed_texture_",
            s = ["s3tc", "astc", "etc", "pvrtc"].reduce(
              (e, t) => ((e[t] = !!i[r + t]), e),
              {}
            );
          return {
            renderer: (t.getParameter(t.RENDERER) || "").toLowerCase(),
            version: (t.getParameter(t.VERSION) || "").toLowerCase(),
            glsl: (
              t.getParameter(t.SHADING_LANGUAGE_VERSION) || ""
            ).toLowerCase(),
            extensions: i,
            compressedTextures: s,
          };
        })(0, i)
      : null),
    (n.gpu = i
      ? (function ({ os: e, webgl: t }, n) {
          const i = {
              string: null,
              quality: { low: !0 },
              qualityIndex: 1,
              type: null,
              series: null,
              version: null,
              numbers: [],
              isMobile: null,
            },
            r = {
              intel: ["intel"],
              nvidia: ["nvidia", "geforce"],
              amd: ["amd", "radeon"],
              adreno: ["adreno"],
              apple: ["apple"],
              mali: ["mali"],
              swiftshader: ["swiftshader"],
            },
            s = n.getExtension(t.extensions.WEBGL_debug_renderer_info),
            a = s ? n.getParameter(s.UNMASKED_RENDERER_WEBGL) : "";
          if (!s || !a.length) return i;
          if (
            ((i.string = (function (e) {
              let t = e.toLowerCase();
              (t = t.replace(/(\(tm\)|\(r\))/g, "")),
                (t = t.trim()),
                t.includes("angle (") &&
                  t.includes("direct3d") &&
                  (t = t.replace("angle (", "").split(" direct3d")[0]);
              t.includes("nvidia") &&
                t.includes("gb") &&
                (t = t.split(/\dgb/)[0]);
              return t;
            })(a)),
            (i.type = By(i.string, r) || zy),
            i.type === zy)
          )
            return i;
          "ios" === e &&
            "apple gpu" === i.string &&
            (i.string = (function ({ os: e, type: t }, n) {
              const i = window.devicePixelRatio,
                r = Math.min(window.screen.width, window.screen.height) * i,
                s = Math.max(window.screen.width, window.screen.height) * i,
                a = "ios" === e && t.tablet,
                o =
                  "\n\t\t// Credits: @Samsy\n\t\tprecision highp float;\n\t\tattribute vec3 position;\n\t\tvarying float vvv;\n\t\tvoid main() {\n\t\t\tvvv = 0.31622776601683794;\n\t\t\tgl_Position = vec4(position, 1.0);\n\t\t}\n\t",
                l =
                  "\n\t\t// Credits: @Samsy\n\t\tprecision highp float;\n\t\tvarying float vvv;\n\t\tvoid main() {\n\t\t\tvec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * vvv;\n\t\t\tenc = fract(enc);\n\t\t\tenc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n\t\t\tgl_FragColor = enc;\n\t\t}\n\t";
              let c = 0;
              const u = n.createShader(35633),
                h = n.createShader(35632),
                d = n.createProgram();
              if (null !== h && null !== u && null !== d) {
                n.shaderSource(u, o),
                  n.shaderSource(h, l),
                  n.compileShader(u),
                  n.compileShader(h),
                  n.attachShader(d, u),
                  n.attachShader(d, h),
                  n.linkProgram(d),
                  n.detachShader(d, u),
                  n.detachShader(d, h),
                  n.deleteShader(u),
                  n.deleteShader(h),
                  n.useProgram(d);
                const e = n.createBuffer(),
                  t = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]);
                n.bindBuffer(34962, e), n.bufferData(34962, t, 35044);
                const i = n.getAttribLocation(d, "position");
                n.vertexAttribPointer(i, 3, 5126, !1, 0, 0),
                  n.enableVertexAttribArray(i),
                  n.clearColor(1, 1, 1, 1),
                  n.clear(16384),
                  n.viewport(0, 0, 1, 1),
                  n.drawArrays(4, 0, 3);
                const r = new Uint8Array(4);
                n.readPixels(0, 0, 1, 1, 6408, 5121, r);
                const s = r.join("");
                n.deleteProgram(d),
                  n.deleteBuffer(e),
                  "801621810" === s ? (c = 11) : "8016218135" === s && (c = 8);
              }
              return a && 8 === c
                ? "apple a8 gpu"
                : a && 11 === c
                ? "apple a11 gpu"
                : a && s <= 1024
                ? "apple a8 gpu"
                : a && s >= 2200
                ? "apple a10 gpu"
                : !a && r < 640
                ? "apple a6 gpu"
                : !a && r <= 640
                ? 8 === c
                  ? "apple a8 gpu"
                  : "apple a7 gpu"
                : (!a && r <= 750) || (!a && r <= 1080)
                ? "apple a9 gpu"
                : !a && s >= 2e3
                ? "apple a10 gpu"
                : "apple gpu";
            })(i, n));
          return (
            (i.isMobile = "m" === i.string[i.string.length - 1]),
            Object.assign(
              i,
              (function (e) {
                const t = e
                    .split(" ")
                    .map((e) => e.replace(/[\D]/g, ""))
                    .filter((e) => e.length > 0)
                    .map((e) => parseFloat(e)),
                  n = t[0] || null;
                return { numbers: t, version: n };
              })(i.string)
            ),
            (i.series = (function (e) {
              const t = {
                  swiftshader: "swiftshader",
                  "apple a": "apple gpu",
                  "apple m1": "apple m1",
                  "apple m": "apple m",
                  "geforce gtx": "geforce gtx",
                  "geforce rtx": "geforce rtx",
                  "geforce mx": "geforce mx",
                  titan: "geforce titan",
                  "quadro fx": "quadro fx",
                  "quadro p": "quadro p",
                  "quadro rtx": "quadro rtx",
                  "quadro ": "quadro",
                  "geforce ": "geforce",
                  "tegra ": "tegra",
                  "radeon vii": "radeon vii",
                  "radeon r7": "radeon r7",
                  "radeon r9": "radeon r9",
                  "radeon r10": "radeon r10",
                  "radeon rx": "radeon rx",
                  "radeon pro vega": "radeon pro vega",
                  "radeon rx vega": "radeon rx vega",
                  "radeon hd": "radeon hd",
                  "radeon pro ": "radeon pro",
                  "radeon ": "radeon",
                  "intel iris ": "intel iris",
                  "intel iris plus ": "intel iris plus",
                  "intel iris pro ": "intel iris pro",
                  "intel hd ": "intel hd",
                  "intel uhd ": "intel uhd",
                  adreno: "adreno",
                  "mali-t": "mali t",
                  "mali-g": "mali g",
                  mali: "mali",
                },
                n = {};
              for (const i in t) e.indexOf(i) > -1 && (n[t[i]] = !0);
              return n;
            })(i.string)),
            Object.assign(
              i,
              (function ({ type: e, browser: t }, n) {
                if (!n || !n.type || "swiftshader" === n.type)
                  return "firefox" === t && e.desktop
                    ? Yy("medium")
                    : Yy("low");
                const i = n.isMobile,
                  r = n.type,
                  s = n.series,
                  a = n.version || 0,
                  o = n.string.match(/(?:^| )mp(\d)+(?: |$)/i),
                  l = o ? parseFloat(o[1]) : 1,
                  c = (e) => s[e],
                  u = (e, t, n) => c(e) && t <= a && (void 0 === n || l <= n),
                  h = (e, t, n) => c(e) && a >= t && (void 0 === n || l >= n),
                  d = {
                    veryhigh: [
                      c("geforce rtx"),
                      c("geforce titan"),
                      c("quadro gtx"),
                      i && h("geforce gtx", 780),
                      !i && h("geforce gtx", 680),
                      h("quadro p", 400),
                      c("radeon vii") || c("radeon r10") || c("radeon r9"),
                      h("radeon r7", 370),
                      h("radeon rx", 570),
                      h("radeon rx vega", 56),
                    ],
                    high: [
                      c("geforce gtx"),
                      c("apple m"),
                      h("geforce mx", 150),
                      h("radeon pro", 450),
                      h("radeon hd", 5570) && !i,
                      (h("intel iris plus", 650) || h("intel iris pro", 580)) &&
                        u("intel iris", 5e3),
                      h("adreno", 418),
                      h("apple gpu", 9),
                      h("mali g", 71),
                      h("mali t", 760, 8) || h("mali t", 880),
                    ],
                    medium: [
                      "nvidia" === r || "amd" === r,
                      c("intel iris plus") || c("intel iris pro"),
                      h("intel hd", 630) && u("intel hd", 2e3),
                      h("adreno", 430),
                      h("apple gpu", 8),
                      c("mali g"),
                      h("mali t", 800, 2) || h("mali t", 860),
                    ],
                  };
                let p = "low";
                for (const f in d) {
                  for (let e = 0, t = d[f].length; e < t; e++)
                    if (d[f][e]) {
                      p = f;
                      break;
                    }
                  if ("low" !== p) break;
                }
                return Yy(p);
              })(s, i)
            ),
            i
          );
        })(n, i)
      : Yy("low")),
    jy(),
    n
  );
}
function Wy(e, t) {
  const n = Uy(e, ["ipad", "mac", "macos"]),
    i = Uy(e, ["iphone"]),
    r = "MacIntel" === navigator.platform;
  return !(i || !n || !r || !t);
}
function qy(e, t) {
  const n = document.createElement("canvas");
  let i;
  try {
    const r = {
      alpha: !1,
      antialias: !1,
      depth: !1,
      failIfMajorPerformanceCaveat: t,
      powerPreference: "high-performance",
      stencil: !1,
    };
    "safari" === e.browser &&
      12 === e.browserVersion &&
      e.type.desktop &&
      delete r.powerPreference,
      (i =
        n.getContext("webgl", r) ||
        n.getContext("webgl-experimental", r) ||
        n.getContext("experimental-webgl", r));
  } catch (r) {}
  return i;
}
function jy(e) {
  e &&
    e.getExtension("WEBGL_lose_context") &&
    e.getExtension("WEBGL_lose_context").loseContext();
}
function Yy(e) {
  const t = Hy;
  return {
    qualities: t,
    qualityIndex: Math.max(0, Object.values(t).indexOf(e)),
  };
}
function Xy(e = {}) {
  const t = {
    install: function (i) {
      (i.config.globalProperties.$device = t),
        i.provide("device", t),
        (function () {
          const i = Gy(e.userAgent);
          Object.assign(t, i),
            n(t.gpu.qualityIndex),
            (function (e) {
              const t = document.documentElement;
              e.hasTouch && t.classList.add("touch");
              for (const n in e.type)
                e.type[n] && t.classList.add(n.toLowerCase());
              e.browser &&
                e.browser.length > 0 &&
                t.classList.add(e.browser.toLowerCase());
              e.os &&
                e.os.length > 0 &&
                "Unknown" !== e.os &&
                t.classList.add(e.os.toLowerCase());
            })(t);
        })(),
        delete t.install;
    },
    updateQuality: n,
  };
  return t;
  function n(e) {
    const n = document.documentElement;
    if (!t.gpu) return;
    t.gpu.qualityIndex = e;
    const i = t.gpu.qualities;
    for (const r in i)
      t.gpu && t.gpu.quality && (t.gpu.quality[i[r]] = r <= e),
        n.classList.toggle(i[r], e == r);
  }
}
const $y = document.documentElement;
let Zy, Ky;
function Jy() {
  const e = Tt(),
    t = Tt(),
    n = Tt(),
    i = Tt(),
    r = Tt(),
    s = uu(l, 500, { trail: !1 });
  let a = null;
  const o = (Ky = {
    install: function (e) {
      (e.config.globalProperties.$viewport = o),
        e.provide("viewport", o),
        (Zy = document.createElement("div")),
        Object.assign(Zy.style, {
          position: "fixed",
          top: 0,
          left: 0,
          width: "200px",
          height: "10px",
          overflowY: "scroll",
          pointerEvents: "none",
          userSelect: "none",
          zIndex: -1,
          opacity: 0,
        }),
        (a = {
          measureScrollbarWidth: function () {
            const e = document.createElement("div");
            Object.assign(Zy.style, {
              width: "200px",
              height: "10px",
              overflowY: "scroll",
            }),
              Object.assign(e.style, { width: "100%", height: "150%" }),
              Zy.appendChild(e),
              document.body.appendChild(Zy);
            const t = parseFloat(getComputedStyle($y).zoom),
              n = isNaN(t) ? 1 : t,
              i = Math.round((200 - Zy.clientWidth) * n);
            return (
              $y.style.setProperty("--scrollbar-width", i + "px"),
              document.body.removeChild(Zy),
              Zy.removeChild(e),
              Object.assign(Zy.style, {
                width: "1px",
                height: "100%",
                overflowY: "hidden",
              }),
              i
            );
          },
          measureViewportHeight: function () {
            document.body.appendChild(Zy);
            const e = Zy.getBoundingClientRect().height;
            return (
              document.body.removeChild(Zy),
              $y.style.setProperty("--inner-height", window.innerHeight + "px"),
              $y.style.setProperty("--vp-height", e + "px"),
              e
            );
          },
        }),
        a.measureScrollbarWidth(),
        document.addEventListener("visibilitychange", u, !1),
        setInterval(c, 5e3),
        window.addEventListener(
          "resize",
          () => {
            l(), s();
          },
          !1
        ),
        l(),
        c(),
        u(),
        delete o.install;
    },
    width: e,
    height: t,
    viewportRatio: i,
    pixelRatio: n,
    visible: r,
  });
  return o;
  function l() {
    (e.value = window.innerWidth),
      (t.value = a.measureViewportHeight()),
      (i.value = e.value / t.value);
  }
  function c() {
    n.value = window.devicePixelRatio || 1;
  }
  function u() {
    (r.value = !document.hidden), l();
  }
}
const Qy = {
  setup(e, { expose: t }) {
    const n = Tt(),
      i = Gi() ? Yt("webGL") : dN;
    let r = Tt();
    return (
      pn(() => {
        (r.value = i.getElement()),
          r.value.classList.add("webgl-canvas"),
          n.value.appendChild(r.value);
      }),
      vn(() => {
        r = null;
      }),
      t({ wrapper: n, canvas: r }),
      (e, t) =>
        t[0] ||
        (mi(-1),
        (t[0] = Mi(
          "aside",
          {
            ref: (e, t) => {
              (t.wrapper = e), (n.value = e);
            },
            class: "webgl-wrapper",
          },
          null,
          512
        )),
        mi(1),
        t[0])
    );
  },
};
let ex = null;
function tx(e) {
  if (null !== ex && (ex.property, 1)) {
    const e = ex;
    return (ex = tx.prototype = null), e;
  }
  return (ex = tx.prototype = null == e ? Object.create(null) : e), new tx();
}
for (let bN = 0; bN <= 10; bN++) tx();
function nx(e, t, n = 0) {
  if (("string" == typeof e && (e = t[e]), 0 === n))
    return function () {
      return e.call(t);
    };
  if (1 === n)
    return function (n) {
      return e.call(t, n);
    };
  if (2 === n)
    return function (n, i) {
      return e.call(t, n, i);
    };
  if (3 === n)
    return function (n, i, r) {
      return e.call(t, n, i, r);
    };
  if (4 === n)
    return function (n, i, r, s) {
      return e.call(t, n, i, r, s);
    };
  if (5 === n)
    return function (n, i, r, s, a) {
      return e.call(t, n, i, r, s, a);
    };
  throw new Error("Too many arguments");
}
function ix(e, t, n = Number.MAX_SAFE_INTEGER) {
  const i = [];
  function r() {
    return new e();
  }
  return (
    "function" == typeof t && (e.prototype.onPoolReset = t),
    (e.prototype.release = function () {
      return e.release(this), this;
    }),
    (e.alloc = function (t) {
      if (!(t <= 0)) for (; t--; ) e.release(r());
    }),
    (e.get = function () {
      const e = i.pop() || r();
      return e.onPoolReset && e.onPoolReset(e), e;
    }),
    (e.release = function () {
      let e = arguments.length;
      for (; e--; ) i.length < n && i.push(arguments[e]);
    }),
    e
  );
}
class rx {
  addEventListener(e, t) {
    void 0 === this._listeners && (this._listeners = {});
    const n = this._listeners;
    void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t);
  }
  hasEventListener(e, t) {
    if (void 0 === this._listeners) return !1;
    const n = this._listeners;
    return void 0 !== n[e] && -1 !== n[e].indexOf(t);
  }
  removeEventListener(e, t) {
    if (void 0 === this._listeners) return;
    const n = this._listeners[e];
    if (void 0 !== n) {
      const e = n.indexOf(t);
      -1 !== e && n.splice(e, 1);
    }
  }
  dispatchEvent(e) {
    if (void 0 === this._listeners) return;
    const t = this._listeners[e.type];
    if (void 0 !== t) {
      e.target = this;
      const n = t.slice(0);
      for (let t = 0, i = n.length; t < i; t++) n[t].call(this, e);
      e.target = null;
    }
  }
}
const sx = Math.PI / 180,
  ax = 180 / Math.PI,
  ox = [];
for (let bN = 0; bN < 256; bN++)
  ox[bN] = (bN < 16 ? "0" : "") + bN.toString(16);
const lx = "undefined" != typeof crypto && "randomUUID" in crypto;
function cx() {
  if (lx) return crypto.randomUUID().toUpperCase();
  const e = (4294967295 * Math.random()) | 0,
    t = (4294967295 * Math.random()) | 0,
    n = (4294967295 * Math.random()) | 0,
    i = (4294967295 * Math.random()) | 0;
  return (
    ox[255 & e] +
    ox[(e >> 8) & 255] +
    ox[(e >> 16) & 255] +
    ox[(e >> 24) & 255] +
    "-" +
    ox[255 & t] +
    ox[(t >> 8) & 255] +
    "-" +
    ox[((t >> 16) & 15) | 64] +
    ox[(t >> 24) & 255] +
    "-" +
    ox[(63 & n) | 128] +
    ox[(n >> 8) & 255] +
    "-" +
    ox[(n >> 16) & 255] +
    ox[(n >> 24) & 255] +
    ox[255 & i] +
    ox[(i >> 8) & 255] +
    ox[(i >> 16) & 255] +
    ox[(i >> 24) & 255]
  ).toUpperCase();
}
function ux(e, t, n) {
  return Math.max(t, Math.min(n, e));
}
function hx(e, t, n) {
  return (1 - n) * e + n * t;
}
function dx(e) {
  return 0 == (e & (e - 1)) && 0 !== e;
}
function px(e) {
  return Math.pow(2, Math.floor(Math.log(e) / Math.LN2));
}
class fx {
  constructor(e = 0, t = 0) {
    (this.x = e), (this.y = t);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e, t) {
    return void 0 !== t
      ? this.addVectors(e, t)
      : ((this.x += e.x), (this.y += e.y), this);
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this;
  }
  sub(e, t) {
    return void 0 !== t
      ? this.subVectors(e, t)
      : ((this.x -= e.x), (this.y -= e.y), this);
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      n = this.y,
      i = e.elements;
    return (
      (this.x = i[0] * t + i[3] * n + i[6]),
      (this.y = i[1] * t + i[4] * n + i[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(e, Math.min(t, n))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      n = this.y - e.y;
    return t * t + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n), (this.y = e.y + (t.y - e.y) * n), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e;
  }
  fromBufferAttribute(e, t, n) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
  }
  rotateAround(e, t) {
    const n = Math.cos(t),
      i = Math.sin(t),
      r = this.x - e.x,
      s = this.y - e.y;
    return (this.x = r * n - s * i + e.x), (this.y = r * i + s * n + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
fx.prototype.isVector2 = !0;
class mx {
  constructor() {
    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  }
  set(e, t, n, i, r, s, a, o, l) {
    const c = this.elements;
    return (
      (c[0] = e),
      (c[1] = i),
      (c[2] = a),
      (c[3] = t),
      (c[4] = r),
      (c[5] = o),
      (c[6] = n),
      (c[7] = s),
      (c[8] = l),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements,
      n = e.elements;
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[3]),
      (t[4] = n[4]),
      (t[5] = n[5]),
      (t[6] = n[6]),
      (t[7] = n[7]),
      (t[8] = n[8]),
      this
    );
  }
  extractBasis(e, t, n) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      n.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements,
      i = t.elements,
      r = this.elements,
      s = n[0],
      a = n[3],
      o = n[6],
      l = n[1],
      c = n[4],
      u = n[7],
      h = n[2],
      d = n[5],
      p = n[8],
      f = i[0],
      m = i[3],
      g = i[6],
      v = i[1],
      _ = i[4],
      y = i[7],
      x = i[2],
      b = i[5],
      w = i[8];
    return (
      (r[0] = s * f + a * v + o * x),
      (r[3] = s * m + a * _ + o * b),
      (r[6] = s * g + a * y + o * w),
      (r[1] = l * f + c * v + u * x),
      (r[4] = l * m + c * _ + u * b),
      (r[7] = l * g + c * y + u * w),
      (r[2] = h * f + d * v + p * x),
      (r[5] = h * m + d * _ + p * b),
      (r[8] = h * g + d * y + p * w),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      r = e[3],
      s = e[4],
      a = e[5],
      o = e[6],
      l = e[7],
      c = e[8];
    return (
      t * s * c - t * a * l - n * r * c + n * a * o + i * r * l - i * s * o
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      r = e[3],
      s = e[4],
      a = e[5],
      o = e[6],
      l = e[7],
      c = e[8],
      u = c * s - a * l,
      h = a * o - c * r,
      d = l * r - s * o,
      p = t * u + n * h + i * d;
    if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const f = 1 / p;
    return (
      (e[0] = u * f),
      (e[1] = (i * l - c * n) * f),
      (e[2] = (a * n - i * s) * f),
      (e[3] = h * f),
      (e[4] = (c * t - i * o) * f),
      (e[5] = (i * r - a * t) * f),
      (e[6] = d * f),
      (e[7] = (n * o - l * t) * f),
      (e[8] = (s * t - n * r) * f),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, n, i, r, s, a) {
    const o = Math.cos(r),
      l = Math.sin(r);
    return (
      this.set(
        n * o,
        n * l,
        -n * (o * s + l * a) + s + e,
        -i * l,
        i * o,
        -i * (-l * s + o * a) + a + t,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, t) {
    const n = this.elements;
    return (
      (n[0] *= e),
      (n[3] *= e),
      (n[6] *= e),
      (n[1] *= t),
      (n[4] *= t),
      (n[7] *= t),
      this
    );
  }
  rotate(e) {
    const t = Math.cos(e),
      n = Math.sin(e),
      i = this.elements,
      r = i[0],
      s = i[3],
      a = i[6],
      o = i[1],
      l = i[4],
      c = i[7];
    return (
      (i[0] = t * r + n * o),
      (i[3] = t * s + n * l),
      (i[6] = t * a + n * c),
      (i[1] = -n * r + t * o),
      (i[4] = -n * s + t * l),
      (i[7] = -n * a + t * c),
      this
    );
  }
  translate(e, t) {
    const n = this.elements;
    return (
      (n[0] += e * n[2]),
      (n[3] += e * n[5]),
      (n[6] += e * n[8]),
      (n[1] += t * n[2]),
      (n[4] += t * n[5]),
      (n[7] += t * n[8]),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      n = e.elements;
    for (let i = 0; i < 9; i++) if (t[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return (
      (e[t] = n[0]),
      (e[t + 1] = n[1]),
      (e[t + 2] = n[2]),
      (e[t + 3] = n[3]),
      (e[t + 4] = n[4]),
      (e[t + 5] = n[5]),
      (e[t + 6] = n[6]),
      (e[t + 7] = n[7]),
      (e[t + 8] = n[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
function gx(e) {
  if (0 === e.length) return -Infinity;
  let t = e[0];
  for (let n = 1, i = e.length; n < i; ++n) e[n] > t && (t = e[n]);
  return t;
}
function vx(e) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", e);
}
let _x;
mx.prototype.isMatrix3 = !0;
let yx = 0;
class xx extends rx {
  constructor(
    e = xx.DEFAULT_IMAGE,
    t = xx.DEFAULT_MAPPING,
    n = 1001,
    i = 1001,
    r = 1006,
    s = 1008,
    a = 1023,
    o = 1009,
    l = 1,
    c = 3e3
  ) {
    super(),
      Object.defineProperty(this, "id", { value: yx++ }),
      (this.uuid = cx()),
      (this.name = ""),
      (this.image = e),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.wrapS = n),
      (this.wrapT = i),
      (this.magFilter = r),
      (this.minFilter = s),
      (this.anisotropy = l),
      (this.format = a),
      (this.internalFormat = null),
      (this.type = o),
      (this.offset = new fx(0, 0)),
      (this.repeat = new fx(1, 1)),
      (this.center = new fx(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new mx()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.encoding = c),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1);
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.image = e.image),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.encoding = e.encoding),
      this
    );
  }
  toJSON(e) {
    const t = void 0 === e || "string" == typeof e;
    if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
    const n = {
      metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    if (void 0 !== this.image) {
      const i = this.image;
      if (
        (void 0 === i.uuid && (i.uuid = cx()),
        !t && void 0 === e.images[i.uuid])
      ) {
        let t;
        if (Array.isArray(i)) {
          t = [];
          for (let e = 0, n = i.length; e < n; e++)
            i[e].isDataTexture ? t.push(bx(i[e].image)) : t.push(bx(i[e]));
        } else t = bx(i);
        e.images[i.uuid] = { uuid: i.uuid, url: t };
      }
      n.image = i.uuid;
    }
    return t || (e.textures[this.uuid] = n), n;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (300 !== this.mapping) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case 1e3:
          e.x = e.x - Math.floor(e.x);
          break;
        case 1001:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case 1002:
          1 === Math.abs(Math.floor(e.x) % 2)
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case 1e3:
          e.y = e.y - Math.floor(e.y);
          break;
        case 1001:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case 1002:
          1 === Math.abs(Math.floor(e.y) % 2)
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    !0 === e && this.version++;
  }
}
function bx(e) {
  return ("undefined" != typeof HTMLImageElement &&
    e instanceof HTMLImageElement) ||
    ("undefined" != typeof HTMLCanvasElement &&
      e instanceof HTMLCanvasElement) ||
    ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)
    ? class {
        static getDataURL(e) {
          if (/^data:/i.test(e.src)) return e.src;
          if ("undefined" == typeof HTMLCanvasElement) return e.src;
          let t;
          if (e instanceof HTMLCanvasElement) t = e;
          else {
            void 0 === _x && (_x = vx("canvas")),
              (_x.width = e.width),
              (_x.height = e.height);
            const n = _x.getContext("2d");
            e instanceof ImageData
              ? n.putImageData(e, 0, 0)
              : n.drawImage(e, 0, 0, e.width, e.height),
              (t = _x);
          }
          return t.width > 2048 || t.height > 2048
            ? t.toDataURL("image/jpeg", 0.6)
            : t.toDataURL("image/png");
        }
      }.getDataURL(e)
    : e.data
    ? {
        data: Array.prototype.slice.call(e.data),
        width: e.width,
        height: e.height,
        type: e.data.constructor.name,
      }
    : {};
}
(xx.DEFAULT_IMAGE = void 0),
  (xx.DEFAULT_MAPPING = 300),
  (xx.prototype.isTexture = !0);
class wx {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    (this.x = e), (this.y = t), (this.z = n), (this.w = i);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, n, i) {
    return (this.x = e), (this.y = t), (this.z = n), (this.w = i), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = void 0 !== e.w ? e.w : 1),
      this
    );
  }
  add(e, t) {
    return void 0 !== t
      ? this.addVectors(e, t)
      : ((this.x += e.x),
        (this.y += e.y),
        (this.z += e.z),
        (this.w += e.w),
        this);
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e, t) {
    return void 0 !== t
      ? this.subVectors(e, t)
      : ((this.x -= e.x),
        (this.y -= e.y),
        (this.z -= e.z),
        (this.w -= e.w),
        this);
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      r = this.w,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[4] * n + s[8] * i + s[12] * r),
      (this.y = s[1] * t + s[5] * n + s[9] * i + s[13] * r),
      (this.z = s[2] * t + s[6] * n + s[10] * i + s[14] * r),
      (this.w = s[3] * t + s[7] * n + s[11] * i + s[15] * r),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, n, i, r;
    const s = 0.01,
      a = 0.1,
      o = e.elements,
      l = o[0],
      c = o[4],
      u = o[8],
      h = o[1],
      d = o[5],
      p = o[9],
      f = o[2],
      m = o[6],
      g = o[10];
    if (Math.abs(c - h) < s && Math.abs(u - f) < s && Math.abs(p - m) < s) {
      if (
        Math.abs(c + h) < a &&
        Math.abs(u + f) < a &&
        Math.abs(p + m) < a &&
        Math.abs(l + d + g - 3) < a
      )
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const e = (l + 1) / 2,
        o = (d + 1) / 2,
        v = (g + 1) / 2,
        _ = (c + h) / 4,
        y = (u + f) / 4,
        x = (p + m) / 4;
      return (
        e > o && e > v
          ? e < s
            ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
            : ((n = Math.sqrt(e)), (i = _ / n), (r = y / n))
          : o > v
          ? o < s
            ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
            : ((i = Math.sqrt(o)), (n = _ / i), (r = x / i))
          : v < s
          ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
          : ((r = Math.sqrt(v)), (n = y / r), (i = x / r)),
        this.set(n, i, r, t),
        this
      );
    }
    let v = Math.sqrt(
      (m - p) * (m - p) + (u - f) * (u - f) + (h - c) * (h - c)
    );
    return (
      Math.abs(v) < 0.001 && (v = 1),
      (this.x = (m - p) / v),
      (this.y = (u - f) / v),
      (this.z = (h - c) / v),
      (this.w = Math.acos((l + d + g - 1) / 2)),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      (this.w = Math.max(e.w, Math.min(t.w, this.w))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      (this.w = Math.max(e, Math.min(t, this.w))),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(e, Math.min(t, n))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n),
      (this.y = e.y + (t.y - e.y) * n),
      (this.z = e.z + (t.z - e.z) * n),
      (this.w = e.w + (t.w - e.w) * n),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t, n) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
wx.prototype.isVector4 = !0;
class Sx extends rx {
  constructor(e, t, n = {}) {
    super(),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new wx(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new wx(0, 0, e, t)),
      (this.texture = new xx(
        void 0,
        n.mapping,
        n.wrapS,
        n.wrapT,
        n.magFilter,
        n.minFilter,
        n.format,
        n.type,
        n.anisotropy,
        n.encoding
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.image = { width: e, height: t, depth: 1 }),
      (this.texture.generateMipmaps =
        void 0 !== n.generateMipmaps && n.generateMipmaps),
      (this.texture.internalFormat =
        void 0 !== n.internalFormat ? n.internalFormat : null),
      (this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006),
      (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
      (this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer),
      (this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null);
  }
  setTexture(e) {
    (e.image = { width: this.width, height: this.height, depth: this.depth }),
      (this.texture = e);
  }
  setSize(e, t, n = 1) {
    (this.width === e && this.height === t && this.depth === n) ||
      ((this.width = e),
      (this.height = t),
      (this.depth = n),
      (this.texture.image.width = e),
      (this.texture.image.height = t),
      (this.texture.image.depth = n),
      this.dispose()),
      this.viewport.set(0, 0, e, t),
      this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.viewport.copy(e.viewport),
      (this.texture = e.texture.clone()),
      (this.texture.image = o({}, this.texture.image)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      (this.depthTexture = e.depthTexture),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
Sx.prototype.isWebGLRenderTarget = !0;
class Mx extends Sx {
  constructor(e, t, n) {
    super(e, t, n), (this.samples = 4);
  }
  copy(e) {
    return super.copy.call(this, e), (this.samples = e.samples), this;
  }
}
Mx.prototype.isWebGLMultisampleRenderTarget = !0;
class Tx {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    (this._x = e), (this._y = t), (this._z = n), (this._w = i);
  }
  static slerp(e, t, n, i) {
    return n.slerpQuaternions(e, t, i);
  }
  static slerpFlat(e, t, n, i, r, s, a) {
    let o = n[i + 0],
      l = n[i + 1],
      c = n[i + 2],
      u = n[i + 3];
    const h = r[s + 0],
      d = r[s + 1],
      p = r[s + 2],
      f = r[s + 3];
    if (0 === a)
      return (
        (e[t + 0] = o), (e[t + 1] = l), (e[t + 2] = c), void (e[t + 3] = u)
      );
    if (1 === a)
      return (
        (e[t + 0] = h), (e[t + 1] = d), (e[t + 2] = p), void (e[t + 3] = f)
      );
    if (u !== f || o !== h || l !== d || c !== p) {
      let e = 1 - a;
      const t = o * h + l * d + c * p + u * f,
        n = t >= 0 ? 1 : -1,
        i = 1 - t * t;
      if (i > Number.EPSILON) {
        const r = Math.sqrt(i),
          s = Math.atan2(r, t * n);
        (e = Math.sin(e * s) / r), (a = Math.sin(a * s) / r);
      }
      const r = a * n;
      if (
        ((o = o * e + h * r),
        (l = l * e + d * r),
        (c = c * e + p * r),
        (u = u * e + f * r),
        e === 1 - a)
      ) {
        const e = 1 / Math.sqrt(o * o + l * l + c * c + u * u);
        (o *= e), (l *= e), (c *= e), (u *= e);
      }
    }
    (e[t] = o), (e[t + 1] = l), (e[t + 2] = c), (e[t + 3] = u);
  }
  static multiplyQuaternionsFlat(e, t, n, i, r, s) {
    const a = n[i],
      o = n[i + 1],
      l = n[i + 2],
      c = n[i + 3],
      u = r[s],
      h = r[s + 1],
      d = r[s + 2],
      p = r[s + 3];
    return (
      (e[t] = a * p + c * u + o * d - l * h),
      (e[t + 1] = o * p + c * h + l * u - a * d),
      (e[t + 2] = l * p + c * d + a * h - o * u),
      (e[t + 3] = c * p - a * u - o * h - l * d),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, t, n, i) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._w = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t) {
    if (!e || !e.isEuler)
      throw new Error(
        "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
      );
    const n = e._x,
      i = e._y,
      r = e._z,
      s = e._order,
      a = Math.cos,
      o = Math.sin,
      l = a(n / 2),
      c = a(i / 2),
      u = a(r / 2),
      h = o(n / 2),
      d = o(i / 2),
      p = o(r / 2);
    switch (s) {
      case "XYZ":
        (this._x = h * c * u + l * d * p),
          (this._y = l * d * u - h * c * p),
          (this._z = l * c * p + h * d * u),
          (this._w = l * c * u - h * d * p);
        break;
      case "YXZ":
        (this._x = h * c * u + l * d * p),
          (this._y = l * d * u - h * c * p),
          (this._z = l * c * p - h * d * u),
          (this._w = l * c * u + h * d * p);
        break;
      case "ZXY":
        (this._x = h * c * u - l * d * p),
          (this._y = l * d * u + h * c * p),
          (this._z = l * c * p + h * d * u),
          (this._w = l * c * u - h * d * p);
        break;
      case "ZYX":
        (this._x = h * c * u - l * d * p),
          (this._y = l * d * u + h * c * p),
          (this._z = l * c * p - h * d * u),
          (this._w = l * c * u + h * d * p);
        break;
      case "YZX":
        (this._x = h * c * u + l * d * p),
          (this._y = l * d * u + h * c * p),
          (this._z = l * c * p - h * d * u),
          (this._w = l * c * u - h * d * p);
        break;
      case "XZY":
        (this._x = h * c * u - l * d * p),
          (this._y = l * d * u - h * c * p),
          (this._z = l * c * p + h * d * u),
          (this._w = l * c * u + h * d * p);
    }
    return !1 !== t && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const n = t / 2,
      i = Math.sin(n);
    return (
      (this._x = e.x * i),
      (this._y = e.y * i),
      (this._z = e.z * i),
      (this._w = Math.cos(n)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      n = t[0],
      i = t[4],
      r = t[8],
      s = t[1],
      a = t[5],
      o = t[9],
      l = t[2],
      c = t[6],
      u = t[10],
      h = n + a + u;
    if (h > 0) {
      const e = 0.5 / Math.sqrt(h + 1);
      (this._w = 0.25 / e),
        (this._x = (c - o) * e),
        (this._y = (r - l) * e),
        (this._z = (s - i) * e);
    } else if (n > a && n > u) {
      const e = 2 * Math.sqrt(1 + n - a - u);
      (this._w = (c - o) / e),
        (this._x = 0.25 * e),
        (this._y = (i + s) / e),
        (this._z = (r + l) / e);
    } else if (a > u) {
      const e = 2 * Math.sqrt(1 + a - n - u);
      (this._w = (r - l) / e),
        (this._x = (i + s) / e),
        (this._y = 0.25 * e),
        (this._z = (o + c) / e);
    } else {
      const e = 2 * Math.sqrt(1 + u - n - a);
      (this._w = (s - i) / e),
        (this._x = (r + l) / e),
        (this._y = (o + c) / e),
        (this._z = 0.25 * e);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let n = e.dot(t) + 1;
    return (
      n < Number.EPSILON
        ? ((n = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = n))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = n)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = n)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(ux(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const n = this.angleTo(e);
    if (0 === n) return this;
    const i = Math.min(1, t / n);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      0 === e
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e, t) {
    return void 0 !== t
      ? this.multiplyQuaternions(e, t)
      : this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const n = e._x,
      i = e._y,
      r = e._z,
      s = e._w,
      a = t._x,
      o = t._y,
      l = t._z,
      c = t._w;
    return (
      (this._x = n * c + s * a + i * l - r * o),
      (this._y = i * c + s * o + r * a - n * l),
      (this._z = r * c + s * l + n * o - i * a),
      (this._w = s * c - n * a - i * o - r * l),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (0 === t) return this;
    if (1 === t) return this.copy(e);
    const n = this._x,
      i = this._y,
      r = this._z,
      s = this._w;
    let a = s * e._w + n * e._x + i * e._y + r * e._z;
    if (
      (a < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (a = -a))
        : this.copy(e),
      a >= 1)
    )
      return (this._w = s), (this._x = n), (this._y = i), (this._z = r), this;
    const o = 1 - a * a;
    if (o <= Number.EPSILON) {
      const e = 1 - t;
      return (
        (this._w = e * s + t * this._w),
        (this._x = e * n + t * this._x),
        (this._y = e * i + t * this._y),
        (this._z = e * r + t * this._z),
        this.normalize(),
        this._onChangeCallback(),
        this
      );
    }
    const l = Math.sqrt(o),
      c = Math.atan2(l, a),
      u = Math.sin((1 - t) * c) / l,
      h = Math.sin(t * c) / l;
    return (
      (this._w = s * u + this._w * h),
      (this._x = n * u + this._x * h),
      (this._y = i * u + this._y * h),
      (this._z = r * u + this._z * h),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, n) {
    this.copy(e).slerp(t, n);
  }
  random() {
    const e = Math.random(),
      t = Math.sqrt(1 - e),
      n = Math.sqrt(e),
      i = 2 * Math.PI * Math.random(),
      r = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(i),
      n * Math.sin(r),
      n * Math.cos(r),
      t * Math.sin(i)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
}
Tx.prototype.isQuaternion = !0;
class Cx {
  constructor(e = 0, t = 0, n = 0) {
    (this.x = e), (this.y = t), (this.z = n);
  }
  set(e, t, n) {
    return (
      void 0 === n && (n = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = n),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e, t) {
    return void 0 !== t
      ? this.addVectors(e, t)
      : ((this.x += e.x), (this.y += e.y), (this.z += e.z), this);
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    );
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
  }
  sub(e, t) {
    return void 0 !== t
      ? this.subVectors(e, t)
      : ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this);
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    );
  }
  multiply(e, t) {
    return void 0 !== t
      ? this.multiplyVectors(e, t)
      : ((this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this);
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    );
  }
  applyEuler(e) {
    return !e || e.isEuler, this.applyQuaternion(Ax.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(Ax.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      r = e.elements;
    return (
      (this.x = r[0] * t + r[3] * n + r[6] * i),
      (this.y = r[1] * t + r[4] * n + r[7] * i),
      (this.z = r[2] * t + r[5] * n + r[8] * i),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      r = e.elements,
      s = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
    return (
      (this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * s),
      (this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * s),
      (this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * s),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      r = e.x,
      s = e.y,
      a = e.z,
      o = e.w,
      l = o * t + s * i - a * n,
      c = o * n + a * t - r * i,
      u = o * i + r * n - s * t,
      h = -r * t - s * n - a * i;
    return (
      (this.x = l * o + h * -r + c * -a - u * -s),
      (this.y = c * o + h * -s + u * -r - l * -a),
      (this.z = u * o + h * -a + l * -s - c * -r),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      r = e.elements;
    return (
      (this.x = r[0] * t + r[4] * n + r[8] * i),
      (this.y = r[1] * t + r[5] * n + r[9] * i),
      (this.z = r[2] * t + r[6] * n + r[10] * i),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(e, Math.min(t, n))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n),
      (this.y = e.y + (t.y - e.y) * n),
      (this.z = e.z + (t.z - e.z) * n),
      this
    );
  }
  cross(e, t) {
    return void 0 !== t ? this.crossVectors(e, t) : this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const n = e.x,
      i = e.y,
      r = e.z,
      s = t.x,
      a = t.y,
      o = t.z;
    return (
      (this.x = i * o - r * a),
      (this.y = r * s - n * o),
      (this.z = n * a - i * s),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (0 === t) return this.set(0, 0, 0);
    const n = e.dot(this) / t;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return Ex.copy(this).projectOnVector(e), this.sub(Ex);
  }
  reflect(e) {
    return this.sub(Ex.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (0 === t) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(ux(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      n = this.y - e.y,
      i = this.z - e.z;
    return t * t + n * n + i * i;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, n) {
    const i = Math.sin(t) * e;
    return (
      (this.x = i * Math.sin(n)),
      (this.y = Math.cos(t) * e),
      (this.z = i * Math.cos(n)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, n) {
    return (
      (this.x = e * Math.sin(t)), (this.y = n), (this.z = e * Math.cos(t)), this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      n = this.setFromMatrixColumn(e, 1).length(),
      i = this.setFromMatrixColumn(e, 2).length();
    return (this.x = t), (this.y = n), (this.z = i), this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, 4 * t);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, 3 * t);
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  fromBufferAttribute(e, t, n) {
    return (
      (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = 2 * (Math.random() - 0.5),
      t = Math.random() * Math.PI * 2,
      n = Math.sqrt(1 - e ** 2);
    return (
      (this.x = n * Math.cos(t)), (this.y = n * Math.sin(t)), (this.z = e), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
Cx.prototype.isVector3 = !0;
const Ex = new Cx(),
  Ax = new Tx();
class Px {
  constructor(
    e = new Cx(Infinity, Infinity, Infinity),
    t = new Cx(-Infinity, -Infinity, -Infinity)
  ) {
    (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    let t = Infinity,
      n = Infinity,
      i = Infinity,
      r = -Infinity,
      s = -Infinity,
      a = -Infinity;
    for (let o = 0, l = e.length; o < l; o += 3) {
      const l = e[o],
        c = e[o + 1],
        u = e[o + 2];
      l < t && (t = l),
        c < n && (n = c),
        u < i && (i = u),
        l > r && (r = l),
        c > s && (s = c),
        u > a && (a = u);
    }
    return this.min.set(t, n, i), this.max.set(r, s, a), this;
  }
  setFromBufferAttribute(e) {
    let t = Infinity,
      n = Infinity,
      i = Infinity,
      r = -Infinity,
      s = -Infinity,
      a = -Infinity;
    for (let o = 0, l = e.count; o < l; o++) {
      const l = e.getX(o),
        c = e.getY(o),
        u = e.getZ(o);
      l < t && (t = l),
        c < n && (n = c),
        u < i && (i = u),
        l > r && (r = l),
        c > s && (s = c),
        u > a && (a = u);
    }
    return this.min.set(t, n, i), this.max.set(r, s, a), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = Ix.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  setFromObject(e) {
    return this.makeEmpty(), this.expandByObject(e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = Infinity),
      (this.max.x = this.max.y = this.max.z = -Infinity),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e) {
    e.updateWorldMatrix(!1, !1);
    const t = e.geometry;
    void 0 !== t &&
      (null === t.boundingBox && t.computeBoundingBox(),
      Rx.copy(t.boundingBox),
      Rx.applyMatrix4(e.matrixWorld),
      this.union(Rx));
    const n = e.children;
    for (let i = 0, r = n.length; i < r; i++) this.expandByObject(n[i]);
    return this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y ||
      e.z < this.min.z ||
      e.z > this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y ||
      e.max.z < this.min.z ||
      e.min.z > this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, Ix),
      Ix.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, n;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (n += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (n += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (n += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (n += e.normal.z * this.min.z)),
      t <= -e.constant && n >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(Ux),
      Bx.subVectors(this.max, Ux),
      Dx.subVectors(e.a, Ux),
      kx.subVectors(e.b, Ux),
      Nx.subVectors(e.c, Ux),
      Ox.subVectors(kx, Dx),
      Fx.subVectors(Nx, kx),
      zx.subVectors(Dx, Nx);
    let t = [
      0,
      -Ox.z,
      Ox.y,
      0,
      -Fx.z,
      Fx.y,
      0,
      -zx.z,
      zx.y,
      Ox.z,
      0,
      -Ox.x,
      Fx.z,
      0,
      -Fx.x,
      zx.z,
      0,
      -zx.x,
      -Ox.y,
      Ox.x,
      0,
      -Fx.y,
      Fx.x,
      0,
      -zx.y,
      zx.x,
      0,
    ];
    return (
      !!Gx(t, Dx, kx, Nx, Bx) &&
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      !!Gx(t, Dx, kx, Nx, Bx) &&
        (Vx.crossVectors(Ox, Fx),
        (t = [Vx.x, Vx.y, Vx.z]),
        Gx(t, Dx, kx, Nx, Bx)))
    );
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return Ix.copy(e).clamp(this.min, this.max).sub(e).length();
  }
  getBoundingSphere(e) {
    return (
      this.getCenter(e.center), (e.radius = 0.5 * this.getSize(Ix).length()), e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return (
      this.isEmpty() ||
        (Lx[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Lx[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Lx[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Lx[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Lx[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Lx[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Lx[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Lx[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Lx)),
      this
    );
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
Px.prototype.isBox3 = !0;
const Lx = [
    new Cx(),
    new Cx(),
    new Cx(),
    new Cx(),
    new Cx(),
    new Cx(),
    new Cx(),
    new Cx(),
  ],
  Ix = new Cx(),
  Rx = new Px(),
  Dx = new Cx(),
  kx = new Cx(),
  Nx = new Cx(),
  Ox = new Cx(),
  Fx = new Cx(),
  zx = new Cx(),
  Ux = new Cx(),
  Bx = new Cx(),
  Vx = new Cx(),
  Hx = new Cx();
function Gx(e, t, n, i, r) {
  for (let s = 0, a = e.length - 3; s <= a; s += 3) {
    Hx.fromArray(e, s);
    const a =
        r.x * Math.abs(Hx.x) + r.y * Math.abs(Hx.y) + r.z * Math.abs(Hx.z),
      o = t.dot(Hx),
      l = n.dot(Hx),
      c = i.dot(Hx);
    if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a) return !1;
  }
  return !0;
}
const Wx = new Px(),
  qx = new Cx(),
  jx = new Cx(),
  Yx = new Cx();
class Xx {
  constructor(e = new Cx(), t = -1) {
    (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this;
  }
  setFromPoints(e, t) {
    const n = this.center;
    void 0 !== t ? n.copy(t) : Wx.setFromPoints(e).getCenter(n);
    let i = 0;
    for (let r = 0, s = e.length; r < s; r++)
      i = Math.max(i, n.distanceToSquared(e[r]));
    return (this.radius = Math.sqrt(i)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const n = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      n > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    Yx.subVectors(e, this.center);
    const t = Yx.lengthSq();
    if (t > this.radius * this.radius) {
      const e = Math.sqrt(t),
        n = 0.5 * (e - this.radius);
      this.center.add(Yx.multiplyScalar(n / e)), (this.radius += n);
    }
    return this;
  }
  union(e) {
    return (
      jx.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius),
      this.expandByPoint(qx.copy(e.center).add(jx)),
      this.expandByPoint(qx.copy(e.center).sub(jx)),
      this
    );
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const $x = new Cx(),
  Zx = new Cx(),
  Kx = new Cx(),
  Jx = new Cx(),
  Qx = new Cx(),
  eb = new Cx(),
  tb = new Cx();
class nb {
  constructor(e = new Cx(), t = new Cx(0, 0, -1)) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.direction).multiplyScalar(e).add(this.origin);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, $x)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const n = t.dot(this.direction);
    return n < 0
      ? t.copy(this.origin)
      : t.copy(this.direction).multiplyScalar(n).add(this.origin);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = $x.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : ($x.copy(this.direction).multiplyScalar(t).add(this.origin),
        $x.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, n, i) {
    Zx.copy(e).add(t).multiplyScalar(0.5),
      Kx.copy(t).sub(e).normalize(),
      Jx.copy(this.origin).sub(Zx);
    const r = 0.5 * e.distanceTo(t),
      s = -this.direction.dot(Kx),
      a = Jx.dot(this.direction),
      o = -Jx.dot(Kx),
      l = Jx.lengthSq(),
      c = Math.abs(1 - s * s);
    let u, h, d, p;
    if (c > 0)
      if (((u = s * o - a), (h = s * a - o), (p = r * c), u >= 0))
        if (h >= -p)
          if (h <= p) {
            const e = 1 / c;
            (u *= e),
              (h *= e),
              (d = u * (u + s * h + 2 * a) + h * (s * u + h + 2 * o) + l);
          } else
            (h = r),
              (u = Math.max(0, -(s * h + a))),
              (d = -u * u + h * (h + 2 * o) + l);
        else
          (h = -r),
            (u = Math.max(0, -(s * h + a))),
            (d = -u * u + h * (h + 2 * o) + l);
      else
        h <= -p
          ? ((u = Math.max(0, -(-s * r + a))),
            (h = u > 0 ? -r : Math.min(Math.max(-r, -o), r)),
            (d = -u * u + h * (h + 2 * o) + l))
          : h <= p
          ? ((u = 0),
            (h = Math.min(Math.max(-r, -o), r)),
            (d = h * (h + 2 * o) + l))
          : ((u = Math.max(0, -(s * r + a))),
            (h = u > 0 ? r : Math.min(Math.max(-r, -o), r)),
            (d = -u * u + h * (h + 2 * o) + l));
    else
      (h = s > 0 ? -r : r),
        (u = Math.max(0, -(s * h + a))),
        (d = -u * u + h * (h + 2 * o) + l);
    return (
      n && n.copy(this.direction).multiplyScalar(u).add(this.origin),
      i && i.copy(Kx).multiplyScalar(h).add(Zx),
      d
    );
  }
  intersectSphere(e, t) {
    $x.subVectors(e.center, this.origin);
    const n = $x.dot(this.direction),
      i = $x.dot($x) - n * n,
      r = e.radius * e.radius;
    if (i > r) return null;
    const s = Math.sqrt(r - i),
      a = n - s,
      o = n + s;
    return a < 0 && o < 0 ? null : a < 0 ? this.at(o, t) : this.at(a, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / t;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, t) {
    const n = this.distanceToPlane(e);
    return null === n ? null : this.at(n, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    if (0 === t) return !0;
    return e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let n, i, r, s, a, o;
    const l = 1 / this.direction.x,
      c = 1 / this.direction.y,
      u = 1 / this.direction.z,
      h = this.origin;
    return (
      l >= 0
        ? ((n = (e.min.x - h.x) * l), (i = (e.max.x - h.x) * l))
        : ((n = (e.max.x - h.x) * l), (i = (e.min.x - h.x) * l)),
      c >= 0
        ? ((r = (e.min.y - h.y) * c), (s = (e.max.y - h.y) * c))
        : ((r = (e.max.y - h.y) * c), (s = (e.min.y - h.y) * c)),
      n > s || r > i
        ? null
        : ((r > n || n != n) && (n = r),
          (s < i || i != i) && (i = s),
          u >= 0
            ? ((a = (e.min.z - h.z) * u), (o = (e.max.z - h.z) * u))
            : ((a = (e.max.z - h.z) * u), (o = (e.min.z - h.z) * u)),
          n > o || a > i
            ? null
            : ((a > n || n != n) && (n = a),
              (o < i || i != i) && (i = o),
              i < 0 ? null : this.at(n >= 0 ? n : i, t)))
    );
  }
  intersectsBox(e) {
    return null !== this.intersectBox(e, $x);
  }
  intersectTriangle(e, t, n, i, r) {
    Qx.subVectors(t, e), eb.subVectors(n, e), tb.crossVectors(Qx, eb);
    let s,
      a = this.direction.dot(tb);
    if (a > 0) {
      if (i) return null;
      s = 1;
    } else {
      if (!(a < 0)) return null;
      (s = -1), (a = -a);
    }
    Jx.subVectors(this.origin, e);
    const o = s * this.direction.dot(eb.crossVectors(Jx, eb));
    if (o < 0) return null;
    const l = s * this.direction.dot(Qx.cross(Jx));
    if (l < 0) return null;
    if (o + l > a) return null;
    const c = -s * Jx.dot(tb);
    return c < 0 ? null : this.at(c / a, r);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class ib {
  constructor() {
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  set(e, t, n, i, r, s, a, o, l, c, u, h, d, p, f, m) {
    const g = this.elements;
    return (
      (g[0] = e),
      (g[4] = t),
      (g[8] = n),
      (g[12] = i),
      (g[1] = r),
      (g[5] = s),
      (g[9] = a),
      (g[13] = o),
      (g[2] = l),
      (g[6] = c),
      (g[10] = u),
      (g[14] = h),
      (g[3] = d),
      (g[7] = p),
      (g[11] = f),
      (g[15] = m),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new ib().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      n = e.elements;
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[3]),
      (t[4] = n[4]),
      (t[5] = n[5]),
      (t[6] = n[6]),
      (t[7] = n[7]),
      (t[8] = n[8]),
      (t[9] = n[9]),
      (t[10] = n[10]),
      (t[11] = n[11]),
      (t[12] = n[12]),
      (t[13] = n[13]),
      (t[14] = n[14]),
      (t[15] = n[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      n = e.elements;
    return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, t, n) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      n.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, n) {
    return (
      this.set(
        e.x,
        t.x,
        n.x,
        0,
        e.y,
        t.y,
        n.y,
        0,
        e.z,
        t.z,
        n.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      n = e.elements,
      i = 1 / rb.setFromMatrixColumn(e, 0).length(),
      r = 1 / rb.setFromMatrixColumn(e, 1).length(),
      s = 1 / rb.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = n[0] * i),
      (t[1] = n[1] * i),
      (t[2] = n[2] * i),
      (t[3] = 0),
      (t[4] = n[4] * r),
      (t[5] = n[5] * r),
      (t[6] = n[6] * r),
      (t[7] = 0),
      (t[8] = n[8] * s),
      (t[9] = n[9] * s),
      (t[10] = n[10] * s),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    !e || e.isEuler;
    const t = this.elements,
      n = e.x,
      i = e.y,
      r = e.z,
      s = Math.cos(n),
      a = Math.sin(n),
      o = Math.cos(i),
      l = Math.sin(i),
      c = Math.cos(r),
      u = Math.sin(r);
    if ("XYZ" === e.order) {
      const e = s * c,
        n = s * u,
        i = a * c,
        r = a * u;
      (t[0] = o * c),
        (t[4] = -o * u),
        (t[8] = l),
        (t[1] = n + i * l),
        (t[5] = e - r * l),
        (t[9] = -a * o),
        (t[2] = r - e * l),
        (t[6] = i + n * l),
        (t[10] = s * o);
    } else if ("YXZ" === e.order) {
      const e = o * c,
        n = o * u,
        i = l * c,
        r = l * u;
      (t[0] = e + r * a),
        (t[4] = i * a - n),
        (t[8] = s * l),
        (t[1] = s * u),
        (t[5] = s * c),
        (t[9] = -a),
        (t[2] = n * a - i),
        (t[6] = r + e * a),
        (t[10] = s * o);
    } else if ("ZXY" === e.order) {
      const e = o * c,
        n = o * u,
        i = l * c,
        r = l * u;
      (t[0] = e - r * a),
        (t[4] = -s * u),
        (t[8] = i + n * a),
        (t[1] = n + i * a),
        (t[5] = s * c),
        (t[9] = r - e * a),
        (t[2] = -s * l),
        (t[6] = a),
        (t[10] = s * o);
    } else if ("ZYX" === e.order) {
      const e = s * c,
        n = s * u,
        i = a * c,
        r = a * u;
      (t[0] = o * c),
        (t[4] = i * l - n),
        (t[8] = e * l + r),
        (t[1] = o * u),
        (t[5] = r * l + e),
        (t[9] = n * l - i),
        (t[2] = -l),
        (t[6] = a * o),
        (t[10] = s * o);
    } else if ("YZX" === e.order) {
      const e = s * o,
        n = s * l,
        i = a * o,
        r = a * l;
      (t[0] = o * c),
        (t[4] = r - e * u),
        (t[8] = i * u + n),
        (t[1] = u),
        (t[5] = s * c),
        (t[9] = -a * c),
        (t[2] = -l * c),
        (t[6] = n * u + i),
        (t[10] = e - r * u);
    } else if ("XZY" === e.order) {
      const e = s * o,
        n = s * l,
        i = a * o,
        r = a * l;
      (t[0] = o * c),
        (t[4] = -u),
        (t[8] = l * c),
        (t[1] = e * u + r),
        (t[5] = s * c),
        (t[9] = n * u - i),
        (t[2] = i * u - n),
        (t[6] = a * c),
        (t[10] = r * u + e);
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(ab, e, ob);
  }
  lookAt(e, t, n) {
    const i = this.elements;
    return (
      ub.subVectors(e, t),
      0 === ub.lengthSq() && (ub.z = 1),
      ub.normalize(),
      lb.crossVectors(n, ub),
      0 === lb.lengthSq() &&
        (1 === Math.abs(n.z) ? (ub.x += 1e-4) : (ub.z += 1e-4),
        ub.normalize(),
        lb.crossVectors(n, ub)),
      lb.normalize(),
      cb.crossVectors(ub, lb),
      (i[0] = lb.x),
      (i[4] = cb.x),
      (i[8] = ub.x),
      (i[1] = lb.y),
      (i[5] = cb.y),
      (i[9] = ub.y),
      (i[2] = lb.z),
      (i[6] = cb.z),
      (i[10] = ub.z),
      this
    );
  }
  multiply(e, t) {
    return void 0 !== t
      ? this.multiplyMatrices(e, t)
      : this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements,
      i = t.elements,
      r = this.elements,
      s = n[0],
      a = n[4],
      o = n[8],
      l = n[12],
      c = n[1],
      u = n[5],
      h = n[9],
      d = n[13],
      p = n[2],
      f = n[6],
      m = n[10],
      g = n[14],
      v = n[3],
      _ = n[7],
      y = n[11],
      x = n[15],
      b = i[0],
      w = i[4],
      S = i[8],
      M = i[12],
      T = i[1],
      C = i[5],
      E = i[9],
      A = i[13],
      P = i[2],
      L = i[6],
      I = i[10],
      R = i[14],
      D = i[3],
      k = i[7],
      N = i[11],
      O = i[15];
    return (
      (r[0] = s * b + a * T + o * P + l * D),
      (r[4] = s * w + a * C + o * L + l * k),
      (r[8] = s * S + a * E + o * I + l * N),
      (r[12] = s * M + a * A + o * R + l * O),
      (r[1] = c * b + u * T + h * P + d * D),
      (r[5] = c * w + u * C + h * L + d * k),
      (r[9] = c * S + u * E + h * I + d * N),
      (r[13] = c * M + u * A + h * R + d * O),
      (r[2] = p * b + f * T + m * P + g * D),
      (r[6] = p * w + f * C + m * L + g * k),
      (r[10] = p * S + f * E + m * I + g * N),
      (r[14] = p * M + f * A + m * R + g * O),
      (r[3] = v * b + _ * T + y * P + x * D),
      (r[7] = v * w + _ * C + y * L + x * k),
      (r[11] = v * S + _ * E + y * I + x * N),
      (r[15] = v * M + _ * A + y * R + x * O),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      n = e[4],
      i = e[8],
      r = e[12],
      s = e[1],
      a = e[5],
      o = e[9],
      l = e[13],
      c = e[2],
      u = e[6],
      h = e[10],
      d = e[14];
    return (
      e[3] *
        (+r * o * u -
          i * l * u -
          r * a * h +
          n * l * h +
          i * a * d -
          n * o * d) +
      e[7] *
        (+t * o * d -
          t * l * h +
          r * s * h -
          i * s * d +
          i * l * c -
          r * o * c) +
      e[11] *
        (+t * l * u -
          t * a * d -
          r * s * u +
          n * s * d +
          r * a * c -
          n * l * c) +
      e[15] *
        (-i * a * c - t * o * u + t * a * h + i * s * u - n * s * h + n * o * c)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, n) {
    const i = this.elements;
    return (
      e.isVector3
        ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
        : ((i[12] = e), (i[13] = t), (i[14] = n)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      r = e[3],
      s = e[4],
      a = e[5],
      o = e[6],
      l = e[7],
      c = e[8],
      u = e[9],
      h = e[10],
      d = e[11],
      p = e[12],
      f = e[13],
      m = e[14],
      g = e[15],
      v = u * m * l - f * h * l + f * o * d - a * m * d - u * o * g + a * h * g,
      _ = p * h * l - c * m * l - p * o * d + s * m * d + c * o * g - s * h * g,
      y = c * f * l - p * u * l + p * a * d - s * f * d - c * a * g + s * u * g,
      x = p * u * o - c * f * o - p * a * h + s * f * h + c * a * m - s * u * m,
      b = t * v + n * _ + i * y + r * x;
    if (0 === b)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const w = 1 / b;
    return (
      (e[0] = v * w),
      (e[1] =
        (f * h * r -
          u * m * r -
          f * i * d +
          n * m * d +
          u * i * g -
          n * h * g) *
        w),
      (e[2] =
        (a * m * r -
          f * o * r +
          f * i * l -
          n * m * l -
          a * i * g +
          n * o * g) *
        w),
      (e[3] =
        (u * o * r -
          a * h * r -
          u * i * l +
          n * h * l +
          a * i * d -
          n * o * d) *
        w),
      (e[4] = _ * w),
      (e[5] =
        (c * m * r -
          p * h * r +
          p * i * d -
          t * m * d -
          c * i * g +
          t * h * g) *
        w),
      (e[6] =
        (p * o * r -
          s * m * r -
          p * i * l +
          t * m * l +
          s * i * g -
          t * o * g) *
        w),
      (e[7] =
        (s * h * r -
          c * o * r +
          c * i * l -
          t * h * l -
          s * i * d +
          t * o * d) *
        w),
      (e[8] = y * w),
      (e[9] =
        (p * u * r -
          c * f * r -
          p * n * d +
          t * f * d +
          c * n * g -
          t * u * g) *
        w),
      (e[10] =
        (s * f * r -
          p * a * r +
          p * n * l -
          t * f * l -
          s * n * g +
          t * a * g) *
        w),
      (e[11] =
        (c * a * r -
          s * u * r -
          c * n * l +
          t * u * l +
          s * n * d -
          t * a * d) *
        w),
      (e[12] = x * w),
      (e[13] =
        (c * f * i -
          p * u * i +
          p * n * h -
          t * f * h -
          c * n * m +
          t * u * m) *
        w),
      (e[14] =
        (p * a * i -
          s * f * i -
          p * n * o +
          t * f * o +
          s * n * m -
          t * a * m) *
        w),
      (e[15] =
        (s * u * i -
          c * a * i +
          c * n * o -
          t * u * o -
          s * n * h +
          t * a * h) *
        w),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      n = e.x,
      i = e.y,
      r = e.z;
    return (
      (t[0] *= n),
      (t[4] *= i),
      (t[8] *= r),
      (t[1] *= n),
      (t[5] *= i),
      (t[9] *= r),
      (t[2] *= n),
      (t[6] *= i),
      (t[10] *= r),
      (t[3] *= n),
      (t[7] *= i),
      (t[11] *= r),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, n, i));
  }
  makeTranslation(e, t, n) {
    return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const n = Math.cos(t),
      i = Math.sin(t),
      r = 1 - n,
      s = e.x,
      a = e.y,
      o = e.z,
      l = r * s,
      c = r * a;
    return (
      this.set(
        l * s + n,
        l * a - i * o,
        l * o + i * a,
        0,
        l * a + i * o,
        c * a + n,
        c * o - i * s,
        0,
        l * o - i * a,
        c * o + i * s,
        r * o * o + n,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, t, n) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, n, i, r, s) {
    return this.set(1, n, r, 0, e, 1, s, 0, t, i, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, n) {
    const i = this.elements,
      r = t._x,
      s = t._y,
      a = t._z,
      o = t._w,
      l = r + r,
      c = s + s,
      u = a + a,
      h = r * l,
      d = r * c,
      p = r * u,
      f = s * c,
      m = s * u,
      g = a * u,
      v = o * l,
      _ = o * c,
      y = o * u,
      x = n.x,
      b = n.y,
      w = n.z;
    return (
      (i[0] = (1 - (f + g)) * x),
      (i[1] = (d + y) * x),
      (i[2] = (p - _) * x),
      (i[3] = 0),
      (i[4] = (d - y) * b),
      (i[5] = (1 - (h + g)) * b),
      (i[6] = (m + v) * b),
      (i[7] = 0),
      (i[8] = (p + _) * w),
      (i[9] = (m - v) * w),
      (i[10] = (1 - (h + f)) * w),
      (i[11] = 0),
      (i[12] = e.x),
      (i[13] = e.y),
      (i[14] = e.z),
      (i[15] = 1),
      this
    );
  }
  decompose(e, t, n) {
    const i = this.elements;
    let r = rb.set(i[0], i[1], i[2]).length();
    const s = rb.set(i[4], i[5], i[6]).length(),
      a = rb.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (r = -r),
      (e.x = i[12]),
      (e.y = i[13]),
      (e.z = i[14]),
      sb.copy(this);
    const o = 1 / r,
      l = 1 / s,
      c = 1 / a;
    return (
      (sb.elements[0] *= o),
      (sb.elements[1] *= o),
      (sb.elements[2] *= o),
      (sb.elements[4] *= l),
      (sb.elements[5] *= l),
      (sb.elements[6] *= l),
      (sb.elements[8] *= c),
      (sb.elements[9] *= c),
      (sb.elements[10] *= c),
      t.setFromRotationMatrix(sb),
      (n.x = r),
      (n.y = s),
      (n.z = a),
      this
    );
  }
  makePerspective(e, t, n, i, r, s) {
    const a = this.elements,
      o = (2 * r) / (t - e),
      l = (2 * r) / (n - i),
      c = (t + e) / (t - e),
      u = (n + i) / (n - i),
      h = -(s + r) / (s - r),
      d = (-2 * s * r) / (s - r);
    return (
      (a[0] = o),
      (a[4] = 0),
      (a[8] = c),
      (a[12] = 0),
      (a[1] = 0),
      (a[5] = l),
      (a[9] = u),
      (a[13] = 0),
      (a[2] = 0),
      (a[6] = 0),
      (a[10] = h),
      (a[14] = d),
      (a[3] = 0),
      (a[7] = 0),
      (a[11] = -1),
      (a[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, n, i, r, s) {
    const a = this.elements,
      o = 1 / (t - e),
      l = 1 / (n - i),
      c = 1 / (s - r),
      u = (t + e) * o,
      h = (n + i) * l,
      d = (s + r) * c;
    return (
      (a[0] = 2 * o),
      (a[4] = 0),
      (a[8] = 0),
      (a[12] = -u),
      (a[1] = 0),
      (a[5] = 2 * l),
      (a[9] = 0),
      (a[13] = -h),
      (a[2] = 0),
      (a[6] = 0),
      (a[10] = -2 * c),
      (a[14] = -d),
      (a[3] = 0),
      (a[7] = 0),
      (a[11] = 0),
      (a[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      n = e.elements;
    for (let i = 0; i < 16; i++) if (t[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return (
      (e[t] = n[0]),
      (e[t + 1] = n[1]),
      (e[t + 2] = n[2]),
      (e[t + 3] = n[3]),
      (e[t + 4] = n[4]),
      (e[t + 5] = n[5]),
      (e[t + 6] = n[6]),
      (e[t + 7] = n[7]),
      (e[t + 8] = n[8]),
      (e[t + 9] = n[9]),
      (e[t + 10] = n[10]),
      (e[t + 11] = n[11]),
      (e[t + 12] = n[12]),
      (e[t + 13] = n[13]),
      (e[t + 14] = n[14]),
      (e[t + 15] = n[15]),
      e
    );
  }
}
ib.prototype.isMatrix4 = !0;
const rb = new Cx(),
  sb = new ib(),
  ab = new Cx(0, 0, 0),
  ob = new Cx(1, 1, 1),
  lb = new Cx(),
  cb = new Cx(),
  ub = new Cx(),
  hb = new ib(),
  db = new Tx();
class pb {
  constructor(e = 0, t = 0, n = 0, i = pb.DefaultOrder) {
    (this._x = e), (this._y = t), (this._z = n), (this._order = i);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, t, n, i = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._order = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, n = !0) {
    const i = e.elements,
      r = i[0],
      s = i[4],
      a = i[8],
      o = i[1],
      l = i[5],
      c = i[9],
      u = i[2],
      h = i[6],
      d = i[10];
    switch (t) {
      case "XYZ":
        (this._y = Math.asin(ux(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(-c, d)), (this._z = Math.atan2(-s, r)))
            : ((this._x = Math.atan2(h, l)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-ux(c, -1, 1))),
          Math.abs(c) < 0.9999999
            ? ((this._y = Math.atan2(a, d)), (this._z = Math.atan2(o, l)))
            : ((this._y = Math.atan2(-u, r)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(ux(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._y = Math.atan2(-u, d)), (this._z = Math.atan2(-s, l)))
            : ((this._y = 0), (this._z = Math.atan2(o, r)));
        break;
      case "ZYX":
        (this._y = Math.asin(-ux(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._x = Math.atan2(h, d)), (this._z = Math.atan2(o, r)))
            : ((this._x = 0), (this._z = Math.atan2(-s, l)));
        break;
      case "YZX":
        (this._z = Math.asin(ux(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(-c, l)), (this._y = Math.atan2(-u, r)))
            : ((this._x = 0), (this._y = Math.atan2(a, d)));
        break;
      case "XZY":
        (this._z = Math.asin(-ux(s, -1, 1))),
          Math.abs(s) < 0.9999999
            ? ((this._x = Math.atan2(h, l)), (this._y = Math.atan2(a, r)))
            : ((this._x = Math.atan2(-c, d)), (this._y = 0));
    }
    return (this._order = t), !0 === n && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, n) {
    return (
      hb.makeRotationFromQuaternion(e), this.setFromRotationMatrix(hb, t, n)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return db.setFromEuler(this), this.setFromQuaternion(db, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      void 0 !== e[3] && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  toVector3(e) {
    return e
      ? e.set(this._x, this._y, this._z)
      : new Cx(this._x, this._y, this._z);
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
}
(pb.prototype.isEuler = !0),
  (pb.DefaultOrder = "XYZ"),
  (pb.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]);
class fb {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e) | 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return 0 != (this.mask & e.mask);
  }
}
let mb = 0;
const gb = new Cx(),
  vb = new Tx(),
  _b = new ib(),
  yb = new Cx(),
  xb = new Cx(),
  bb = new Cx(),
  wb = new Tx(),
  Sb = new Cx(1, 0, 0),
  Mb = new Cx(0, 1, 0),
  Tb = new Cx(0, 0, 1),
  Cb = { type: "added" },
  Eb = { type: "removed" };
class Ab extends rx {
  constructor() {
    super(),
      Object.defineProperty(this, "id", { value: mb++ }),
      (this.uuid = cx()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = Ab.DefaultUp.clone());
    const e = new Cx(),
      t = new pb(),
      n = new Tx(),
      i = new Cx(1, 1, 1);
    t._onChange(function () {
      n.setFromEuler(t, !1);
    }),
      n._onChange(function () {
        t.setFromQuaternion(n, void 0, !1);
      }),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: n },
        scale: { configurable: !0, enumerable: !0, value: i },
        modelViewMatrix: { value: new ib() },
        normalMatrix: { value: new mx() },
      }),
      (this.matrix = new ib()),
      (this.matrixWorld = new ib()),
      (this.matrixAutoUpdate = Ab.DefaultMatrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new fb()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return vb.setFromAxisAngle(e, t), this.quaternion.multiply(vb), this;
  }
  rotateOnWorldAxis(e, t) {
    return vb.setFromAxisAngle(e, t), this.quaternion.premultiply(vb), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(Sb, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(Mb, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(Tb, e);
  }
  translateOnAxis(e, t) {
    return (
      gb.copy(e).applyQuaternion(this.quaternion),
      this.position.add(gb.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(Sb, e);
  }
  translateY(e) {
    return this.translateOnAxis(Mb, e);
  }
  translateZ(e) {
    return this.translateOnAxis(Tb, e);
  }
  localToWorld(e) {
    return e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return e.applyMatrix4(_b.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, n) {
    e.isVector3 ? yb.copy(e) : yb.set(e, t, n);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1),
      xb.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? _b.lookAt(xb, yb, this.up)
        : _b.lookAt(yb, xb, this.up),
      this.quaternion.setFromRotationMatrix(_b),
      i &&
        (_b.extractRotation(i.matrixWorld),
        vb.setFromRotationMatrix(_b),
        this.quaternion.premultiply(vb.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
      return this;
    }
    return (
      e === this ||
        (e &&
          e.isObject3D &&
          (null !== e.parent && e.parent.remove(e),
          (e.parent = this),
          this.children.push(e),
          e.dispatchEvent(Cb))),
      this
    );
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let e = 0; e < arguments.length; e++) this.remove(arguments[e]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      -1 !== t &&
        ((e.parent = null), this.children.splice(t, 1), e.dispatchEvent(Eb)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return null !== e && e.remove(this), this;
  }
  clear() {
    for (let e = 0; e < this.children.length; e++) {
      const t = this.children[e];
      (t.parent = null), t.dispatchEvent(Eb);
    }
    return (this.children.length = 0), this;
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      _b.copy(this.matrixWorld).invert(),
      null !== e.parent &&
        (e.parent.updateWorldMatrix(!0, !1), _b.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(_b),
      this.add(e),
      e.updateWorldMatrix(!1, !0),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let n = 0, i = this.children.length; n < i; n++) {
      const i = this.children[n].getObjectByProperty(e, t);
      if (void 0 !== i) return i;
    }
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(xb, e, bb), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(xb, wb, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e);
  }
  traverseVisible(e) {
    if (!1 === this.visible) return;
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    null !== t && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (null === this.parent
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, t) {
    const n = this.parent;
    if (
      (!0 === e && null !== n && n.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      null === this.parent
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          ),
      !0 === t)
    ) {
      const e = this.children;
      for (let t = 0, n = e.length; t < n; t++) e[t].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const t = void 0 === e || "string" == typeof e,
      n = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
      }),
      (n.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const i = {};
    function r(t, n) {
      return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid;
    }
    if (
      ((i.uuid = this.uuid),
      (i.type = this.type),
      "" !== this.name && (i.name = this.name),
      !0 === this.castShadow && (i.castShadow = !0),
      !0 === this.receiveShadow && (i.receiveShadow = !0),
      !1 === this.visible && (i.visible = !1),
      !1 === this.frustumCulled && (i.frustumCulled = !1),
      0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
      "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
      (i.layers = this.layers.mask),
      (i.matrix = this.matrix.toArray()),
      !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((i.type = "InstancedMesh"),
        (i.count = this.count),
        (i.instanceMatrix = this.instanceMatrix.toJSON()),
        null !== this.instanceColor &&
          (i.instanceColor = this.instanceColor.toJSON())),
      this.isScene)
    )
      this.background &&
        (this.background.isColor
          ? (i.background = this.background.toJSON())
          : this.background.isTexture &&
            (i.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = r(e.geometries, this.geometry);
      const t = this.geometry.parameters;
      if (void 0 !== t && void 0 !== t.shapes) {
        const n = t.shapes;
        if (Array.isArray(n))
          for (let t = 0, i = n.length; t < i; t++) {
            const i = n[t];
            r(e.shapes, i);
          }
        else r(e.shapes, n);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((i.bindMode = this.bindMode),
        (i.bindMatrix = this.bindMatrix.toArray()),
        void 0 !== this.skeleton &&
          (r(e.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
      void 0 !== this.material)
    )
      if (Array.isArray(this.material)) {
        const t = [];
        for (let n = 0, i = this.material.length; n < i; n++)
          t.push(r(e.materials, this.material[n]));
        i.material = t;
      } else i.material = r(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let t = 0; t < this.children.length; t++)
        i.children.push(this.children[t].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let t = 0; t < this.animations.length; t++) {
        const n = this.animations[t];
        i.animations.push(r(e.animations, n));
      }
    }
    if (t) {
      const t = s(e.geometries),
        i = s(e.materials),
        r = s(e.textures),
        a = s(e.images),
        o = s(e.shapes),
        l = s(e.skeletons),
        c = s(e.animations);
      t.length > 0 && (n.geometries = t),
        i.length > 0 && (n.materials = i),
        r.length > 0 && (n.textures = r),
        a.length > 0 && (n.images = a),
        o.length > 0 && (n.shapes = o),
        l.length > 0 && (n.skeletons = l),
        c.length > 0 && (n.animations = c);
    }
    return (n.object = i), n;
    function s(e) {
      const t = [];
      for (const n in e) {
        const i = e[n];
        delete i.metadata, t.push(i);
      }
      return t;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      !0 === t)
    )
      for (let n = 0; n < e.children.length; n++) {
        const t = e.children[n];
        this.add(t.clone());
      }
    return this;
  }
}
(Ab.DefaultUp = new Cx(0, 1, 0)),
  (Ab.DefaultMatrixAutoUpdate = !0),
  (Ab.prototype.isObject3D = !0);
const Pb = new Cx(),
  Lb = new Cx(),
  Ib = new Cx(),
  Rb = new Cx(),
  Db = new Cx(),
  kb = new Cx(),
  Nb = new Cx(),
  Ob = new Cx(),
  Fb = new Cx(),
  zb = new Cx();
class Ub {
  constructor(e = new Cx(), t = new Cx(), n = new Cx()) {
    (this.a = e), (this.b = t), (this.c = n);
  }
  static getNormal(e, t, n, i) {
    i.subVectors(n, t), Pb.subVectors(e, t), i.cross(Pb);
    const r = i.lengthSq();
    return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
  }
  static getBarycoord(e, t, n, i, r) {
    Pb.subVectors(i, t), Lb.subVectors(n, t), Ib.subVectors(e, t);
    const s = Pb.dot(Pb),
      a = Pb.dot(Lb),
      o = Pb.dot(Ib),
      l = Lb.dot(Lb),
      c = Lb.dot(Ib),
      u = s * l - a * a;
    if (0 === u) return r.set(-2, -1, -1);
    const h = 1 / u,
      d = (l * o - a * c) * h,
      p = (s * c - a * o) * h;
    return r.set(1 - d - p, p, d);
  }
  static containsPoint(e, t, n, i) {
    return (
      this.getBarycoord(e, t, n, i, Rb),
      Rb.x >= 0 && Rb.y >= 0 && Rb.x + Rb.y <= 1
    );
  }
  static getUV(e, t, n, i, r, s, a, o) {
    return (
      this.getBarycoord(e, t, n, i, Rb),
      o.set(0, 0),
      o.addScaledVector(r, Rb.x),
      o.addScaledVector(s, Rb.y),
      o.addScaledVector(a, Rb.z),
      o
    );
  }
  static isFrontFacing(e, t, n, i) {
    return Pb.subVectors(n, t), Lb.subVectors(e, t), Pb.cross(Lb).dot(i) < 0;
  }
  set(e, t, n) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, t, n, i) {
    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, t, n, i) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, n),
      this.c.fromBufferAttribute(e, i),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      Pb.subVectors(this.c, this.b),
      Lb.subVectors(this.a, this.b),
      0.5 * Pb.cross(Lb).length()
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Ub.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return Ub.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, n, i, r) {
    return Ub.getUV(e, this.a, this.b, this.c, t, n, i, r);
  }
  containsPoint(e) {
    return Ub.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Ub.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const n = this.a,
      i = this.b,
      r = this.c;
    let s, a;
    Db.subVectors(i, n), kb.subVectors(r, n), Ob.subVectors(e, n);
    const o = Db.dot(Ob),
      l = kb.dot(Ob);
    if (o <= 0 && l <= 0) return t.copy(n);
    Fb.subVectors(e, i);
    const c = Db.dot(Fb),
      u = kb.dot(Fb);
    if (c >= 0 && u <= c) return t.copy(i);
    const h = o * u - c * l;
    if (h <= 0 && o >= 0 && c <= 0)
      return (s = o / (o - c)), t.copy(n).addScaledVector(Db, s);
    zb.subVectors(e, r);
    const d = Db.dot(zb),
      p = kb.dot(zb);
    if (p >= 0 && d <= p) return t.copy(r);
    const f = d * l - o * p;
    if (f <= 0 && l >= 0 && p <= 0)
      return (a = l / (l - p)), t.copy(n).addScaledVector(kb, a);
    const m = c * p - d * u;
    if (m <= 0 && u - c >= 0 && d - p >= 0)
      return (
        Nb.subVectors(r, i),
        (a = (u - c) / (u - c + (d - p))),
        t.copy(i).addScaledVector(Nb, a)
      );
    const g = 1 / (m + f + h);
    return (
      (s = f * g),
      (a = h * g),
      t.copy(n).addScaledVector(Db, s).addScaledVector(kb, a)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
let Bb = 0;
class Vb extends rx {
  constructor() {
    super(),
      Object.defineProperty(this, "id", { value: Bb++ }),
      (this.uuid = cx()),
      (this.name = ""),
      (this.type = "Material"),
      (this.fog = !0),
      (this.blending = 1),
      (this.side = 0),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.format = 1023),
      (this.transparent = !1),
      (this.blendSrc = 204),
      (this.blendDst = 205),
      (this.blendEquation = 100),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.depthFunc = 3),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = 519),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = 7680),
      (this.stencilZFail = 7680),
      (this.stencilZPass = 7680),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (void 0 !== e)
      for (const t in e) {
        const n = e[t];
        if (void 0 === n) continue;
        if ("shading" === t) {
          this.flatShading = 1 === n;
          continue;
        }
        const i = this[t];
        void 0 !== i &&
          (i && i.isColor
            ? i.set(n)
            : i && i.isVector3 && n && n.isVector3
            ? i.copy(n)
            : (this[t] = n));
      }
  }
  toJSON(e) {
    const t = void 0 === e || "string" == typeof e;
    t && (e = { textures: {}, images: {} });
    const n = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    function i(e) {
      const t = [];
      for (const n in e) {
        const i = e[n];
        delete i.metadata, t.push(i);
      }
      return t;
    }
    if (
      ((n.uuid = this.uuid),
      (n.type = this.type),
      "" !== this.name && (n.name = this.name),
      this.color && this.color.isColor && (n.color = this.color.getHex()),
      void 0 !== this.roughness && (n.roughness = this.roughness),
      void 0 !== this.metalness && (n.metalness = this.metalness),
      void 0 !== this.sheen && (n.sheen = this.sheen),
      this.sheenTint &&
        this.sheenTint.isColor &&
        (n.sheenTint = this.sheenTint.getHex()),
      void 0 !== this.sheenRoughness &&
        (n.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (n.emissive = this.emissive.getHex()),
      this.emissiveIntensity &&
        1 !== this.emissiveIntensity &&
        (n.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (n.specular = this.specular.getHex()),
      void 0 !== this.specularIntensity &&
        (n.specularIntensity = this.specularIntensity),
      this.specularTint &&
        this.specularTint.isColor &&
        (n.specularTint = this.specularTint.getHex()),
      void 0 !== this.shininess && (n.shininess = this.shininess),
      void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
      void 0 !== this.clearcoatRoughness &&
        (n.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (n.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (n.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((n.lightMap = this.lightMap.toJSON(e).uuid),
        (n.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((n.aoMap = this.aoMap.toJSON(e).uuid),
        (n.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
        (n.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((n.normalMap = this.normalMap.toJSON(e).uuid),
        (n.normalMapType = this.normalMapType),
        (n.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
        (n.displacementScale = this.displacementScale),
        (n.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (n.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularTintMap &&
        this.specularTintMap.isTexture &&
        (n.specularTintMap = this.specularTintMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((n.envMap = this.envMap.toJSON(e).uuid),
        void 0 !== this.combine && (n.combine = this.combine)),
      void 0 !== this.envMapIntensity &&
        (n.envMapIntensity = this.envMapIntensity),
      void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),
      void 0 !== this.refractionRatio &&
        (n.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (n.gradientMap = this.gradientMap.toJSON(e).uuid),
      void 0 !== this.transmission && (n.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      void 0 !== this.thickness && (n.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      void 0 !== this.attenuationDistance &&
        (n.attenuationDistance = this.attenuationDistance),
      void 0 !== this.attenuationTint &&
        (n.attenuationTint = this.attenuationTint.getHex()),
      void 0 !== this.size && (n.size = this.size),
      null !== this.shadowSide && (n.shadowSide = this.shadowSide),
      void 0 !== this.sizeAttenuation &&
        (n.sizeAttenuation = this.sizeAttenuation),
      1 !== this.blending && (n.blending = this.blending),
      0 !== this.side && (n.side = this.side),
      this.vertexColors && (n.vertexColors = !0),
      this.opacity < 1 && (n.opacity = this.opacity),
      1023 !== this.format && (n.format = this.format),
      !0 === this.transparent && (n.transparent = this.transparent),
      (n.depthFunc = this.depthFunc),
      (n.depthTest = this.depthTest),
      (n.depthWrite = this.depthWrite),
      (n.colorWrite = this.colorWrite),
      (n.stencilWrite = this.stencilWrite),
      (n.stencilWriteMask = this.stencilWriteMask),
      (n.stencilFunc = this.stencilFunc),
      (n.stencilRef = this.stencilRef),
      (n.stencilFuncMask = this.stencilFuncMask),
      (n.stencilFail = this.stencilFail),
      (n.stencilZFail = this.stencilZFail),
      (n.stencilZPass = this.stencilZPass),
      this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
      !0 === this.polygonOffset && (n.polygonOffset = !0),
      0 !== this.polygonOffsetFactor &&
        (n.polygonOffsetFactor = this.polygonOffsetFactor),
      0 !== this.polygonOffsetUnits &&
        (n.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth),
      void 0 !== this.dashSize && (n.dashSize = this.dashSize),
      void 0 !== this.gapSize && (n.gapSize = this.gapSize),
      void 0 !== this.scale && (n.scale = this.scale),
      !0 === this.dithering && (n.dithering = !0),
      this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
      !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage),
      !0 === this.premultipliedAlpha &&
        (n.premultipliedAlpha = this.premultipliedAlpha),
      !0 === this.wireframe && (n.wireframe = this.wireframe),
      this.wireframeLinewidth > 1 &&
        (n.wireframeLinewidth = this.wireframeLinewidth),
      "round" !== this.wireframeLinecap &&
        (n.wireframeLinecap = this.wireframeLinecap),
      "round" !== this.wireframeLinejoin &&
        (n.wireframeLinejoin = this.wireframeLinejoin),
      !0 === this.flatShading && (n.flatShading = this.flatShading),
      !1 === this.visible && (n.visible = !1),
      !1 === this.toneMapped && (n.toneMapped = !1),
      "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
      t)
    ) {
      const t = i(e.textures),
        r = i(e.images);
      t.length > 0 && (n.textures = t), r.length > 0 && (n.images = r);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.fog = e.fog),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.format = e.format),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const t = e.clippingPlanes;
    let n = null;
    if (null !== t) {
      const e = t.length;
      n = new Array(e);
      for (let i = 0; i !== e; ++i) n[i] = t[i].clone();
    }
    return (
      (this.clippingPlanes = n),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    !0 === e && this.version++;
  }
}
Vb.prototype.isMaterial = !0;
const Hb = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  Gb = { h: 0, s: 0, l: 0 },
  Wb = { h: 0, s: 0, l: 0 };
function qb(e, t, n) {
  return (
    n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6
      ? e + 6 * (t - e) * n
      : n < 0.5
      ? t
      : n < 2 / 3
      ? e + 6 * (t - e) * (2 / 3 - n)
      : e
  );
}
function jb(e) {
  return e < 0.04045
    ? 0.0773993808 * e
    : Math.pow(0.9478672986 * e + 0.0521327014, 2.4);
}
function Yb(e) {
  return e < 0.0031308 ? 12.92 * e : 1.055 * Math.pow(e, 0.41666) - 0.055;
}
class Xb {
  constructor(e, t, n) {
    return void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n);
  }
  set(e) {
    return (
      e && e.isColor
        ? this.copy(e)
        : "number" == typeof e
        ? this.setHex(e)
        : "string" == typeof e && this.setStyle(e),
      this
    );
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (255 & e) / 255),
      this
    );
  }
  setRGB(e, t, n) {
    return (this.r = e), (this.g = t), (this.b = n), this;
  }
  setHSL(e, t, n) {
    var i;
    if (
      ((e = ((e % (i = 1)) + i) % i),
      (t = ux(t, 0, 1)),
      (n = ux(n, 0, 1)),
      0 === t)
    )
      this.r = this.g = this.b = n;
    else {
      const i = n <= 0.5 ? n * (1 + t) : n + t - n * t,
        r = 2 * n - i;
      (this.r = qb(r, i, e + 1 / 3)),
        (this.g = qb(r, i, e)),
        (this.b = qb(r, i, e - 1 / 3));
    }
    return this;
  }
  setStyle(e) {
    function t(e) {
      void 0 !== e && parseFloat(e);
    }
    let n;
    if ((n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e))) {
      let e;
      const i = n[1],
        r = n[2];
      switch (i) {
        case "rgb":
        case "rgba":
          if (
            (e =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                r
              ))
          )
            return (
              (this.r = Math.min(255, parseInt(e[1], 10)) / 255),
              (this.g = Math.min(255, parseInt(e[2], 10)) / 255),
              (this.b = Math.min(255, parseInt(e[3], 10)) / 255),
              t(e[4]),
              this
            );
          if (
            (e =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                r
              ))
          )
            return (
              (this.r = Math.min(100, parseInt(e[1], 10)) / 100),
              (this.g = Math.min(100, parseInt(e[2], 10)) / 100),
              (this.b = Math.min(100, parseInt(e[3], 10)) / 100),
              t(e[4]),
              this
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (e =
              /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                r
              ))
          ) {
            const n = parseFloat(e[1]) / 360,
              i = parseInt(e[2], 10) / 100,
              r = parseInt(e[3], 10) / 100;
            return t(e[4]), this.setHSL(n, i, r);
          }
      }
    } else if ((n = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const e = n[1],
        t = e.length;
      if (3 === t)
        return (
          (this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255),
          (this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255),
          (this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255),
          this
        );
      if (6 === t)
        return (
          (this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255),
          (this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255),
          (this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255),
          this
        );
    }
    return e && e.length > 0 ? this.setColorName(e) : this;
  }
  setColorName(e) {
    const t = Hb[e.toLowerCase()];
    return void 0 !== t && this.setHex(t), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copyGammaToLinear(e, t = 2) {
    return (
      (this.r = Math.pow(e.r, t)),
      (this.g = Math.pow(e.g, t)),
      (this.b = Math.pow(e.b, t)),
      this
    );
  }
  copyLinearToGamma(e, t = 2) {
    const n = t > 0 ? 1 / t : 1;
    return (
      (this.r = Math.pow(e.r, n)),
      (this.g = Math.pow(e.g, n)),
      (this.b = Math.pow(e.b, n)),
      this
    );
  }
  convertGammaToLinear(e) {
    return this.copyGammaToLinear(this, e), this;
  }
  convertLinearToGamma(e) {
    return this.copyLinearToGamma(this, e), this;
  }
  copySRGBToLinear(e) {
    return (this.r = jb(e.r)), (this.g = jb(e.g)), (this.b = jb(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = Yb(e.r)), (this.g = Yb(e.g)), (this.b = Yb(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex() {
    return (
      ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0)
    );
  }
  getHexString() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  }
  getHSL(e) {
    const t = this.r,
      n = this.g,
      i = this.b,
      r = Math.max(t, n, i),
      s = Math.min(t, n, i);
    let a, o;
    const l = (s + r) / 2;
    if (s === r) (a = 0), (o = 0);
    else {
      const e = r - s;
      switch (((o = l <= 0.5 ? e / (r + s) : e / (2 - r - s)), r)) {
        case t:
          a = (n - i) / e + (n < i ? 6 : 0);
          break;
        case n:
          a = (i - t) / e + 2;
          break;
        case i:
          a = (t - n) / e + 4;
      }
      a /= 6;
    }
    return (e.h = a), (e.s = o), (e.l = l), e;
  }
  getStyle() {
    return (
      "rgb(" +
      ((255 * this.r) | 0) +
      "," +
      ((255 * this.g) | 0) +
      "," +
      ((255 * this.b) | 0) +
      ")"
    );
  }
  offsetHSL(e, t, n) {
    return (
      this.getHSL(Gb),
      (Gb.h += e),
      (Gb.s += t),
      (Gb.l += n),
      this.setHSL(Gb.h, Gb.s, Gb.l),
      this
    );
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, n) {
    return (
      (this.r = e.r + (t.r - e.r) * n),
      (this.g = e.g + (t.g - e.g) * n),
      (this.b = e.b + (t.b - e.b) * n),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(Gb), e.getHSL(Wb);
    const n = hx(Gb.h, Wb.h, t),
      i = hx(Gb.s, Wb.s, t),
      r = hx(Gb.l, Wb.l, t);
    return this.setHSL(n, i, r), this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)),
      (this.g = e.getY(t)),
      (this.b = e.getZ(t)),
      !0 === e.normalized &&
        ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
      this
    );
  }
  toJSON() {
    return this.getHex();
  }
}
(Xb.NAMES = Hb),
  (Xb.prototype.isColor = !0),
  (Xb.prototype.r = 1),
  (Xb.prototype.g = 1),
  (Xb.prototype.b = 1);
class $b extends Vb {
  constructor(e) {
    super(),
      (this.type = "MeshBasicMaterial"),
      (this.color = new Xb(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = 0),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      this
    );
  }
}
$b.prototype.isMeshBasicMaterial = !0;
const Zb = new Cx(),
  Kb = new fx();
class Jb {
  constructor(e, t, n) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = void 0 !== e ? e.length / t : 0),
      (this.normalized = !0 === n),
      (this.usage = 35044),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    !0 === e && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, n) {
    (e *= this.itemSize), (n *= t.itemSize);
    for (let i = 0, r = this.itemSize; i < r; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  copyColorsArray(e) {
    const t = this.array;
    let n = 0;
    for (let i = 0, r = e.length; i < r; i++) {
      let r = e[i];
      void 0 === r && (r = new Xb()),
        (t[n++] = r.r),
        (t[n++] = r.g),
        (t[n++] = r.b);
    }
    return this;
  }
  copyVector2sArray(e) {
    const t = this.array;
    let n = 0;
    for (let i = 0, r = e.length; i < r; i++) {
      let r = e[i];
      void 0 === r && (r = new fx()), (t[n++] = r.x), (t[n++] = r.y);
    }
    return this;
  }
  copyVector3sArray(e) {
    const t = this.array;
    let n = 0;
    for (let i = 0, r = e.length; i < r; i++) {
      let r = e[i];
      void 0 === r && (r = new Cx()),
        (t[n++] = r.x),
        (t[n++] = r.y),
        (t[n++] = r.z);
    }
    return this;
  }
  copyVector4sArray(e) {
    const t = this.array;
    let n = 0;
    for (let i = 0, r = e.length; i < r; i++) {
      let r = e[i];
      void 0 === r && (r = new wx()),
        (t[n++] = r.x),
        (t[n++] = r.y),
        (t[n++] = r.z),
        (t[n++] = r.w);
    }
    return this;
  }
  applyMatrix3(e) {
    if (2 === this.itemSize)
      for (let t = 0, n = this.count; t < n; t++)
        Kb.fromBufferAttribute(this, t),
          Kb.applyMatrix3(e),
          this.setXY(t, Kb.x, Kb.y);
    else if (3 === this.itemSize)
      for (let t = 0, n = this.count; t < n; t++)
        Zb.fromBufferAttribute(this, t),
          Zb.applyMatrix3(e),
          this.setXYZ(t, Zb.x, Zb.y, Zb.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.count; t < n; t++)
      (Zb.x = this.getX(t)),
        (Zb.y = this.getY(t)),
        (Zb.z = this.getZ(t)),
        Zb.applyMatrix4(e),
        this.setXYZ(t, Zb.x, Zb.y, Zb.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      (Zb.x = this.getX(t)),
        (Zb.y = this.getY(t)),
        (Zb.z = this.getZ(t)),
        Zb.applyNormalMatrix(e),
        this.setXYZ(t, Zb.x, Zb.y, Zb.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      (Zb.x = this.getX(t)),
        (Zb.y = this.getY(t)),
        (Zb.z = this.getZ(t)),
        Zb.transformDirection(e),
        this.setXYZ(t, Zb.x, Zb.y, Zb.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getX(e) {
    return this.array[e * this.itemSize];
  }
  setX(e, t) {
    return (this.array[e * this.itemSize] = t), this;
  }
  getY(e) {
    return this.array[e * this.itemSize + 1];
  }
  setY(e, t) {
    return (this.array[e * this.itemSize + 1] = t), this;
  }
  getZ(e) {
    return this.array[e * this.itemSize + 2];
  }
  setZ(e, t) {
    return (this.array[e * this.itemSize + 2] = t), this;
  }
  getW(e) {
    return this.array[e * this.itemSize + 3];
  }
  setW(e, t) {
    return (this.array[e * this.itemSize + 3] = t), this;
  }
  setXY(e, t, n) {
    return (
      (e *= this.itemSize),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      this
    );
  }
  setXYZ(e, t, n, i) {
    return (
      (e *= this.itemSize),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      (this.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, n, i, r) {
    return (
      (e *= this.itemSize),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      (this.array[e + 2] = i),
      (this.array[e + 3] = r),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized,
    };
    return (
      "" !== this.name && (e.name = this.name),
      35044 !== this.usage && (e.usage = this.usage),
      (0 === this.updateRange.offset && -1 === this.updateRange.count) ||
        (e.updateRange = this.updateRange),
      e
    );
  }
}
Jb.prototype.isBufferAttribute = !0;
class Qb extends Jb {
  constructor(e, t, n) {
    super(new Uint8Array(e), t, n);
  }
}
class ew extends Jb {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n);
  }
}
class tw extends Jb {
  constructor(e, t, n) {
    super(new Uint32Array(e), t, n);
  }
}
(class extends Jb {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n);
  }
}).prototype.isFloat16BufferAttribute = !0;
class nw extends Jb {
  constructor(e, t, n) {
    super(new Float32Array(e), t, n);
  }
}
let iw = 0;
const rw = new ib(),
  sw = new Ab(),
  aw = new Cx(),
  ow = new Px(),
  lw = new Px(),
  cw = new Cx();
class uw extends rx {
  constructor() {
    super(),
      Object.defineProperty(this, "id", { value: iw++ }),
      (this.uuid = cx()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: Infinity }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (gx(e) > 65535 ? tw : ew)(e, 1))
        : (this.index = e),
      this
    );
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return void 0 !== this.attributes[e];
  }
  addGroup(e, t, n = 0) {
    this.groups.push({ start: e, count: t, materialIndex: n });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    void 0 !== t && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const n = this.attributes.normal;
    if (void 0 !== n) {
      const t = new mx().getNormalMatrix(e);
      n.applyNormalMatrix(t), (n.needsUpdate = !0);
    }
    const i = this.attributes.tangent;
    return (
      void 0 !== i && (i.transformDirection(e), (i.needsUpdate = !0)),
      null !== this.boundingBox && this.computeBoundingBox(),
      null !== this.boundingSphere && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return rw.makeRotationFromQuaternion(e), this.applyMatrix4(rw), this;
  }
  rotateX(e) {
    return rw.makeRotationX(e), this.applyMatrix4(rw), this;
  }
  rotateY(e) {
    return rw.makeRotationY(e), this.applyMatrix4(rw), this;
  }
  rotateZ(e) {
    return rw.makeRotationZ(e), this.applyMatrix4(rw), this;
  }
  translate(e, t, n) {
    return rw.makeTranslation(e, t, n), this.applyMatrix4(rw), this;
  }
  scale(e, t, n) {
    return rw.makeScale(e, t, n), this.applyMatrix4(rw), this;
  }
  lookAt(e) {
    return sw.lookAt(e), sw.updateMatrix(), this.applyMatrix4(sw.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(aw).negate(),
      this.translate(aw.x, aw.y, aw.z),
      this
    );
  }
  setFromPoints(e) {
    const t = [];
    for (let n = 0, i = e.length; n < i; n++) {
      const i = e[n];
      t.push(i.x, i.y, i.z || 0);
    }
    return this.setAttribute("position", new nw(t, 3)), this;
  }
  computeBoundingBox() {
    null === this.boundingBox && (this.boundingBox = new Px());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute)
      this.boundingBox.set(
        new Cx(-Infinity, -Infinity, -Infinity),
        new Cx(Infinity, Infinity, Infinity)
      );
    else {
      if (void 0 !== e) {
        if ((this.boundingBox.setFromBufferAttribute(e), t))
          for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e];
            ow.setFromBufferAttribute(n),
              this.morphTargetsRelative
                ? (cw.addVectors(this.boundingBox.min, ow.min),
                  this.boundingBox.expandByPoint(cw),
                  cw.addVectors(this.boundingBox.max, ow.max),
                  this.boundingBox.expandByPoint(cw))
                : (this.boundingBox.expandByPoint(ow.min),
                  this.boundingBox.expandByPoint(ow.max));
          }
      } else this.boundingBox.makeEmpty();
      isNaN(this.boundingBox.min.x) ||
        isNaN(this.boundingBox.min.y) ||
        isNaN(this.boundingBox.min.z);
    }
  }
  computeBoundingSphere() {
    null === this.boundingSphere && (this.boundingSphere = new Xx());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) this.boundingSphere.set(new Cx(), Infinity);
    else if (e) {
      const n = this.boundingSphere.center;
      if ((ow.setFromBufferAttribute(e), t))
        for (let e = 0, r = t.length; e < r; e++) {
          const n = t[e];
          lw.setFromBufferAttribute(n),
            this.morphTargetsRelative
              ? (cw.addVectors(ow.min, lw.min),
                ow.expandByPoint(cw),
                cw.addVectors(ow.max, lw.max),
                ow.expandByPoint(cw))
              : (ow.expandByPoint(lw.min), ow.expandByPoint(lw.max));
        }
      ow.getCenter(n);
      let i = 0;
      for (let t = 0, r = e.count; t < r; t++)
        cw.fromBufferAttribute(e, t),
          (i = Math.max(i, n.distanceToSquared(cw)));
      if (t)
        for (let r = 0, s = t.length; r < s; r++) {
          const s = t[r],
            a = this.morphTargetsRelative;
          for (let t = 0, r = s.count; t < r; t++)
            cw.fromBufferAttribute(s, t),
              a && (aw.fromBufferAttribute(e, t), cw.add(aw)),
              (i = Math.max(i, n.distanceToSquared(cw)));
        }
      (this.boundingSphere.radius = Math.sqrt(i)),
        isNaN(this.boundingSphere.radius);
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      null === e ||
      void 0 === t.position ||
      void 0 === t.normal ||
      void 0 === t.uv
    )
      return;
    const n = e.array,
      i = t.position.array,
      r = t.normal.array,
      s = t.uv.array,
      a = i.length / 3;
    void 0 === t.tangent &&
      this.setAttribute("tangent", new Jb(new Float32Array(4 * a), 4));
    const o = t.tangent.array,
      l = [],
      c = [];
    for (let T = 0; T < a; T++) (l[T] = new Cx()), (c[T] = new Cx());
    const u = new Cx(),
      h = new Cx(),
      d = new Cx(),
      p = new fx(),
      f = new fx(),
      m = new fx(),
      g = new Cx(),
      v = new Cx();
    function _(e, t, n) {
      u.fromArray(i, 3 * e),
        h.fromArray(i, 3 * t),
        d.fromArray(i, 3 * n),
        p.fromArray(s, 2 * e),
        f.fromArray(s, 2 * t),
        m.fromArray(s, 2 * n),
        h.sub(u),
        d.sub(u),
        f.sub(p),
        m.sub(p);
      const r = 1 / (f.x * m.y - m.x * f.y);
      isFinite(r) &&
        (g
          .copy(h)
          .multiplyScalar(m.y)
          .addScaledVector(d, -f.y)
          .multiplyScalar(r),
        v
          .copy(d)
          .multiplyScalar(f.x)
          .addScaledVector(h, -m.x)
          .multiplyScalar(r),
        l[e].add(g),
        l[t].add(g),
        l[n].add(g),
        c[e].add(v),
        c[t].add(v),
        c[n].add(v));
    }
    let y = this.groups;
    0 === y.length && (y = [{ start: 0, count: n.length }]);
    for (let T = 0, C = y.length; T < C; ++T) {
      const e = y[T],
        t = e.start;
      for (let i = t, r = t + e.count; i < r; i += 3)
        _(n[i + 0], n[i + 1], n[i + 2]);
    }
    const x = new Cx(),
      b = new Cx(),
      w = new Cx(),
      S = new Cx();
    function M(e) {
      w.fromArray(r, 3 * e), S.copy(w);
      const t = l[e];
      x.copy(t),
        x.sub(w.multiplyScalar(w.dot(t))).normalize(),
        b.crossVectors(S, t);
      const n = b.dot(c[e]) < 0 ? -1 : 1;
      (o[4 * e] = x.x),
        (o[4 * e + 1] = x.y),
        (o[4 * e + 2] = x.z),
        (o[4 * e + 3] = n);
    }
    for (let T = 0, C = y.length; T < C; ++T) {
      const e = y[T],
        t = e.start;
      for (let i = t, r = t + e.count; i < r; i += 3)
        M(n[i + 0]), M(n[i + 1]), M(n[i + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position");
    if (void 0 !== t) {
      let n = this.getAttribute("normal");
      if (void 0 === n)
        (n = new Jb(new Float32Array(3 * t.count), 3)),
          this.setAttribute("normal", n);
      else for (let e = 0, t = n.count; e < t; e++) n.setXYZ(e, 0, 0, 0);
      const i = new Cx(),
        r = new Cx(),
        s = new Cx(),
        a = new Cx(),
        o = new Cx(),
        l = new Cx(),
        c = new Cx(),
        u = new Cx();
      if (e)
        for (let h = 0, d = e.count; h < d; h += 3) {
          const d = e.getX(h + 0),
            p = e.getX(h + 1),
            f = e.getX(h + 2);
          i.fromBufferAttribute(t, d),
            r.fromBufferAttribute(t, p),
            s.fromBufferAttribute(t, f),
            c.subVectors(s, r),
            u.subVectors(i, r),
            c.cross(u),
            a.fromBufferAttribute(n, d),
            o.fromBufferAttribute(n, p),
            l.fromBufferAttribute(n, f),
            a.add(c),
            o.add(c),
            l.add(c),
            n.setXYZ(d, a.x, a.y, a.z),
            n.setXYZ(p, o.x, o.y, o.z),
            n.setXYZ(f, l.x, l.y, l.z);
        }
      else
        for (let e = 0, h = t.count; e < h; e += 3)
          i.fromBufferAttribute(t, e + 0),
            r.fromBufferAttribute(t, e + 1),
            s.fromBufferAttribute(t, e + 2),
            c.subVectors(s, r),
            u.subVectors(i, r),
            c.cross(u),
            n.setXYZ(e + 0, c.x, c.y, c.z),
            n.setXYZ(e + 1, c.x, c.y, c.z),
            n.setXYZ(e + 2, c.x, c.y, c.z);
      this.normalizeNormals(), (n.needsUpdate = !0);
    }
  }
  merge(e, t) {
    if (!e || !e.isBufferGeometry) return;
    void 0 === t && (t = 0);
    const n = this.attributes;
    for (const i in n) {
      if (void 0 === e.attributes[i]) continue;
      const r = n[i].array,
        s = e.attributes[i],
        a = s.array,
        o = s.itemSize * t,
        l = Math.min(a.length, r.length - o);
      for (let e = 0, t = o; e < l; e++, t++) r[t] = a[e];
    }
    return this;
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, n = e.count; t < n; t++)
      cw.fromBufferAttribute(e, t),
        cw.normalize(),
        e.setXYZ(t, cw.x, cw.y, cw.z);
  }
  toNonIndexed() {
    function e(e, t) {
      const n = e.array,
        i = e.itemSize,
        r = e.normalized,
        s = new n.constructor(t.length * i);
      let a = 0,
        o = 0;
      for (let l = 0, c = t.length; l < c; l++) {
        a = e.isInterleavedBufferAttribute
          ? t[l] * e.data.stride + e.offset
          : t[l] * i;
        for (let e = 0; e < i; e++) s[o++] = n[a++];
      }
      return new Jb(s, i, r);
    }
    if (null === this.index) return this;
    const t = new uw(),
      n = this.index.array,
      i = this.attributes;
    for (const a in i) {
      const r = e(i[a], n);
      t.setAttribute(a, r);
    }
    const r = this.morphAttributes;
    for (const a in r) {
      const i = [],
        s = r[a];
      for (let t = 0, r = s.length; t < r; t++) {
        const r = e(s[t], n);
        i.push(r);
      }
      t.morphAttributes[a] = i;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const s = this.groups;
    for (let a = 0, o = s.length; a < o; a++) {
      const e = s[a];
      t.addGroup(e.start, e.count, e.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      "" !== this.name && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      void 0 !== this.parameters)
    ) {
      const t = this.parameters;
      for (const n in t) void 0 !== t[n] && (e[n] = t[n]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    null !== t &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const n = this.attributes;
    for (const o in n) {
      const t = n[o];
      e.data.attributes[o] = t.toJSON(e.data);
    }
    const i = {};
    let r = !1;
    for (const o in this.morphAttributes) {
      const t = this.morphAttributes[o],
        n = [];
      for (let i = 0, r = t.length; i < r; i++) {
        const r = t[i];
        n.push(r.toJSON(e.data));
      }
      n.length > 0 && ((i[o] = n), (r = !0));
    }
    r &&
      ((e.data.morphAttributes = i),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const s = this.groups;
    s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
    const a = this.boundingSphere;
    return (
      null !== a &&
        (e.data.boundingSphere = {
          center: a.center.toArray(),
          radius: a.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const t = {};
    this.name = e.name;
    const n = e.index;
    null !== n && this.setIndex(n.clone(t));
    const i = e.attributes;
    for (const l in i) {
      const e = i[l];
      this.setAttribute(l, e.clone(t));
    }
    const r = e.morphAttributes;
    for (const l in r) {
      const e = [],
        n = r[l];
      for (let i = 0, r = n.length; i < r; i++) e.push(n[i].clone(t));
      this.morphAttributes[l] = e;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const s = e.groups;
    for (let l = 0, c = s.length; l < c; l++) {
      const e = s[l];
      this.addGroup(e.start, e.count, e.materialIndex);
    }
    const a = e.boundingBox;
    null !== a && (this.boundingBox = a.clone());
    const o = e.boundingSphere;
    return (
      null !== o && (this.boundingSphere = o.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      void 0 !== e.parameters &&
        (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
uw.prototype.isBufferGeometry = !0;
const hw = new ib(),
  dw = new nb(),
  pw = new Xx(),
  fw = new Cx(),
  mw = new Cx(),
  gw = new Cx(),
  vw = new Cx(),
  _w = new Cx(),
  yw = new Cx(),
  xw = new Cx(),
  bw = new Cx(),
  ww = new Cx(),
  Sw = new fx(),
  Mw = new fx(),
  Tw = new fx(),
  Cw = new Cx(),
  Ew = new Cx();
class Aw extends Ab {
  constructor(e = new uw(), t = new $b()) {
    super(),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e) {
    return (
      super.copy(e),
      void 0 !== e.morphTargetInfluences &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      void 0 !== e.morphTargetDictionary &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const e = this.geometry;
    if (e.isBufferGeometry) {
      const t = e.morphAttributes,
        n = Object.keys(t);
      if (n.length > 0) {
        const e = t[n[0]];
        if (void 0 !== e) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let t = 0, n = e.length; t < n; t++) {
            const n = e[t].name || String(t);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[n] = t);
          }
        }
      }
    } else {
      const t = e.morphTargets;
      void 0 !== t && t.length;
    }
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.material,
      r = this.matrixWorld;
    if (void 0 === i) return;
    if (
      (null === n.boundingSphere && n.computeBoundingSphere(),
      pw.copy(n.boundingSphere),
      pw.applyMatrix4(r),
      !1 === e.ray.intersectsSphere(pw))
    )
      return;
    if (
      (hw.copy(r).invert(),
      dw.copy(e.ray).applyMatrix4(hw),
      null !== n.boundingBox && !1 === dw.intersectsBox(n.boundingBox))
    )
      return;
    let s;
    if (n.isBufferGeometry) {
      const r = n.index,
        a = n.attributes.position,
        o = n.morphAttributes.position,
        l = n.morphTargetsRelative,
        c = n.attributes.uv,
        u = n.attributes.uv2,
        h = n.groups,
        d = n.drawRange;
      if (null !== r)
        if (Array.isArray(i))
          for (let n = 0, p = h.length; n < p; n++) {
            const p = h[n],
              f = i[p.materialIndex];
            for (
              let n = Math.max(p.start, d.start),
                i = Math.min(
                  r.count,
                  Math.min(p.start + p.count, d.start + d.count)
                );
              n < i;
              n += 3
            ) {
              const i = r.getX(n),
                h = r.getX(n + 1),
                d = r.getX(n + 2);
              (s = Pw(this, f, e, dw, a, o, l, c, u, i, h, d)),
                s &&
                  ((s.faceIndex = Math.floor(n / 3)),
                  (s.face.materialIndex = p.materialIndex),
                  t.push(s));
            }
          }
        else {
          for (
            let n = Math.max(0, d.start),
              h = Math.min(r.count, d.start + d.count);
            n < h;
            n += 3
          ) {
            const h = r.getX(n),
              d = r.getX(n + 1),
              p = r.getX(n + 2);
            (s = Pw(this, i, e, dw, a, o, l, c, u, h, d, p)),
              s && ((s.faceIndex = Math.floor(n / 3)), t.push(s));
          }
        }
      else if (void 0 !== a)
        if (Array.isArray(i))
          for (let n = 0, p = h.length; n < p; n++) {
            const r = h[n],
              p = i[r.materialIndex];
            for (
              let n = Math.max(r.start, d.start),
                i = Math.min(
                  a.count,
                  Math.min(r.start + r.count, d.start + d.count)
                );
              n < i;
              n += 3
            ) {
              (s = Pw(this, p, e, dw, a, o, l, c, u, n, n + 1, n + 2)),
                s &&
                  ((s.faceIndex = Math.floor(n / 3)),
                  (s.face.materialIndex = r.materialIndex),
                  t.push(s));
            }
          }
        else {
          for (
            let n = Math.max(0, d.start),
              r = Math.min(a.count, d.start + d.count);
            n < r;
            n += 3
          ) {
            (s = Pw(this, i, e, dw, a, o, l, c, u, n, n + 1, n + 2)),
              s && ((s.faceIndex = Math.floor(n / 3)), t.push(s));
          }
        }
    } else n.isGeometry;
  }
}
function Pw(e, t, n, i, r, s, a, o, l, c, u, h) {
  fw.fromBufferAttribute(r, c),
    mw.fromBufferAttribute(r, u),
    gw.fromBufferAttribute(r, h);
  const d = e.morphTargetInfluences;
  if (s && d) {
    xw.set(0, 0, 0), bw.set(0, 0, 0), ww.set(0, 0, 0);
    for (let e = 0, t = s.length; e < t; e++) {
      const t = d[e],
        n = s[e];
      0 !== t &&
        (vw.fromBufferAttribute(n, c),
        _w.fromBufferAttribute(n, u),
        yw.fromBufferAttribute(n, h),
        a
          ? (xw.addScaledVector(vw, t),
            bw.addScaledVector(_w, t),
            ww.addScaledVector(yw, t))
          : (xw.addScaledVector(vw.sub(fw), t),
            bw.addScaledVector(_w.sub(mw), t),
            ww.addScaledVector(yw.sub(gw), t)));
    }
    fw.add(xw), mw.add(bw), gw.add(ww);
  }
  e.isSkinnedMesh &&
    (e.boneTransform(c, fw), e.boneTransform(u, mw), e.boneTransform(h, gw));
  const p = (function (e, t, n, i, r, s, a, o) {
    let l;
    if (
      ((l =
        1 === t.side
          ? i.intersectTriangle(a, s, r, !0, o)
          : i.intersectTriangle(r, s, a, 2 !== t.side, o)),
      null === l)
    )
      return null;
    Ew.copy(o), Ew.applyMatrix4(e.matrixWorld);
    const c = n.ray.origin.distanceTo(Ew);
    return c < n.near || c > n.far
      ? null
      : { distance: c, point: Ew.clone(), object: e };
  })(e, t, n, i, fw, mw, gw, Cw);
  if (p) {
    o &&
      (Sw.fromBufferAttribute(o, c),
      Mw.fromBufferAttribute(o, u),
      Tw.fromBufferAttribute(o, h),
      (p.uv = Ub.getUV(Cw, fw, mw, gw, Sw, Mw, Tw, new fx()))),
      l &&
        (Sw.fromBufferAttribute(l, c),
        Mw.fromBufferAttribute(l, u),
        Tw.fromBufferAttribute(l, h),
        (p.uv2 = Ub.getUV(Cw, fw, mw, gw, Sw, Mw, Tw, new fx())));
    const e = { a: c, b: u, c: h, normal: new Cx(), materialIndex: 0 };
    Ub.getNormal(fw, mw, gw, e.normal), (p.face = e);
  }
  return p;
}
Aw.prototype.isMesh = !0;
class Lw extends uw {
  constructor(e = 1, t = 1, n = 1, i = 1, r = 1, s = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: n,
        widthSegments: i,
        heightSegments: r,
        depthSegments: s,
      });
    const a = this;
    (i = Math.floor(i)), (r = Math.floor(r)), (s = Math.floor(s));
    const o = [],
      l = [],
      c = [],
      u = [];
    let h = 0,
      d = 0;
    function p(e, t, n, i, r, s, p, f, m, g, v) {
      const _ = s / m,
        y = p / g,
        x = s / 2,
        b = p / 2,
        w = f / 2,
        S = m + 1,
        M = g + 1;
      let T = 0,
        C = 0;
      const E = new Cx();
      for (let a = 0; a < M; a++) {
        const s = a * y - b;
        for (let o = 0; o < S; o++) {
          const h = o * _ - x;
          (E[e] = h * i),
            (E[t] = s * r),
            (E[n] = w),
            l.push(E.x, E.y, E.z),
            (E[e] = 0),
            (E[t] = 0),
            (E[n] = f > 0 ? 1 : -1),
            c.push(E.x, E.y, E.z),
            u.push(o / m),
            u.push(1 - a / g),
            (T += 1);
        }
      }
      for (let a = 0; a < g; a++)
        for (let e = 0; e < m; e++) {
          const t = h + e + S * a,
            n = h + e + S * (a + 1),
            i = h + (e + 1) + S * (a + 1),
            r = h + (e + 1) + S * a;
          o.push(t, n, r), o.push(n, i, r), (C += 6);
        }
      a.addGroup(d, C, v), (d += C), (h += T);
    }
    p("z", "y", "x", -1, -1, n, t, e, s, r, 0),
      p("z", "y", "x", 1, -1, n, t, -e, s, r, 1),
      p("x", "z", "y", 1, 1, e, n, t, i, s, 2),
      p("x", "z", "y", 1, -1, e, n, -t, i, s, 3),
      p("x", "y", "z", 1, -1, e, t, n, i, r, 4),
      p("x", "y", "z", -1, -1, e, t, -n, i, r, 5),
      this.setIndex(o),
      this.setAttribute("position", new nw(l, 3)),
      this.setAttribute("normal", new nw(c, 3)),
      this.setAttribute("uv", new nw(u, 2));
  }
  static fromJSON(e) {
    return new Lw(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function Iw(e) {
  const t = {};
  for (const n in e) {
    t[n] = {};
    for (const i in e[n]) {
      const r = e[n][i];
      r &&
      (r.isColor ||
        r.isMatrix3 ||
        r.isMatrix4 ||
        r.isVector2 ||
        r.isVector3 ||
        r.isVector4 ||
        r.isTexture ||
        r.isQuaternion)
        ? (t[n][i] = r.clone())
        : Array.isArray(r)
        ? (t[n][i] = r.slice())
        : (t[n][i] = r);
    }
  }
  return t;
}
function Rw(e) {
  const t = {};
  for (let n = 0; n < e.length; n++) {
    const i = Iw(e[n]);
    for (const e in i) t[e] = i[e];
  }
  return t;
}
const Dw = { clone: Iw, merge: Rw };
class kw extends Vb {
  constructor(e) {
    super(),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.vertexShader =
        "void main(){gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}"),
      (this.fragmentShader =
        "void main(){gl_FragColor=vec4(1.0,0.0,0.0,1.0);}"),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1,
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv2: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      void 0 !== e && (e.attributes, this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = Iw(e.uniforms)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (t.glslVersion = this.glslVersion), (t.uniforms = {});
    for (const i in this.uniforms) {
      const n = this.uniforms[i].value;
      n && n.isTexture
        ? (t.uniforms[i] = { type: "t", value: n.toJSON(e).uuid })
        : n && n.isColor
        ? (t.uniforms[i] = { type: "c", value: n.getHex() })
        : n && n.isVector2
        ? (t.uniforms[i] = { type: "v2", value: n.toArray() })
        : n && n.isVector3
        ? (t.uniforms[i] = { type: "v3", value: n.toArray() })
        : n && n.isVector4
        ? (t.uniforms[i] = { type: "v4", value: n.toArray() })
        : n && n.isMatrix3
        ? (t.uniforms[i] = { type: "m3", value: n.toArray() })
        : n && n.isMatrix4
        ? (t.uniforms[i] = { type: "m4", value: n.toArray() })
        : (t.uniforms[i] = { value: n });
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader);
    const n = {};
    for (const i in this.extensions) !0 === this.extensions[i] && (n[i] = !0);
    return Object.keys(n).length > 0 && (t.extensions = n), t;
  }
}
kw.prototype.isShaderMaterial = !0;
class Nw extends Ab {
  constructor() {
    super(),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new ib()),
      (this.projectionMatrix = new ib()),
      (this.projectionMatrixInverse = new ib());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      this
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(-t[8], -t[9], -t[10]).normalize();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
Nw.prototype.isCamera = !0;
class Ow extends Nw {
  constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
    super(),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = n),
      (this.far = i),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = null === e.view ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    (this.fov = 2 * ax * Math.atan(t)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(0.5 * sx * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return 2 * ax * Math.atan(Math.tan(0.5 * sx * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(e, t, n, i, r, s) {
    (this.aspect = e / t),
      null === this.view &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = r),
      (this.view.height = s),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    null !== this.view && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(0.5 * sx * this.fov)) / this.zoom,
      n = 2 * t,
      i = this.aspect * n,
      r = -0.5 * i;
    const s = this.view;
    if (null !== this.view && this.view.enabled) {
      const e = s.fullWidth,
        a = s.fullHeight;
      (r += (s.offsetX * i) / e),
        (t -= (s.offsetY * n) / a),
        (i *= s.width / e),
        (n *= s.height / a);
    }
    const a = this.filmOffset;
    0 !== a && (r += (e * a) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      null !== this.view && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
Ow.prototype.isPerspectiveCamera = !0;
class Fw extends Ab {
  constructor(e, t, n) {
    if ((super(), (this.type = "CubeCamera"), !0 !== n.isWebGLCubeRenderTarget))
      return;
    this.renderTarget = n;
    const i = new Ow(90, 1, e, t);
    (i.layers = this.layers),
      i.up.set(0, -1, 0),
      i.lookAt(new Cx(1, 0, 0)),
      this.add(i);
    const r = new Ow(90, 1, e, t);
    (r.layers = this.layers),
      r.up.set(0, -1, 0),
      r.lookAt(new Cx(-1, 0, 0)),
      this.add(r);
    const s = new Ow(90, 1, e, t);
    (s.layers = this.layers),
      s.up.set(0, 0, 1),
      s.lookAt(new Cx(0, 1, 0)),
      this.add(s);
    const a = new Ow(90, 1, e, t);
    (a.layers = this.layers),
      a.up.set(0, 0, -1),
      a.lookAt(new Cx(0, -1, 0)),
      this.add(a);
    const o = new Ow(90, 1, e, t);
    (o.layers = this.layers),
      o.up.set(0, -1, 0),
      o.lookAt(new Cx(0, 0, 1)),
      this.add(o);
    const l = new Ow(90, 1, e, t);
    (l.layers = this.layers),
      l.up.set(0, -1, 0),
      l.lookAt(new Cx(0, 0, -1)),
      this.add(l);
  }
  update(e, t) {
    null === this.parent && this.updateMatrixWorld();
    const n = this.renderTarget,
      [i, r, s, a, o, l] = this.children,
      c = e.xr.enabled,
      u = e.getRenderTarget();
    e.xr.enabled = !1;
    const h = n.texture.generateMipmaps;
    (n.texture.generateMipmaps = !1),
      e.setRenderTarget(n, 0),
      e.render(t, i),
      e.setRenderTarget(n, 1),
      e.render(t, r),
      e.setRenderTarget(n, 2),
      e.render(t, s),
      e.setRenderTarget(n, 3),
      e.render(t, a),
      e.setRenderTarget(n, 4),
      e.render(t, o),
      (n.texture.generateMipmaps = h),
      e.setRenderTarget(n, 5),
      e.render(t, l),
      e.setRenderTarget(u),
      (e.xr.enabled = c);
  }
}
class zw extends xx {
  constructor(e, t, n, i, r, s, a, o, l, c) {
    super(
      (e = void 0 !== e ? e : []),
      (t = void 0 !== t ? t : 301),
      n,
      i,
      r,
      s,
      a,
      o,
      l,
      c
    ),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
zw.prototype.isCubeTexture = !0;
class Uw extends Sx {
  constructor(e, t, n) {
    Number.isInteger(t) && (t = n),
      super(e, e, t),
      (t = t || {}),
      (this.texture = new zw(
        void 0,
        t.mapping,
        t.wrapS,
        t.wrapT,
        t.magFilter,
        t.minFilter,
        t.format,
        t.type,
        t.anisotropy,
        t.encoding
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        void 0 !== t.generateMipmaps && t.generateMipmaps),
      (this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : 1006),
      (this.texture._needsFlipEnvMap = !1);
  }
  fromEquirectangularTexture(e, t) {
    (this.texture.type = t.type),
      (this.texture.format = 1023),
      (this.texture.encoding = t.encoding),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter);
    const n = {
        uniforms: { tEquirect: { value: null } },
        vertexShader:
          "varying vec3 vWorldDirection;vec3 transformDirection(in vec3 dir,in mat4 matrix){return normalize((matrix*vec4(dir,0.0)).xyz);}void main(){vWorldDirection=transformDirection(position,modelMatrix);\n#include <begin_vertex>\n#include <project_vertex>\n}",
        fragmentShader:
          "uniform sampler2D tEquirect;varying vec3 vWorldDirection;\n#include <common>\nvoid main(){vec3 direction=normalize(vWorldDirection);vec2 sampleUV=equirectUv(direction);gl_FragColor=texture2D(tEquirect,sampleUV);}",
      },
      i = new Lw(5, 5, 5),
      r = new kw({
        name: "CubemapFromEquirect",
        uniforms: Iw(n.uniforms),
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        side: 1,
        blending: 0,
      });
    r.uniforms.tEquirect.value = t;
    const s = new Aw(i, r),
      a = t.minFilter;
    1008 === t.minFilter && (t.minFilter = 1006);
    return (
      new Fw(1, 10, this).update(e, s),
      (t.minFilter = a),
      s.geometry.dispose(),
      s.material.dispose(),
      this
    );
  }
  clear(e, t, n, i) {
    const r = e.getRenderTarget();
    for (let s = 0; s < 6; s++) e.setRenderTarget(this, s), e.clear(t, n, i);
    e.setRenderTarget(r);
  }
}
Uw.prototype.isWebGLCubeRenderTarget = !0;
const Bw = new Cx(),
  Vw = new Cx(),
  Hw = new mx();
class Gw {
  constructor(e = new Cx(1, 0, 0), t = 0) {
    (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this;
  }
  setComponents(e, t, n, i) {
    return this.normal.set(e, t, n), (this.constant = i), this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, t, n) {
    const i = Bw.subVectors(n, t).cross(Vw.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e);
  }
  intersectLine(e, t) {
    const n = e.delta(Bw),
      i = this.normal.dot(n);
    if (0 === i)
      return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
    const r = -(e.start.dot(this.normal) + this.constant) / i;
    return r < 0 || r > 1 ? null : t.copy(n).multiplyScalar(r).add(e.start);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      n = this.distanceToPoint(e.end);
    return (t < 0 && n > 0) || (n < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const n = t || Hw.getNormalMatrix(e),
      i = this.coplanarPoint(Bw).applyMatrix4(e),
      r = this.normal.applyMatrix3(n).normalize();
    return (this.constant = -i.dot(r)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
Gw.prototype.isPlane = !0;
const Ww = new Xx(),
  qw = new Cx();
class jw {
  constructor(
    e = new Gw(),
    t = new Gw(),
    n = new Gw(),
    i = new Gw(),
    r = new Gw(),
    s = new Gw()
  ) {
    this.planes = [e, t, n, i, r, s];
  }
  set(e, t, n, i, r, s) {
    const a = this.planes;
    return (
      a[0].copy(e),
      a[1].copy(t),
      a[2].copy(n),
      a[3].copy(i),
      a[4].copy(r),
      a[5].copy(s),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e) {
    const t = this.planes,
      n = e.elements,
      i = n[0],
      r = n[1],
      s = n[2],
      a = n[3],
      o = n[4],
      l = n[5],
      c = n[6],
      u = n[7],
      h = n[8],
      d = n[9],
      p = n[10],
      f = n[11],
      m = n[12],
      g = n[13],
      v = n[14],
      _ = n[15];
    return (
      t[0].setComponents(a - i, u - o, f - h, _ - m).normalize(),
      t[1].setComponents(a + i, u + o, f + h, _ + m).normalize(),
      t[2].setComponents(a + r, u + l, f + d, _ + g).normalize(),
      t[3].setComponents(a - r, u - l, f - d, _ - g).normalize(),
      t[4].setComponents(a - s, u - c, f - p, _ - v).normalize(),
      t[5].setComponents(a + s, u + c, f + p, _ + v).normalize(),
      this
    );
  }
  intersectsObject(e) {
    const t = e.geometry;
    return (
      null === t.boundingSphere && t.computeBoundingSphere(),
      Ww.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
      this.intersectsSphere(Ww)
    );
  }
  intersectsSprite(e) {
    return (
      Ww.center.set(0, 0, 0),
      (Ww.radius = 0.7071067811865476),
      Ww.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(Ww)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      n = e.center,
      i = -e.radius;
    for (let r = 0; r < 6; r++) {
      if (t[r].distanceToPoint(n) < i) return !1;
    }
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) {
      const i = t[n];
      if (
        ((qw.x = i.normal.x > 0 ? e.max.x : e.min.x),
        (qw.y = i.normal.y > 0 ? e.max.y : e.min.y),
        (qw.z = i.normal.z > 0 ? e.max.z : e.min.z),
        i.distanceToPoint(qw) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) if (t[n].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function Yw() {
  let e = null,
    t = !1,
    n = null,
    i = null;
  function r(t, s) {
    n(t, s), (i = e.requestAnimationFrame(r));
  }
  return {
    start: function () {
      !0 !== t && null !== n && ((i = e.requestAnimationFrame(r)), (t = !0));
    },
    stop: function () {
      e.cancelAnimationFrame(i), (t = !1);
    },
    setAnimationLoop: function (e) {
      n = e;
    },
    setContext: function (t) {
      e = t;
    },
  };
}
function Xw(e, t) {
  const n = t.isWebGL2,
    i = new WeakMap();
  return {
    get: function (e) {
      return e.isInterleavedBufferAttribute && (e = e.data), i.get(e);
    },
    remove: function (t) {
      t.isInterleavedBufferAttribute && (t = t.data);
      const n = i.get(t);
      n && (e.deleteBuffer(n.buffer), i.delete(t));
    },
    update: function (t, r) {
      if (t.isGLBufferAttribute) {
        const e = i.get(t);
        return void (
          (!e || e.version < t.version) &&
          i.set(t, {
            buffer: t.buffer,
            type: t.type,
            bytesPerElement: t.elementSize,
            version: t.version,
          })
        );
      }
      t.isInterleavedBufferAttribute && (t = t.data);
      const s = i.get(t);
      void 0 === s
        ? i.set(
            t,
            (function (t, i) {
              const r = t.array,
                s = t.usage,
                a = e.createBuffer();
              e.bindBuffer(i, a), e.bufferData(i, r, s), t.onUploadCallback();
              let o = 5126;
              return (
                r instanceof Float32Array
                  ? (o = 5126)
                  : r instanceof Float64Array ||
                    (r instanceof Uint16Array
                      ? t.isFloat16BufferAttribute
                        ? n && (o = 5131)
                        : (o = 5123)
                      : r instanceof Int16Array
                      ? (o = 5122)
                      : r instanceof Uint32Array
                      ? (o = 5125)
                      : r instanceof Int32Array
                      ? (o = 5124)
                      : r instanceof Int8Array
                      ? (o = 5120)
                      : (r instanceof Uint8Array ||
                          r instanceof Uint8ClampedArray) &&
                        (o = 5121)),
                {
                  buffer: a,
                  type: o,
                  bytesPerElement: r.BYTES_PER_ELEMENT,
                  version: t.version,
                }
              );
            })(t, r)
          )
        : s.version < t.version &&
          (!(function (t, i, r) {
            const s = i.array,
              a = i.updateRange;
            e.bindBuffer(r, t),
              -1 === a.count
                ? e.bufferSubData(r, 0, s)
                : (n
                    ? e.bufferSubData(
                        r,
                        a.offset * s.BYTES_PER_ELEMENT,
                        s,
                        a.offset,
                        a.count
                      )
                    : e.bufferSubData(
                        r,
                        a.offset * s.BYTES_PER_ELEMENT,
                        s.subarray(a.offset, a.offset + a.count)
                      ),
                  (a.count = -1));
          })(s.buffer, t, r),
          (s.version = t.version));
    },
  };
}
class $w extends uw {
  constructor(e = 1, t = 1, n = 1, i = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: n,
        heightSegments: i,
      });
    const r = e / 2,
      s = t / 2,
      a = Math.floor(n),
      o = Math.floor(i),
      l = a + 1,
      c = o + 1,
      u = e / a,
      h = t / o,
      d = [],
      p = [],
      f = [],
      m = [];
    for (let g = 0; g < c; g++) {
      const e = g * h - s;
      for (let t = 0; t < l; t++) {
        const n = t * u - r;
        p.push(n, -e, 0), f.push(0, 0, 1), m.push(t / a), m.push(1 - g / o);
      }
    }
    for (let g = 0; g < o; g++)
      for (let e = 0; e < a; e++) {
        const t = e + l * g,
          n = e + l * (g + 1),
          i = e + 1 + l * (g + 1),
          r = e + 1 + l * g;
        d.push(t, n, r), d.push(n, i, r);
      }
    this.setIndex(d),
      this.setAttribute("position", new nw(p, 3)),
      this.setAttribute("normal", new nw(f, 3)),
      this.setAttribute("uv", new nw(m, 2));
  }
  static fromJSON(e) {
    return new $w(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
const Zw = {
    alphamap_fragment:
      "#ifdef USE_ALPHAMAP\ndiffuseColor.a*=texture2D(alphaMap,vUv).g;\n#endif",
    alphamap_pars_fragment:
      "#ifdef USE_ALPHAMAP\nuniform sampler2D alphaMap;\n#endif",
    alphatest_fragment:
      "#ifdef USE_ALPHATEST\nif(diffuseColor.a<alphaTest)discard;\n#endif",
    alphatest_pars_fragment:
      "#ifdef USE_ALPHATEST\nuniform float alphaTest;\n#endif",
    aomap_fragment:
      "#ifdef USE_AOMAP\nfloat ambientOcclusion=(texture2D(aoMap,vUv2).r-1.0)*aoMapIntensity+1.0;reflectedLight.indirectDiffuse*=ambientOcclusion;\n#if defined(USE_ENVMAP)&&defined(STANDARD)\nfloat dotNV=saturate(dot(geometry.normal,geometry.viewDir));reflectedLight.indirectSpecular*=computeSpecularOcclusion(dotNV,ambientOcclusion,material.roughness);\n#endif\n#endif",
    aomap_pars_fragment:
      "#ifdef USE_AOMAP\nuniform sampler2D aoMap;uniform float aoMapIntensity;\n#endif",
    begin_vertex: "vec3 transformed=vec3(position);",
    beginnormal_vertex:
      "vec3 objectNormal=vec3(normal);\n#ifdef USE_TANGENT\nvec3 objectTangent=vec3(tangent.xyz);\n#endif",
    bsdfs:
      "vec3 BRDF_Lambert(const in vec3 diffuseColor){return RECIPROCAL_PI*diffuseColor;}vec3 F_Schlick(const in vec3 f0,const in float f90,const in float dotVH){float fresnel=exp2((-5.55473*dotVH-6.98316)*dotVH);return f0*(1.0-fresnel)+(f90*fresnel);}float V_GGX_SmithCorrelated(const in float alpha,const in float dotNL,const in float dotNV){float a2=pow2(alpha);float gv=dotNL*sqrt(a2+(1.0-a2)*pow2(dotNV));float gl=dotNV*sqrt(a2+(1.0-a2)*pow2(dotNL));return 0.5/max(gv+gl,EPSILON);}float D_GGX(const in float alpha,const in float dotNH){float a2=pow2(alpha);float denom=pow2(dotNH)*(a2-1.0)+1.0;return RECIPROCAL_PI*a2/pow2(denom);}vec3 BRDF_GGX(const in vec3 lightDir,const in vec3 viewDir,const in vec3 normal,const in vec3 f0,const in float f90,const in float roughness){float alpha=pow2(roughness);vec3 halfDir=normalize(lightDir+viewDir);float dotNL=saturate(dot(normal,lightDir));float dotNV=saturate(dot(normal,viewDir));float dotNH=saturate(dot(normal,halfDir));float dotVH=saturate(dot(viewDir,halfDir));vec3 F=F_Schlick(f0,f90,dotVH);float V=V_GGX_SmithCorrelated(alpha,dotNL,dotNV);float D=D_GGX(alpha,dotNH);return F*(V*D);}vec2 LTC_Uv(const in vec3 N,const in vec3 V,const in float roughness){const float LUT_SIZE=64.0;const float LUT_SCALE=(LUT_SIZE-1.0)/LUT_SIZE;const float LUT_BIAS=0.5/LUT_SIZE;float dotNV=saturate(dot(N,V));vec2 uv=vec2(roughness,sqrt(1.0-dotNV));uv=uv*LUT_SCALE+LUT_BIAS;return uv;}float LTC_ClippedSphereFormFactor(const in vec3 f){float l=length(f);return max((l*l+f.z)/(l+1.0),0.0);}vec3 LTC_EdgeVectorFormFactor(const in vec3 v1,const in vec3 v2){float x=dot(v1,v2);float y=abs(x);float a=0.8543985+(0.4965155+0.0145206*y)*y;float b=3.4175940+(4.1616724+y)*y;float v=a/b;float theta_sintheta=(x>0.0)?v:0.5*inversesqrt(max(1.0-x*x,1e-7))-v;return cross(v1,v2)*theta_sintheta;}vec3 LTC_Evaluate(const in vec3 N,const in vec3 V,const in vec3 P,const in mat3 mInv,const in vec3 rectCoords[4]){vec3 v1=rectCoords[1]-rectCoords[0];vec3 v2=rectCoords[3]-rectCoords[0];vec3 lightNormal=cross(v1,v2);if(dot(lightNormal,P-rectCoords[0])<0.0)return vec3(0.0);vec3 T1,T2;T1=normalize(V-N*dot(V,N));T2=-cross(N,T1);mat3 mat=mInv*transposeMat3(mat3(T1,T2,N));vec3 coords[4];coords[0]=mat*(rectCoords[0]-P);coords[1]=mat*(rectCoords[1]-P);coords[2]=mat*(rectCoords[2]-P);coords[3]=mat*(rectCoords[3]-P);coords[0]=normalize(coords[0]);coords[1]=normalize(coords[1]);coords[2]=normalize(coords[2]);coords[3]=normalize(coords[3]);vec3 vectorFormFactor=vec3(0.0);vectorFormFactor+=LTC_EdgeVectorFormFactor(coords[0],coords[1]);vectorFormFactor+=LTC_EdgeVectorFormFactor(coords[1],coords[2]);vectorFormFactor+=LTC_EdgeVectorFormFactor(coords[2],coords[3]);vectorFormFactor+=LTC_EdgeVectorFormFactor(coords[3],coords[0]);float result=LTC_ClippedSphereFormFactor(vectorFormFactor);return vec3(result);}float G_BlinnPhong_Implicit(){return 0.25;}float D_BlinnPhong(const in float shininess,const in float dotNH){return RECIPROCAL_PI*(shininess*0.5+1.0)*pow(dotNH,shininess);}vec3 BRDF_BlinnPhong(const in vec3 lightDir,const in vec3 viewDir,const in vec3 normal,const in vec3 specularColor,const in float shininess){vec3 halfDir=normalize(lightDir+viewDir);float dotNH=saturate(dot(normal,halfDir));float dotVH=saturate(dot(viewDir,halfDir));vec3 F=F_Schlick(specularColor,1.0,dotVH);float G=G_BlinnPhong_Implicit();float D=D_BlinnPhong(shininess,dotNH);return F*(G*D);}\n#if defined(USE_SHEEN)\nfloat D_Charlie(float roughness,float dotNH){float alpha=pow2(roughness);float invAlpha=1.0/alpha;float cos2h=dotNH*dotNH;float sin2h=max(1.0-cos2h,0.0078125);return(2.0+invAlpha)*pow(sin2h,invAlpha*0.5)/(2.0*PI);}float V_Neubelt(float dotNV,float dotNL){return saturate(1.0/(4.0*(dotNL+dotNV-dotNL*dotNV)));}vec3 BRDF_Sheen(const in vec3 lightDir,const in vec3 viewDir,const in vec3 normal,vec3 sheenTint,const in float sheenRoughness){vec3 halfDir=normalize(lightDir+viewDir);float dotNL=saturate(dot(normal,lightDir));float dotNV=saturate(dot(normal,viewDir));float dotNH=saturate(dot(normal,halfDir));float D=D_Charlie(sheenRoughness,dotNH);float V=V_Neubelt(dotNV,dotNL);return sheenTint*(D*V);}\n#endif",
    bumpmap_pars_fragment:
      "#ifdef USE_BUMPMAP\nuniform sampler2D bumpMap;uniform float bumpScale;vec2 dHdxy_fwd(){vec2 dSTdx=dFdx(vUv);vec2 dSTdy=dFdy(vUv);float Hll=bumpScale*texture2D(bumpMap,vUv).x;float dBx=bumpScale*texture2D(bumpMap,vUv+dSTdx).x-Hll;float dBy=bumpScale*texture2D(bumpMap,vUv+dSTdy).x-Hll;return vec2(dBx,dBy);}vec3 perturbNormalArb(vec3 surf_pos,vec3 surf_norm,vec2 dHdxy,float faceDirection){vec3 vSigmaX=vec3(dFdx(surf_pos.x),dFdx(surf_pos.y),dFdx(surf_pos.z));vec3 vSigmaY=vec3(dFdy(surf_pos.x),dFdy(surf_pos.y),dFdy(surf_pos.z));vec3 vN=surf_norm;vec3 R1=cross(vSigmaY,vN);vec3 R2=cross(vN,vSigmaX);float fDet=dot(vSigmaX,R1)*faceDirection;vec3 vGrad=sign(fDet)*(dHdxy.x*R1+dHdxy.y*R2);return normalize(abs(fDet)*surf_norm-vGrad);}\n#endif",
    clipping_planes_fragment:
      "#if NUM_CLIPPING_PLANES>0\nvec4 plane;\n#pragma unroll_loop_start\nfor(int i=0;i<UNION_CLIPPING_PLANES;i++){plane=clippingPlanes[i];if(dot(vClipPosition,plane.xyz)>plane.w)discard;}\n#pragma unroll_loop_end\n#if UNION_CLIPPING_PLANES<NUM_CLIPPING_PLANES\nbool clipped=true;\n#pragma unroll_loop_start\nfor(int i=UNION_CLIPPING_PLANES;i<NUM_CLIPPING_PLANES;i++){plane=clippingPlanes[i];clipped=(dot(vClipPosition,plane.xyz)>plane.w)&&clipped;}\n#pragma unroll_loop_end\nif(clipped)discard;\n#endif\n#endif",
    clipping_planes_pars_fragment:
      "#if NUM_CLIPPING_PLANES>0\nvarying vec3 vClipPosition;uniform vec4 clippingPlanes[NUM_CLIPPING_PLANES];\n#endif",
    clipping_planes_pars_vertex:
      "#if NUM_CLIPPING_PLANES>0\nvarying vec3 vClipPosition;\n#endif",
    clipping_planes_vertex:
      "#if NUM_CLIPPING_PLANES>0\nvClipPosition=-mvPosition.xyz;\n#endif",
    color_fragment:
      "#if defined(USE_COLOR_ALPHA)\ndiffuseColor*=vColor;\n#elif defined(USE_COLOR)\ndiffuseColor.rgb*=vColor;\n#endif",
    color_pars_fragment:
      "#if defined(USE_COLOR_ALPHA)\nvarying vec4 vColor;\n#elif defined(USE_COLOR)\nvarying vec3 vColor;\n#endif",
    color_pars_vertex:
      "#if defined(USE_COLOR_ALPHA)\nvarying vec4 vColor;\n#elif defined(USE_COLOR)||defined(USE_INSTANCING_COLOR)\nvarying vec3 vColor;\n#endif",
    color_vertex:
      "#if defined(USE_COLOR_ALPHA)\nvColor=vec4(1.0);\n#elif defined(USE_COLOR)||defined(USE_INSTANCING_COLOR)\nvColor=vec3(1.0);\n#endif\n#ifdef USE_COLOR\nvColor*=color;\n#endif\n#ifdef USE_INSTANCING_COLOR\nvColor.xyz*=instanceColor.xyz;\n#endif",
    common:
      "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a)clamp(a,0.0,1.0)\n#endif\n#define whiteComplement(a)(1.0-saturate(a))\nfloat pow2(const in float x){return x*x;}float pow3(const in float x){return x*x*x;}float pow4(const in float x){float x2=x*x;return x2*x2;}float max3(const in vec3 v){return max(max(v.x,v.y),v.z);}float average(const in vec3 color){return dot(color,vec3(0.3333));}highp float rand(const in vec2 uv){const highp float a=12.9898,b=78.233,c=43758.5453;highp float dt=dot(uv.xy,vec2(a,b)),sn=mod(dt,PI);return fract(sin(sn)*c);}\n#ifdef HIGH_PRECISION\nfloat precisionSafeLength(vec3 v){return length(v);}\n#else\nfloat precisionSafeLength(vec3 v){float maxComponent=max3(abs(v));return length(v/maxComponent)*maxComponent;}\n#endif\nstruct IncidentLight{vec3 color;vec3 direction;bool visible;};struct ReflectedLight{vec3 directDiffuse;vec3 directSpecular;vec3 indirectDiffuse;vec3 indirectSpecular;};struct GeometricContext{vec3 position;vec3 normal;vec3 viewDir;\n#ifdef USE_CLEARCOAT\nvec3 clearcoatNormal;\n#endif\n};vec3 transformDirection(in vec3 dir,in mat4 matrix){return normalize((matrix*vec4(dir,0.0)).xyz);}vec3 inverseTransformDirection(in vec3 dir,in mat4 matrix){return normalize((vec4(dir,0.0)*matrix).xyz);}mat3 transposeMat3(const in mat3 m){mat3 tmp;tmp[0]=vec3(m[0].x,m[1].x,m[2].x);tmp[1]=vec3(m[0].y,m[1].y,m[2].y);tmp[2]=vec3(m[0].z,m[1].z,m[2].z);return tmp;}float linearToRelativeLuminance(const in vec3 color){vec3 weights=vec3(0.2126,0.7152,0.0722);return dot(weights,color.rgb);}bool isPerspectiveMatrix(mat4 m){return m[2][3]==-1.0;}vec2 equirectUv(in vec3 dir){float u=atan(dir.z,dir.x)*RECIPROCAL_PI2+0.5;float v=asin(clamp(dir.y,-1.0,1.0))*RECIPROCAL_PI+0.5;return vec2(u,v);}",
    cube_uv_reflection_fragment:
      "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction){vec3 absDirection=abs(direction);float face=-1.0;if(absDirection.x>absDirection.z){if(absDirection.x>absDirection.y)face=direction.x>0.0?0.0:3.0;else face=direction.y>0.0?1.0:4.0;}else{if(absDirection.z>absDirection.y)face=direction.z>0.0?2.0:5.0;else face=direction.y>0.0?1.0:4.0;}return face;}vec2 getUV(vec3 direction,float face){vec2 uv;if(face==0.0){uv=vec2(direction.z,direction.y)/abs(direction.x);}else if(face==1.0){uv=vec2(-direction.x,-direction.z)/abs(direction.y);}else if(face==2.0){uv=vec2(-direction.x,direction.y)/abs(direction.z);}else if(face==3.0){uv=vec2(-direction.z,direction.y)/abs(direction.x);}else if(face==4.0){uv=vec2(-direction.x,direction.z)/abs(direction.y);}else{uv=vec2(direction.x,direction.y)/abs(direction.z);}return 0.5*(uv+1.0);}vec3 bilinearCubeUV(sampler2D envMap,vec3 direction,float mipInt){float face=getFace(direction);float filterInt=max(cubeUV_minMipLevel-mipInt,0.0);mipInt=max(mipInt,cubeUV_minMipLevel);float faceSize=exp2(mipInt);float texelSize=1.0/(3.0*cubeUV_maxTileSize);vec2 uv=getUV(direction,face)*(faceSize-1.0);vec2 f=fract(uv);uv+=0.5-f;if(face>2.0){uv.y+=faceSize;face-=3.0;}uv.x+=face*faceSize;if(mipInt<cubeUV_maxMipLevel){uv.y+=2.0*cubeUV_maxTileSize;}uv.y+=filterInt*2.0*cubeUV_minTileSize;uv.x+=3.0*max(0.0,cubeUV_maxTileSize-2.0*faceSize);uv*=texelSize;vec3 tl=envMapTexelToLinear(texture2D(envMap,uv)).rgb;uv.x+=texelSize;vec3 tr=envMapTexelToLinear(texture2D(envMap,uv)).rgb;uv.y+=texelSize;vec3 br=envMapTexelToLinear(texture2D(envMap,uv)).rgb;uv.x-=texelSize;vec3 bl=envMapTexelToLinear(texture2D(envMap,uv)).rgb;vec3 tm=mix(tl,tr,f.x);vec3 bm=mix(bl,br,f.x);return mix(tm,bm,f.y);}\n#define r0 1.0\n#define v0 0.339\n#define m0-2.0\n#define r1 0.8\n#define v1 0.276\n#define m1-1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness){float mip=0.0;if(roughness>=r1){mip=(r0-roughness)*(m1-m0)/(r0-r1)+m0;}else if(roughness>=r4){mip=(r1-roughness)*(m4-m1)/(r1-r4)+m1;}else if(roughness>=r5){mip=(r4-roughness)*(m5-m4)/(r4-r5)+m4;}else if(roughness>=r6){mip=(r5-roughness)*(m6-m5)/(r5-r6)+m5;}else{mip=-2.0*log2(1.16*roughness);}return mip;}vec4 textureCubeUV(sampler2D envMap,vec3 sampleDir,float roughness){float mip=clamp(roughnessToMip(roughness),m0,cubeUV_maxMipLevel);float mipF=fract(mip);float mipInt=floor(mip);vec3 color0=bilinearCubeUV(envMap,sampleDir,mipInt);if(mipF==0.0){return vec4(color0,1.0);}else{vec3 color1=bilinearCubeUV(envMap,sampleDir,mipInt+1.0);return vec4(mix(color0,color1,mipF),1.0);}}\n#endif",
    defaultnormal_vertex:
      "vec3 transformedNormal=objectNormal;\n#ifdef USE_INSTANCING\nmat3 m=mat3(instanceMatrix);transformedNormal/=vec3(dot(m[0],m[0]),dot(m[1],m[1]),dot(m[2],m[2]));transformedNormal=m*transformedNormal;\n#endif\ntransformedNormal=normalMatrix*transformedNormal;\n#ifdef FLIP_SIDED\ntransformedNormal=-transformedNormal;\n#endif\n#ifdef USE_TANGENT\nvec3 transformedTangent=(modelViewMatrix*vec4(objectTangent,0.0)).xyz;\n#ifdef FLIP_SIDED\ntransformedTangent=-transformedTangent;\n#endif\n#endif",
    displacementmap_pars_vertex:
      "#ifdef USE_DISPLACEMENTMAP\nuniform sampler2D displacementMap;uniform float displacementScale;uniform float displacementBias;\n#endif",
    displacementmap_vertex:
      "#ifdef USE_DISPLACEMENTMAP\ntransformed+=normalize(objectNormal)*(texture2D(displacementMap,vUv).x*displacementScale+displacementBias);\n#endif",
    emissivemap_fragment:
      "#ifdef USE_EMISSIVEMAP\nvec4 emissiveColor=texture2D(emissiveMap,vUv);emissiveColor.rgb=emissiveMapTexelToLinear(emissiveColor).rgb;totalEmissiveRadiance*=emissiveColor.rgb;\n#endif",
    emissivemap_pars_fragment:
      "#ifdef USE_EMISSIVEMAP\nuniform sampler2D emissiveMap;\n#endif",
    encodings_fragment: "gl_FragColor=linearToOutputTexel(gl_FragColor);",
    encodings_pars_fragment:
      "vec4 LinearToLinear(in vec4 value){return value;}vec4 GammaToLinear(in vec4 value,in float gammaFactor){return vec4(pow(value.rgb,vec3(gammaFactor)),value.a);}vec4 LinearToGamma(in vec4 value,in float gammaFactor){return vec4(pow(value.rgb,vec3(1.0/gammaFactor)),value.a);}vec4 sRGBToLinear(in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}vec4 LinearTosRGB(in vec4 value){return vec4(mix(pow(value.rgb,vec3(0.41666))*1.055-vec3(0.055),value.rgb*12.92,vec3(lessThanEqual(value.rgb,vec3(0.0031308)))),value.a);}vec4 RGBEToLinear(in vec4 value){return vec4(value.rgb*exp2(value.a*255.0-128.0),1.0);}vec4 LinearToRGBE(in vec4 value){float maxComponent=max(max(value.r,value.g),value.b);float fExp=clamp(ceil(log2(maxComponent)),-128.0,127.0);return vec4(value.rgb/exp2(fExp),(fExp+128.0)/255.0);}vec4 RGBMToLinear(in vec4 value,in float maxRange){return vec4(value.rgb*value.a*maxRange,1.0);}vec4 LinearToRGBM(in vec4 value,in float maxRange){float maxRGB=max(value.r,max(value.g,value.b));float M=clamp(maxRGB/maxRange,0.0,1.0);M=ceil(M*255.0)/255.0;return vec4(value.rgb/(M*maxRange),M);}vec4 RGBDToLinear(in vec4 value,in float maxRange){return vec4(value.rgb*((maxRange/255.0)/value.a),1.0);}vec4 LinearToRGBD(in vec4 value,in float maxRange){float maxRGB=max(value.r,max(value.g,value.b));float D=max(maxRange/maxRGB,1.0);D=clamp(floor(D)/255.0,0.0,1.0);return vec4(value.rgb*(D*(255.0/maxRange)),D);}const mat3 cLogLuvM=mat3(0.2209,0.3390,0.4184,0.1138,0.6780,0.7319,0.0102,0.1130,0.2969);vec4 LinearToLogLuv(in vec4 value){vec3 Xp_Y_XYZp=cLogLuvM*value.rgb;Xp_Y_XYZp=max(Xp_Y_XYZp,vec3(1e-6,1e-6,1e-6));vec4 vResult;vResult.xy=Xp_Y_XYZp.xy/Xp_Y_XYZp.z;float Le=2.0*log2(Xp_Y_XYZp.y)+127.0;vResult.w=fract(Le);vResult.z=(Le-(floor(vResult.w*255.0))/255.0)/255.0;return vResult;}const mat3 cLogLuvInverseM=mat3(6.0014,-2.7008,-1.7996,-1.3320,3.1029,-5.7721,0.3008,-1.0882,5.6268);vec4 LogLuvToLinear(in vec4 value){float Le=value.z*255.0+value.w;vec3 Xp_Y_XYZp;Xp_Y_XYZp.y=exp2((Le-127.0)/2.0);Xp_Y_XYZp.z=Xp_Y_XYZp.y/value.y;Xp_Y_XYZp.x=value.x*Xp_Y_XYZp.z;vec3 vRGB=cLogLuvInverseM*Xp_Y_XYZp.rgb;return vec4(max(vRGB,0.0),1.0);}",
    envmap_fragment:
      "#ifdef USE_ENVMAP\n#ifdef ENV_WORLDPOS\nvec3 cameraToFrag;if(isOrthographic){cameraToFrag=normalize(vec3(-viewMatrix[0][2],-viewMatrix[1][2],-viewMatrix[2][2]));}else{cameraToFrag=normalize(vWorldPosition-cameraPosition);}vec3 worldNormal=inverseTransformDirection(normal,viewMatrix);\n#ifdef ENVMAP_MODE_REFLECTION\nvec3 reflectVec=reflect(cameraToFrag,worldNormal);\n#else\nvec3 reflectVec=refract(cameraToFrag,worldNormal,refractionRatio);\n#endif\n#else\nvec3 reflectVec=vReflect;\n#endif\n#ifdef ENVMAP_TYPE_CUBE\nvec4 envColor=textureCube(envMap,vec3(flipEnvMap*reflectVec.x,reflectVec.yz));envColor=envMapTexelToLinear(envColor);\n#elif defined(ENVMAP_TYPE_CUBE_UV)\nvec4 envColor=textureCubeUV(envMap,reflectVec,0.0);\n#else\nvec4 envColor=vec4(0.0);\n#endif\n#ifdef ENVMAP_BLENDING_MULTIPLY\noutgoingLight=mix(outgoingLight,outgoingLight*envColor.xyz,specularStrength*reflectivity);\n#elif defined(ENVMAP_BLENDING_MIX)\noutgoingLight=mix(outgoingLight,envColor.xyz,specularStrength*reflectivity);\n#elif defined(ENVMAP_BLENDING_ADD)\noutgoingLight+=envColor.xyz*specularStrength*reflectivity;\n#endif\n#endif",
    envmap_common_pars_fragment:
      "#ifdef USE_ENVMAP\nuniform float envMapIntensity;uniform float flipEnvMap;uniform int maxMipLevel;\n#ifdef ENVMAP_TYPE_CUBE\nuniform samplerCube envMap;\n#else\nuniform sampler2D envMap;\n#endif\n#endif",
    envmap_pars_fragment:
      "#ifdef USE_ENVMAP\nuniform float reflectivity;\n#if defined(USE_BUMPMAP)||defined(USE_NORMALMAP)||defined(PHONG)\n#define ENV_WORLDPOS\n#endif\n#ifdef ENV_WORLDPOS\nvarying vec3 vWorldPosition;uniform float refractionRatio;\n#else\nvarying vec3 vReflect;\n#endif\n#endif",
    envmap_pars_vertex:
      "#ifdef USE_ENVMAP\n#if defined(USE_BUMPMAP)||defined(USE_NORMALMAP)||defined(PHONG)\n#define ENV_WORLDPOS\n#endif\n#ifdef ENV_WORLDPOS\nvarying vec3 vWorldPosition;\n#else\nvarying vec3 vReflect;uniform float refractionRatio;\n#endif\n#endif",
    envmap_physical_pars_fragment:
      "#if defined(USE_ENVMAP)\n#ifdef ENVMAP_MODE_REFRACTION\nuniform float refractionRatio;\n#endif\nvec3 getIBLIrradiance(const in vec3 normal){\n#if defined(ENVMAP_TYPE_CUBE_UV)\nvec3 worldNormal=inverseTransformDirection(normal,viewMatrix);vec4 envMapColor=textureCubeUV(envMap,worldNormal,1.0);return PI*envMapColor.rgb*envMapIntensity;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 getIBLRadiance(const in vec3 viewDir,const in vec3 normal,const in float roughness){\n#if defined(ENVMAP_TYPE_CUBE_UV)\nvec3 reflectVec;\n#ifdef ENVMAP_MODE_REFLECTION\nreflectVec=reflect(-viewDir,normal);reflectVec=normalize(mix(reflectVec,normal,roughness*roughness));\n#else\nreflectVec=refract(-viewDir,normal,refractionRatio);\n#endif\nreflectVec=inverseTransformDirection(reflectVec,viewMatrix);vec4 envMapColor=textureCubeUV(envMap,reflectVec,roughness);return envMapColor.rgb*envMapIntensity;\n#else\nreturn vec3(0.0);\n#endif\n}\n#endif",
    envmap_vertex:
      "#ifdef USE_ENVMAP\n#ifdef ENV_WORLDPOS\nvWorldPosition=worldPosition.xyz;\n#else\nvec3 cameraToVertex;if(isOrthographic){cameraToVertex=normalize(vec3(-viewMatrix[0][2],-viewMatrix[1][2],-viewMatrix[2][2]));}else{cameraToVertex=normalize(worldPosition.xyz-cameraPosition);}vec3 worldNormal=inverseTransformDirection(transformedNormal,viewMatrix);\n#ifdef ENVMAP_MODE_REFLECTION\nvReflect=reflect(cameraToVertex,worldNormal);\n#else\nvReflect=refract(cameraToVertex,worldNormal,refractionRatio);\n#endif\n#endif\n#endif",
    fog_vertex: "#ifdef USE_FOG\nvFogDepth=-mvPosition.z;\n#endif",
    fog_pars_vertex: "#ifdef USE_FOG\nvarying float vFogDepth;\n#endif",
    fog_fragment:
      "#ifdef USE_FOG\n#ifdef FOG_EXP2\nfloat fogFactor=1.0-exp(-fogDensity*fogDensity*vFogDepth*vFogDepth);\n#else\nfloat fogFactor=smoothstep(fogNear,fogFar,vFogDepth);\n#endif\ngl_FragColor.rgb=mix(gl_FragColor.rgb,fogColor,fogFactor);\n#endif",
    fog_pars_fragment:
      "#ifdef USE_FOG\nuniform vec3 fogColor;varying float vFogDepth;\n#ifdef FOG_EXP2\nuniform float fogDensity;\n#else\nuniform float fogNear;uniform float fogFar;\n#endif\n#endif",
    gradientmap_pars_fragment:
      "#ifdef USE_GRADIENTMAP\nuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance(vec3 normal,vec3 lightDirection){float dotNL=dot(normal,lightDirection);vec2 coord=vec2(dotNL*0.5+0.5,0.0);\n#ifdef USE_GRADIENTMAP\nreturn texture2D(gradientMap,coord).rgb;\n#else\nreturn(coord.x<0.7)?vec3(0.7):vec3(1.0);\n#endif\n}",
    lightmap_fragment:
      "#ifdef USE_LIGHTMAP\nvec4 lightMapTexel=texture2D(lightMap,vUv2);vec3 lightMapIrradiance=lightMapTexelToLinear(lightMapTexel).rgb*lightMapIntensity;\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nlightMapIrradiance*=PI;\n#endif\nreflectedLight.indirectDiffuse+=lightMapIrradiance;\n#endif",
    lightmap_pars_fragment:
      "#ifdef USE_LIGHTMAP\nuniform sampler2D lightMap;uniform float lightMapIntensity;\n#endif",
    lights_lambert_vertex:
      "vec3 diffuse=vec3(1.0);GeometricContext geometry;geometry.position=mvPosition.xyz;geometry.normal=normalize(transformedNormal);geometry.viewDir=(isOrthographic)?vec3(0,0,1):normalize(-mvPosition.xyz);GeometricContext backGeometry;backGeometry.position=geometry.position;backGeometry.normal=-geometry.normal;backGeometry.viewDir=geometry.viewDir;vLightFront=vec3(0.0);vIndirectFront=vec3(0.0);\n#ifdef DOUBLE_SIDED\nvLightBack=vec3(0.0);vIndirectBack=vec3(0.0);\n#endif\nIncidentLight directLight;float dotNL;vec3 directLightColor_Diffuse;vIndirectFront+=getAmbientLightIrradiance(ambientLightColor);vIndirectFront+=getLightProbeIrradiance(lightProbe,geometry.normal);\n#ifdef DOUBLE_SIDED\nvIndirectBack+=getAmbientLightIrradiance(ambientLightColor);vIndirectBack+=getLightProbeIrradiance(lightProbe,backGeometry.normal);\n#endif\n#if NUM_POINT_LIGHTS>0\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_POINT_LIGHTS;i++){getPointLightInfo(pointLights[i],geometry,directLight);dotNL=dot(geometry.normal,directLight.direction);directLightColor_Diffuse=directLight.color;vLightFront+=saturate(dotNL)*directLightColor_Diffuse;\n#ifdef DOUBLE_SIDED\nvLightBack+=saturate(-dotNL)*directLightColor_Diffuse;\n#endif\n}\n#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS>0\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_SPOT_LIGHTS;i++){getSpotLightInfo(spotLights[i],geometry,directLight);dotNL=dot(geometry.normal,directLight.direction);directLightColor_Diffuse=directLight.color;vLightFront+=saturate(dotNL)*directLightColor_Diffuse;\n#ifdef DOUBLE_SIDED\nvLightBack+=saturate(-dotNL)*directLightColor_Diffuse;\n#endif\n}\n#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS>0\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_DIR_LIGHTS;i++){getDirectionalLightInfo(directionalLights[i],geometry,directLight);dotNL=dot(geometry.normal,directLight.direction);directLightColor_Diffuse=directLight.color;vLightFront+=saturate(dotNL)*directLightColor_Diffuse;\n#ifdef DOUBLE_SIDED\nvLightBack+=saturate(-dotNL)*directLightColor_Diffuse;\n#endif\n}\n#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS>0\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_HEMI_LIGHTS;i++){vIndirectFront+=getHemisphereLightIrradiance(hemisphereLights[i],geometry.normal);\n#ifdef DOUBLE_SIDED\nvIndirectBack+=getHemisphereLightIrradiance(hemisphereLights[i],backGeometry.normal);\n#endif\n}\n#pragma unroll_loop_end\n#endif",
    lights_pars_begin:
      "uniform bool receiveShadow;uniform vec3 ambientLightColor;uniform vec3 lightProbe[9];vec3 shGetIrradianceAt(in vec3 normal,in vec3 shCoefficients[9]){float x=normal.x,y=normal.y,z=normal.z;vec3 result=shCoefficients[0]*0.886227;result+=shCoefficients[1]*2.0*0.511664*y;result+=shCoefficients[2]*2.0*0.511664*z;result+=shCoefficients[3]*2.0*0.511664*x;result+=shCoefficients[4]*2.0*0.429043*x*y;result+=shCoefficients[5]*2.0*0.429043*y*z;result+=shCoefficients[6]*(0.743125*z*z-0.247708);result+=shCoefficients[7]*2.0*0.429043*x*z;result+=shCoefficients[8]*0.429043*(x*x-y*y);return result;}vec3 getLightProbeIrradiance(const in vec3 lightProbe[9],const in vec3 normal){vec3 worldNormal=inverseTransformDirection(normal,viewMatrix);vec3 irradiance=shGetIrradianceAt(worldNormal,lightProbe);return irradiance;}vec3 getAmbientLightIrradiance(const in vec3 ambientLightColor){vec3 irradiance=ambientLightColor;return irradiance;}float getDistanceAttenuation(const in float lightDistance,const in float cutoffDistance,const in float decayExponent){\n#if defined(PHYSICALLY_CORRECT_LIGHTS)\nfloat distanceFalloff=1.0/max(pow(lightDistance,decayExponent),0.01);if(cutoffDistance>0.0){distanceFalloff*=pow2(saturate(1.0-pow4(lightDistance/cutoffDistance)));}return distanceFalloff;\n#else\nif(cutoffDistance>0.0&&decayExponent>0.0){return pow(saturate(-lightDistance/cutoffDistance+1.0),decayExponent);}return 1.0;\n#endif\n}float getSpotAttenuation(const in float coneCosine,const in float penumbraCosine,const in float angleCosine){return smoothstep(coneCosine,penumbraCosine,angleCosine);}\n#if NUM_DIR_LIGHTS>0\nstruct DirectionalLight{vec3 direction;vec3 color;};uniform DirectionalLight directionalLights[NUM_DIR_LIGHTS];void getDirectionalLightInfo(const in DirectionalLight directionalLight,const in GeometricContext geometry,out IncidentLight light){light.color=directionalLight.color;light.direction=directionalLight.direction;light.visible=true;}\n#endif\n#if NUM_POINT_LIGHTS>0\nstruct PointLight{vec3 position;vec3 color;float distance;float decay;};uniform PointLight pointLights[NUM_POINT_LIGHTS];void getPointLightInfo(const in PointLight pointLight,const in GeometricContext geometry,out IncidentLight light){vec3 lVector=pointLight.position-geometry.position;light.direction=normalize(lVector);float lightDistance=length(lVector);light.color=pointLight.color;light.color*=getDistanceAttenuation(lightDistance,pointLight.distance,pointLight.decay);light.visible=(light.color!=vec3(0.0));}\n#endif\n#if NUM_SPOT_LIGHTS>0\nstruct SpotLight{vec3 position;vec3 direction;vec3 color;float distance;float decay;float coneCos;float penumbraCos;};uniform SpotLight spotLights[NUM_SPOT_LIGHTS];void getSpotLightInfo(const in SpotLight spotLight,const in GeometricContext geometry,out IncidentLight light){vec3 lVector=spotLight.position-geometry.position;light.direction=normalize(lVector);float angleCos=dot(light.direction,spotLight.direction);float spotAttenuation=getSpotAttenuation(spotLight.coneCos,spotLight.penumbraCos,angleCos);if(spotAttenuation>0.0){float lightDistance=length(lVector);light.color=spotLight.color*spotAttenuation;light.color*=getDistanceAttenuation(lightDistance,spotLight.distance,spotLight.decay);light.visible=(light.color!=vec3(0.0));}else{light.color=vec3(0.0);light.visible=false;}}\n#endif\n#if NUM_RECT_AREA_LIGHTS>0\nstruct RectAreaLight{vec3 color;vec3 position;vec3 halfWidth;vec3 halfHeight;};uniform sampler2D ltc_1;uniform sampler2D ltc_2;uniform RectAreaLight rectAreaLights[NUM_RECT_AREA_LIGHTS];\n#endif\n#if NUM_HEMI_LIGHTS>0\nstruct HemisphereLight{vec3 direction;vec3 skyColor;vec3 groundColor;};uniform HemisphereLight hemisphereLights[NUM_HEMI_LIGHTS];vec3 getHemisphereLightIrradiance(const in HemisphereLight hemiLight,const in vec3 normal){float dotNL=dot(normal,hemiLight.direction);float hemiDiffuseWeight=0.5*dotNL+0.5;vec3 irradiance=mix(hemiLight.groundColor,hemiLight.skyColor,hemiDiffuseWeight);return irradiance;}\n#endif",
    lights_toon_fragment:
      "ToonMaterial material;material.diffuseColor=diffuseColor.rgb;",
    lights_toon_pars_fragment:
      "varying vec3 vViewPosition;struct ToonMaterial{vec3 diffuseColor;};void RE_Direct_Toon(const in IncidentLight directLight,const in GeometricContext geometry,const in ToonMaterial material,inout ReflectedLight reflectedLight){vec3 irradiance=getGradientIrradiance(geometry.normal,directLight.direction)*directLight.color;reflectedLight.directDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);}void RE_IndirectDiffuse_Toon(const in vec3 irradiance,const in GeometricContext geometry,const in ToonMaterial material,inout ReflectedLight reflectedLight){reflectedLight.indirectDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);}\n#define RE_Direct RE_Direct_Toon\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD(material)(0)",
    lights_phong_fragment:
      "BlinnPhongMaterial material;material.diffuseColor=diffuseColor.rgb;material.specularColor=specular;material.specularShininess=shininess;material.specularStrength=specularStrength;",
    lights_phong_pars_fragment:
      "varying vec3 vViewPosition;struct BlinnPhongMaterial{vec3 diffuseColor;vec3 specularColor;float specularShininess;float specularStrength;};void RE_Direct_BlinnPhong(const in IncidentLight directLight,const in GeometricContext geometry,const in BlinnPhongMaterial material,inout ReflectedLight reflectedLight){float dotNL=saturate(dot(geometry.normal,directLight.direction));vec3 irradiance=dotNL*directLight.color;reflectedLight.directDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);reflectedLight.directSpecular+=irradiance*BRDF_BlinnPhong(directLight.direction,geometry.viewDir,geometry.normal,material.specularColor,material.specularShininess)*material.specularStrength;}void RE_IndirectDiffuse_BlinnPhong(const in vec3 irradiance,const in GeometricContext geometry,const in BlinnPhongMaterial material,inout ReflectedLight reflectedLight){reflectedLight.indirectDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);}\n#define RE_Direct RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD(material)(0)",
    lights_physical_fragment:
      "PhysicalMaterial material;material.diffuseColor=diffuseColor.rgb*(1.0-metalnessFactor);vec3 dxy=max(abs(dFdx(geometryNormal)),abs(dFdy(geometryNormal)));float geometryRoughness=max(max(dxy.x,dxy.y),dxy.z);material.roughness=max(roughnessFactor,0.0525);material.roughness+=geometryRoughness;material.roughness=min(material.roughness,1.0);\n#ifdef IOR\n#ifdef SPECULAR\nfloat specularIntensityFactor=specularIntensity;vec3 specularTintFactor=specularTint;\n#ifdef USE_SPECULARINTENSITYMAP\nspecularIntensityFactor*=texture2D(specularIntensityMap,vUv).a;\n#endif\n#ifdef USE_SPECULARTINTMAP\nspecularTintFactor*=specularTintMapTexelToLinear(texture2D(specularTintMap,vUv)).rgb;\n#endif\nmaterial.specularF90=mix(specularIntensityFactor,1.0,metalnessFactor);\n#else\nfloat specularIntensityFactor=1.0;vec3 specularTintFactor=vec3(1.0);material.specularF90=1.0;\n#endif\nmaterial.specularColor=mix(min(pow2((ior-1.0)/(ior+1.0))*specularTintFactor,vec3(1.0))*specularIntensityFactor,diffuseColor.rgb,metalnessFactor);\n#else\nmaterial.specularColor=mix(vec3(0.04),diffuseColor.rgb,metalnessFactor);material.specularF90=1.0;\n#endif\n#ifdef USE_CLEARCOAT\nmaterial.clearcoat=clearcoat;material.clearcoatRoughness=clearcoatRoughness;material.clearcoatF0=vec3(0.04);material.clearcoatF90=1.0;\n#ifdef USE_CLEARCOATMAP\nmaterial.clearcoat*=texture2D(clearcoatMap,vUv).x;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\nmaterial.clearcoatRoughness*=texture2D(clearcoatRoughnessMap,vUv).y;\n#endif\nmaterial.clearcoat=saturate(material.clearcoat);material.clearcoatRoughness=max(material.clearcoatRoughness,0.0525);material.clearcoatRoughness+=geometryRoughness;material.clearcoatRoughness=min(material.clearcoatRoughness,1.0);\n#endif\n#ifdef USE_SHEEN\nmaterial.sheenTint=sheenTint;material.sheenRoughness=clamp(sheenRoughness,0.07,1.0);\n#endif",
    lights_physical_pars_fragment:
      "struct PhysicalMaterial{vec3 diffuseColor;float roughness;vec3 specularColor;float specularF90;\n#ifdef USE_CLEARCOAT\nfloat clearcoat;float clearcoatRoughness;vec3 clearcoatF0;float clearcoatF90;\n#endif\n#ifdef USE_SHEEN\nvec3 sheenTint;float sheenRoughness;\n#endif\n};vec3 clearcoatSpecular=vec3(0.0);vec2 DFGApprox(const in vec3 normal,const in vec3 viewDir,const in float roughness){float dotNV=saturate(dot(normal,viewDir));const vec4 c0=vec4(-1,-0.0275,-0.572,0.022);const vec4 c1=vec4(1,0.0425,1.04,-0.04);vec4 r=roughness*c0+c1;float a004=min(r.x*r.x,exp2(-9.28*dotNV))*r.x+r.y;vec2 fab=vec2(-1.04,1.04)*a004+r.zw;return fab;}vec3 EnvironmentBRDF(const in vec3 normal,const in vec3 viewDir,const in vec3 specularColor,const in float specularF90,const in float roughness){vec2 fab=DFGApprox(normal,viewDir,roughness);return specularColor*fab.x+specularF90*fab.y;}void computeMultiscattering(const in vec3 normal,const in vec3 viewDir,const in vec3 specularColor,const in float specularF90,const in float roughness,inout vec3 singleScatter,inout vec3 multiScatter){vec2 fab=DFGApprox(normal,viewDir,roughness);vec3 FssEss=specularColor*fab.x+specularF90*fab.y;float Ess=fab.x+fab.y;float Ems=1.0-Ess;vec3 Favg=specularColor+(1.0-specularColor)*0.047619;vec3 Fms=FssEss*Favg/(1.0-Ems*Favg);singleScatter+=FssEss;multiScatter+=Fms*Ems;}\n#if NUM_RECT_AREA_LIGHTS>0\nvoid RE_Direct_RectArea_Physical(const in RectAreaLight rectAreaLight,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){vec3 normal=geometry.normal;vec3 viewDir=geometry.viewDir;vec3 position=geometry.position;vec3 lightPos=rectAreaLight.position;vec3 halfWidth=rectAreaLight.halfWidth;vec3 halfHeight=rectAreaLight.halfHeight;vec3 lightColor=rectAreaLight.color;float roughness=material.roughness;vec3 rectCoords[4];rectCoords[0]=lightPos+halfWidth-halfHeight;rectCoords[1]=lightPos-halfWidth-halfHeight;rectCoords[2]=lightPos-halfWidth+halfHeight;rectCoords[3]=lightPos+halfWidth+halfHeight;vec2 uv=LTC_Uv(normal,viewDir,roughness);vec4 t1=texture2D(ltc_1,uv);vec4 t2=texture2D(ltc_2,uv);mat3 mInv=mat3(vec3(t1.x,0,t1.y),vec3(0,1,0),vec3(t1.z,0,t1.w));vec3 fresnel=(material.specularColor*t2.x+(vec3(1.0)-material.specularColor)*t2.y);reflectedLight.directSpecular+=lightColor*fresnel*LTC_Evaluate(normal,viewDir,position,mInv,rectCoords);reflectedLight.directDiffuse+=lightColor*material.diffuseColor*LTC_Evaluate(normal,viewDir,position,mat3(1.0),rectCoords);}\n#endif\nvoid RE_Direct_Physical(const in IncidentLight directLight,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){float dotNL=saturate(dot(geometry.normal,directLight.direction));vec3 irradiance=dotNL*directLight.color;\n#ifdef USE_CLEARCOAT\nfloat dotNLcc=saturate(dot(geometry.clearcoatNormal,directLight.direction));vec3 ccIrradiance=dotNLcc*directLight.color;clearcoatSpecular+=ccIrradiance*BRDF_GGX(directLight.direction,geometry.viewDir,geometry.clearcoatNormal,material.clearcoatF0,material.clearcoatF90,material.clearcoatRoughness);\n#endif\n#ifdef USE_SHEEN\nreflectedLight.directSpecular+=irradiance*BRDF_Sheen(directLight.direction,geometry.viewDir,geometry.normal,material.sheenTint,material.sheenRoughness);\n#endif\nreflectedLight.directSpecular+=irradiance*BRDF_GGX(directLight.direction,geometry.viewDir,geometry.normal,material.specularColor,material.specularF90,material.roughness);reflectedLight.directDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);}void RE_IndirectDiffuse_Physical(const in vec3 irradiance,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){reflectedLight.indirectDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);}void RE_IndirectSpecular_Physical(const in vec3 radiance,const in vec3 irradiance,const in vec3 clearcoatRadiance,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){\n#ifdef USE_CLEARCOAT\nclearcoatSpecular+=clearcoatRadiance*EnvironmentBRDF(geometry.clearcoatNormal,geometry.viewDir,material.clearcoatF0,material.clearcoatF90,material.clearcoatRoughness);\n#endif\nvec3 singleScattering=vec3(0.0);vec3 multiScattering=vec3(0.0);vec3 cosineWeightedIrradiance=irradiance*RECIPROCAL_PI;computeMultiscattering(geometry.normal,geometry.viewDir,material.specularColor,material.specularF90,material.roughness,singleScattering,multiScattering);vec3 diffuse=material.diffuseColor*(1.0-(singleScattering+multiScattering));reflectedLight.indirectSpecular+=radiance*singleScattering;reflectedLight.indirectSpecular+=multiScattering*cosineWeightedIrradiance;reflectedLight.indirectDiffuse+=diffuse*cosineWeightedIrradiance;}\n#define RE_Direct RE_Direct_Physical\n#define RE_Direct_RectArea RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion(const in float dotNV,const in float ambientOcclusion,const in float roughness){return saturate(pow(dotNV+ambientOcclusion,exp2(-16.0*roughness-1.0))-1.0+ambientOcclusion);}",
    lights_fragment_begin:
      "GeometricContext geometry;geometry.position=-vViewPosition;geometry.normal=normal;geometry.viewDir=(isOrthographic)?vec3(0,0,1):normalize(vViewPosition);\n#ifdef USE_CLEARCOAT\ngeometry.clearcoatNormal=clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if (NUM_POINT_LIGHTS>0)&&defined(RE_Direct)\nPointLight pointLight;\n#if defined(USE_SHADOWMAP)&&NUM_POINT_LIGHT_SHADOWS>0\nPointLightShadow pointLightShadow;\n#endif\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_POINT_LIGHTS;i++){pointLight=pointLights[i];getPointLightInfo(pointLight,geometry,directLight);\n#if defined(USE_SHADOWMAP)&&(UNROLLED_LOOP_INDEX<NUM_POINT_LIGHT_SHADOWS)\npointLightShadow=pointLightShadows[i];directLight.color*=all(bvec2(directLight.visible,receiveShadow))?getPointShadow(pointShadowMap[i],pointLightShadow.shadowMapSize,pointLightShadow.shadowBias,pointLightShadow.shadowRadius,vPointShadowCoord[i],pointLightShadow.shadowCameraNear,pointLightShadow.shadowCameraFar):1.0;\n#endif\nRE_Direct(directLight,geometry,material,reflectedLight);}\n#pragma unroll_loop_end\n#endif\n#if (NUM_SPOT_LIGHTS>0)&&defined(RE_Direct)\nSpotLight spotLight;\n#if defined(USE_SHADOWMAP)&&NUM_SPOT_LIGHT_SHADOWS>0\nSpotLightShadow spotLightShadow;\n#endif\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_SPOT_LIGHTS;i++){spotLight=spotLights[i];getSpotLightInfo(spotLight,geometry,directLight);\n#if defined(USE_SHADOWMAP)&&(UNROLLED_LOOP_INDEX<NUM_SPOT_LIGHT_SHADOWS)\nspotLightShadow=spotLightShadows[i];directLight.color*=all(bvec2(directLight.visible,receiveShadow))?getShadow(spotShadowMap[i],spotLightShadow.shadowMapSize,spotLightShadow.shadowBias,spotLightShadow.shadowRadius,vSpotShadowCoord[i]):1.0;\n#endif\nRE_Direct(directLight,geometry,material,reflectedLight);}\n#pragma unroll_loop_end\n#endif\n#if (NUM_DIR_LIGHTS>0)&&defined(RE_Direct)\nDirectionalLight directionalLight;\n#if defined(USE_SHADOWMAP)&&NUM_DIR_LIGHT_SHADOWS>0\nDirectionalLightShadow directionalLightShadow;\n#endif\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_DIR_LIGHTS;i++){directionalLight=directionalLights[i];getDirectionalLightInfo(directionalLight,geometry,directLight);\n#if defined(USE_SHADOWMAP)&&(UNROLLED_LOOP_INDEX<NUM_DIR_LIGHT_SHADOWS)\ndirectionalLightShadow=directionalLightShadows[i];directLight.color*=all(bvec2(directLight.visible,receiveShadow))?getShadow(directionalShadowMap[i],directionalLightShadow.shadowMapSize,directionalLightShadow.shadowBias,directionalLightShadow.shadowRadius,vDirectionalShadowCoord[i]):1.0;\n#endif\nRE_Direct(directLight,geometry,material,reflectedLight);}\n#pragma unroll_loop_end\n#endif\n#if (NUM_RECT_AREA_LIGHTS>0)&&defined(RE_Direct_RectArea)\nRectAreaLight rectAreaLight;\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_RECT_AREA_LIGHTS;i++){rectAreaLight=rectAreaLights[i];RE_Direct_RectArea(rectAreaLight,geometry,material,reflectedLight);}\n#pragma unroll_loop_end\n#endif\n#if defined(RE_IndirectDiffuse)\nvec3 iblIrradiance=vec3(0.0);vec3 irradiance=getAmbientLightIrradiance(ambientLightColor);irradiance+=getLightProbeIrradiance(lightProbe,geometry.normal);\n#if (NUM_HEMI_LIGHTS>0)\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_HEMI_LIGHTS;i++){irradiance+=getHemisphereLightIrradiance(hemisphereLights[i],geometry.normal);}\n#pragma unroll_loop_end\n#endif\n#endif\n#if defined(RE_IndirectSpecular)\nvec3 radiance=vec3(0.0);vec3 clearcoatRadiance=vec3(0.0);\n#endif",
    lights_fragment_maps:
      "#if defined(RE_IndirectDiffuse)\n#ifdef USE_LIGHTMAP\nvec4 lightMapTexel=texture2D(lightMap,vUv2);vec3 lightMapIrradiance=lightMapTexelToLinear(lightMapTexel).rgb*lightMapIntensity;\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nlightMapIrradiance*=PI;\n#endif\nirradiance+=lightMapIrradiance;\n#endif\n#if defined(USE_ENVMAP)&&defined(STANDARD)&&defined(ENVMAP_TYPE_CUBE_UV)\niblIrradiance+=getIBLIrradiance(geometry.normal);\n#endif\n#endif\n#if defined(USE_ENVMAP)&&defined(RE_IndirectSpecular)\nradiance+=getIBLRadiance(geometry.viewDir,geometry.normal,material.roughness);\n#ifdef USE_CLEARCOAT\nclearcoatRadiance+=getIBLRadiance(geometry.viewDir,geometry.clearcoatNormal,material.clearcoatRoughness);\n#endif\n#endif",
    lights_fragment_end:
      "#if defined(RE_IndirectDiffuse)\nRE_IndirectDiffuse(irradiance,geometry,material,reflectedLight);\n#endif\n#if defined(RE_IndirectSpecular)\nRE_IndirectSpecular(radiance,iblIrradiance,clearcoatRadiance,geometry,material,reflectedLight);\n#endif",
    logdepthbuf_fragment:
      "#if defined(USE_LOGDEPTHBUF)&&defined(USE_LOGDEPTHBUF_EXT)\ngl_FragDepthEXT=vIsPerspective==0.0?gl_FragCoord.z:log2(vFragDepth)*logDepthBufFC*0.5;\n#endif",
    logdepthbuf_pars_fragment:
      "#if defined(USE_LOGDEPTHBUF)&&defined(USE_LOGDEPTHBUF_EXT)\nuniform float logDepthBufFC;varying float vFragDepth;varying float vIsPerspective;\n#endif",
    logdepthbuf_pars_vertex:
      "#ifdef USE_LOGDEPTHBUF\n#ifdef USE_LOGDEPTHBUF_EXT\nvarying float vFragDepth;varying float vIsPerspective;\n#else\nuniform float logDepthBufFC;\n#endif\n#endif",
    logdepthbuf_vertex:
      "#ifdef USE_LOGDEPTHBUF\n#ifdef USE_LOGDEPTHBUF_EXT\nvFragDepth=1.0+gl_Position.w;vIsPerspective=float(isPerspectiveMatrix(projectionMatrix));\n#else\nif(isPerspectiveMatrix(projectionMatrix)){gl_Position.z=log2(max(EPSILON,gl_Position.w+1.0))*logDepthBufFC-1.0;gl_Position.z*=gl_Position.w;}\n#endif\n#endif",
    map_fragment:
      "#ifdef USE_MAP\nvec4 texelColor=texture2D(map,vUv);texelColor=mapTexelToLinear(texelColor);diffuseColor*=texelColor;\n#endif",
    map_pars_fragment: "#ifdef USE_MAP\nuniform sampler2D map;\n#endif",
    map_particle_fragment:
      "#if defined(USE_MAP)||defined(USE_ALPHAMAP)\nvec2 uv=(uvTransform*vec3(gl_PointCoord.x,1.0-gl_PointCoord.y,1)).xy;\n#endif\n#ifdef USE_MAP\nvec4 mapTexel=texture2D(map,uv);diffuseColor*=mapTexelToLinear(mapTexel);\n#endif\n#ifdef USE_ALPHAMAP\ndiffuseColor.a*=texture2D(alphaMap,uv).g;\n#endif",
    map_particle_pars_fragment:
      "#if defined(USE_MAP)||defined(USE_ALPHAMAP)\nuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\nuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\nuniform sampler2D alphaMap;\n#endif",
    metalnessmap_fragment:
      "float metalnessFactor=metalness;\n#ifdef USE_METALNESSMAP\nvec4 texelMetalness=texture2D(metalnessMap,vUv);metalnessFactor*=texelMetalness.b;\n#endif",
    metalnessmap_pars_fragment:
      "#ifdef USE_METALNESSMAP\nuniform sampler2D metalnessMap;\n#endif",
    morphnormal_vertex:
      "#ifdef USE_MORPHNORMALS\nobjectNormal*=morphTargetBaseInfluence;\n#ifdef MORPHTARGETS_TEXTURE\nfor(int i=0;i<MORPHTARGETS_COUNT;i++){if(morphTargetInfluences[i]>0.0)objectNormal+=getMorph(gl_VertexID,i,1,2)*morphTargetInfluences[i];}\n#else\nobjectNormal+=morphNormal0*morphTargetInfluences[0];objectNormal+=morphNormal1*morphTargetInfluences[1];objectNormal+=morphNormal2*morphTargetInfluences[2];objectNormal+=morphNormal3*morphTargetInfluences[3];\n#endif\n#endif",
    morphtarget_pars_vertex:
      "#ifdef USE_MORPHTARGETS\nuniform float morphTargetBaseInfluence;\n#ifdef MORPHTARGETS_TEXTURE\nuniform float morphTargetInfluences[MORPHTARGETS_COUNT];uniform sampler2DArray morphTargetsTexture;uniform vec2 morphTargetsTextureSize;vec3 getMorph(const in int vertexIndex,const in int morphTargetIndex,const in int offset,const in int stride){float texelIndex=float(vertexIndex*stride+offset);float y=floor(texelIndex/morphTargetsTextureSize.x);float x=texelIndex-y*morphTargetsTextureSize.x;vec3 morphUV=vec3((x+0.5)/morphTargetsTextureSize.x,y/morphTargetsTextureSize.y,morphTargetIndex);return texture(morphTargetsTexture,morphUV).xyz;}\n#else\n#ifndef USE_MORPHNORMALS\nuniform float morphTargetInfluences[8];\n#else\nuniform float morphTargetInfluences[4];\n#endif\n#endif\n#endif",
    morphtarget_vertex:
      "#ifdef USE_MORPHTARGETS\ntransformed*=morphTargetBaseInfluence;\n#ifdef MORPHTARGETS_TEXTURE\nfor(int i=0;i<MORPHTARGETS_COUNT;i++){\n#ifndef USE_MORPHNORMALS\nif(morphTargetInfluences[i]>0.0)transformed+=getMorph(gl_VertexID,i,0,1)*morphTargetInfluences[i];\n#else\nif(morphTargetInfluences[i]>0.0)transformed+=getMorph(gl_VertexID,i,0,2)*morphTargetInfluences[i];\n#endif\n}\n#else\ntransformed+=morphTarget0*morphTargetInfluences[0];transformed+=morphTarget1*morphTargetInfluences[1];transformed+=morphTarget2*morphTargetInfluences[2];transformed+=morphTarget3*morphTargetInfluences[3];\n#ifndef USE_MORPHNORMALS\ntransformed+=morphTarget4*morphTargetInfluences[4];transformed+=morphTarget5*morphTargetInfluences[5];transformed+=morphTarget6*morphTargetInfluences[6];transformed+=morphTarget7*morphTargetInfluences[7];\n#endif\n#endif\n#endif",
    normal_fragment_begin:
      "float faceDirection=gl_FrontFacing?1.0:-1.0;\n#ifdef FLAT_SHADED\nvec3 fdx=vec3(dFdx(vViewPosition.x),dFdx(vViewPosition.y),dFdx(vViewPosition.z));vec3 fdy=vec3(dFdy(vViewPosition.x),dFdy(vViewPosition.y),dFdy(vViewPosition.z));vec3 normal=normalize(cross(fdx,fdy));\n#else\nvec3 normal=normalize(vNormal);\n#ifdef DOUBLE_SIDED\nnormal=normal*faceDirection;\n#endif\n#ifdef USE_TANGENT\nvec3 tangent=normalize(vTangent);vec3 bitangent=normalize(vBitangent);\n#ifdef DOUBLE_SIDED\ntangent=tangent*faceDirection;bitangent=bitangent*faceDirection;\n#endif\n#if defined(TANGENTSPACE_NORMALMAP)||defined(USE_CLEARCOAT_NORMALMAP)\nmat3 vTBN=mat3(tangent,bitangent,normal);\n#endif\n#endif\n#endif\nvec3 geometryNormal=normal;",
    normal_fragment_maps:
      "#ifdef OBJECTSPACE_NORMALMAP\nnormal=texture2D(normalMap,vUv).xyz*2.0-1.0;\n#ifdef FLIP_SIDED\nnormal=-normal;\n#endif\n#ifdef DOUBLE_SIDED\nnormal=normal*faceDirection;\n#endif\nnormal=normalize(normalMatrix*normal);\n#elif defined(TANGENTSPACE_NORMALMAP)\nvec3 mapN=texture2D(normalMap,vUv).xyz*2.0-1.0;mapN.xy*=normalScale;\n#ifdef USE_TANGENT\nnormal=normalize(vTBN*mapN);\n#else\nnormal=perturbNormal2Arb(-vViewPosition,normal,mapN,faceDirection);\n#endif\n#elif defined(USE_BUMPMAP)\nnormal=perturbNormalArb(-vViewPosition,normal,dHdxy_fwd(),faceDirection);\n#endif",
    normal_pars_fragment:
      "#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#ifdef USE_TANGENT\nvarying vec3 vTangent;varying vec3 vBitangent;\n#endif\n#endif",
    normal_pars_vertex:
      "#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#ifdef USE_TANGENT\nvarying vec3 vTangent;varying vec3 vBitangent;\n#endif\n#endif",
    normal_vertex:
      "#ifndef FLAT_SHADED\nvNormal=normalize(transformedNormal);\n#ifdef USE_TANGENT\nvTangent=normalize(transformedTangent);vBitangent=normalize(cross(vNormal,vTangent)*tangent.w);\n#endif\n#endif",
    normalmap_pars_fragment:
      "#ifdef USE_NORMALMAP\nuniform sampler2D normalMap;uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nuniform mat3 normalMatrix;\n#endif\n#if !defined(USE_TANGENT)&&(defined(TANGENTSPACE_NORMALMAP)||defined(USE_CLEARCOAT_NORMALMAP))\nvec3 perturbNormal2Arb(vec3 eye_pos,vec3 surf_norm,vec3 mapN,float faceDirection){vec3 q0=vec3(dFdx(eye_pos.x),dFdx(eye_pos.y),dFdx(eye_pos.z));vec3 q1=vec3(dFdy(eye_pos.x),dFdy(eye_pos.y),dFdy(eye_pos.z));vec2 st0=dFdx(vUv.st);vec2 st1=dFdy(vUv.st);vec3 N=surf_norm;vec3 q1perp=cross(q1,N);vec3 q0perp=cross(N,q0);vec3 T=q1perp*st0.x+q0perp*st1.x;vec3 B=q1perp*st0.y+q0perp*st1.y;float det=max(dot(T,T),dot(B,B));float scale=(det==0.0)?0.0:faceDirection*inversesqrt(det);return normalize(T*(mapN.x*scale)+B*(mapN.y*scale)+N*mapN.z);}\n#endif",
    clearcoat_normal_fragment_begin:
      "#ifdef USE_CLEARCOAT\nvec3 clearcoatNormal=geometryNormal;\n#endif",
    clearcoat_normal_fragment_maps:
      "#ifdef USE_CLEARCOAT_NORMALMAP\nvec3 clearcoatMapN=texture2D(clearcoatNormalMap,vUv).xyz*2.0-1.0;clearcoatMapN.xy*=clearcoatNormalScale;\n#ifdef USE_TANGENT\nclearcoatNormal=normalize(vTBN*clearcoatMapN);\n#else\nclearcoatNormal=perturbNormal2Arb(-vViewPosition,clearcoatNormal,clearcoatMapN,faceDirection);\n#endif\n#endif",
    clearcoat_pars_fragment:
      "#ifdef USE_CLEARCOATMAP\nuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\nuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\nuniform sampler2D clearcoatNormalMap;uniform vec2 clearcoatNormalScale;\n#endif",
    output_fragment:
      "#ifdef OPAQUE\ndiffuseColor.a=1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a*=transmissionAlpha+0.1;\n#endif\ngl_FragColor=vec4(outgoingLight,diffuseColor.a);",
    packing:
      "vec3 packNormalToRGB(const in vec3 normal){return normalize(normal)*0.5+0.5;}vec3 unpackRGBToNormal(const in vec3 rgb){return 2.0*rgb.xyz-1.0;}const float PackUpscale=256./255.;const float UnpackDownscale=255./256.;const vec3 PackFactors=vec3(256.*256.*256.,256.*256.,256.);const vec4 UnpackFactors=UnpackDownscale/vec4(PackFactors,1.);const float ShiftRight8=1./256.;vec4 packDepthToRGBA(const in float v){vec4 r=vec4(fract(v*PackFactors),v);r.yzw-=r.xyz*ShiftRight8;return r*PackUpscale;}float unpackRGBAToDepth(const in vec4 v){return dot(v,UnpackFactors);}vec4 pack2HalfToRGBA(vec2 v){vec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));return vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);}vec2 unpackRGBATo2Half(vec4 v){return vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));}float viewZToOrthographicDepth(const in float viewZ,const in float near,const in float far){return(viewZ+near)/(near-far);}float orthographicDepthToViewZ(const in float linearClipZ,const in float near,const in float far){return linearClipZ*(near-far)-near;}float viewZToPerspectiveDepth(const in float viewZ,const in float near,const in float far){return((near+viewZ)*far)/((far-near)*viewZ);}float perspectiveDepthToViewZ(const in float invClipZ,const in float near,const in float far){return(near*far)/((far-near)*invClipZ-far);}",
    premultiplied_alpha_fragment:
      "#ifdef PREMULTIPLIED_ALPHA\ngl_FragColor.rgb*=gl_FragColor.a;\n#endif",
    project_vertex:
      "vec4 mvPosition=vec4(transformed,1.0);\n#ifdef USE_INSTANCING\nmvPosition=instanceMatrix*mvPosition;\n#endif\nmvPosition=modelViewMatrix*mvPosition;gl_Position=projectionMatrix*mvPosition;",
    dithering_fragment:
      "#ifdef DITHERING\ngl_FragColor.rgb=dithering(gl_FragColor.rgb);\n#endif",
    dithering_pars_fragment:
      "#ifdef DITHERING\nvec3 dithering(vec3 color){float grid_position=rand(gl_FragCoord.xy);vec3 dither_shift_RGB=vec3(0.25/255.0,-0.25/255.0,0.25/255.0);dither_shift_RGB=mix(2.0*dither_shift_RGB,-2.0*dither_shift_RGB,grid_position);return color+dither_shift_RGB;}\n#endif",
    roughnessmap_fragment:
      "float roughnessFactor=roughness;\n#ifdef USE_ROUGHNESSMAP\nvec4 texelRoughness=texture2D(roughnessMap,vUv);roughnessFactor*=texelRoughness.g;\n#endif",
    roughnessmap_pars_fragment:
      "#ifdef USE_ROUGHNESSMAP\nuniform sampler2D roughnessMap;\n#endif",
    shadowmap_pars_fragment:
      "#ifdef USE_SHADOWMAP\n#if NUM_DIR_LIGHT_SHADOWS>0\nuniform sampler2D directionalShadowMap[NUM_DIR_LIGHT_SHADOWS];varying vec4 vDirectionalShadowCoord[NUM_DIR_LIGHT_SHADOWS];struct DirectionalLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;};uniform DirectionalLightShadow directionalLightShadows[NUM_DIR_LIGHT_SHADOWS];\n#endif\n#if NUM_SPOT_LIGHT_SHADOWS>0\nuniform sampler2D spotShadowMap[NUM_SPOT_LIGHT_SHADOWS];varying vec4 vSpotShadowCoord[NUM_SPOT_LIGHT_SHADOWS];struct SpotLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;};uniform SpotLightShadow spotLightShadows[NUM_SPOT_LIGHT_SHADOWS];\n#endif\n#if NUM_POINT_LIGHT_SHADOWS>0\nuniform sampler2D pointShadowMap[NUM_POINT_LIGHT_SHADOWS];varying vec4 vPointShadowCoord[NUM_POINT_LIGHT_SHADOWS];struct PointLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;float shadowCameraNear;float shadowCameraFar;};uniform PointLightShadow pointLightShadows[NUM_POINT_LIGHT_SHADOWS];\n#endif\nfloat texture2DCompare(sampler2D depths,vec2 uv,float compare){return step(compare,unpackRGBAToDepth(texture2D(depths,uv)));}vec2 texture2DDistribution(sampler2D shadow,vec2 uv){return unpackRGBATo2Half(texture2D(shadow,uv));}float VSMShadow(sampler2D shadow,vec2 uv,float compare){float occlusion=1.0;vec2 distribution=texture2DDistribution(shadow,uv);float hard_shadow=step(compare,distribution.x);if(hard_shadow!=1.0){float distance=compare-distribution.x;float variance=max(0.00000,distribution.y*distribution.y);float softness_probability=variance/(variance+distance*distance);softness_probability=clamp((softness_probability-0.3)/(0.95-0.3),0.0,1.0);occlusion=clamp(max(hard_shadow,softness_probability),0.0,1.0);}return occlusion;}float getShadow(sampler2D shadowMap,vec2 shadowMapSize,float shadowBias,float shadowRadius,vec4 shadowCoord){float shadow=1.0;shadowCoord.xyz/=shadowCoord.w;shadowCoord.z+=shadowBias;bvec4 inFrustumVec=bvec4(shadowCoord.x>=0.0,shadowCoord.x<=1.0,shadowCoord.y>=0.0,shadowCoord.y<=1.0);bool inFrustum=all(inFrustumVec);bvec2 frustumTestVec=bvec2(inFrustum,shadowCoord.z<=1.0);bool frustumTest=all(frustumTestVec);if(frustumTest){\n#if defined(SHADOWMAP_TYPE_PCF)\nvec2 texelSize=vec2(1.0)/shadowMapSize;float dx0=-texelSize.x*shadowRadius;float dy0=-texelSize.y*shadowRadius;float dx1=+texelSize.x*shadowRadius;float dy1=+texelSize.y*shadowRadius;float dx2=dx0/2.0;float dy2=dy0/2.0;float dx3=dx1/2.0;float dy3=dy1/2.0;shadow=(texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx0,dy0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(0.0,dy0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx1,dy0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx2,dy2),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(0.0,dy2),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx3,dy2),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx0,0.0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx2,0.0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy,shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx3,0.0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx1,0.0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx2,dy3),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(0.0,dy3),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx3,dy3),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx0,dy1),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(0.0,dy1),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx1,dy1),shadowCoord.z))*(1.0/17.0);\n#elif defined(SHADOWMAP_TYPE_PCF_SOFT)\nvec2 texelSize=vec2(1.0)/shadowMapSize;float dx=texelSize.x;float dy=texelSize.y;vec2 uv=shadowCoord.xy;vec2 f=fract(uv*shadowMapSize+0.5);uv-=f*texelSize;shadow=(texture2DCompare(shadowMap,uv,shadowCoord.z)+texture2DCompare(shadowMap,uv+vec2(dx,0.0),shadowCoord.z)+texture2DCompare(shadowMap,uv+vec2(0.0,dy),shadowCoord.z)+texture2DCompare(shadowMap,uv+texelSize,shadowCoord.z)+mix(texture2DCompare(shadowMap,uv+vec2(-dx,0.0),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(2.0*dx,0.0),shadowCoord.z),f.x)+mix(texture2DCompare(shadowMap,uv+vec2(-dx,dy),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(2.0*dx,dy),shadowCoord.z),f.x)+mix(texture2DCompare(shadowMap,uv+vec2(0.0,-dy),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(0.0,2.0*dy),shadowCoord.z),f.y)+mix(texture2DCompare(shadowMap,uv+vec2(dx,-dy),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(dx,2.0*dy),shadowCoord.z),f.y)+mix(mix(texture2DCompare(shadowMap,uv+vec2(-dx,-dy),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(2.0*dx,-dy),shadowCoord.z),f.x),mix(texture2DCompare(shadowMap,uv+vec2(-dx,2.0*dy),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(2.0*dx,2.0*dy),shadowCoord.z),f.x),f.y))*(1.0/9.0);\n#elif defined(SHADOWMAP_TYPE_VSM)\nshadow=VSMShadow(shadowMap,shadowCoord.xy,shadowCoord.z);\n#else\nshadow=texture2DCompare(shadowMap,shadowCoord.xy,shadowCoord.z);\n#endif\n}return shadow;}vec2 cubeToUV(vec3 v,float texelSizeY){vec3 absV=abs(v);float scaleToCube=1.0/max(absV.x,max(absV.y,absV.z));absV*=scaleToCube;v*=scaleToCube*(1.0-2.0*texelSizeY);vec2 planar=v.xy;float almostATexel=1.5*texelSizeY;float almostOne=1.0-almostATexel;if(absV.z>=almostOne){if(v.z>0.0)planar.x=4.0-v.x;}else if(absV.x>=almostOne){float signX=sign(v.x);planar.x=v.z*signX+2.0*signX;}else if(absV.y>=almostOne){float signY=sign(v.y);planar.x=v.x+2.0*signY+2.0;planar.y=v.z*signY-2.0;}return vec2(0.125,0.25)*planar+vec2(0.375,0.75);}float getPointShadow(sampler2D shadowMap,vec2 shadowMapSize,float shadowBias,float shadowRadius,vec4 shadowCoord,float shadowCameraNear,float shadowCameraFar){vec2 texelSize=vec2(1.0)/(shadowMapSize*vec2(4.0,2.0));vec3 lightToPosition=shadowCoord.xyz;float dp=(length(lightToPosition)-shadowCameraNear)/(shadowCameraFar-shadowCameraNear);dp+=shadowBias;vec3 bd3D=normalize(lightToPosition);\n#if defined(SHADOWMAP_TYPE_PCF)||defined(SHADOWMAP_TYPE_PCF_SOFT)||defined(SHADOWMAP_TYPE_VSM)\nvec2 offset=vec2(-1,1)*shadowRadius*texelSize.y;return(texture2DCompare(shadowMap,cubeToUV(bd3D+offset.xyy,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.yyy,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.xyx,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.yyx,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.xxy,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.yxy,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.xxx,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.yxx,texelSize.y),dp))*(1.0/9.0);\n#else\nreturn texture2DCompare(shadowMap,cubeToUV(bd3D,texelSize.y),dp);\n#endif\n}\n#endif",
    shadowmap_pars_vertex:
      "#ifdef USE_SHADOWMAP\n#if NUM_DIR_LIGHT_SHADOWS>0\nuniform mat4 directionalShadowMatrix[NUM_DIR_LIGHT_SHADOWS];varying vec4 vDirectionalShadowCoord[NUM_DIR_LIGHT_SHADOWS];struct DirectionalLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;};uniform DirectionalLightShadow directionalLightShadows[NUM_DIR_LIGHT_SHADOWS];\n#endif\n#if NUM_SPOT_LIGHT_SHADOWS>0\nuniform mat4 spotShadowMatrix[NUM_SPOT_LIGHT_SHADOWS];varying vec4 vSpotShadowCoord[NUM_SPOT_LIGHT_SHADOWS];struct SpotLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;};uniform SpotLightShadow spotLightShadows[NUM_SPOT_LIGHT_SHADOWS];\n#endif\n#if NUM_POINT_LIGHT_SHADOWS>0\nuniform mat4 pointShadowMatrix[NUM_POINT_LIGHT_SHADOWS];varying vec4 vPointShadowCoord[NUM_POINT_LIGHT_SHADOWS];struct PointLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;float shadowCameraNear;float shadowCameraFar;};uniform PointLightShadow pointLightShadows[NUM_POINT_LIGHT_SHADOWS];\n#endif\n#endif",
    shadowmap_vertex:
      "#ifdef USE_SHADOWMAP\n#if NUM_DIR_LIGHT_SHADOWS>0||NUM_SPOT_LIGHT_SHADOWS>0||NUM_POINT_LIGHT_SHADOWS>0\nvec3 shadowWorldNormal=inverseTransformDirection(transformedNormal,viewMatrix);vec4 shadowWorldPosition;\n#endif\n#if NUM_DIR_LIGHT_SHADOWS>0\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_DIR_LIGHT_SHADOWS;i++){shadowWorldPosition=worldPosition+vec4(shadowWorldNormal*directionalLightShadows[i].shadowNormalBias,0);vDirectionalShadowCoord[i]=directionalShadowMatrix[i]*shadowWorldPosition;}\n#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHT_SHADOWS>0\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_SPOT_LIGHT_SHADOWS;i++){shadowWorldPosition=worldPosition+vec4(shadowWorldNormal*spotLightShadows[i].shadowNormalBias,0);vSpotShadowCoord[i]=spotShadowMatrix[i]*shadowWorldPosition;}\n#pragma unroll_loop_end\n#endif\n#if NUM_POINT_LIGHT_SHADOWS>0\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_POINT_LIGHT_SHADOWS;i++){shadowWorldPosition=worldPosition+vec4(shadowWorldNormal*pointLightShadows[i].shadowNormalBias,0);vPointShadowCoord[i]=pointShadowMatrix[i]*shadowWorldPosition;}\n#pragma unroll_loop_end\n#endif\n#endif",
    shadowmask_pars_fragment:
      "float getShadowMask(){float shadow=1.0;\n#ifdef USE_SHADOWMAP\n#if NUM_DIR_LIGHT_SHADOWS>0\nDirectionalLightShadow directionalLight;\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_DIR_LIGHT_SHADOWS;i++){directionalLight=directionalLightShadows[i];shadow*=receiveShadow?getShadow(directionalShadowMap[i],directionalLight.shadowMapSize,directionalLight.shadowBias,directionalLight.shadowRadius,vDirectionalShadowCoord[i]):1.0;}\n#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHT_SHADOWS>0\nSpotLightShadow spotLight;\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_SPOT_LIGHT_SHADOWS;i++){spotLight=spotLightShadows[i];shadow*=receiveShadow?getShadow(spotShadowMap[i],spotLight.shadowMapSize,spotLight.shadowBias,spotLight.shadowRadius,vSpotShadowCoord[i]):1.0;}\n#pragma unroll_loop_end\n#endif\n#if NUM_POINT_LIGHT_SHADOWS>0\nPointLightShadow pointLight;\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_POINT_LIGHT_SHADOWS;i++){pointLight=pointLightShadows[i];shadow*=receiveShadow?getPointShadow(pointShadowMap[i],pointLight.shadowMapSize,pointLight.shadowBias,pointLight.shadowRadius,vPointShadowCoord[i],pointLight.shadowCameraNear,pointLight.shadowCameraFar):1.0;}\n#pragma unroll_loop_end\n#endif\n#endif\nreturn shadow;}",
    skinbase_vertex:
      "#ifdef USE_SKINNING\nmat4 boneMatX=getBoneMatrix(skinIndex.x);mat4 boneMatY=getBoneMatrix(skinIndex.y);mat4 boneMatZ=getBoneMatrix(skinIndex.z);mat4 boneMatW=getBoneMatrix(skinIndex.w);\n#endif",
    skinning_pars_vertex:
      "#ifdef USE_SKINNING\nuniform mat4 bindMatrix;uniform mat4 bindMatrixInverse;\n#ifdef BONE_TEXTURE\nuniform highp sampler2D boneTexture;uniform int boneTextureSize;mat4 getBoneMatrix(const in float i){float j=i*4.0;float x=mod(j,float(boneTextureSize));float y=floor(j/float(boneTextureSize));float dx=1.0/float(boneTextureSize);float dy=1.0/float(boneTextureSize);y=dy*(y+0.5);vec4 v1=texture2D(boneTexture,vec2(dx*(x+0.5),y));vec4 v2=texture2D(boneTexture,vec2(dx*(x+1.5),y));vec4 v3=texture2D(boneTexture,vec2(dx*(x+2.5),y));vec4 v4=texture2D(boneTexture,vec2(dx*(x+3.5),y));mat4 bone=mat4(v1,v2,v3,v4);return bone;}\n#else\nuniform mat4 boneMatrices[MAX_BONES];mat4 getBoneMatrix(const in float i){mat4 bone=boneMatrices[int(i)];return bone;}\n#endif\n#endif",
    skinning_vertex:
      "#ifdef USE_SKINNING\nvec4 skinVertex=bindMatrix*vec4(transformed,1.0);vec4 skinned=vec4(0.0);skinned+=boneMatX*skinVertex*skinWeight.x;skinned+=boneMatY*skinVertex*skinWeight.y;skinned+=boneMatZ*skinVertex*skinWeight.z;skinned+=boneMatW*skinVertex*skinWeight.w;transformed=(bindMatrixInverse*skinned).xyz;\n#endif",
    skinnormal_vertex:
      "#ifdef USE_SKINNING\nmat4 skinMatrix=mat4(0.0);skinMatrix+=skinWeight.x*boneMatX;skinMatrix+=skinWeight.y*boneMatY;skinMatrix+=skinWeight.z*boneMatZ;skinMatrix+=skinWeight.w*boneMatW;skinMatrix=bindMatrixInverse*skinMatrix*bindMatrix;objectNormal=vec4(skinMatrix*vec4(objectNormal,0.0)).xyz;\n#ifdef USE_TANGENT\nobjectTangent=vec4(skinMatrix*vec4(objectTangent,0.0)).xyz;\n#endif\n#endif",
    specularmap_fragment:
      "float specularStrength;\n#ifdef USE_SPECULARMAP\nvec4 texelSpecular=texture2D(specularMap,vUv);specularStrength=texelSpecular.r;\n#else\nspecularStrength=1.0;\n#endif",
    specularmap_pars_fragment:
      "#ifdef USE_SPECULARMAP\nuniform sampler2D specularMap;\n#endif",
    tonemapping_fragment:
      "#if defined(TONE_MAPPING)\ngl_FragColor.rgb=toneMapping(gl_FragColor.rgb);\n#endif",
    tonemapping_pars_fragment:
      "#ifndef saturate\n#define saturate(a)clamp(a,0.0,1.0)\n#endif\nuniform float toneMappingExposure;vec3 LinearToneMapping(vec3 color){return toneMappingExposure*color;}vec3 ReinhardToneMapping(vec3 color){color*=toneMappingExposure;return saturate(color/(vec3(1.0)+color));}vec3 OptimizedCineonToneMapping(vec3 color){color*=toneMappingExposure;color=max(vec3(0.0),color-0.004);return pow((color*(6.2*color+0.5))/(color*(6.2*color+1.7)+0.06),vec3(2.2));}vec3 RRTAndODTFit(vec3 v){vec3 a=v*(v+0.0245786)-0.000090537;vec3 b=v*(0.983729*v+0.4329510)+0.238081;return a/b;}vec3 ACESFilmicToneMapping(vec3 color){const mat3 ACESInputMat=mat3(vec3(0.59719,0.07600,0.02840),vec3(0.35458,0.90834,0.13383),vec3(0.04823,0.01566,0.83777));const mat3 ACESOutputMat=mat3(vec3(1.60475,-0.10208,-0.00327),vec3(-0.53108,1.10813,-0.07276),vec3(-0.07367,-0.00605,1.07602));color*=toneMappingExposure/0.6;color=ACESInputMat*color;color=RRTAndODTFit(color);color=ACESOutputMat*color;return saturate(color);}vec3 CustomToneMapping(vec3 color){return color;}",
    transmission_fragment:
      "#ifdef USE_TRANSMISSION\nfloat transmissionAlpha=1.0;float transmissionFactor=transmission;float thicknessFactor=thickness;\n#ifdef USE_TRANSMISSIONMAP\ntransmissionFactor*=texture2D(transmissionMap,vUv).r;\n#endif\n#ifdef USE_THICKNESSMAP\nthicknessFactor*=texture2D(thicknessMap,vUv).g;\n#endif\nvec3 pos=vWorldPosition;vec3 v=normalize(cameraPosition-pos);vec3 n=inverseTransformDirection(normal,viewMatrix);vec4 transmission=getIBLVolumeRefraction(n,v,roughnessFactor,material.diffuseColor,material.specularColor,material.specularF90,pos,modelMatrix,viewMatrix,projectionMatrix,ior,thicknessFactor,attenuationTint,attenuationDistance);totalDiffuse=mix(totalDiffuse,transmission.rgb,transmissionFactor);transmissionAlpha=mix(transmissionAlpha,transmission.a,transmissionFactor);\n#endif",
    transmission_pars_fragment:
      "#ifdef USE_TRANSMISSION\nuniform float transmission;uniform float thickness;uniform float attenuationDistance;uniform vec3 attenuationTint;\n#ifdef USE_TRANSMISSIONMAP\nuniform sampler2D transmissionMap;\n#endif\n#ifdef USE_THICKNESSMAP\nuniform sampler2D thicknessMap;\n#endif\nuniform vec2 transmissionSamplerSize;uniform sampler2D transmissionSamplerMap;uniform mat4 modelMatrix;uniform mat4 projectionMatrix;varying vec3 vWorldPosition;vec3 getVolumeTransmissionRay(vec3 n,vec3 v,float thickness,float ior,mat4 modelMatrix){vec3 refractionVector=refract(-v,normalize(n),1.0/ior);vec3 modelScale;modelScale.x=length(vec3(modelMatrix[0].xyz));modelScale.y=length(vec3(modelMatrix[1].xyz));modelScale.z=length(vec3(modelMatrix[2].xyz));return normalize(refractionVector)*thickness*modelScale;}float applyIorToRoughness(float roughness,float ior){return roughness*clamp(ior*2.0-2.0,0.0,1.0);}vec4 getTransmissionSample(vec2 fragCoord,float roughness,float ior){float framebufferLod=log2(transmissionSamplerSize.x)*applyIorToRoughness(roughness,ior);\n#ifdef TEXTURE_LOD_EXT\nreturn texture2DLodEXT(transmissionSamplerMap,fragCoord.xy,framebufferLod);\n#else\nreturn texture2D(transmissionSamplerMap,fragCoord.xy,framebufferLod);\n#endif\n}vec3 applyVolumeAttenuation(vec3 radiance,float transmissionDistance,vec3 attenuationColor,float attenuationDistance){if(attenuationDistance==0.0){return radiance;}else{vec3 attenuationCoefficient=-log(attenuationColor)/attenuationDistance;vec3 transmittance=exp(-attenuationCoefficient*transmissionDistance);return transmittance*radiance;}}vec4 getIBLVolumeRefraction(vec3 n,vec3 v,float roughness,vec3 diffuseColor,vec3 specularColor,float specularF90,vec3 position,mat4 modelMatrix,mat4 viewMatrix,mat4 projMatrix,float ior,float thickness,vec3 attenuationColor,float attenuationDistance){vec3 transmissionRay=getVolumeTransmissionRay(n,v,thickness,ior,modelMatrix);vec3 refractedRayExit=position+transmissionRay;vec4 ndcPos=projMatrix*viewMatrix*vec4(refractedRayExit,1.0);vec2 refractionCoords=ndcPos.xy/ndcPos.w;refractionCoords+=1.0;refractionCoords/=2.0;vec4 transmittedLight=getTransmissionSample(refractionCoords,roughness,ior);vec3 attenuatedColor=applyVolumeAttenuation(transmittedLight.rgb,length(transmissionRay),attenuationColor,attenuationDistance);vec3 F=EnvironmentBRDF(n,v,specularColor,specularF90,roughness);return vec4((1.0-F)*attenuatedColor*diffuseColor,transmittedLight.a);}\n#endif",
    uv_pars_fragment:
      "#if (defined(USE_UV)&&!defined(UVS_VERTEX_ONLY))\nvarying vec2 vUv;\n#endif",
    uv_pars_vertex:
      "#ifdef USE_UV\n#ifdef UVS_VERTEX_ONLY\nvec2 vUv;\n#else\nvarying vec2 vUv;\n#endif\nuniform mat3 uvTransform;\n#endif",
    uv_vertex: "#ifdef USE_UV\nvUv=(uvTransform*vec3(uv,1)).xy;\n#endif",
    uv2_pars_fragment:
      "#if defined(USE_LIGHTMAP)||defined(USE_AOMAP)\nvarying vec2 vUv2;\n#endif",
    uv2_pars_vertex:
      "#if defined(USE_LIGHTMAP)||defined(USE_AOMAP)\nattribute vec2 uv2;varying vec2 vUv2;uniform mat3 uv2Transform;\n#endif",
    uv2_vertex:
      "#if defined(USE_LIGHTMAP)||defined(USE_AOMAP)\nvUv2=(uv2Transform*vec3(uv2,1)).xy;\n#endif",
    worldpos_vertex:
      "#if defined(USE_ENVMAP)||defined(DISTANCE)||defined(USE_SHADOWMAP)||defined(USE_TRANSMISSION)\nvec4 worldPosition=vec4(transformed,1.0);\n#ifdef USE_INSTANCING\nworldPosition=instanceMatrix*worldPosition;\n#endif\nworldPosition=modelMatrix*worldPosition;\n#endif",
    background_vert:
      "varying vec2 vUv;uniform mat3 uvTransform;void main(){vUv=(uvTransform*vec3(uv,1)).xy;gl_Position=vec4(position.xy,1.0,1.0);}",
    background_frag:
      "uniform sampler2D t2D;varying vec2 vUv;void main(){vec4 texColor=texture2D(t2D,vUv);gl_FragColor=mapTexelToLinear(texColor);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n}",
    cube_vert:
      "varying vec3 vWorldDirection;\n#include <common>\nvoid main(){vWorldDirection=transformDirection(position,modelMatrix);\n#include <begin_vertex>\n#include <project_vertex>\ngl_Position.z=gl_Position.w;}",
    cube_frag:
      "#include <envmap_common_pars_fragment>\nuniform float opacity;varying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main(){vec3 vReflect=vWorldDirection;\n#include <envmap_fragment>\ngl_FragColor=envColor;gl_FragColor.a*=opacity;\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n}",
    depth_vert:
      "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;void main(){\n#include <uv_vertex>\n#include <skinbase_vertex>\n#ifdef USE_DISPLACEMENTMAP\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinnormal_vertex>\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvHighPrecisionZW=gl_Position.zw;}",
    depth_frag:
      "#if DEPTH_PACKING==3200\nuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;void main(){\n#include <clipping_planes_fragment>\nvec4 diffuseColor=vec4(1.0);\n#if DEPTH_PACKING==3200\ndiffuseColor.a=opacity;\n#endif\n#include <map_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <logdepthbuf_fragment>\nfloat fragCoordZ=0.5*vHighPrecisionZW[0]/vHighPrecisionZW[1]+0.5;\n#if DEPTH_PACKING==3200\ngl_FragColor=vec4(vec3(1.0-fragCoordZ),opacity);\n#elif DEPTH_PACKING==3201\ngl_FragColor=packDepthToRGBA(fragCoordZ);\n#endif\n}",
    distanceRGBA_vert:
      "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){\n#include <uv_vertex>\n#include <skinbase_vertex>\n#ifdef USE_DISPLACEMENTMAP\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinnormal_vertex>\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <worldpos_vertex>\n#include <clipping_planes_vertex>\nvWorldPosition=worldPosition.xyz;}",
    distanceRGBA_frag:
      "#define DISTANCE\nuniform vec3 referencePosition;uniform float nearDistance;uniform float farDistance;varying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\nvec4 diffuseColor=vec4(1.0);\n#include <map_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\nfloat dist=length(vWorldPosition-referencePosition);dist=(dist-nearDistance)/(farDistance-nearDistance);dist=saturate(dist);gl_FragColor=packDepthToRGBA(dist);}",
    equirect_vert:
      "varying vec3 vWorldDirection;\n#include <common>\nvoid main(){vWorldDirection=transformDirection(position,modelMatrix);\n#include <begin_vertex>\n#include <project_vertex>\n}",
    equirect_frag:
      "uniform sampler2D tEquirect;varying vec3 vWorldDirection;\n#include <common>\nvoid main(){vec3 direction=normalize(vWorldDirection);vec2 sampleUV=equirectUv(direction);vec4 texColor=texture2D(tEquirect,sampleUV);gl_FragColor=mapTexelToLinear(texColor);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n}",
    linedashed_vert:
      "uniform float scale;attribute float lineDistance;varying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){vLineDistance=scale*lineDistance;\n#include <color_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#include <fog_vertex>\n}",
    linedashed_frag:
      "uniform vec3 diffuse;uniform float opacity;uniform float dashSize;uniform float totalSize;varying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\nif(mod(vLineDistance,totalSize)>dashSize){discard;}vec3 outgoingLight=vec3(0.0);vec4 diffuseColor=vec4(diffuse,opacity);\n#include <logdepthbuf_fragment>\n#include <color_fragment>\noutgoingLight=diffuseColor.rgb;\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n}",
    meshbasic_vert:
      "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){\n#include <uv_vertex>\n#include <uv2_vertex>\n#include <color_vertex>\n#if defined(USE_ENVMAP)||defined(USE_SKINNING)\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#include <worldpos_vertex>\n#include <envmap_vertex>\n#include <fog_vertex>\n}",
    meshbasic_frag:
      "uniform vec3 diffuse;uniform float opacity;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\nvec4 diffuseColor=vec4(diffuse,opacity);\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <specularmap_fragment>\nReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));\n#ifdef USE_LIGHTMAP\nvec4 lightMapTexel=texture2D(lightMap,vUv2);reflectedLight.indirectDiffuse+=lightMapTexelToLinear(lightMapTexel).rgb*lightMapIntensity;\n#else\nreflectedLight.indirectDiffuse+=vec3(1.0);\n#endif\n#include <aomap_fragment>\nreflectedLight.indirectDiffuse*=diffuseColor.rgb;vec3 outgoingLight=reflectedLight.indirectDiffuse;\n#include <envmap_fragment>\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",
    meshlambert_vert:
      "#define LAMBERT\nvarying vec3 vLightFront;varying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\nvarying vec3 vLightBack;varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){\n#include <uv_vertex>\n#include <uv2_vertex>\n#include <color_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#include <worldpos_vertex>\n#include <envmap_vertex>\n#include <lights_lambert_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n}",
    meshlambert_frag:
      "uniform vec3 diffuse;uniform vec3 emissive;uniform float opacity;varying vec3 vLightFront;varying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\nvarying vec3 vLightBack;varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\nvec4 diffuseColor=vec4(diffuse,opacity);ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));vec3 totalEmissiveRadiance=emissive;\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <specularmap_fragment>\n#include <emissivemap_fragment>\n#ifdef DOUBLE_SIDED\nreflectedLight.indirectDiffuse+=(gl_FrontFacing)?vIndirectFront:vIndirectBack;\n#else\nreflectedLight.indirectDiffuse+=vIndirectFront;\n#endif\n#include <lightmap_fragment>\nreflectedLight.indirectDiffuse*=BRDF_Lambert(diffuseColor.rgb);\n#ifdef DOUBLE_SIDED\nreflectedLight.directDiffuse=(gl_FrontFacing)?vLightFront:vLightBack;\n#else\nreflectedLight.directDiffuse=vLightFront;\n#endif\nreflectedLight.directDiffuse*=BRDF_Lambert(diffuseColor.rgb)*getShadowMask();\n#include <aomap_fragment>\nvec3 outgoingLight=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+totalEmissiveRadiance;\n#include <envmap_fragment>\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",
    meshmatcap_vert:
      "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){\n#include <uv_vertex>\n#include <color_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#include <fog_vertex>\nvViewPosition=-mvPosition.xyz;}",
    meshmatcap_frag:
      "#define MATCAP\nuniform vec3 diffuse;uniform float opacity;uniform sampler2D matcap;varying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\nvec4 diffuseColor=vec4(diffuse,opacity);\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\nvec3 viewDir=normalize(vViewPosition);vec3 x=normalize(vec3(viewDir.z,0.0,-viewDir.x));vec3 y=cross(viewDir,x);vec2 uv=vec2(dot(x,normal),dot(y,normal))*0.495+0.5;\n#ifdef USE_MATCAP\nvec4 matcapColor=texture2D(matcap,uv);matcapColor=matcapTexelToLinear(matcapColor);\n#else\nvec4 matcapColor=vec4(1.0);\n#endif\nvec3 outgoingLight=diffuseColor.rgb*matcapColor.rgb;\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",
    meshnormal_vert:
      "#define NORMAL\n#if defined(FLAT_SHADED)||defined(USE_BUMPMAP)||defined(TANGENTSPACE_NORMALMAP)\nvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){\n#include <uv_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#if defined(FLAT_SHADED)||defined(USE_BUMPMAP)||defined(TANGENTSPACE_NORMALMAP)\nvViewPosition=-mvPosition.xyz;\n#endif\n}",
    meshnormal_frag:
      "#define NORMAL\nuniform float opacity;\n#if defined(FLAT_SHADED)||defined(USE_BUMPMAP)||defined(TANGENTSPACE_NORMALMAP)\nvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\n#include <logdepthbuf_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\ngl_FragColor=vec4(packNormalToRGB(normal),opacity);}",
    meshphong_vert:
      "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){\n#include <uv_vertex>\n#include <uv2_vertex>\n#include <color_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition=-mvPosition.xyz;\n#include <worldpos_vertex>\n#include <envmap_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n}",
    meshphong_frag:
      "#define PHONG\nuniform vec3 diffuse;uniform vec3 emissive;uniform vec3 specular;uniform float shininess;uniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\nvec4 diffuseColor=vec4(diffuse,opacity);ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));vec3 totalEmissiveRadiance=emissive;\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <specularmap_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <emissivemap_fragment>\n#include <lights_phong_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#include <aomap_fragment>\nvec3 outgoingLight=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+reflectedLight.directSpecular+reflectedLight.indirectSpecular+totalEmissiveRadiance;\n#include <envmap_fragment>\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",
    meshphysical_vert:
      "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\nvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){\n#include <uv_vertex>\n#include <uv2_vertex>\n#include <color_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition=-mvPosition.xyz;\n#include <worldpos_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n#ifdef USE_TRANSMISSION\nvWorldPosition=worldPosition.xyz;\n#endif\n}",
    meshphysical_frag:
      "#define STANDARD\n#ifdef PHYSICAL\n#define IOR\n#define SPECULAR\n#endif\nuniform vec3 diffuse;uniform vec3 emissive;uniform float roughness;uniform float metalness;uniform float opacity;\n#ifdef IOR\nuniform float ior;\n#endif\n#ifdef SPECULAR\nuniform float specularIntensity;uniform vec3 specularTint;\n#ifdef USE_SPECULARINTENSITYMAP\nuniform sampler2D specularIntensityMap;\n#endif\n#ifdef USE_SPECULARTINTMAP\nuniform sampler2D specularTintMap;\n#endif\n#endif\n#ifdef USE_CLEARCOAT\nuniform float clearcoat;uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\nuniform vec3 sheenTint;uniform float sheenRoughness;\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\nvec4 diffuseColor=vec4(diffuse,opacity);ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));vec3 totalEmissiveRadiance=emissive;\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <roughnessmap_fragment>\n#include <metalnessmap_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <clearcoat_normal_fragment_begin>\n#include <clearcoat_normal_fragment_maps>\n#include <emissivemap_fragment>\n#include <lights_physical_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#include <aomap_fragment>\nvec3 totalDiffuse=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse;vec3 totalSpecular=reflectedLight.directSpecular+reflectedLight.indirectSpecular;\n#include <transmission_fragment>\nvec3 outgoingLight=totalDiffuse+totalSpecular+totalEmissiveRadiance;\n#ifdef USE_CLEARCOAT\nfloat dotNVcc=saturate(dot(geometry.clearcoatNormal,geometry.viewDir));vec3 Fcc=F_Schlick(material.clearcoatF0,material.clearcoatF90,dotNVcc);outgoingLight=outgoingLight*(1.0-clearcoat*Fcc)+clearcoatSpecular*clearcoat;\n#endif\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",
    meshtoon_vert:
      "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){\n#include <uv_vertex>\n#include <uv2_vertex>\n#include <color_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition=-mvPosition.xyz;\n#include <worldpos_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n}",
    meshtoon_frag:
      "#define TOON\nuniform vec3 diffuse;uniform vec3 emissive;uniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\nvec4 diffuseColor=vec4(diffuse,opacity);ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));vec3 totalEmissiveRadiance=emissive;\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <emissivemap_fragment>\n#include <lights_toon_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#include <aomap_fragment>\nvec3 outgoingLight=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+totalEmissiveRadiance;\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",
    points_vert:
      "uniform float size;uniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){\n#include <color_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <project_vertex>\ngl_PointSize=size;\n#ifdef USE_SIZEATTENUATION\nbool isPerspective=isPerspectiveMatrix(projectionMatrix);if(isPerspective)gl_PointSize*=(scale/-mvPosition.z);\n#endif\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#include <worldpos_vertex>\n#include <fog_vertex>\n}",
    points_frag:
      "uniform vec3 diffuse;uniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\nvec3 outgoingLight=vec3(0.0);vec4 diffuseColor=vec4(diffuse,opacity);\n#include <logdepthbuf_fragment>\n#include <map_particle_fragment>\n#include <color_fragment>\n#include <alphatest_fragment>\noutgoingLight=diffuseColor.rgb;\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n}",
    shadow_vert:
      "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main(){\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <project_vertex>\n#include <worldpos_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n}",
    shadow_frag:
      "uniform vec3 color;uniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main(){gl_FragColor=vec4(color,opacity*(1.0-getShadowMask()));\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n}",
    sprite_vert:
      "uniform float rotation;uniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){\n#include <uv_vertex>\nvec4 mvPosition=modelViewMatrix*vec4(0.0,0.0,0.0,1.0);vec2 scale;scale.x=length(vec3(modelMatrix[0].x,modelMatrix[0].y,modelMatrix[0].z));scale.y=length(vec3(modelMatrix[1].x,modelMatrix[1].y,modelMatrix[1].z));\n#ifndef USE_SIZEATTENUATION\nbool isPerspective=isPerspectiveMatrix(projectionMatrix);if(isPerspective)scale*=-mvPosition.z;\n#endif\nvec2 alignedPosition=(position.xy-(center-vec2(0.5)))*scale;vec2 rotatedPosition;rotatedPosition.x=cos(rotation)*alignedPosition.x-sin(rotation)*alignedPosition.y;rotatedPosition.y=sin(rotation)*alignedPosition.x+cos(rotation)*alignedPosition.y;mvPosition.xy+=rotatedPosition;gl_Position=projectionMatrix*mvPosition;\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#include <fog_vertex>\n}",
    sprite_frag:
      "uniform vec3 diffuse;uniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\nvec3 outgoingLight=vec3(0.0);vec4 diffuseColor=vec4(diffuse,opacity);\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\noutgoingLight=diffuseColor.rgb;\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n}",
  },
  Kw = {
    common: {
      diffuse: { value: new Xb(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      uvTransform: { value: new mx() },
      uv2Transform: { value: new mx() },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
    },
    specularmap: { specularMap: { value: null } },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
      maxMipLevel: { value: 0 },
    },
    aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
    lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
    emissivemap: { emissiveMap: { value: null } },
    bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
    normalmap: {
      normalMap: { value: null },
      normalScale: { value: new fx(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    roughnessmap: { roughnessMap: { value: null } },
    metalnessmap: { metalnessMap: { value: null } },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Xb(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotShadowMap: { value: [] },
      spotShadowMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new Xb(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
      uvTransform: { value: new mx() },
    },
    sprite: {
      diffuse: { value: new Xb(16777215) },
      opacity: { value: 1 },
      center: { value: new fx(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
      uvTransform: { value: new mx() },
    },
  },
  Jw = {
    basic: {
      uniforms: Rw([
        Kw.common,
        Kw.specularmap,
        Kw.envmap,
        Kw.aomap,
        Kw.lightmap,
        Kw.fog,
      ]),
      vertexShader: Zw.meshbasic_vert,
      fragmentShader: Zw.meshbasic_frag,
    },
    lambert: {
      uniforms: Rw([
        Kw.common,
        Kw.specularmap,
        Kw.envmap,
        Kw.aomap,
        Kw.lightmap,
        Kw.emissivemap,
        Kw.fog,
        Kw.lights,
        { emissive: { value: new Xb(0) } },
      ]),
      vertexShader: Zw.meshlambert_vert,
      fragmentShader: Zw.meshlambert_frag,
    },
    phong: {
      uniforms: Rw([
        Kw.common,
        Kw.specularmap,
        Kw.envmap,
        Kw.aomap,
        Kw.lightmap,
        Kw.emissivemap,
        Kw.bumpmap,
        Kw.normalmap,
        Kw.displacementmap,
        Kw.fog,
        Kw.lights,
        {
          emissive: { value: new Xb(0) },
          specular: { value: new Xb(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: Zw.meshphong_vert,
      fragmentShader: Zw.meshphong_frag,
    },
    standard: {
      uniforms: Rw([
        Kw.common,
        Kw.envmap,
        Kw.aomap,
        Kw.lightmap,
        Kw.emissivemap,
        Kw.bumpmap,
        Kw.normalmap,
        Kw.displacementmap,
        Kw.roughnessmap,
        Kw.metalnessmap,
        Kw.fog,
        Kw.lights,
        {
          emissive: { value: new Xb(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: Zw.meshphysical_vert,
      fragmentShader: Zw.meshphysical_frag,
    },
    toon: {
      uniforms: Rw([
        Kw.common,
        Kw.aomap,
        Kw.lightmap,
        Kw.emissivemap,
        Kw.bumpmap,
        Kw.normalmap,
        Kw.displacementmap,
        Kw.gradientmap,
        Kw.fog,
        Kw.lights,
        { emissive: { value: new Xb(0) } },
      ]),
      vertexShader: Zw.meshtoon_vert,
      fragmentShader: Zw.meshtoon_frag,
    },
    matcap: {
      uniforms: Rw([
        Kw.common,
        Kw.bumpmap,
        Kw.normalmap,
        Kw.displacementmap,
        Kw.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: Zw.meshmatcap_vert,
      fragmentShader: Zw.meshmatcap_frag,
    },
    points: {
      uniforms: Rw([Kw.points, Kw.fog]),
      vertexShader: Zw.points_vert,
      fragmentShader: Zw.points_frag,
    },
    dashed: {
      uniforms: Rw([
        Kw.common,
        Kw.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: Zw.linedashed_vert,
      fragmentShader: Zw.linedashed_frag,
    },
    depth: {
      uniforms: Rw([Kw.common, Kw.displacementmap]),
      vertexShader: Zw.depth_vert,
      fragmentShader: Zw.depth_frag,
    },
    normal: {
      uniforms: Rw([
        Kw.common,
        Kw.bumpmap,
        Kw.normalmap,
        Kw.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: Zw.meshnormal_vert,
      fragmentShader: Zw.meshnormal_frag,
    },
    sprite: {
      uniforms: Rw([Kw.sprite, Kw.fog]),
      vertexShader: Zw.sprite_vert,
      fragmentShader: Zw.sprite_frag,
    },
    background: {
      uniforms: { uvTransform: { value: new mx() }, t2D: { value: null } },
      vertexShader: Zw.background_vert,
      fragmentShader: Zw.background_frag,
    },
    cube: {
      uniforms: Rw([Kw.envmap, { opacity: { value: 1 } }]),
      vertexShader: Zw.cube_vert,
      fragmentShader: Zw.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: Zw.equirect_vert,
      fragmentShader: Zw.equirect_frag,
    },
    distanceRGBA: {
      uniforms: Rw([
        Kw.common,
        Kw.displacementmap,
        {
          referencePosition: { value: new Cx() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: Zw.distanceRGBA_vert,
      fragmentShader: Zw.distanceRGBA_frag,
    },
    shadow: {
      uniforms: Rw([
        Kw.lights,
        Kw.fog,
        { color: { value: new Xb(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: Zw.shadow_vert,
      fragmentShader: Zw.shadow_frag,
    },
  };
function Qw(e, t, n, i, r) {
  const s = new Xb(0);
  let a,
    o,
    l = 0,
    c = null,
    u = 0,
    h = null;
  function d(e, t) {
    n.buffers.color.setClear(e.r, e.g, e.b, t, r);
  }
  return {
    getClearColor: function () {
      return s;
    },
    setClearColor: function (e, t = 1) {
      s.set(e), (l = t), d(s, l);
    },
    getClearAlpha: function () {
      return l;
    },
    setClearAlpha: function (e) {
      (l = e), d(s, l);
    },
    render: function (n, r) {
      let p = !1,
        f = !0 === r.isScene ? r.background : null;
      f && f.isTexture && (f = t.get(f));
      const m = e.xr,
        g = m.getSession && m.getSession();
      g && "additive" === g.environmentBlendMode && (f = null),
        null === f ? d(s, l) : f && f.isColor && (d(f, 1), (p = !0)),
        (e.autoClear || p) &&
          e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
        f && (f.isCubeTexture || 306 === f.mapping)
          ? (void 0 === o &&
              ((o = new Aw(
                new Lw(1, 1, 1),
                new kw({
                  name: "BackgroundCubeMaterial",
                  uniforms: Iw(Jw.cube.uniforms),
                  vertexShader: Jw.cube.vertexShader,
                  fragmentShader: Jw.cube.fragmentShader,
                  side: 1,
                  depthTest: !1,
                  depthWrite: !1,
                  fog: !1,
                })
              )),
              o.geometry.deleteAttribute("normal"),
              o.geometry.deleteAttribute("uv"),
              (o.onBeforeRender = function (e, t, n) {
                this.matrixWorld.copyPosition(n.matrixWorld);
              }),
              Object.defineProperty(o.material, "envMap", {
                get: function () {
                  return this.uniforms.envMap.value;
                },
              }),
              i.update(o)),
            (o.material.uniforms.envMap.value = f),
            (o.material.uniforms.flipEnvMap.value =
              f.isCubeTexture && !1 === f.isRenderTargetTexture ? -1 : 1),
            (c === f && u === f.version && h === e.toneMapping) ||
              ((o.material.needsUpdate = !0),
              (c = f),
              (u = f.version),
              (h = e.toneMapping)),
            n.unshift(o, o.geometry, o.material, 0, 0, null))
          : f &&
            f.isTexture &&
            (void 0 === a &&
              ((a = new Aw(
                new $w(2, 2),
                new kw({
                  name: "BackgroundMaterial",
                  uniforms: Iw(Jw.background.uniforms),
                  vertexShader: Jw.background.vertexShader,
                  fragmentShader: Jw.background.fragmentShader,
                  side: 0,
                  depthTest: !1,
                  depthWrite: !1,
                  fog: !1,
                })
              )),
              a.geometry.deleteAttribute("normal"),
              Object.defineProperty(a.material, "map", {
                get: function () {
                  return this.uniforms.t2D.value;
                },
              }),
              i.update(a)),
            (a.material.uniforms.t2D.value = f),
            !0 === f.matrixAutoUpdate && f.updateMatrix(),
            a.material.uniforms.uvTransform.value.copy(f.matrix),
            (c === f && u === f.version && h === e.toneMapping) ||
              ((a.material.needsUpdate = !0),
              (c = f),
              (u = f.version),
              (h = e.toneMapping)),
            n.unshift(a, a.geometry, a.material, 0, 0, null));
    },
  };
}
function eS(e, t, n, i) {
  const r = e.getParameter(34921),
    s = i.isWebGL2 ? null : t.get("OES_vertex_array_object"),
    a = i.isWebGL2 || null !== s,
    o = {},
    l = d(null);
  let c = l;
  function u(t) {
    return i.isWebGL2 ? e.bindVertexArray(t) : s.bindVertexArrayOES(t);
  }
  function h(t) {
    return i.isWebGL2 ? e.deleteVertexArray(t) : s.deleteVertexArrayOES(t);
  }
  function d(e) {
    const t = [],
      n = [],
      i = [];
    for (let s = 0; s < r; s++) (t[s] = 0), (n[s] = 0), (i[s] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: t,
      enabledAttributes: n,
      attributeDivisors: i,
      object: e,
      attributes: {},
      index: null,
    };
  }
  function p() {
    const e = c.newAttributes;
    for (let t = 0, n = e.length; t < n; t++) e[t] = 0;
  }
  function f(e) {
    m(e, 0);
  }
  function m(n, r) {
    const s = c.newAttributes,
      a = c.enabledAttributes,
      o = c.attributeDivisors;
    if (
      ((s[n] = 1),
      0 === a[n] && (e.enableVertexAttribArray(n), (a[n] = 1)),
      o[n] !== r)
    ) {
      (i.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[
        i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
      ](n, r),
        (o[n] = r);
    }
  }
  function g() {
    const t = c.newAttributes,
      n = c.enabledAttributes;
    for (let i = 0, r = n.length; i < r; i++)
      n[i] !== t[i] && (e.disableVertexAttribArray(i), (n[i] = 0));
  }
  function v(t, n, r, s, a, o) {
    !0 !== i.isWebGL2 || (5124 !== r && 5125 !== r)
      ? e.vertexAttribPointer(t, n, r, s, a, o)
      : e.vertexAttribIPointer(t, n, r, a, o);
  }
  function _() {
    y(), c !== l && ((c = l), u(c.object));
  }
  function y() {
    (l.geometry = null), (l.program = null), (l.wireframe = !1);
  }
  return {
    setup: function (r, l, h, _, y) {
      let x = !1;
      if (a) {
        const t = (function (t, n, r) {
          const a = !0 === r.wireframe;
          let l = o[t.id];
          void 0 === l && ((l = {}), (o[t.id] = l));
          let c = l[n.id];
          void 0 === c && ((c = {}), (l[n.id] = c));
          let u = c[a];
          void 0 === u &&
            ((u = d(
              i.isWebGL2 ? e.createVertexArray() : s.createVertexArrayOES()
            )),
            (c[a] = u));
          return u;
        })(_, h, l);
        c !== t && ((c = t), u(c.object)),
          (x = (function (e, t) {
            const n = c.attributes,
              i = e.attributes;
            let r = 0;
            for (const s in i) {
              const e = n[s],
                t = i[s];
              if (void 0 === e) return !0;
              if (e.attribute !== t) return !0;
              if (e.data !== t.data) return !0;
              r++;
            }
            return c.attributesNum !== r || c.index !== t;
          })(_, y)),
          x &&
            (function (e, t) {
              const n = {},
                i = e.attributes;
              let r = 0;
              for (const s in i) {
                const e = i[s],
                  t = {};
                (t.attribute = e), e.data && (t.data = e.data), (n[s] = t), r++;
              }
              (c.attributes = n), (c.attributesNum = r), (c.index = t);
            })(_, y);
      } else {
        const e = !0 === l.wireframe;
        (c.geometry === _.id && c.program === h.id && c.wireframe === e) ||
          ((c.geometry = _.id),
          (c.program = h.id),
          (c.wireframe = e),
          (x = !0));
      }
      !0 === r.isInstancedMesh && (x = !0),
        null !== y && n.update(y, 34963),
        x &&
          (!(function (r, s, a, o) {
            if (
              !1 === i.isWebGL2 &&
              (r.isInstancedMesh || o.isInstancedBufferGeometry) &&
              null === t.get("ANGLE_instanced_arrays")
            )
              return;
            p();
            const l = o.attributes,
              c = a.getAttributes(),
              u = s.defaultAttributeValues;
            for (const t in c) {
              const i = c[t];
              if (i.location >= 0) {
                let s = l[t];
                if (
                  (void 0 === s &&
                    ("instanceMatrix" === t &&
                      r.instanceMatrix &&
                      (s = r.instanceMatrix),
                    "instanceColor" === t &&
                      r.instanceColor &&
                      (s = r.instanceColor)),
                  void 0 !== s)
                ) {
                  const t = s.normalized,
                    a = s.itemSize,
                    l = n.get(s);
                  if (void 0 === l) continue;
                  const c = l.buffer,
                    u = l.type,
                    h = l.bytesPerElement;
                  if (s.isInterleavedBufferAttribute) {
                    const n = s.data,
                      l = n.stride,
                      d = s.offset;
                    if (n && n.isInstancedInterleavedBuffer) {
                      for (let e = 0; e < i.locationSize; e++)
                        m(i.location + e, n.meshPerAttribute);
                      !0 !== r.isInstancedMesh &&
                        void 0 === o._maxInstanceCount &&
                        (o._maxInstanceCount = n.meshPerAttribute * n.count);
                    } else
                      for (let e = 0; e < i.locationSize; e++)
                        f(i.location + e);
                    e.bindBuffer(34962, c);
                    for (let e = 0; e < i.locationSize; e++)
                      v(
                        i.location + e,
                        a / i.locationSize,
                        u,
                        t,
                        l * h,
                        (d + (a / i.locationSize) * e) * h
                      );
                  } else {
                    if (s.isInstancedBufferAttribute) {
                      for (let e = 0; e < i.locationSize; e++)
                        m(i.location + e, s.meshPerAttribute);
                      !0 !== r.isInstancedMesh &&
                        void 0 === o._maxInstanceCount &&
                        (o._maxInstanceCount = s.meshPerAttribute * s.count);
                    } else
                      for (let e = 0; e < i.locationSize; e++)
                        f(i.location + e);
                    e.bindBuffer(34962, c);
                    for (let e = 0; e < i.locationSize; e++)
                      v(
                        i.location + e,
                        a / i.locationSize,
                        u,
                        t,
                        a * h,
                        (a / i.locationSize) * e * h
                      );
                  }
                } else if (void 0 !== u) {
                  const n = u[t];
                  if (void 0 !== n)
                    switch (n.length) {
                      case 2:
                        e.vertexAttrib2fv(i.location, n);
                        break;
                      case 3:
                        e.vertexAttrib3fv(i.location, n);
                        break;
                      case 4:
                        e.vertexAttrib4fv(i.location, n);
                        break;
                      default:
                        e.vertexAttrib1fv(i.location, n);
                    }
                }
              }
            }
            g();
          })(r, l, h, _),
          null !== y && e.bindBuffer(34963, n.get(y).buffer));
    },
    reset: _,
    resetDefaultState: y,
    dispose: function () {
      _();
      for (const e in o) {
        const t = o[e];
        for (const e in t) {
          const n = t[e];
          for (const e in n) h(n[e].object), delete n[e];
          delete t[e];
        }
        delete o[e];
      }
    },
    releaseStatesOfGeometry: function (e) {
      if (void 0 === o[e.id]) return;
      const t = o[e.id];
      for (const n in t) {
        const e = t[n];
        for (const t in e) h(e[t].object), delete e[t];
        delete t[n];
      }
      delete o[e.id];
    },
    releaseStatesOfProgram: function (e) {
      for (const t in o) {
        const n = o[t];
        if (void 0 === n[e.id]) continue;
        const i = n[e.id];
        for (const e in i) h(i[e].object), delete i[e];
        delete n[e.id];
      }
    },
    initAttributes: p,
    enableAttribute: f,
    disableUnusedAttributes: g,
  };
}
function tS(e, t, n, i) {
  const r = i.isWebGL2;
  let s;
  (this.setMode = function (e) {
    s = e;
  }),
    (this.render = function (t, i) {
      e.drawArrays(s, t, i), n.update(i, s, 1);
    }),
    (this.renderInstances = function (i, a, o) {
      if (0 === o) return;
      let l, c;
      if (r) (l = e), (c = "drawArraysInstanced");
      else if (
        ((l = t.get("ANGLE_instanced_arrays")),
        (c = "drawArraysInstancedANGLE"),
        null === l)
      )
        return;
      l[c](s, i, a, o), n.update(a, s, o);
    });
}
function nS(e, t, n) {
  let i;
  function r(t) {
    if ("highp" === t) {
      if (
        e.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
        e.getShaderPrecisionFormat(35632, 36338).precision > 0
      )
        return "highp";
      t = "mediump";
    }
    return "mediump" === t &&
      e.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
      e.getShaderPrecisionFormat(35632, 36337).precision > 0
      ? "mediump"
      : "lowp";
  }
  const s =
    ("undefined" != typeof WebGL2RenderingContext &&
      e instanceof WebGL2RenderingContext) ||
    ("undefined" != typeof WebGL2ComputeRenderingContext &&
      e instanceof WebGL2ComputeRenderingContext);
  let a = void 0 !== n.precision ? n.precision : "highp";
  const o = r(a);
  o !== a && (a = o);
  const l = s || t.has("WEBGL_draw_buffers"),
    c = !0 === n.logarithmicDepthBuffer,
    u = e.getParameter(34930),
    h = e.getParameter(35660),
    d = e.getParameter(3379),
    p = e.getParameter(34076),
    f = e.getParameter(34921),
    m = e.getParameter(36347),
    g = e.getParameter(36348),
    v = e.getParameter(36349),
    _ = h > 0,
    y = s || t.has("OES_texture_float");
  return {
    isWebGL2: s,
    drawBuffers: l,
    getMaxAnisotropy: function () {
      if (void 0 !== i) return i;
      if (!0 === t.has("EXT_texture_filter_anisotropic")) {
        const n = t.get("EXT_texture_filter_anisotropic");
        i = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      } else i = 0;
      return i;
    },
    getMaxPrecision: r,
    precision: a,
    logarithmicDepthBuffer: c,
    maxTextures: u,
    maxVertexTextures: h,
    maxTextureSize: d,
    maxCubemapSize: p,
    maxAttributes: f,
    maxVertexUniforms: m,
    maxVaryings: g,
    maxFragmentUniforms: v,
    vertexTextures: _,
    floatFragmentTextures: y,
    floatVertexTextures: _ && y,
    maxSamples: s ? e.getParameter(36183) : 0,
  };
}
function iS(e) {
  const t = this;
  let n = null,
    i = 0,
    r = !1,
    s = !1;
  const a = new Gw(),
    o = new mx(),
    l = { value: null, needsUpdate: !1 };
  function c() {
    l.value !== n && ((l.value = n), (l.needsUpdate = i > 0)),
      (t.numPlanes = i),
      (t.numIntersection = 0);
  }
  function u(e, n, i, r) {
    const s = null !== e ? e.length : 0;
    let c = null;
    if (0 !== s) {
      if (((c = l.value), !0 !== r || null === c)) {
        const t = i + 4 * s,
          r = n.matrixWorldInverse;
        o.getNormalMatrix(r),
          (null === c || c.length < t) && (c = new Float32Array(t));
        for (let n = 0, l = i; n !== s; ++n, l += 4)
          a.copy(e[n]).applyMatrix4(r, o),
            a.normal.toArray(c, l),
            (c[l + 3] = a.constant);
      }
      (l.value = c), (l.needsUpdate = !0);
    }
    return (t.numPlanes = s), (t.numIntersection = 0), c;
  }
  (this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (e, t, s) {
      const a = 0 !== e.length || t || 0 !== i || r;
      return (r = t), (n = u(e, s, 0)), (i = e.length), a;
    }),
    (this.beginShadows = function () {
      (s = !0), u(null);
    }),
    (this.endShadows = function () {
      (s = !1), c();
    }),
    (this.setState = function (t, a, o) {
      const h = t.clippingPlanes,
        d = t.clipIntersection,
        p = t.clipShadows,
        f = e.get(t);
      if (!r || null === h || 0 === h.length || (s && !p)) s ? u(null) : c();
      else {
        const e = s ? 0 : i,
          t = 4 * e;
        let r = f.clippingState || null;
        (l.value = r), (r = u(h, a, t, o));
        for (let i = 0; i !== t; ++i) r[i] = n[i];
        (f.clippingState = r),
          (this.numIntersection = d ? this.numPlanes : 0),
          (this.numPlanes += e);
      }
    });
}
function rS(e) {
  let t = new WeakMap();
  function n(e, t) {
    return 303 === t ? (e.mapping = 301) : 304 === t && (e.mapping = 302), e;
  }
  function i(e) {
    const n = e.target;
    n.removeEventListener("dispose", i);
    const r = t.get(n);
    void 0 !== r && (t.delete(n), r.dispose());
  }
  return {
    get: function (r) {
      if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
        const s = r.mapping;
        if (303 === s || 304 === s) {
          if (t.has(r)) {
            return n(t.get(r).texture, r.mapping);
          }
          {
            const s = r.image;
            if (s && s.height > 0) {
              const a = e.getRenderTarget(),
                o = new Uw(s.height / 2);
              return (
                o.fromEquirectangularTexture(e, r),
                t.set(r, o),
                e.setRenderTarget(a),
                r.addEventListener("dispose", i),
                n(o.texture, r.mapping)
              );
            }
            return null;
          }
        }
      }
      return r;
    },
    dispose: function () {
      t = new WeakMap();
    },
  };
}
Jw.physical = {
  uniforms: Rw([
    Jw.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: new fx(1, 1) },
      clearcoatNormalMap: { value: null },
      sheen: { value: 0 },
      sheenTint: { value: new Xb(0) },
      sheenRoughness: { value: 0 },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionSamplerSize: { value: new fx() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      attenuationDistance: { value: 0 },
      attenuationTint: { value: new Xb(0) },
      specularIntensity: { value: 0 },
      specularIntensityMap: { value: null },
      specularTint: { value: new Xb(1, 1, 1) },
      specularTintMap: { value: null },
    },
  ]),
  vertexShader: Zw.meshphysical_vert,
  fragmentShader: Zw.meshphysical_frag,
};
class sS extends Nw {
  constructor(e = -1, t = 1, n = 1, i = -1, r = 0.1, s = 2e3) {
    super(),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = n),
      (this.bottom = i),
      (this.near = r),
      (this.far = s),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = null === e.view ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, n, i, r, s) {
    null === this.view &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = r),
      (this.view.height = s),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    null !== this.view && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      n = (this.right + this.left) / 2,
      i = (this.top + this.bottom) / 2;
    let r = n - e,
      s = n + e,
      a = i + t,
      o = i - t;
    if (null !== this.view && this.view.enabled) {
      const e = (this.right - this.left) / this.view.fullWidth / this.zoom,
        t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (r += e * this.view.offsetX),
        (s = r + e * this.view.width),
        (a -= t * this.view.offsetY),
        (o = a - t * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      null !== this.view && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
sS.prototype.isOrthographicCamera = !0;
class aS extends kw {
  constructor(e) {
    super(e), (this.type = "RawShaderMaterial");
  }
}
aS.prototype.isRawShaderMaterial = !0;
const oS = Math.pow(2, 8),
  lS = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  cS = 5 + lS.length,
  uS = { 3e3: 0, 3001: 1, 3002: 2, 3004: 3, 3005: 4, 3006: 5, 3007: 6 },
  hS = new sS(),
  { _lodPlanes: dS, _sizeLods: pS, _sigmas: fS } = wS(),
  mS = new Xb();
let gS = null;
const vS = (1 + Math.sqrt(5)) / 2,
  _S = 1 / vS,
  yS = [
    new Cx(1, 1, 1),
    new Cx(-1, 1, 1),
    new Cx(1, 1, -1),
    new Cx(-1, 1, -1),
    new Cx(0, vS, _S),
    new Cx(0, vS, -_S),
    new Cx(_S, 0, vS),
    new Cx(-_S, 0, vS),
    new Cx(vS, _S, 0),
    new Cx(-vS, _S, 0),
  ];
class xS {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._blurMaterial = (function (e) {
        const t = new Float32Array(e),
          n = new Cx(0, 1, 0);
        return new aS({
          name: "SphericalGaussianBlur",
          defines: { n: e },
          uniforms: {
            envMap: { value: null },
            samples: { value: 1 },
            weights: { value: t },
            latitudinal: { value: !1 },
            dTheta: { value: 0 },
            mipInt: { value: 0 },
            poleAxis: { value: n },
            inputEncoding: { value: uS[3e3] },
            outputEncoding: { value: uS[3e3] },
          },
          vertexShader: ES(),
          fragmentShader: `precision mediump float;precision mediump int;varying vec3 vOutputDirection;uniform sampler2D envMap;uniform int samples;uniform float weights[n];uniform bool latitudinal;uniform float dTheta;uniform float mipInt;uniform vec3 poleAxis;\n${AS()}\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\nvec3 getSample(float theta,vec3 axis){float cosTheta=cos(theta);vec3 sampleDirection=vOutputDirection*cosTheta+cross(axis,vOutputDirection)*sin(theta)+axis*dot(axis,vOutputDirection)*(1.0-cosTheta);return bilinearCubeUV(envMap,sampleDirection,mipInt);}void main(){vec3 axis=latitudinal?poleAxis:cross(poleAxis,vOutputDirection);if(all(equal(axis,vec3(0.0)))){axis=vec3(vOutputDirection.z,0.0,-vOutputDirection.x);}axis=normalize(axis);gl_FragColor=vec4(0.0,0.0,0.0,1.0);gl_FragColor.rgb+=weights[0]*getSample(0.0,axis);for(int i=1;i<n;i++){if(i>=samples){break;}float theta=dTheta*float(i);gl_FragColor.rgb+=weights[i]*getSample(-1.0*theta,axis);gl_FragColor.rgb+=weights[i]*getSample(theta,axis);}gl_FragColor=linearToOutputTexel(gl_FragColor);}`,
          blending: 0,
          depthTest: !1,
          depthWrite: !1,
        });
      })(20)),
      (this._equirectShader = null),
      (this._cubemapShader = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, n = 0.1, i = 100) {
    gS = this._renderer.getRenderTarget();
    const r = this._allocateTargets();
    return (
      this._sceneToCubeUV(e, n, i, r),
      t > 0 && this._blur(r, 0, 0, t),
      this._applyPMREM(r),
      this._cleanup(r),
      r
    );
  }
  fromEquirectangular(e) {
    return this._fromTexture(e);
  }
  fromCubemap(e) {
    return this._fromTexture(e);
  }
  compileCubemapShader() {
    null === this._cubemapShader &&
      ((this._cubemapShader = CS()),
      this._compileMaterial(this._cubemapShader));
  }
  compileEquirectangularShader() {
    null === this._equirectShader &&
      ((this._equirectShader = TS()),
      this._compileMaterial(this._equirectShader));
  }
  dispose() {
    this._blurMaterial.dispose(),
      null !== this._cubemapShader && this._cubemapShader.dispose(),
      null !== this._equirectShader && this._equirectShader.dispose();
    for (let e = 0; e < dS.length; e++) dS[e].dispose();
  }
  _cleanup(e) {
    this._pingPongRenderTarget.dispose(),
      this._renderer.setRenderTarget(gS),
      (e.scissorTest = !1),
      MS(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e) {
    gS = this._renderer.getRenderTarget();
    const t = this._allocateTargets(e);
    return (
      this._textureToCubeUV(e, t), this._applyPMREM(t), this._cleanup(t), t
    );
  }
  _allocateTargets(e) {
    const t = {
        magFilter: 1003,
        minFilter: 1003,
        generateMipmaps: !1,
        type: 1009,
        format: 1023,
        encoding: bS(e) ? e.encoding : 3002,
        depthBuffer: !1,
      },
      n = SS(t);
    return (n.depthBuffer = !e), (this._pingPongRenderTarget = SS(t)), n;
  }
  _compileMaterial(e) {
    const t = new Aw(dS[0], e);
    this._renderer.compile(t, hS);
  }
  _sceneToCubeUV(e, t, n, i) {
    const r = new Ow(90, 1, t, n),
      s = [1, -1, 1, 1, 1, 1],
      a = [1, 1, 1, -1, -1, -1],
      o = this._renderer,
      l = o.autoClear,
      c = o.outputEncoding,
      u = o.toneMapping;
    o.getClearColor(mS),
      (o.toneMapping = 0),
      (o.outputEncoding = 3e3),
      (o.autoClear = !1);
    const h = new $b({
        name: "PMREM.Background",
        side: 1,
        depthWrite: !1,
        depthTest: !1,
      }),
      d = new Aw(new Lw(), h);
    let p = !1;
    const f = e.background;
    f
      ? f.isColor && (h.color.copy(f), (e.background = null), (p = !0))
      : (h.color.copy(mS), (p = !0));
    for (let m = 0; m < 6; m++) {
      const t = m % 3;
      0 == t
        ? (r.up.set(0, s[m], 0), r.lookAt(a[m], 0, 0))
        : 1 == t
        ? (r.up.set(0, 0, s[m]), r.lookAt(0, a[m], 0))
        : (r.up.set(0, s[m], 0), r.lookAt(0, 0, a[m])),
        MS(i, t * oS, m > 2 ? oS : 0, oS, oS),
        o.setRenderTarget(i),
        p && o.render(d, r),
        o.render(e, r);
    }
    d.geometry.dispose(),
      d.material.dispose(),
      (o.toneMapping = u),
      (o.outputEncoding = c),
      (o.autoClear = l),
      (e.background = f);
  }
  _setEncoding(e, t) {
    !0 === this._renderer.capabilities.isWebGL2 &&
    1023 === t.format &&
    1009 === t.type &&
    3001 === t.encoding
      ? (e.value = uS[3e3])
      : (e.value = uS[t.encoding]);
  }
  _textureToCubeUV(e, t) {
    const n = this._renderer;
    e.isCubeTexture
      ? null == this._cubemapShader && (this._cubemapShader = CS())
      : null == this._equirectShader && (this._equirectShader = TS());
    const i = e.isCubeTexture ? this._cubemapShader : this._equirectShader,
      r = new Aw(dS[0], i),
      s = i.uniforms;
    (s.envMap.value = e),
      e.isCubeTexture ||
        s.texelSize.value.set(1 / e.image.width, 1 / e.image.height),
      this._setEncoding(s.inputEncoding, e),
      this._setEncoding(s.outputEncoding, t.texture),
      MS(t, 0, 0, 3 * oS, 2 * oS),
      n.setRenderTarget(t),
      n.render(r, hS);
  }
  _applyPMREM(e) {
    const t = this._renderer,
      n = t.autoClear;
    t.autoClear = !1;
    for (let i = 1; i < cS; i++) {
      const t = Math.sqrt(fS[i] * fS[i] - fS[i - 1] * fS[i - 1]),
        n = yS[(i - 1) % yS.length];
      this._blur(e, i - 1, i, t, n);
    }
    t.autoClear = n;
  }
  _blur(e, t, n, i, r) {
    const s = this._pingPongRenderTarget;
    this._halfBlur(e, s, t, n, i, "latitudinal", r),
      this._halfBlur(s, e, n, n, i, "longitudinal", r);
  }
  _halfBlur(e, t, n, i, r, s, a) {
    const o = this._renderer,
      l = this._blurMaterial,
      c = new Aw(dS[i], l),
      u = l.uniforms,
      h = pS[n] - 1,
      d = isFinite(r) ? Math.PI / (2 * h) : (2 * Math.PI) / 39,
      p = r / d,
      f = isFinite(r) ? 1 + Math.floor(3 * p) : 20,
      m = [];
    let g = 0;
    for (let _ = 0; _ < 20; ++_) {
      const e = _ / p,
        t = Math.exp((-e * e) / 2);
      m.push(t), 0 == _ ? (g += t) : _ < f && (g += 2 * t);
    }
    for (let _ = 0; _ < m.length; _++) m[_] = m[_] / g;
    (u.envMap.value = e.texture),
      (u.samples.value = f),
      (u.weights.value = m),
      (u.latitudinal.value = "latitudinal" === s),
      a && (u.poleAxis.value = a),
      (u.dTheta.value = d),
      (u.mipInt.value = 8 - n),
      this._setEncoding(u.inputEncoding, e.texture),
      this._setEncoding(u.outputEncoding, e.texture);
    const v = pS[i];
    MS(
      t,
      3 * Math.max(0, oS - 2 * v),
      (0 === i ? 0 : 2 * oS) + 2 * v * (i > 4 ? i - 8 + 4 : 0),
      3 * v,
      2 * v
    ),
      o.setRenderTarget(t),
      o.render(c, hS);
  }
}
function bS(e) {
  return (
    void 0 !== e &&
    1009 === e.type &&
    (3e3 === e.encoding || 3001 === e.encoding || 3007 === e.encoding)
  );
}
function wS() {
  const e = [],
    t = [],
    n = [];
  let i = 8;
  for (let r = 0; r < cS; r++) {
    const s = Math.pow(2, i);
    t.push(s);
    let a = 1 / s;
    r > 4 ? (a = lS[r - 8 + 4 - 1]) : 0 == r && (a = 0), n.push(a);
    const o = 1 / (s - 1),
      l = -o / 2,
      c = 1 + o / 2,
      u = [l, l, c, l, c, c, l, l, c, c, l, c],
      h = 6,
      d = 6,
      p = 3,
      f = 2,
      m = 1,
      g = new Float32Array(p * d * h),
      v = new Float32Array(f * d * h),
      _ = new Float32Array(m * d * h);
    for (let e = 0; e < h; e++) {
      const t = ((e % 3) * 2) / 3 - 1,
        n = e > 2 ? 0 : -1,
        i = [
          t,
          n,
          0,
          t + 2 / 3,
          n,
          0,
          t + 2 / 3,
          n + 1,
          0,
          t,
          n,
          0,
          t + 2 / 3,
          n + 1,
          0,
          t,
          n + 1,
          0,
        ];
      g.set(i, p * d * e), v.set(u, f * d * e);
      const r = [e, e, e, e, e, e];
      _.set(r, m * d * e);
    }
    const y = new uw();
    y.setAttribute("position", new Jb(g, p)),
      y.setAttribute("uv", new Jb(v, f)),
      y.setAttribute("faceIndex", new Jb(_, m)),
      e.push(y),
      i > 4 && i--;
  }
  return { _lodPlanes: e, _sizeLods: t, _sigmas: n };
}
function SS(e) {
  const t = new Sx(3 * oS, 3 * oS, e);
  return (
    (t.texture.mapping = 306),
    (t.texture.name = "PMREM.cubeUv"),
    (t.scissorTest = !0),
    t
  );
}
function MS(e, t, n, i, r) {
  e.viewport.set(t, n, i, r), e.scissor.set(t, n, i, r);
}
function TS() {
  const e = new fx(1, 1);
  return new aS({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null },
      texelSize: { value: e },
      inputEncoding: { value: uS[3e3] },
      outputEncoding: { value: uS[3e3] },
    },
    vertexShader: ES(),
    fragmentShader: `precision mediump float;precision mediump int;varying vec3 vOutputDirection;uniform sampler2D envMap;uniform vec2 texelSize;\n${AS()}\n#include <common>\nvoid main(){gl_FragColor=vec4(0.0,0.0,0.0,1.0);vec3 outputDirection=normalize(vOutputDirection);vec2 uv=equirectUv(outputDirection);vec2 f=fract(uv/texelSize-0.5);uv-=f*texelSize;vec3 tl=envMapTexelToLinear(texture2D(envMap,uv)).rgb;uv.x+=texelSize.x;vec3 tr=envMapTexelToLinear(texture2D(envMap,uv)).rgb;uv.y+=texelSize.y;vec3 br=envMapTexelToLinear(texture2D(envMap,uv)).rgb;uv.x-=texelSize.x;vec3 bl=envMapTexelToLinear(texture2D(envMap,uv)).rgb;vec3 tm=mix(tl,tr,f.x);vec3 bm=mix(bl,br,f.x);gl_FragColor.rgb=mix(tm,bm,f.y);gl_FragColor=linearToOutputTexel(gl_FragColor);}`,
    blending: 0,
    depthTest: !1,
    depthWrite: !1,
  });
}
function CS() {
  return new aS({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      inputEncoding: { value: uS[3e3] },
      outputEncoding: { value: uS[3e3] },
    },
    vertexShader: ES(),
    fragmentShader: `precision mediump float;precision mediump int;varying vec3 vOutputDirection;uniform samplerCube envMap;\n${AS()}\nvoid main(){gl_FragColor=vec4(0.0,0.0,0.0,1.0);gl_FragColor.rgb=envMapTexelToLinear(textureCube(envMap,vec3(-vOutputDirection.x,vOutputDirection.yz))).rgb;gl_FragColor=linearToOutputTexel(gl_FragColor);}`,
    blending: 0,
    depthTest: !1,
    depthWrite: !1,
  });
}
function ES() {
  return "precision mediump float;precision mediump int;attribute vec3 position;attribute vec2 uv;attribute float faceIndex;varying vec3 vOutputDirection;vec3 getDirection(vec2 uv,float face){uv=2.0*uv-1.0;vec3 direction=vec3(uv,1.0);if(face==0.0){direction=direction.zyx;}else if(face==1.0){direction=direction.xzy;direction.xz*=-1.0;}else if(face==2.0){direction.x*=-1.0;}else if(face==3.0){direction=direction.zyx;direction.xz*=-1.0;}else if(face==4.0){direction=direction.xzy;direction.xy*=-1.0;}else if(face==5.0){direction.z*=-1.0;}return direction;}void main(){vOutputDirection=getDirection(uv,faceIndex);gl_Position=vec4(position,1.0);}";
}
function AS() {
  return "uniform int inputEncoding;uniform int outputEncoding;\n#include <encodings_pars_fragment>\nvec4 inputTexelToLinear(vec4 value){if(inputEncoding==0){return value;}else if(inputEncoding==1){return sRGBToLinear(value);}else if(inputEncoding==2){return RGBEToLinear(value);}else if(inputEncoding==3){return RGBMToLinear(value,7.0);}else if(inputEncoding==4){return RGBMToLinear(value,16.0);}else if(inputEncoding==5){return RGBDToLinear(value,256.0);}else{return GammaToLinear(value,2.2);}}vec4 linearToOutputTexel(vec4 value){if(outputEncoding==0){return value;}else if(outputEncoding==1){return LinearTosRGB(value);}else if(outputEncoding==2){return LinearToRGBE(value);}else if(outputEncoding==3){return LinearToRGBM(value,7.0);}else if(outputEncoding==4){return LinearToRGBM(value,16.0);}else if(outputEncoding==5){return LinearToRGBD(value,256.0);}else{return LinearToGamma(value,2.2);}}vec4 envMapTexelToLinear(vec4 color){return inputTexelToLinear(color);}";
}
function PS(e) {
  let t = new WeakMap(),
    n = null;
  function i(e) {
    const n = e.target;
    n.removeEventListener("dispose", i);
    const r = t.get(n);
    void 0 !== r && (t.delete(n), r.dispose());
  }
  return {
    get: function (r) {
      if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
        const s = r.mapping,
          a = 303 === s || 304 === s,
          o = 301 === s || 302 === s;
        if (a || o) {
          if (t.has(r)) return t.get(r).texture;
          {
            const s = r.image;
            if (
              (a && s && s.height > 0) ||
              (o &&
                s &&
                (function (e) {
                  let t = 0;
                  const n = 6;
                  for (let i = 0; i < n; i++) void 0 !== e[i] && t++;
                  return t === n;
                })(s))
            ) {
              const s = e.getRenderTarget();
              null === n && (n = new xS(e));
              const o = a ? n.fromEquirectangular(r) : n.fromCubemap(r);
              return (
                t.set(r, o),
                e.setRenderTarget(s),
                r.addEventListener("dispose", i),
                o.texture
              );
            }
            return null;
          }
        }
      }
      return r;
    },
    dispose: function () {
      (t = new WeakMap()), null !== n && (n.dispose(), (n = null));
    },
  };
}
function LS(e) {
  const t = {};
  function n(n) {
    if (void 0 !== t[n]) return t[n];
    let i;
    switch (n) {
      case "WEBGL_depth_texture":
        i =
          e.getExtension("WEBGL_depth_texture") ||
          e.getExtension("MOZ_WEBGL_depth_texture") ||
          e.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i =
          e.getExtension("EXT_texture_filter_anisotropic") ||
          e.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i =
          e.getExtension("WEBGL_compressed_texture_s3tc") ||
          e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i =
          e.getExtension("WEBGL_compressed_texture_pvrtc") ||
          e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = e.getExtension(n);
    }
    return (t[n] = i), i;
  }
  return {
    has: function (e) {
      return null !== n(e);
    },
    init: function (e) {
      e.isWebGL2
        ? n("EXT_color_buffer_float")
        : (n("WEBGL_depth_texture"),
          n("OES_texture_float"),
          n("OES_texture_half_float"),
          n("OES_texture_half_float_linear"),
          n("OES_standard_derivatives"),
          n("OES_element_index_uint"),
          n("OES_vertex_array_object"),
          n("ANGLE_instanced_arrays")),
        n("OES_texture_float_linear"),
        n("EXT_color_buffer_half_float"),
        n("EXT_multisampled_render_to_texture");
    },
    get: function (e) {
      const t = n(e);
      return t;
    },
  };
}
function IS(e, t, n, i) {
  const r = {},
    s = new WeakMap();
  function a(e) {
    const o = e.target;
    null !== o.index && t.remove(o.index);
    for (const n in o.attributes) t.remove(o.attributes[n]);
    o.removeEventListener("dispose", a), delete r[o.id];
    const l = s.get(o);
    l && (t.remove(l), s.delete(o)),
      i.releaseStatesOfGeometry(o),
      !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
      n.memory.geometries--;
  }
  function o(e) {
    const n = [],
      i = e.index,
      r = e.attributes.position;
    let a = 0;
    if (null !== i) {
      const e = i.array;
      a = i.version;
      for (let t = 0, i = e.length; t < i; t += 3) {
        const i = e[t + 0],
          r = e[t + 1],
          s = e[t + 2];
        n.push(i, r, r, s, s, i);
      }
    } else {
      const e = r.array;
      a = r.version;
      for (let t = 0, i = e.length / 3 - 1; t < i; t += 3) {
        const e = t + 0,
          i = t + 1,
          r = t + 2;
        n.push(e, i, i, r, r, e);
      }
    }
    const o = new (gx(n) > 65535 ? tw : ew)(n, 1);
    o.version = a;
    const l = s.get(e);
    l && t.remove(l), s.set(e, o);
  }
  return {
    get: function (e, t) {
      return (
        !0 === r[t.id] ||
          (t.addEventListener("dispose", a),
          (r[t.id] = !0),
          n.memory.geometries++),
        t
      );
    },
    update: function (e) {
      const n = e.attributes;
      for (const r in n) t.update(n[r], 34962);
      const i = e.morphAttributes;
      for (const r in i) {
        const e = i[r];
        for (let n = 0, i = e.length; n < i; n++) t.update(e[n], 34962);
      }
    },
    getWireframeAttribute: function (e) {
      const t = s.get(e);
      if (t) {
        const n = e.index;
        null !== n && t.version < n.version && o(e);
      } else o(e);
      return s.get(e);
    },
  };
}
function RS(e, t, n, i) {
  const r = i.isWebGL2;
  let s, a, o;
  (this.setMode = function (e) {
    s = e;
  }),
    (this.setIndex = function (e) {
      (a = e.type), (o = e.bytesPerElement);
    }),
    (this.render = function (t, i) {
      e.drawElements(s, i, a, t * o), n.update(i, s, 1);
    }),
    (this.renderInstances = function (i, l, c) {
      if (0 === c) return;
      let u, h;
      if (r) (u = e), (h = "drawElementsInstanced");
      else if (
        ((u = t.get("ANGLE_instanced_arrays")),
        (h = "drawElementsInstancedANGLE"),
        null === u)
      )
        return;
      u[h](s, l, a, i * o, c), n.update(l, s, c);
    });
}
function DS(e) {
  const t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  return {
    memory: { geometries: 0, textures: 0 },
    render: t,
    programs: null,
    autoReset: !0,
    reset: function () {
      t.frame++,
        (t.calls = 0),
        (t.triangles = 0),
        (t.points = 0),
        (t.lines = 0);
    },
    update: function (e, n, i) {
      switch ((t.calls++, n)) {
        case 4:
          t.triangles += i * (e / 3);
          break;
        case 1:
          t.lines += i * (e / 2);
          break;
        case 3:
          t.lines += i * (e - 1);
          break;
        case 2:
          t.lines += i * e;
          break;
        case 0:
          t.points += i * e;
      }
    },
  };
}
class kS extends xx {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null),
      (this.image = { data: e, width: t, height: n, depth: i }),
      (this.magFilter = 1003),
      (this.minFilter = 1003),
      (this.wrapR = 1001),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.needsUpdate = !0);
  }
}
function NS(e, t) {
  return e[0] - t[0];
}
function OS(e, t) {
  return Math.abs(t[1]) - Math.abs(e[1]);
}
function FS(e, t) {
  let n = 1;
  const i = t.isInterleavedBufferAttribute ? t.data.array : t.array;
  i instanceof Int8Array
    ? (n = 127)
    : i instanceof Int16Array
    ? (n = 32767)
    : i instanceof Int32Array && (n = 2147483647),
    e.divideScalar(n);
}
function zS(e, t, n) {
  const i = {},
    r = new Float32Array(8),
    s = new WeakMap(),
    a = new Cx(),
    o = [];
  for (let l = 0; l < 8; l++) o[l] = [l, 0];
  return {
    update: function (l, c, u, h) {
      const d = l.morphTargetInfluences;
      if (!0 === t.isWebGL2) {
        const i = c.morphAttributes.position.length;
        let r = s.get(c);
        if (void 0 === r || r.count !== i) {
          void 0 !== r && r.texture.dispose();
          const e = void 0 !== c.morphAttributes.normal,
            n = c.morphAttributes.position,
            o = c.morphAttributes.normal || [],
            l = !0 === e ? 2 : 1;
          let u = c.attributes.position.count * l,
            h = 1;
          u > t.maxTextureSize &&
            ((h = Math.ceil(u / t.maxTextureSize)), (u = t.maxTextureSize));
          const d = new Float32Array(u * h * 4 * i),
            p = new kS(d, u, h, i);
          (p.format = 1023), (p.type = 1015);
          const f = 4 * l;
          for (let t = 0; t < i; t++) {
            const i = n[t],
              r = o[t],
              s = u * h * 4 * t;
            for (let t = 0; t < i.count; t++) {
              a.fromBufferAttribute(i, t), !0 === i.normalized && FS(a, i);
              const n = t * f;
              (d[s + n + 0] = a.x),
                (d[s + n + 1] = a.y),
                (d[s + n + 2] = a.z),
                (d[s + n + 3] = 0),
                !0 === e &&
                  (a.fromBufferAttribute(r, t),
                  !0 === r.normalized && FS(a, r),
                  (d[s + n + 4] = a.x),
                  (d[s + n + 5] = a.y),
                  (d[s + n + 6] = a.z),
                  (d[s + n + 7] = 0));
            }
          }
          (r = { count: i, texture: p, size: new fx(u, h) }), s.set(c, r);
        }
        let o = 0;
        for (let e = 0; e < d.length; e++) o += d[e];
        const l = c.morphTargetsRelative ? 1 : 1 - o;
        h.getUniforms().setValue(e, "morphTargetBaseInfluence", l),
          h.getUniforms().setValue(e, "morphTargetInfluences", d),
          h.getUniforms().setValue(e, "morphTargetsTexture", r.texture, n),
          h.getUniforms().setValue(e, "morphTargetsTextureSize", r.size);
      } else {
        const t = void 0 === d ? 0 : d.length;
        let n = i[c.id];
        if (void 0 === n || n.length !== t) {
          n = [];
          for (let e = 0; e < t; e++) n[e] = [e, 0];
          i[c.id] = n;
        }
        for (let e = 0; e < t; e++) {
          const t = n[e];
          (t[0] = e), (t[1] = d[e]);
        }
        n.sort(OS);
        for (let e = 0; e < 8; e++)
          e < t && n[e][1]
            ? ((o[e][0] = n[e][0]), (o[e][1] = n[e][1]))
            : ((o[e][0] = Number.MAX_SAFE_INTEGER), (o[e][1] = 0));
        o.sort(NS);
        const s = c.morphAttributes.position,
          a = c.morphAttributes.normal;
        let l = 0;
        for (let e = 0; e < 8; e++) {
          const t = o[e],
            n = t[0],
            i = t[1];
          n !== Number.MAX_SAFE_INTEGER && i
            ? (s &&
                c.getAttribute("morphTarget" + e) !== s[n] &&
                c.setAttribute("morphTarget" + e, s[n]),
              a &&
                c.getAttribute("morphNormal" + e) !== a[n] &&
                c.setAttribute("morphNormal" + e, a[n]),
              (r[e] = i),
              (l += i))
            : (s &&
                !0 === c.hasAttribute("morphTarget" + e) &&
                c.deleteAttribute("morphTarget" + e),
              a &&
                !0 === c.hasAttribute("morphNormal" + e) &&
                c.deleteAttribute("morphNormal" + e),
              (r[e] = 0));
        }
        const u = c.morphTargetsRelative ? 1 : 1 - l;
        h.getUniforms().setValue(e, "morphTargetBaseInfluence", u),
          h.getUniforms().setValue(e, "morphTargetInfluences", r);
      }
    },
  };
}
function US(e, t, n, i) {
  let r = new WeakMap();
  function s(e) {
    const t = e.target;
    t.removeEventListener("dispose", s),
      n.remove(t.instanceMatrix),
      null !== t.instanceColor && n.remove(t.instanceColor);
  }
  return {
    update: function (e) {
      const a = i.render.frame,
        o = e.geometry,
        l = t.get(e, o);
      return (
        r.get(l) !== a && (t.update(l), r.set(l, a)),
        e.isInstancedMesh &&
          (!1 === e.hasEventListener("dispose", s) &&
            e.addEventListener("dispose", s),
          n.update(e.instanceMatrix, 34962),
          null !== e.instanceColor && n.update(e.instanceColor, 34962)),
        l
      );
    },
    dispose: function () {
      r = new WeakMap();
    },
  };
}
kS.prototype.isDataTexture2DArray = !0;
class BS extends xx {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null),
      (this.image = { data: e, width: t, height: n, depth: i }),
      (this.magFilter = 1003),
      (this.minFilter = 1003),
      (this.wrapR = 1001),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.needsUpdate = !0);
  }
}
BS.prototype.isDataTexture3D = !0;
const VS = new xx(),
  HS = new kS(),
  GS = new BS(),
  WS = new zw(),
  qS = [],
  jS = [],
  YS = new Float32Array(16),
  XS = new Float32Array(9),
  $S = new Float32Array(4);
function ZS(e, t, n) {
  const i = e[0];
  if (i <= 0 || i > 0) return e;
  const r = t * n;
  let s = qS[r];
  if ((void 0 === s && ((s = new Float32Array(r)), (qS[r] = s)), 0 !== t)) {
    i.toArray(s, 0);
    for (let i = 1, r = 0; i !== t; ++i) (r += n), e[i].toArray(s, r);
  }
  return s;
}
function KS(e, t) {
  if (e.length !== t.length) return !1;
  for (let n = 0, i = e.length; n < i; n++) if (e[n] !== t[n]) return !1;
  return !0;
}
function JS(e, t) {
  for (let n = 0, i = t.length; n < i; n++) e[n] = t[n];
}
function QS(e, t) {
  let n = jS[t];
  void 0 === n && ((n = new Int32Array(t)), (jS[t] = n));
  for (let i = 0; i !== t; ++i) n[i] = e.allocateTextureUnit();
  return n;
}
function eM(e, t) {
  const n = this.cache;
  n[0] !== t && (e.uniform1f(this.addr, t), (n[0] = t));
}
function tM(e, t) {
  const n = this.cache;
  if (void 0 !== t.x)
    (n[0] === t.x && n[1] === t.y) ||
      (e.uniform2f(this.addr, t.x, t.y), (n[0] = t.x), (n[1] = t.y));
  else {
    if (KS(n, t)) return;
    e.uniform2fv(this.addr, t), JS(n, t);
  }
}
function nM(e, t) {
  const n = this.cache;
  if (void 0 !== t.x)
    (n[0] === t.x && n[1] === t.y && n[2] === t.z) ||
      (e.uniform3f(this.addr, t.x, t.y, t.z),
      (n[0] = t.x),
      (n[1] = t.y),
      (n[2] = t.z));
  else if (void 0 !== t.r)
    (n[0] === t.r && n[1] === t.g && n[2] === t.b) ||
      (e.uniform3f(this.addr, t.r, t.g, t.b),
      (n[0] = t.r),
      (n[1] = t.g),
      (n[2] = t.b));
  else {
    if (KS(n, t)) return;
    e.uniform3fv(this.addr, t), JS(n, t);
  }
}
function iM(e, t) {
  const n = this.cache;
  if (void 0 !== t.x)
    (n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w) ||
      (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
      (n[0] = t.x),
      (n[1] = t.y),
      (n[2] = t.z),
      (n[3] = t.w));
  else {
    if (KS(n, t)) return;
    e.uniform4fv(this.addr, t), JS(n, t);
  }
}
function rM(e, t) {
  const n = this.cache,
    i = t.elements;
  if (void 0 === i) {
    if (KS(n, t)) return;
    e.uniformMatrix2fv(this.addr, !1, t), JS(n, t);
  } else {
    if (KS(n, i)) return;
    $S.set(i), e.uniformMatrix2fv(this.addr, !1, $S), JS(n, i);
  }
}
function sM(e, t) {
  const n = this.cache,
    i = t.elements;
  if (void 0 === i) {
    if (KS(n, t)) return;
    e.uniformMatrix3fv(this.addr, !1, t), JS(n, t);
  } else {
    if (KS(n, i)) return;
    XS.set(i), e.uniformMatrix3fv(this.addr, !1, XS), JS(n, i);
  }
}
function aM(e, t) {
  const n = this.cache,
    i = t.elements;
  if (void 0 === i) {
    if (KS(n, t)) return;
    e.uniformMatrix4fv(this.addr, !1, t), JS(n, t);
  } else {
    if (KS(n, i)) return;
    YS.set(i), e.uniformMatrix4fv(this.addr, !1, YS), JS(n, i);
  }
}
function oM(e, t) {
  const n = this.cache;
  n[0] !== t && (e.uniform1i(this.addr, t), (n[0] = t));
}
function lM(e, t) {
  const n = this.cache;
  KS(n, t) || (e.uniform2iv(this.addr, t), JS(n, t));
}
function cM(e, t) {
  const n = this.cache;
  KS(n, t) || (e.uniform3iv(this.addr, t), JS(n, t));
}
function uM(e, t) {
  const n = this.cache;
  KS(n, t) || (e.uniform4iv(this.addr, t), JS(n, t));
}
function hM(e, t) {
  const n = this.cache;
  n[0] !== t && (e.uniform1ui(this.addr, t), (n[0] = t));
}
function dM(e, t) {
  const n = this.cache;
  KS(n, t) || (e.uniform2uiv(this.addr, t), JS(n, t));
}
function pM(e, t) {
  const n = this.cache;
  KS(n, t) || (e.uniform3uiv(this.addr, t), JS(n, t));
}
function fM(e, t) {
  const n = this.cache;
  KS(n, t) || (e.uniform4uiv(this.addr, t), JS(n, t));
}
function mM(e, t, n) {
  const i = this.cache,
    r = n.allocateTextureUnit();
  i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
    n.safeSetTexture2D(t || VS, r);
}
function gM(e, t, n) {
  const i = this.cache,
    r = n.allocateTextureUnit();
  i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
    n.setTexture3D(t || GS, r);
}
function vM(e, t, n) {
  const i = this.cache,
    r = n.allocateTextureUnit();
  i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
    n.safeSetTextureCube(t || WS, r);
}
function _M(e, t, n) {
  const i = this.cache,
    r = n.allocateTextureUnit();
  i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
    n.setTexture2DArray(t || HS, r);
}
function yM(e, t) {
  e.uniform1fv(this.addr, t);
}
function xM(e, t) {
  const n = ZS(t, this.size, 2);
  e.uniform2fv(this.addr, n);
}
function bM(e, t) {
  const n = ZS(t, this.size, 3);
  e.uniform3fv(this.addr, n);
}
function wM(e, t) {
  const n = ZS(t, this.size, 4);
  e.uniform4fv(this.addr, n);
}
function SM(e, t) {
  const n = ZS(t, this.size, 4);
  e.uniformMatrix2fv(this.addr, !1, n);
}
function MM(e, t) {
  const n = ZS(t, this.size, 9);
  e.uniformMatrix3fv(this.addr, !1, n);
}
function TM(e, t) {
  const n = ZS(t, this.size, 16);
  e.uniformMatrix4fv(this.addr, !1, n);
}
function CM(e, t) {
  e.uniform1iv(this.addr, t);
}
function EM(e, t) {
  e.uniform2iv(this.addr, t);
}
function AM(e, t) {
  e.uniform3iv(this.addr, t);
}
function PM(e, t) {
  e.uniform4iv(this.addr, t);
}
function LM(e, t) {
  e.uniform1uiv(this.addr, t);
}
function IM(e, t) {
  e.uniform2uiv(this.addr, t);
}
function RM(e, t) {
  e.uniform3uiv(this.addr, t);
}
function DM(e, t) {
  e.uniform4uiv(this.addr, t);
}
function kM(e, t, n) {
  const i = t.length,
    r = QS(n, i);
  e.uniform1iv(this.addr, r);
  for (let s = 0; s !== i; ++s) n.safeSetTexture2D(t[s] || VS, r[s]);
}
function NM(e, t, n) {
  const i = t.length,
    r = QS(n, i);
  e.uniform1iv(this.addr, r);
  for (let s = 0; s !== i; ++s) n.safeSetTextureCube(t[s] || WS, r[s]);
}
function OM(e, t, n) {
  (this.id = e),
    (this.addr = n),
    (this.cache = []),
    (this.setValue = (function (e) {
      switch (e) {
        case 5126:
          return eM;
        case 35664:
          return tM;
        case 35665:
          return nM;
        case 35666:
          return iM;
        case 35674:
          return rM;
        case 35675:
          return sM;
        case 35676:
          return aM;
        case 5124:
        case 35670:
          return oM;
        case 35667:
        case 35671:
          return lM;
        case 35668:
        case 35672:
          return cM;
        case 35669:
        case 35673:
          return uM;
        case 5125:
          return hM;
        case 36294:
          return dM;
        case 36295:
          return pM;
        case 36296:
          return fM;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return mM;
        case 35679:
        case 36299:
        case 36307:
          return gM;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return vM;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
          return _M;
      }
    })(t.type));
}
function FM(e, t, n) {
  (this.id = e),
    (this.addr = n),
    (this.cache = []),
    (this.size = t.size),
    (this.setValue = (function (e) {
      switch (e) {
        case 5126:
          return yM;
        case 35664:
          return xM;
        case 35665:
          return bM;
        case 35666:
          return wM;
        case 35674:
          return SM;
        case 35675:
          return MM;
        case 35676:
          return TM;
        case 5124:
        case 35670:
          return CM;
        case 35667:
        case 35671:
          return EM;
        case 35668:
        case 35672:
          return AM;
        case 35669:
        case 35673:
          return PM;
        case 5125:
          return LM;
        case 36294:
          return IM;
        case 36295:
          return RM;
        case 36296:
          return DM;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return kM;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return NM;
      }
    })(t.type));
}
function zM(e) {
  (this.id = e), (this.seq = []), (this.map = {});
}
(FM.prototype.updateCache = function (e) {
  const t = this.cache;
  e instanceof Float32Array &&
    t.length !== e.length &&
    (this.cache = new Float32Array(e.length)),
    JS(t, e);
}),
  (zM.prototype.setValue = function (e, t, n) {
    const i = this.seq;
    for (let r = 0, s = i.length; r !== s; ++r) {
      const s = i[r];
      s.setValue(e, t[s.id], n);
    }
  });
const UM = /(\w+)(\])?(\[|\.)?/g;
function BM(e, t) {
  e.seq.push(t), (e.map[t.id] = t);
}
function VM(e, t, n) {
  const i = e.name,
    r = i.length;
  for (UM.lastIndex = 0; ; ) {
    const s = UM.exec(i),
      a = UM.lastIndex;
    let o = s[1];
    const l = "]" === s[2],
      c = s[3];
    if ((l && (o |= 0), void 0 === c || ("[" === c && a + 2 === r))) {
      BM(n, void 0 === c ? new OM(o, e, t) : new FM(o, e, t));
      break;
    }
    {
      let e = n.map[o];
      void 0 === e && ((e = new zM(o)), BM(n, e)), (n = e);
    }
  }
}
function HM(e, t) {
  (this.seq = []), (this.map = {});
  const n = e.getProgramParameter(t, 35718);
  for (let i = 0; i < n; ++i) {
    const n = e.getActiveUniform(t, i);
    VM(n, e.getUniformLocation(t, n.name), this);
  }
}
function GM(e, t, n) {
  const i = e.createShader(t);
  return e.shaderSource(i, n), e.compileShader(i), i;
}
(HM.prototype.setValue = function (e, t, n, i) {
  const r = this.map[t];
  void 0 !== r && r.setValue(e, n, i);
}),
  (HM.prototype.setOptional = function (e, t, n) {
    const i = t[n];
    void 0 !== i && this.setValue(e, n, i);
  }),
  (HM.upload = function (e, t, n, i) {
    for (let r = 0, s = t.length; r !== s; ++r) {
      const s = t[r],
        a = n[s.id];
      !1 !== a.needsUpdate && s.setValue(e, a.value, i);
    }
  }),
  (HM.seqWithValue = function (e, t) {
    const n = [];
    for (let i = 0, r = e.length; i !== r; ++i) {
      const r = e[i];
      r.id in t && n.push(r);
    }
    return n;
  });
let WM = 0;
function qM(e) {
  switch (e) {
    case 3e3:
    default:
      return ["Linear", "( value )"];
    case 3001:
      return ["sRGB", "( value )"];
    case 3002:
      return ["RGBE", "( value )"];
    case 3004:
      return ["RGBM", "( value, 7.0 )"];
    case 3005:
      return ["RGBM", "( value, 16.0 )"];
    case 3006:
      return ["RGBD", "( value, 256.0 )"];
    case 3007:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
    case 3003:
      return ["LogLuv", "( value )"];
  }
}
function jM(e, t, n) {
  const i = e.getShaderParameter(t, 35713),
    r = e.getShaderInfoLog(t).trim();
  return i && "" === r
    ? ""
    : n.toUpperCase() +
        "\n\n" +
        r +
        "\n\n" +
        (function (e) {
          const t = e.split("\n");
          for (let n = 0; n < t.length; n++) t[n] = n + 1 + ": " + t[n];
          return t.join("\n");
        })(e.getShaderSource(t));
}
function YM(e, t) {
  const n = qM(t);
  return (
    "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
  );
}
function XM(e, t) {
  const n = qM(t);
  return "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }";
}
function $M(e, t) {
  let n;
  switch (t) {
    case 1:
    default:
      n = "Linear";
      break;
    case 2:
      n = "Reinhard";
      break;
    case 3:
      n = "OptimizedCineon";
      break;
    case 4:
      n = "ACESFilmic";
      break;
    case 5:
      n = "Custom";
  }
  return (
    "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
  );
}
function ZM(e) {
  return "" !== e;
}
function KM(e, t) {
  return e
    .replace(/NUM_DIR_LIGHTS/g, t.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights)
    .replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, t.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
}
function JM(e, t) {
  return e
    .replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      t.numClippingPlanes - t.numClipIntersection
    );
}
const QM = /^[ \t]*#include +<([\w\d./]+)>/gm;
function eT(e) {
  return e.replace(QM, tT);
}
function tT(e, t) {
  const n = Zw[t];
  if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">");
  return eT(n);
}
const nT =
    /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
  iT =
    /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function rT(e) {
  return e.replace(iT, aT).replace(nT, sT);
}
function sT(e, t, n, i) {
  return aT(e, t, n, i);
}
function aT(e, t, n, i) {
  let r = "";
  for (let s = parseInt(t); s < parseInt(n); s++)
    r += i
      .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, s);
  return r;
}
function oT(e) {
  let t =
    "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
  return (
    "highp" === e.precision
      ? (t += "\n#define HIGH_PRECISION")
      : "mediump" === e.precision
      ? (t += "\n#define MEDIUM_PRECISION")
      : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"),
    t
  );
}
function lT(e, t, n, i) {
  const r = e.getContext(),
    s = n.defines;
  let a = n.vertexShader,
    o = n.fragmentShader;
  const l = (function (e) {
      let t = "SHADOWMAP_TYPE_BASIC";
      return (
        1 === e.shadowMapType
          ? (t = "SHADOWMAP_TYPE_PCF")
          : 2 === e.shadowMapType
          ? (t = "SHADOWMAP_TYPE_PCF_SOFT")
          : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"),
        t
      );
    })(n),
    c = (function (e) {
      let t = "ENVMAP_TYPE_CUBE";
      if (e.envMap)
        switch (e.envMapMode) {
          case 301:
          case 302:
            t = "ENVMAP_TYPE_CUBE";
            break;
          case 306:
          case 307:
            t = "ENVMAP_TYPE_CUBE_UV";
        }
      return t;
    })(n),
    u = (function (e) {
      let t = "ENVMAP_MODE_REFLECTION";
      if (e.envMap)
        switch (e.envMapMode) {
          case 302:
          case 307:
            t = "ENVMAP_MODE_REFRACTION";
        }
      return t;
    })(n),
    h = (function (e) {
      let t = "ENVMAP_BLENDING_NONE";
      if (e.envMap)
        switch (e.combine) {
          case 0:
            t = "ENVMAP_BLENDING_MULTIPLY";
            break;
          case 1:
            t = "ENVMAP_BLENDING_MIX";
            break;
          case 2:
            t = "ENVMAP_BLENDING_ADD";
        }
      return t;
    })(n),
    d = e.gammaFactor > 0 ? e.gammaFactor : 1,
    p = n.isWebGL2
      ? ""
      : (function (e) {
          return [
            e.extensionDerivatives ||
            e.envMapCubeUV ||
            e.bumpMap ||
            e.tangentSpaceNormalMap ||
            e.clearcoatNormalMap ||
            e.flatShading ||
            "physical" === e.shaderID
              ? "#extension GL_OES_standard_derivatives : enable"
              : "",
            (e.extensionFragDepth || e.logarithmicDepthBuffer) &&
            e.rendererExtensionFragDepth
              ? "#extension GL_EXT_frag_depth : enable"
              : "",
            e.extensionDrawBuffers && e.rendererExtensionDrawBuffers
              ? "#extension GL_EXT_draw_buffers : require"
              : "",
            (e.extensionShaderTextureLOD || e.envMap || e.transmission) &&
            e.rendererExtensionShaderTextureLod
              ? "#extension GL_EXT_shader_texture_lod : enable"
              : "",
          ]
            .filter(ZM)
            .join("\n");
        })(n),
    f = (function (e) {
      const t = [];
      for (const n in e) {
        const i = e[n];
        !1 !== i && t.push("#define " + n + " " + i);
      }
      return t.join("\n");
    })(s),
    m = r.createProgram();
  let g,
    v,
    _ = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
  n.isRawShaderMaterial
    ? ((g = [f].filter(ZM).join("\n")),
      g.length > 0 && (g += "\n"),
      (v = [p, f].filter(ZM).join("\n")),
      v.length > 0 && (v += "\n"))
    : ((g = [
        oT(n),
        "#define SHADER_NAME " + n.shaderName,
        f,
        n.instancing ? "#define USE_INSTANCING" : "",
        n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
        "#define GAMMA_FACTOR " + d,
        "#define MAX_BONES " + n.maxBones,
        n.useFog && n.fog ? "#define USE_FOG" : "",
        n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
        n.map ? "#define USE_MAP" : "",
        n.envMap ? "#define USE_ENVMAP" : "",
        n.envMap ? "#define " + u : "",
        n.lightMap ? "#define USE_LIGHTMAP" : "",
        n.aoMap ? "#define USE_AOMAP" : "",
        n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        n.bumpMap ? "#define USE_BUMPMAP" : "",
        n.normalMap ? "#define USE_NORMALMAP" : "",
        n.normalMap && n.objectSpaceNormalMap
          ? "#define OBJECTSPACE_NORMALMAP"
          : "",
        n.normalMap && n.tangentSpaceNormalMap
          ? "#define TANGENTSPACE_NORMALMAP"
          : "",
        n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        n.displacementMap && n.supportsVertexTextures
          ? "#define USE_DISPLACEMENTMAP"
          : "",
        n.specularMap ? "#define USE_SPECULARMAP" : "",
        n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
        n.specularTintMap ? "#define USE_SPECULARTINTMAP" : "",
        n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        n.metalnessMap ? "#define USE_METALNESSMAP" : "",
        n.alphaMap ? "#define USE_ALPHAMAP" : "",
        n.transmission ? "#define USE_TRANSMISSION" : "",
        n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        n.vertexTangents ? "#define USE_TANGENT" : "",
        n.vertexColors ? "#define USE_COLOR" : "",
        n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        n.vertexUvs ? "#define USE_UV" : "",
        n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        n.flatShading ? "#define FLAT_SHADED" : "",
        n.skinning ? "#define USE_SKINNING" : "",
        n.useVertexTexture ? "#define BONE_TEXTURE" : "",
        n.morphTargets ? "#define USE_MORPHTARGETS" : "",
        n.morphNormals && !1 === n.flatShading
          ? "#define USE_MORPHNORMALS"
          : "",
        n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
        n.morphTargets && n.isWebGL2
          ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount
          : "",
        n.doubleSided ? "#define DOUBLE_SIDED" : "",
        n.flipSided ? "#define FLIP_SIDED" : "",
        n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        n.shadowMapEnabled ? "#define " + l : "",
        n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "\tattribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "\tattribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_TANGENT",
        "\tattribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "\tattribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "\tattribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "\tattribute vec3 morphTarget0;",
        "\tattribute vec3 morphTarget1;",
        "\tattribute vec3 morphTarget2;",
        "\tattribute vec3 morphTarget3;",
        "\t#ifdef USE_MORPHNORMALS",
        "\t\tattribute vec3 morphNormal0;",
        "\t\tattribute vec3 morphNormal1;",
        "\t\tattribute vec3 morphNormal2;",
        "\t\tattribute vec3 morphNormal3;",
        "\t#else",
        "\t\tattribute vec3 morphTarget4;",
        "\t\tattribute vec3 morphTarget5;",
        "\t\tattribute vec3 morphTarget6;",
        "\t\tattribute vec3 morphTarget7;",
        "\t#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "\tattribute vec4 skinIndex;",
        "\tattribute vec4 skinWeight;",
        "#endif",
        "\n",
      ]
        .filter(ZM)
        .join("\n")),
      (v = [
        p,
        oT(n),
        "#define SHADER_NAME " + n.shaderName,
        f,
        "#define GAMMA_FACTOR " + d,
        n.useFog && n.fog ? "#define USE_FOG" : "",
        n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
        n.map ? "#define USE_MAP" : "",
        n.matcap ? "#define USE_MATCAP" : "",
        n.envMap ? "#define USE_ENVMAP" : "",
        n.envMap ? "#define " + c : "",
        n.envMap ? "#define " + u : "",
        n.envMap ? "#define " + h : "",
        n.lightMap ? "#define USE_LIGHTMAP" : "",
        n.aoMap ? "#define USE_AOMAP" : "",
        n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        n.bumpMap ? "#define USE_BUMPMAP" : "",
        n.normalMap ? "#define USE_NORMALMAP" : "",
        n.normalMap && n.objectSpaceNormalMap
          ? "#define OBJECTSPACE_NORMALMAP"
          : "",
        n.normalMap && n.tangentSpaceNormalMap
          ? "#define TANGENTSPACE_NORMALMAP"
          : "",
        n.clearcoat ? "#define USE_CLEARCOAT" : "",
        n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        n.specularMap ? "#define USE_SPECULARMAP" : "",
        n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
        n.specularTintMap ? "#define USE_SPECULARTINTMAP" : "",
        n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        n.metalnessMap ? "#define USE_METALNESSMAP" : "",
        n.alphaMap ? "#define USE_ALPHAMAP" : "",
        n.alphaTest ? "#define USE_ALPHATEST" : "",
        n.sheen ? "#define USE_SHEEN" : "",
        n.transmission ? "#define USE_TRANSMISSION" : "",
        n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        n.vertexTangents ? "#define USE_TANGENT" : "",
        n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
        n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        n.vertexUvs ? "#define USE_UV" : "",
        n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        n.gradientMap ? "#define USE_GRADIENTMAP" : "",
        n.flatShading ? "#define FLAT_SHADED" : "",
        n.doubleSided ? "#define DOUBLE_SIDED" : "",
        n.flipSided ? "#define FLIP_SIDED" : "",
        n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        n.shadowMapEnabled ? "#define " + l : "",
        n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
        n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        (n.extensionShaderTextureLOD || n.envMap) &&
        n.rendererExtensionShaderTextureLod
          ? "#define TEXTURE_LOD_EXT"
          : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        0 !== n.toneMapping ? "#define TONE_MAPPING" : "",
        0 !== n.toneMapping ? Zw.tonemapping_pars_fragment : "",
        0 !== n.toneMapping ? $M("toneMapping", n.toneMapping) : "",
        n.dithering ? "#define DITHERING" : "",
        1022 === n.format ? "#define OPAQUE" : "",
        Zw.encodings_pars_fragment,
        n.map ? YM("mapTexelToLinear", n.mapEncoding) : "",
        n.matcap ? YM("matcapTexelToLinear", n.matcapEncoding) : "",
        n.envMap ? YM("envMapTexelToLinear", n.envMapEncoding) : "",
        n.emissiveMap
          ? YM("emissiveMapTexelToLinear", n.emissiveMapEncoding)
          : "",
        n.specularTintMap
          ? YM("specularTintMapTexelToLinear", n.specularTintMapEncoding)
          : "",
        n.lightMap ? YM("lightMapTexelToLinear", n.lightMapEncoding) : "",
        XM("linearToOutputTexel", n.outputEncoding),
        n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
        "\n",
      ]
        .filter(ZM)
        .join("\n"))),
    (a = eT(a)),
    (a = KM(a, n)),
    (a = JM(a, n)),
    (o = eT(o)),
    (o = KM(o, n)),
    (o = JM(o, n)),
    (a = rT(a)),
    (o = rT(o)),
    n.isWebGL2 &&
      !0 !== n.isRawShaderMaterial &&
      ((_ = "#version 300 es\n"),
      (g =
        [
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join("\n") +
        "\n" +
        g),
      (v =
        [
          "#define varying in",
          "300 es" === n.glslVersion ? "" : "out highp vec4 pc_fragColor;",
          "300 es" === n.glslVersion ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join("\n") +
        "\n" +
        v));
  const y = _ + v + o,
    x = GM(r, 35633, _ + g + a),
    b = GM(r, 35632, y);
  if (
    (r.attachShader(m, x),
    r.attachShader(m, b),
    void 0 !== n.index0AttributeName
      ? r.bindAttribLocation(m, 0, n.index0AttributeName)
      : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"),
    r.linkProgram(m),
    e.debug.checkShaderErrors)
  ) {
    const e = r.getProgramInfoLog(m).trim(),
      t = r.getShaderInfoLog(x).trim(),
      n = r.getShaderInfoLog(b).trim();
    let i = !0,
      s = !0;
    if (!1 === r.getProgramParameter(m, 35714)) {
      i = !1;
      jM(r, x, "vertex"), jM(r, b, "fragment");
    } else "" !== e || ("" !== t && "" !== n) || (s = !1);
    s &&
      (this.diagnostics = {
        runnable: i,
        programLog: e,
        vertexShader: { log: t, prefix: g },
        fragmentShader: { log: n, prefix: v },
      });
  }
  let w, S;
  return (
    r.deleteShader(x),
    r.deleteShader(b),
    (this.getUniforms = function () {
      return void 0 === w && (w = new HM(r, m)), w;
    }),
    (this.getAttributes = function () {
      return (
        void 0 === S &&
          (S = (function (e, t) {
            const n = {},
              i = e.getProgramParameter(t, 35721);
            for (let r = 0; r < i; r++) {
              const i = e.getActiveAttrib(t, r),
                s = i.name;
              let a = 1;
              35674 === i.type && (a = 2),
                35675 === i.type && (a = 3),
                35676 === i.type && (a = 4),
                (n[s] = {
                  type: i.type,
                  location: e.getAttribLocation(t, s),
                  locationSize: a,
                });
            }
            return n;
          })(r, m)),
        S
      );
    }),
    (this.destroy = function () {
      i.releaseStatesOfProgram(this),
        r.deleteProgram(m),
        (this.program = void 0);
    }),
    (this.name = n.shaderName),
    (this.id = WM++),
    (this.cacheKey = t),
    (this.usedTimes = 1),
    (this.program = m),
    (this.vertexShader = x),
    (this.fragmentShader = b),
    this
  );
}
function cT(e, t, n, i, r, s, a) {
  const o = [],
    l = r.isWebGL2,
    c = r.logarithmicDepthBuffer,
    u = r.floatVertexTextures,
    h = r.maxVertexUniforms,
    d = r.vertexTextures;
  let p = r.precision;
  const f = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "toon",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite",
    },
    m = [
      "precision",
      "isWebGL2",
      "supportsVertexTextures",
      "outputEncoding",
      "instancing",
      "instancingColor",
      "map",
      "mapEncoding",
      "matcap",
      "matcapEncoding",
      "envMap",
      "envMapMode",
      "envMapEncoding",
      "envMapCubeUV",
      "lightMap",
      "lightMapEncoding",
      "aoMap",
      "emissiveMap",
      "emissiveMapEncoding",
      "bumpMap",
      "normalMap",
      "objectSpaceNormalMap",
      "tangentSpaceNormalMap",
      "clearcoat",
      "clearcoatMap",
      "clearcoatRoughnessMap",
      "clearcoatNormalMap",
      "displacementMap",
      "specularMap",
      "specularIntensityMap",
      "specularTintMap",
      "specularTintMapEncoding",
      "roughnessMap",
      "metalnessMap",
      "gradientMap",
      "alphaMap",
      "alphaTest",
      "combine",
      "vertexColors",
      "vertexAlphas",
      "vertexTangents",
      "vertexUvs",
      "uvsVertexOnly",
      "fog",
      "useFog",
      "fogExp2",
      "flatShading",
      "sizeAttenuation",
      "logarithmicDepthBuffer",
      "skinning",
      "maxBones",
      "useVertexTexture",
      "morphTargets",
      "morphNormals",
      "morphTargetsCount",
      "premultipliedAlpha",
      "numDirLights",
      "numPointLights",
      "numSpotLights",
      "numHemiLights",
      "numRectAreaLights",
      "numDirLightShadows",
      "numPointLightShadows",
      "numSpotLightShadows",
      "shadowMapEnabled",
      "shadowMapType",
      "toneMapping",
      "physicallyCorrectLights",
      "doubleSided",
      "flipSided",
      "numClippingPlanes",
      "numClipIntersection",
      "depthPacking",
      "dithering",
      "format",
      "sheen",
      "transmission",
      "transmissionMap",
      "thicknessMap",
    ];
  function g(e) {
    let t;
    return (
      (t =
        e && e.isTexture
          ? e.encoding
          : e && e.isWebGLRenderTarget
          ? e.texture.encoding
          : 3e3),
      l &&
        e &&
        e.isTexture &&
        1023 === e.format &&
        1009 === e.type &&
        3001 === e.encoding &&
        (t = 3e3),
      t
    );
  }
  return {
    getParameters: function (s, o, m, v, _) {
      const y = v.fog,
        x = s.isMeshStandardMaterial ? v.environment : null,
        b = (s.isMeshStandardMaterial ? n : t).get(s.envMap || x),
        w = f[s.type],
        S = _.isSkinnedMesh
          ? (function (e) {
              const t = e.skeleton.bones;
              if (u) return 1024;
              {
                const e = h,
                  n = Math.floor((e - 20) / 4),
                  i = Math.min(n, t.length);
                return i < t.length ? 0 : i;
              }
            })(_)
          : 0;
      let M, T;
      if (
        (null !== s.precision &&
          ((p = r.getMaxPrecision(s.precision)), s.precision),
        w)
      ) {
        const e = Jw[w];
        (M = e.vertexShader), (T = e.fragmentShader);
      } else (M = s.vertexShader), (T = s.fragmentShader);
      const C = e.getRenderTarget(),
        E = s.alphaTest > 0,
        A = s.clearcoat > 0;
      return {
        isWebGL2: l,
        shaderID: w,
        shaderName: s.type,
        vertexShader: M,
        fragmentShader: T,
        defines: s.defines,
        isRawShaderMaterial: !0 === s.isRawShaderMaterial,
        glslVersion: s.glslVersion,
        precision: p,
        instancing: !0 === _.isInstancedMesh,
        instancingColor: !0 === _.isInstancedMesh && null !== _.instanceColor,
        supportsVertexTextures: d,
        outputEncoding: null !== C ? g(C.texture) : e.outputEncoding,
        map: !!s.map,
        mapEncoding: g(s.map),
        matcap: !!s.matcap,
        matcapEncoding: g(s.matcap),
        envMap: !!b,
        envMapMode: b && b.mapping,
        envMapEncoding: g(b),
        envMapCubeUV: !!b && (306 === b.mapping || 307 === b.mapping),
        lightMap: !!s.lightMap,
        lightMapEncoding: g(s.lightMap),
        aoMap: !!s.aoMap,
        emissiveMap: !!s.emissiveMap,
        emissiveMapEncoding: g(s.emissiveMap),
        bumpMap: !!s.bumpMap,
        normalMap: !!s.normalMap,
        objectSpaceNormalMap: 1 === s.normalMapType,
        tangentSpaceNormalMap: 0 === s.normalMapType,
        clearcoat: A,
        clearcoatMap: A && !!s.clearcoatMap,
        clearcoatRoughnessMap: A && !!s.clearcoatRoughnessMap,
        clearcoatNormalMap: A && !!s.clearcoatNormalMap,
        displacementMap: !!s.displacementMap,
        roughnessMap: !!s.roughnessMap,
        metalnessMap: !!s.metalnessMap,
        specularMap: !!s.specularMap,
        specularIntensityMap: !!s.specularIntensityMap,
        specularTintMap: !!s.specularTintMap,
        specularTintMapEncoding: g(s.specularTintMap),
        alphaMap: !!s.alphaMap,
        alphaTest: E,
        gradientMap: !!s.gradientMap,
        sheen: s.sheen > 0,
        transmission: s.transmission > 0,
        transmissionMap: !!s.transmissionMap,
        thicknessMap: !!s.thicknessMap,
        combine: s.combine,
        vertexTangents:
          !!s.normalMap && !!_.geometry && !!_.geometry.attributes.tangent,
        vertexColors: s.vertexColors,
        vertexAlphas:
          !0 === s.vertexColors &&
          !!_.geometry &&
          !!_.geometry.attributes.color &&
          4 === _.geometry.attributes.color.itemSize,
        vertexUvs: !!(
          s.map ||
          s.bumpMap ||
          s.normalMap ||
          s.specularMap ||
          s.alphaMap ||
          s.emissiveMap ||
          s.roughnessMap ||
          s.metalnessMap ||
          s.clearcoatMap ||
          s.clearcoatRoughnessMap ||
          s.clearcoatNormalMap ||
          s.displacementMap ||
          s.transmissionMap ||
          s.thicknessMap ||
          s.specularIntensityMap ||
          s.specularTintMap
        ),
        uvsVertexOnly: !(
          s.map ||
          s.bumpMap ||
          s.normalMap ||
          s.specularMap ||
          s.alphaMap ||
          s.emissiveMap ||
          s.roughnessMap ||
          s.metalnessMap ||
          s.clearcoatNormalMap ||
          s.transmission > 0 ||
          s.transmissionMap ||
          s.thicknessMap ||
          s.specularIntensityMap ||
          s.specularTintMap ||
          !s.displacementMap
        ),
        fog: !!y,
        useFog: s.fog,
        fogExp2: y && y.isFogExp2,
        flatShading: !!s.flatShading,
        sizeAttenuation: s.sizeAttenuation,
        logarithmicDepthBuffer: c,
        skinning: !0 === _.isSkinnedMesh && S > 0,
        maxBones: S,
        useVertexTexture: u,
        morphTargets: !!_.geometry && !!_.geometry.morphAttributes.position,
        morphNormals: !!_.geometry && !!_.geometry.morphAttributes.normal,
        morphTargetsCount:
          _.geometry && _.geometry.morphAttributes.position
            ? _.geometry.morphAttributes.position.length
            : 0,
        numDirLights: o.directional.length,
        numPointLights: o.point.length,
        numSpotLights: o.spot.length,
        numRectAreaLights: o.rectArea.length,
        numHemiLights: o.hemi.length,
        numDirLightShadows: o.directionalShadowMap.length,
        numPointLightShadows: o.pointShadowMap.length,
        numSpotLightShadows: o.spotShadowMap.length,
        numClippingPlanes: a.numPlanes,
        numClipIntersection: a.numIntersection,
        format: s.format,
        dithering: s.dithering,
        shadowMapEnabled: e.shadowMap.enabled && m.length > 0,
        shadowMapType: e.shadowMap.type,
        toneMapping: s.toneMapped ? e.toneMapping : 0,
        physicallyCorrectLights: e.physicallyCorrectLights,
        premultipliedAlpha: s.premultipliedAlpha,
        doubleSided: 2 === s.side,
        flipSided: 1 === s.side,
        depthPacking: void 0 !== s.depthPacking && s.depthPacking,
        index0AttributeName: s.index0AttributeName,
        extensionDerivatives: s.extensions && s.extensions.derivatives,
        extensionFragDepth: s.extensions && s.extensions.fragDepth,
        extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,
        extensionShaderTextureLOD:
          s.extensions && s.extensions.shaderTextureLOD,
        rendererExtensionFragDepth: l || i.has("EXT_frag_depth"),
        rendererExtensionDrawBuffers: l || i.has("WEBGL_draw_buffers"),
        rendererExtensionShaderTextureLod: l || i.has("EXT_shader_texture_lod"),
        customProgramCacheKey: s.customProgramCacheKey(),
      };
    },
    getProgramCacheKey: function (t) {
      const n = [];
      if (
        (t.shaderID
          ? n.push(t.shaderID)
          : (n.push(t.fragmentShader), n.push(t.vertexShader)),
        void 0 !== t.defines)
      )
        for (const e in t.defines) n.push(e), n.push(t.defines[e]);
      if (!1 === t.isRawShaderMaterial) {
        for (let e = 0; e < m.length; e++) n.push(t[m[e]]);
        n.push(e.outputEncoding), n.push(e.gammaFactor);
      }
      return n.push(t.customProgramCacheKey), n.join();
    },
    getUniforms: function (e) {
      const t = f[e.type];
      let n;
      if (t) {
        const e = Jw[t];
        n = Dw.clone(e.uniforms);
      } else n = e.uniforms;
      return n;
    },
    acquireProgram: function (t, n) {
      let i;
      for (let e = 0, r = o.length; e < r; e++) {
        const t = o[e];
        if (t.cacheKey === n) {
          (i = t), ++i.usedTimes;
          break;
        }
      }
      return void 0 === i && ((i = new lT(e, n, t, s)), o.push(i)), i;
    },
    releaseProgram: function (e) {
      if (0 == --e.usedTimes) {
        const t = o.indexOf(e);
        (o[t] = o[o.length - 1]), o.pop(), e.destroy();
      }
    },
    programs: o,
  };
}
function uT() {
  let e = new WeakMap();
  return {
    get: function (t) {
      let n = e.get(t);
      return void 0 === n && ((n = {}), e.set(t, n)), n;
    },
    remove: function (t) {
      e.delete(t);
    },
    update: function (t, n, i) {
      e.get(t)[n] = i;
    },
    dispose: function () {
      e = new WeakMap();
    },
  };
}
function hT(e, t) {
  return e.groupOrder !== t.groupOrder
    ? e.groupOrder - t.groupOrder
    : e.renderOrder !== t.renderOrder
    ? e.renderOrder - t.renderOrder
    : e.program !== t.program
    ? e.program.id - t.program.id
    : e.material.id !== t.material.id
    ? e.material.id - t.material.id
    : e.z !== t.z
    ? e.z - t.z
    : e.id - t.id;
}
function dT(e, t) {
  return e.groupOrder !== t.groupOrder
    ? e.groupOrder - t.groupOrder
    : e.renderOrder !== t.renderOrder
    ? e.renderOrder - t.renderOrder
    : e.z !== t.z
    ? t.z - e.z
    : e.id - t.id;
}
function pT(e) {
  const t = [];
  let n = 0;
  const i = [],
    r = [],
    s = [],
    a = { id: -1 };
  function o(i, r, s, o, l, c) {
    let u = t[n];
    const h = e.get(s);
    return (
      void 0 === u
        ? ((u = {
            id: i.id,
            object: i,
            geometry: r,
            material: s,
            program: h.program || a,
            groupOrder: o,
            renderOrder: i.renderOrder,
            z: l,
            group: c,
          }),
          (t[n] = u))
        : ((u.id = i.id),
          (u.object = i),
          (u.geometry = r),
          (u.material = s),
          (u.program = h.program || a),
          (u.groupOrder = o),
          (u.renderOrder = i.renderOrder),
          (u.z = l),
          (u.group = c)),
      n++,
      u
    );
  }
  return {
    opaque: i,
    transmissive: r,
    transparent: s,
    init: function () {
      (n = 0), (i.length = 0), (r.length = 0), (s.length = 0);
    },
    push: function (e, t, n, a, l, c) {
      const u = o(e, t, n, a, l, c);
      n.transmission > 0
        ? r.push(u)
        : !0 === n.transparent
        ? s.push(u)
        : i.push(u);
    },
    unshift: function (e, t, n, a, l, c) {
      const u = o(e, t, n, a, l, c);
      n.transmission > 0
        ? r.unshift(u)
        : !0 === n.transparent
        ? s.unshift(u)
        : i.unshift(u);
    },
    finish: function () {
      for (let e = n, i = t.length; e < i; e++) {
        const n = t[e];
        if (null === n.id) break;
        (n.id = null),
          (n.object = null),
          (n.geometry = null),
          (n.material = null),
          (n.program = null),
          (n.group = null);
      }
    },
    sort: function (e, t) {
      i.length > 1 && i.sort(e || hT),
        r.length > 1 && r.sort(t || dT),
        s.length > 1 && s.sort(t || dT);
    },
  };
}
function fT(e) {
  let t = new WeakMap();
  return {
    get: function (n, i) {
      let r;
      return (
        !1 === t.has(n)
          ? ((r = new pT(e)), t.set(n, [r]))
          : i >= t.get(n).length
          ? ((r = new pT(e)), t.get(n).push(r))
          : (r = t.get(n)[i]),
        r
      );
    },
    dispose: function () {
      t = new WeakMap();
    },
  };
}
function mT() {
  const e = {};
  return {
    get: function (t) {
      if (void 0 !== e[t.id]) return e[t.id];
      let n;
      switch (t.type) {
        case "DirectionalLight":
          n = { direction: new Cx(), color: new Xb() };
          break;
        case "SpotLight":
          n = {
            position: new Cx(),
            direction: new Cx(),
            color: new Xb(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          n = { position: new Cx(), color: new Xb(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          n = {
            direction: new Cx(),
            skyColor: new Xb(),
            groundColor: new Xb(),
          };
          break;
        case "RectAreaLight":
          n = {
            color: new Xb(),
            position: new Cx(),
            halfWidth: new Cx(),
            halfHeight: new Cx(),
          };
      }
      return (e[t.id] = n), n;
    },
  };
}
let gT = 0;
function vT(e, t) {
  return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0);
}
function _T(e, t) {
  const n = new mT(),
    i = (function () {
      const e = {};
      return {
        get: function (t) {
          if (void 0 !== e[t.id]) return e[t.id];
          let n;
          switch (t.type) {
            case "DirectionalLight":
            case "SpotLight":
              n = {
                shadowBias: 0,
                shadowNormalBias: 0,
                shadowRadius: 1,
                shadowMapSize: new fx(),
              };
              break;
            case "PointLight":
              n = {
                shadowBias: 0,
                shadowNormalBias: 0,
                shadowRadius: 1,
                shadowMapSize: new fx(),
                shadowCameraNear: 1,
                shadowCameraFar: 1e3,
              };
          }
          return (e[t.id] = n), n;
        },
      };
    })(),
    r = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotShadow: [],
      spotShadowMap: [],
      spotShadowMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
    };
  for (let l = 0; l < 9; l++) r.probe.push(new Cx());
  const s = new Cx(),
    a = new ib(),
    o = new ib();
  return {
    setup: function (s, a) {
      let o = 0,
        l = 0,
        c = 0;
      for (let e = 0; e < 9; e++) r.probe[e].set(0, 0, 0);
      let u = 0,
        h = 0,
        d = 0,
        p = 0,
        f = 0,
        m = 0,
        g = 0,
        v = 0;
      s.sort(vT);
      const _ = !0 !== a ? Math.PI : 1;
      for (let e = 0, t = s.length; e < t; e++) {
        const t = s[e],
          a = t.color,
          y = t.intensity,
          x = t.distance,
          b = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
        if (t.isAmbientLight)
          (o += a.r * y * _), (l += a.g * y * _), (c += a.b * y * _);
        else if (t.isLightProbe)
          for (let e = 0; e < 9; e++)
            r.probe[e].addScaledVector(t.sh.coefficients[e], y);
        else if (t.isDirectionalLight) {
          const e = n.get(t);
          if (
            (e.color.copy(t.color).multiplyScalar(t.intensity * _),
            t.castShadow)
          ) {
            const e = t.shadow,
              n = i.get(t);
            (n.shadowBias = e.bias),
              (n.shadowNormalBias = e.normalBias),
              (n.shadowRadius = e.radius),
              (n.shadowMapSize = e.mapSize),
              (r.directionalShadow[u] = n),
              (r.directionalShadowMap[u] = b),
              (r.directionalShadowMatrix[u] = t.shadow.matrix),
              m++;
          }
          (r.directional[u] = e), u++;
        } else if (t.isSpotLight) {
          const e = n.get(t);
          if (
            (e.position.setFromMatrixPosition(t.matrixWorld),
            e.color.copy(a).multiplyScalar(y * _),
            (e.distance = x),
            (e.coneCos = Math.cos(t.angle)),
            (e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra))),
            (e.decay = t.decay),
            t.castShadow)
          ) {
            const e = t.shadow,
              n = i.get(t);
            (n.shadowBias = e.bias),
              (n.shadowNormalBias = e.normalBias),
              (n.shadowRadius = e.radius),
              (n.shadowMapSize = e.mapSize),
              (r.spotShadow[d] = n),
              (r.spotShadowMap[d] = b),
              (r.spotShadowMatrix[d] = t.shadow.matrix),
              v++;
          }
          (r.spot[d] = e), d++;
        } else if (t.isRectAreaLight) {
          const e = n.get(t);
          e.color.copy(a).multiplyScalar(y),
            e.halfWidth.set(0.5 * t.width, 0, 0),
            e.halfHeight.set(0, 0.5 * t.height, 0),
            (r.rectArea[p] = e),
            p++;
        } else if (t.isPointLight) {
          const e = n.get(t);
          if (
            (e.color.copy(t.color).multiplyScalar(t.intensity * _),
            (e.distance = t.distance),
            (e.decay = t.decay),
            t.castShadow)
          ) {
            const e = t.shadow,
              n = i.get(t);
            (n.shadowBias = e.bias),
              (n.shadowNormalBias = e.normalBias),
              (n.shadowRadius = e.radius),
              (n.shadowMapSize = e.mapSize),
              (n.shadowCameraNear = e.camera.near),
              (n.shadowCameraFar = e.camera.far),
              (r.pointShadow[h] = n),
              (r.pointShadowMap[h] = b),
              (r.pointShadowMatrix[h] = t.shadow.matrix),
              g++;
          }
          (r.point[h] = e), h++;
        } else if (t.isHemisphereLight) {
          const e = n.get(t);
          e.skyColor.copy(t.color).multiplyScalar(y * _),
            e.groundColor.copy(t.groundColor).multiplyScalar(y * _),
            (r.hemi[f] = e),
            f++;
        }
      }
      p > 0 &&
        (t.isWebGL2 || !0 === e.has("OES_texture_float_linear")
          ? ((r.rectAreaLTC1 = Kw.LTC_FLOAT_1),
            (r.rectAreaLTC2 = Kw.LTC_FLOAT_2))
          : !0 === e.has("OES_texture_half_float_linear") &&
            ((r.rectAreaLTC1 = Kw.LTC_HALF_1),
            (r.rectAreaLTC2 = Kw.LTC_HALF_2))),
        (r.ambient[0] = o),
        (r.ambient[1] = l),
        (r.ambient[2] = c);
      const y = r.hash;
      (y.directionalLength === u &&
        y.pointLength === h &&
        y.spotLength === d &&
        y.rectAreaLength === p &&
        y.hemiLength === f &&
        y.numDirectionalShadows === m &&
        y.numPointShadows === g &&
        y.numSpotShadows === v) ||
        ((r.directional.length = u),
        (r.spot.length = d),
        (r.rectArea.length = p),
        (r.point.length = h),
        (r.hemi.length = f),
        (r.directionalShadow.length = m),
        (r.directionalShadowMap.length = m),
        (r.pointShadow.length = g),
        (r.pointShadowMap.length = g),
        (r.spotShadow.length = v),
        (r.spotShadowMap.length = v),
        (r.directionalShadowMatrix.length = m),
        (r.pointShadowMatrix.length = g),
        (r.spotShadowMatrix.length = v),
        (y.directionalLength = u),
        (y.pointLength = h),
        (y.spotLength = d),
        (y.rectAreaLength = p),
        (y.hemiLength = f),
        (y.numDirectionalShadows = m),
        (y.numPointShadows = g),
        (y.numSpotShadows = v),
        (r.version = gT++));
    },
    setupView: function (e, t) {
      let n = 0,
        i = 0,
        l = 0,
        c = 0,
        u = 0;
      const h = t.matrixWorldInverse;
      for (let d = 0, p = e.length; d < p; d++) {
        const t = e[d];
        if (t.isDirectionalLight) {
          const e = r.directional[n];
          e.direction.setFromMatrixPosition(t.matrixWorld),
            s.setFromMatrixPosition(t.target.matrixWorld),
            e.direction.sub(s),
            e.direction.transformDirection(h),
            n++;
        } else if (t.isSpotLight) {
          const e = r.spot[l];
          e.position.setFromMatrixPosition(t.matrixWorld),
            e.position.applyMatrix4(h),
            e.direction.setFromMatrixPosition(t.matrixWorld),
            s.setFromMatrixPosition(t.target.matrixWorld),
            e.direction.sub(s),
            e.direction.transformDirection(h),
            l++;
        } else if (t.isRectAreaLight) {
          const e = r.rectArea[c];
          e.position.setFromMatrixPosition(t.matrixWorld),
            e.position.applyMatrix4(h),
            o.identity(),
            a.copy(t.matrixWorld),
            a.premultiply(h),
            o.extractRotation(a),
            e.halfWidth.set(0.5 * t.width, 0, 0),
            e.halfHeight.set(0, 0.5 * t.height, 0),
            e.halfWidth.applyMatrix4(o),
            e.halfHeight.applyMatrix4(o),
            c++;
        } else if (t.isPointLight) {
          const e = r.point[i];
          e.position.setFromMatrixPosition(t.matrixWorld),
            e.position.applyMatrix4(h),
            i++;
        } else if (t.isHemisphereLight) {
          const e = r.hemi[u];
          e.direction.setFromMatrixPosition(t.matrixWorld),
            e.direction.transformDirection(h),
            e.direction.normalize(),
            u++;
        }
      }
    },
    state: r,
  };
}
function yT(e, t) {
  const n = new _T(e, t),
    i = [],
    r = [];
  return {
    init: function () {
      (i.length = 0), (r.length = 0);
    },
    state: { lightsArray: i, shadowsArray: r, lights: n },
    setupLights: function (e) {
      n.setup(i, e);
    },
    setupLightsView: function (e) {
      n.setupView(i, e);
    },
    pushLight: function (e) {
      i.push(e);
    },
    pushShadow: function (e) {
      r.push(e);
    },
  };
}
function xT(e, t) {
  let n = new WeakMap();
  return {
    get: function (i, r = 0) {
      let s;
      return (
        !1 === n.has(i)
          ? ((s = new yT(e, t)), n.set(i, [s]))
          : r >= n.get(i).length
          ? ((s = new yT(e, t)), n.get(i).push(s))
          : (s = n.get(i)[r]),
        s
      );
    },
    dispose: function () {
      n = new WeakMap();
    },
  };
}
class bT extends Vb {
  constructor(e) {
    super(),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = 3200),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
bT.prototype.isMeshDepthMaterial = !0;
class wT extends Vb {
  constructor(e) {
    super(),
      (this.type = "MeshDistanceMaterial"),
      (this.referencePosition = new Cx()),
      (this.nearDistance = 1),
      (this.farDistance = 1e3),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.fog = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.referencePosition.copy(e.referencePosition),
      (this.nearDistance = e.nearDistance),
      (this.farDistance = e.farDistance),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
wT.prototype.isMeshDistanceMaterial = !0;
function ST(e, t, n) {
  let i = new jw();
  const r = new fx(),
    s = new fx(),
    a = new wx(),
    o = new bT({ depthPacking: 3201 }),
    l = new wT(),
    c = {},
    u = n.maxTextureSize,
    h = { 0: 1, 1: 0, 2: 2 },
    d = new kw({
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new fx() },
        radius: { value: 4 },
        samples: { value: 8 },
      },
      vertexShader: "void main(){gl_Position=vec4(position,1.0);}",
      fragmentShader:
        "uniform sampler2D shadow_pass;uniform vec2 resolution;uniform float radius;uniform float samples;\n#include <packing>\nvoid main(){float mean=0.0;float squared_mean=0.0;float uvStride=samples<=1.0?0.0:2.0/(samples-1.0);float uvStart=samples<=1.0?0.0:-1.0;for(float i=0.0;i<samples;i++){float uvOffset=uvStart+i*uvStride;\n#ifdef HORIZONTAL_PASS\nvec2 distribution=unpackRGBATo2Half(texture2D(shadow_pass,(gl_FragCoord.xy+vec2(uvOffset,0.0)*radius)/resolution));mean+=distribution.x;squared_mean+=distribution.y*distribution.y+distribution.x*distribution.x;\n#else\nfloat depth=unpackRGBAToDepth(texture2D(shadow_pass,(gl_FragCoord.xy+vec2(0.0,uvOffset)*radius)/resolution));mean+=depth;squared_mean+=depth*depth;\n#endif\n}mean=mean/samples;squared_mean=squared_mean/samples;float std_dev=sqrt(squared_mean-mean*mean);gl_FragColor=pack2HalfToRGBA(vec2(mean,std_dev));}",
    }),
    p = d.clone();
  p.defines.HORIZONTAL_PASS = 1;
  const f = new uw();
  f.setAttribute(
    "position",
    new Jb(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const m = new Aw(f, d),
    g = this;
  function v(n, i) {
    const r = t.update(m);
    (d.uniforms.shadow_pass.value = n.map.texture),
      (d.uniforms.resolution.value = n.mapSize),
      (d.uniforms.radius.value = n.radius),
      (d.uniforms.samples.value = n.blurSamples),
      e.setRenderTarget(n.mapPass),
      e.clear(),
      e.renderBufferDirect(i, null, r, d, m, null),
      (p.uniforms.shadow_pass.value = n.mapPass.texture),
      (p.uniforms.resolution.value = n.mapSize),
      (p.uniforms.radius.value = n.radius),
      (p.uniforms.samples.value = n.blurSamples),
      e.setRenderTarget(n.map),
      e.clear(),
      e.renderBufferDirect(i, null, r, p, m, null);
  }
  function _(t, n, i, r, s, a, u) {
    let d = null;
    const p =
      !0 === r.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
    if (
      ((d = void 0 !== p ? p : !0 === r.isPointLight ? l : o),
      (e.localClippingEnabled &&
        !0 === i.clipShadows &&
        0 !== i.clippingPlanes.length) ||
        (i.displacementMap && 0 !== i.displacementScale) ||
        (i.alphaMap && i.alphaTest > 0))
    ) {
      const e = d.uuid,
        t = i.uuid;
      let n = c[e];
      void 0 === n && ((n = {}), (c[e] = n));
      let r = n[t];
      void 0 === r && ((r = d.clone()), (n[t] = r)), (d = r);
    }
    return (
      (d.visible = i.visible),
      (d.wireframe = i.wireframe),
      (d.side =
        3 === u
          ? null !== i.shadowSide
            ? i.shadowSide
            : i.side
          : null !== i.shadowSide
          ? i.shadowSide
          : h[i.side]),
      (d.alphaMap = i.alphaMap),
      (d.alphaTest = i.alphaTest),
      (d.clipShadows = i.clipShadows),
      (d.clippingPlanes = i.clippingPlanes),
      (d.clipIntersection = i.clipIntersection),
      (d.displacementMap = i.displacementMap),
      (d.displacementScale = i.displacementScale),
      (d.displacementBias = i.displacementBias),
      (d.wireframeLinewidth = i.wireframeLinewidth),
      (d.linewidth = i.linewidth),
      !0 === r.isPointLight &&
        !0 === d.isMeshDistanceMaterial &&
        (d.referencePosition.setFromMatrixPosition(r.matrixWorld),
        (d.nearDistance = s),
        (d.farDistance = a)),
      d
    );
  }
  function y(n, r, s, a, o) {
    if (!1 === n.visible) return;
    if (
      n.layers.test(r.layers) &&
      (n.isMesh || n.isLine || n.isPoints) &&
      (n.castShadow || (n.receiveShadow && 3 === o)) &&
      (!n.frustumCulled || i.intersectsObject(n))
    ) {
      n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
      const i = t.update(n),
        r = n.material;
      if (Array.isArray(r)) {
        const t = i.groups;
        for (let l = 0, c = t.length; l < c; l++) {
          const c = t[l],
            u = r[c.materialIndex];
          if (u && u.visible) {
            const t = _(n, 0, u, a, s.near, s.far, o);
            e.renderBufferDirect(s, null, i, t, n, c);
          }
        }
      } else if (r.visible) {
        const t = _(n, 0, r, a, s.near, s.far, o);
        e.renderBufferDirect(s, null, i, t, n, null);
      }
    }
    const l = n.children;
    for (let e = 0, t = l.length; e < t; e++) y(l[e], r, s, a, o);
  }
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = 1),
    (this.render = function (t, n, o) {
      if (!1 === g.enabled) return;
      if (!1 === g.autoUpdate && !1 === g.needsUpdate) return;
      if (0 === t.length) return;
      const l = e.getRenderTarget(),
        c = e.getActiveCubeFace(),
        h = e.getActiveMipmapLevel(),
        d = e.state;
      d.setBlending(0),
        d.buffers.color.setClear(1, 1, 1, 1),
        d.buffers.depth.setTest(!0),
        d.setScissorTest(!1);
      for (let p = 0, f = t.length; p < f; p++) {
        const l = t[p],
          c = l.shadow;
        if (void 0 === c) continue;
        if (!1 === c.autoUpdate && !1 === c.needsUpdate) continue;
        r.copy(c.mapSize);
        const h = c.getFrameExtents();
        if (
          (r.multiply(h),
          s.copy(c.mapSize),
          (r.x > u || r.y > u) &&
            (r.x > u &&
              ((s.x = Math.floor(u / h.x)),
              (r.x = s.x * h.x),
              (c.mapSize.x = s.x)),
            r.y > u &&
              ((s.y = Math.floor(u / h.y)),
              (r.y = s.y * h.y),
              (c.mapSize.y = s.y))),
          null === c.map && !c.isPointLightShadow && 3 === this.type)
        ) {
          const e = { minFilter: 1006, magFilter: 1006, format: 1023 };
          (c.map = new Sx(r.x, r.y, e)),
            (c.map.texture.name = l.name + ".shadowMap"),
            (c.mapPass = new Sx(r.x, r.y, e)),
            c.camera.updateProjectionMatrix();
        }
        if (null === c.map) {
          const e = { minFilter: 1003, magFilter: 1003, format: 1023 };
          (c.map = new Sx(r.x, r.y, e)),
            (c.map.texture.name = l.name + ".shadowMap"),
            c.camera.updateProjectionMatrix();
        }
        e.setRenderTarget(c.map), e.clear();
        const f = c.getViewportCount();
        for (let e = 0; e < f; e++) {
          const t = c.getViewport(e);
          a.set(s.x * t.x, s.y * t.y, s.x * t.z, s.y * t.w),
            d.viewport(a),
            c.updateMatrices(l, e),
            (i = c.getFrustum()),
            y(n, o, c.camera, l, this.type);
        }
        c.isPointLightShadow || 3 !== this.type || v(c, o),
          (c.needsUpdate = !1);
      }
      (g.needsUpdate = !1), e.setRenderTarget(l, c, h);
    });
}
function MT(e, t, n) {
  const i = n.isWebGL2;
  const r = new (function () {
      let t = !1;
      const n = new wx();
      let i = null;
      const r = new wx(0, 0, 0, 0);
      return {
        setMask: function (n) {
          i === n || t || (e.colorMask(n, n, n, n), (i = n));
        },
        setLocked: function (e) {
          t = e;
        },
        setClear: function (t, i, s, a, o) {
          !0 === o && ((t *= a), (i *= a), (s *= a)),
            n.set(t, i, s, a),
            !1 === r.equals(n) && (e.clearColor(t, i, s, a), r.copy(n));
        },
        reset: function () {
          (t = !1), (i = null), r.set(-1, 0, 0, 0);
        },
      };
    })(),
    s = new (function () {
      let t = !1,
        n = null,
        i = null,
        r = null;
      return {
        setTest: function (e) {
          e ? F(2929) : z(2929);
        },
        setMask: function (i) {
          n === i || t || (e.depthMask(i), (n = i));
        },
        setFunc: function (t) {
          if (i !== t) {
            if (t)
              switch (t) {
                case 0:
                  e.depthFunc(512);
                  break;
                case 1:
                  e.depthFunc(519);
                  break;
                case 2:
                  e.depthFunc(513);
                  break;
                case 3:
                default:
                  e.depthFunc(515);
                  break;
                case 4:
                  e.depthFunc(514);
                  break;
                case 5:
                  e.depthFunc(518);
                  break;
                case 6:
                  e.depthFunc(516);
                  break;
                case 7:
                  e.depthFunc(517);
              }
            else e.depthFunc(515);
            i = t;
          }
        },
        setLocked: function (e) {
          t = e;
        },
        setClear: function (t) {
          r !== t && (e.clearDepth(t), (r = t));
        },
        reset: function () {
          (t = !1), (n = null), (i = null), (r = null);
        },
      };
    })(),
    a = new (function () {
      let t = !1,
        n = null,
        i = null,
        r = null,
        s = null,
        a = null,
        o = null,
        l = null,
        c = null;
      return {
        setTest: function (e) {
          t || (e ? F(2960) : z(2960));
        },
        setMask: function (i) {
          n === i || t || (e.stencilMask(i), (n = i));
        },
        setFunc: function (t, n, a) {
          (i === t && r === n && s === a) ||
            (e.stencilFunc(t, n, a), (i = t), (r = n), (s = a));
        },
        setOp: function (t, n, i) {
          (a === t && o === n && l === i) ||
            (e.stencilOp(t, n, i), (a = t), (o = n), (l = i));
        },
        setLocked: function (e) {
          t = e;
        },
        setClear: function (t) {
          c !== t && (e.clearStencil(t), (c = t));
        },
        reset: function () {
          (t = !1),
            (n = null),
            (i = null),
            (r = null),
            (s = null),
            (a = null),
            (o = null),
            (l = null),
            (c = null);
        },
      };
    })();
  let o = {},
    l = null,
    c = {},
    u = null,
    h = !1,
    d = null,
    p = null,
    f = null,
    m = null,
    g = null,
    v = null,
    _ = null,
    y = !1,
    x = null,
    b = null,
    w = null,
    S = null,
    M = null;
  const T = e.getParameter(35661);
  let C = !1,
    E = 0;
  const A = e.getParameter(7938);
  -1 !== A.indexOf("WebGL")
    ? ((E = parseFloat(/^WebGL (\d)/.exec(A)[1])), (C = E >= 1))
    : -1 !== A.indexOf("OpenGL ES") &&
      ((E = parseFloat(/^OpenGL ES (\d)/.exec(A)[1])), (C = E >= 2));
  let P = null,
    L = {};
  const I = e.getParameter(3088),
    R = e.getParameter(2978),
    D = new wx().fromArray(I),
    k = new wx().fromArray(R);
  function N(t, n, i) {
    const r = new Uint8Array(4),
      s = e.createTexture();
    e.bindTexture(t, s),
      e.texParameteri(t, 10241, 9728),
      e.texParameteri(t, 10240, 9728);
    for (let a = 0; a < i; a++)
      e.texImage2D(n + a, 0, 6408, 1, 1, 0, 6408, 5121, r);
    return s;
  }
  const O = {};
  function F(t) {
    !0 !== o[t] && (e.enable(t), (o[t] = !0));
  }
  function z(t) {
    !1 !== o[t] && (e.disable(t), (o[t] = !1));
  }
  (O[3553] = N(3553, 3553, 1)),
    (O[34067] = N(34067, 34069, 6)),
    r.setClear(0, 0, 0, 1),
    s.setClear(1),
    a.setClear(0),
    F(2929),
    s.setFunc(3),
    H(!1),
    G(1),
    F(2884),
    V(0);
  const U = { 100: 32774, 101: 32778, 102: 32779 };
  if (i) (U[103] = 32775), (U[104] = 32776);
  else {
    const e = t.get("EXT_blend_minmax");
    null !== e && ((U[103] = e.MIN_EXT), (U[104] = e.MAX_EXT));
  }
  const B = {
    200: 0,
    201: 1,
    202: 768,
    204: 770,
    210: 776,
    208: 774,
    206: 772,
    203: 769,
    205: 771,
    209: 775,
    207: 773,
  };
  function V(t, n, i, r, s, a, o, l) {
    if (0 !== t) {
      if ((!1 === h && (F(3042), (h = !0)), 5 === t))
        (s = s || n),
          (a = a || i),
          (o = o || r),
          (n === p && s === g) ||
            (e.blendEquationSeparate(U[n], U[s]), (p = n), (g = s)),
          (i === f && r === m && a === v && o === _) ||
            (e.blendFuncSeparate(B[i], B[r], B[a], B[o]),
            (f = i),
            (m = r),
            (v = a),
            (_ = o)),
          (d = t),
          (y = null);
      else if (t !== d || l !== y) {
        if (
          ((100 === p && 100 === g) ||
            (e.blendEquation(32774), (p = 100), (g = 100)),
          l)
        )
          switch (t) {
            case 1:
              e.blendFuncSeparate(1, 771, 1, 771);
              break;
            case 2:
              e.blendFunc(1, 1);
              break;
            case 3:
              e.blendFuncSeparate(0, 0, 769, 771);
              break;
            case 4:
              e.blendFuncSeparate(0, 768, 0, 770);
          }
        else
          switch (t) {
            case 1:
              e.blendFuncSeparate(770, 771, 1, 771);
              break;
            case 2:
              e.blendFunc(770, 1);
              break;
            case 3:
              e.blendFunc(0, 769);
              break;
            case 4:
              e.blendFunc(0, 768);
          }
        (f = null), (m = null), (v = null), (_ = null), (d = t), (y = l);
      }
    } else !0 === h && (z(3042), (h = !1));
  }
  function H(t) {
    x !== t && (t ? e.frontFace(2304) : e.frontFace(2305), (x = t));
  }
  function G(t) {
    0 !== t
      ? (F(2884),
        t !== b &&
          (1 === t
            ? e.cullFace(1029)
            : 2 === t
            ? e.cullFace(1028)
            : e.cullFace(1032)))
      : z(2884),
      (b = t);
  }
  function W(t, n, i) {
    t
      ? (F(32823),
        (S === n && M === i) || (e.polygonOffset(n, i), (S = n), (M = i)))
      : z(32823);
  }
  function q(t) {
    void 0 === t && (t = 33984 + T - 1),
      P !== t && (e.activeTexture(t), (P = t));
  }
  return {
    buffers: { color: r, depth: s, stencil: a },
    enable: F,
    disable: z,
    bindFramebuffer: function (t, n) {
      return (
        null === n && null !== l && (n = l),
        c[t] !== n &&
          (e.bindFramebuffer(t, n),
          (c[t] = n),
          i && (36009 === t && (c[36160] = n), 36160 === t && (c[36009] = n)),
          !0)
      );
    },
    bindXRFramebuffer: function (t) {
      t !== l && (e.bindFramebuffer(36160, t), (l = t));
    },
    useProgram: function (t) {
      return u !== t && (e.useProgram(t), (u = t), !0);
    },
    setBlending: V,
    setMaterial: function (e, t) {
      2 === e.side ? z(2884) : F(2884);
      let n = 1 === e.side;
      t && (n = !n),
        H(n),
        1 === e.blending && !1 === e.transparent
          ? V(0)
          : V(
              e.blending,
              e.blendEquation,
              e.blendSrc,
              e.blendDst,
              e.blendEquationAlpha,
              e.blendSrcAlpha,
              e.blendDstAlpha,
              e.premultipliedAlpha
            ),
        s.setFunc(e.depthFunc),
        s.setTest(e.depthTest),
        s.setMask(e.depthWrite),
        r.setMask(e.colorWrite);
      const i = e.stencilWrite;
      a.setTest(i),
        i &&
          (a.setMask(e.stencilWriteMask),
          a.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask),
          a.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
        W(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits),
        !0 === e.alphaToCoverage ? F(32926) : z(32926);
    },
    setFlipSided: H,
    setCullFace: G,
    setLineWidth: function (t) {
      t !== w && (C && e.lineWidth(t), (w = t));
    },
    setPolygonOffset: W,
    setScissorTest: function (e) {
      e ? F(3089) : z(3089);
    },
    activeTexture: q,
    bindTexture: function (t, n) {
      null === P && q();
      let i = L[P];
      void 0 === i && ((i = { type: void 0, texture: void 0 }), (L[P] = i)),
        (i.type === t && i.texture === n) ||
          (e.bindTexture(t, n || O[t]), (i.type = t), (i.texture = n));
    },
    unbindTexture: function () {
      const t = L[P];
      void 0 !== t &&
        void 0 !== t.type &&
        (e.bindTexture(t.type, null), (t.type = void 0), (t.texture = void 0));
    },
    compressedTexImage2D: function () {
      try {
        e.compressedTexImage2D.apply(e, arguments);
      } catch (t) {}
    },
    texImage2D: function () {
      try {
        e.texImage2D.apply(e, arguments);
      } catch (t) {}
    },
    texImage3D: function () {
      try {
        e.texImage3D.apply(e, arguments);
      } catch (t) {}
    },
    scissor: function (t) {
      !1 === D.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), D.copy(t));
    },
    viewport: function (t) {
      !1 === k.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), k.copy(t));
    },
    reset: function () {
      e.disable(3042),
        e.disable(2884),
        e.disable(2929),
        e.disable(32823),
        e.disable(3089),
        e.disable(2960),
        e.disable(32926),
        e.blendEquation(32774),
        e.blendFunc(1, 0),
        e.blendFuncSeparate(1, 0, 1, 0),
        e.colorMask(!0, !0, !0, !0),
        e.clearColor(0, 0, 0, 0),
        e.depthMask(!0),
        e.depthFunc(513),
        e.clearDepth(1),
        e.stencilMask(4294967295),
        e.stencilFunc(519, 0, 4294967295),
        e.stencilOp(7680, 7680, 7680),
        e.clearStencil(0),
        e.cullFace(1029),
        e.frontFace(2305),
        e.polygonOffset(0, 0),
        e.activeTexture(33984),
        e.bindFramebuffer(36160, null),
        !0 === i &&
          (e.bindFramebuffer(36009, null), e.bindFramebuffer(36008, null)),
        e.useProgram(null),
        e.lineWidth(1),
        e.scissor(0, 0, e.canvas.width, e.canvas.height),
        e.viewport(0, 0, e.canvas.width, e.canvas.height),
        (o = {}),
        (P = null),
        (L = {}),
        (l = null),
        (c = {}),
        (u = null),
        (h = !1),
        (d = null),
        (p = null),
        (f = null),
        (m = null),
        (g = null),
        (v = null),
        (_ = null),
        (y = !1),
        (x = null),
        (b = null),
        (w = null),
        (S = null),
        (M = null),
        D.set(0, 0, e.canvas.width, e.canvas.height),
        k.set(0, 0, e.canvas.width, e.canvas.height),
        r.reset(),
        s.reset(),
        a.reset();
    },
  };
}
function TT(e, t, n, i, r, s, a) {
  const o = r.isWebGL2,
    l = (r.maxTextures, r.maxCubemapSize),
    c = r.maxTextureSize,
    u = r.maxSamples,
    h = new WeakMap();
  let d,
    p = !1;
  try {
    p =
      "undefined" != typeof OffscreenCanvas &&
      null !== new OffscreenCanvas(1, 1).getContext("2d");
  } catch (F) {}
  function f(e, t) {
    return p ? new OffscreenCanvas(e, t) : vx("canvas");
  }
  function m(e, t, n, i) {
    let r = 1;
    if (
      ((e.width > i || e.height > i) && (r = i / Math.max(e.width, e.height)),
      r < 1 || !0 === t)
    ) {
      if (
        ("undefined" != typeof HTMLImageElement &&
          e instanceof HTMLImageElement) ||
        ("undefined" != typeof HTMLCanvasElement &&
          e instanceof HTMLCanvasElement) ||
        ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)
      ) {
        const i = t ? px : Math.floor,
          s = i(r * e.width),
          a = i(r * e.height);
        void 0 === d && (d = f(s, a));
        const o = n ? f(s, a) : d;
        (o.width = s), (o.height = a);
        return o.getContext("2d").drawImage(e, 0, 0, s, a), o;
      }
      return e;
    }
    return e;
  }
  function g(e) {
    return dx(e.width) && dx(e.height);
  }
  function v(e, t) {
    return (
      e.generateMipmaps && t && 1003 !== e.minFilter && 1006 !== e.minFilter
    );
  }
  function _(t, n, r, s, a = 1) {
    e.generateMipmap(t);
    i.get(n).__maxMipLevel = Math.log2(Math.max(r, s, a));
  }
  function y(n, i, r, s) {
    if (!1 === o) return i;
    if (null !== n && void 0 !== e[n]) return e[n];
    let a = i;
    return (
      6403 === i &&
        (5126 === r && (a = 33326),
        5131 === r && (a = 33325),
        5121 === r && (a = 33321)),
      6407 === i &&
        (5126 === r && (a = 34837),
        5131 === r && (a = 34843),
        5121 === r && (a = 32849)),
      6408 === i &&
        (5126 === r && (a = 34836),
        5131 === r && (a = 34842),
        5121 === r && (a = 3001 === s ? 35907 : 32856)),
      (33325 !== a && 33326 !== a && 34842 !== a && 34836 !== a) ||
        t.get("EXT_color_buffer_float"),
      a
    );
  }
  function x(e) {
    return 1003 === e || 1004 === e || 1005 === e ? 9728 : 9729;
  }
  function b(t) {
    const n = t.target;
    n.removeEventListener("dispose", b),
      (function (t) {
        const n = i.get(t);
        if (void 0 === n.__webglInit) return;
        e.deleteTexture(n.__webglTexture), i.remove(t);
      })(n),
      n.isVideoTexture && h.delete(n),
      a.memory.textures--;
  }
  function w(t) {
    const n = t.target;
    n.removeEventListener("dispose", w),
      (function (t) {
        const n = t.texture,
          r = i.get(t),
          s = i.get(n);
        if (!t) return;
        void 0 !== s.__webglTexture &&
          (e.deleteTexture(s.__webglTexture), a.memory.textures--);
        t.depthTexture && t.depthTexture.dispose();
        if (t.isWebGLCubeRenderTarget)
          for (let i = 0; i < 6; i++)
            e.deleteFramebuffer(r.__webglFramebuffer[i]),
              r.__webglDepthbuffer &&
                e.deleteRenderbuffer(r.__webglDepthbuffer[i]);
        else
          e.deleteFramebuffer(r.__webglFramebuffer),
            r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer),
            r.__webglMultisampledFramebuffer &&
              e.deleteFramebuffer(r.__webglMultisampledFramebuffer),
            r.__webglColorRenderbuffer &&
              e.deleteRenderbuffer(r.__webglColorRenderbuffer),
            r.__webglDepthRenderbuffer &&
              e.deleteRenderbuffer(r.__webglDepthRenderbuffer);
        if (t.isWebGLMultipleRenderTargets)
          for (let o = 0, l = n.length; o < l; o++) {
            const t = i.get(n[o]);
            t.__webglTexture &&
              (e.deleteTexture(t.__webglTexture), a.memory.textures--),
              i.remove(n[o]);
          }
        i.remove(n), i.remove(t);
      })(n);
  }
  let S = 0;
  function M(e, t) {
    const r = i.get(e);
    if (
      (e.isVideoTexture &&
        (function (e) {
          const t = a.render.frame;
          h.get(e) !== t && (h.set(e, t), e.update());
        })(e),
      e.version > 0 && r.__version !== e.version)
    ) {
      const n = e.image;
      if (void 0 === n);
      else if (!1 !== n.complete) return void L(r, e, t);
    }
    n.activeTexture(33984 + t), n.bindTexture(3553, r.__webglTexture);
  }
  function T(t, r) {
    const a = i.get(t);
    t.version > 0 && a.__version !== t.version
      ? (function (t, i, r) {
          if (6 !== i.image.length) return;
          P(t, i),
            n.activeTexture(33984 + r),
            n.bindTexture(34067, t.__webglTexture),
            e.pixelStorei(37440, i.flipY),
            e.pixelStorei(37441, i.premultiplyAlpha),
            e.pixelStorei(3317, i.unpackAlignment),
            e.pixelStorei(37443, 0);
          const a =
              i && (i.isCompressedTexture || i.image[0].isCompressedTexture),
            c = i.image[0] && i.image[0].isDataTexture,
            u = [];
          for (let e = 0; e < 6; e++)
            u[e] =
              a || c
                ? c
                  ? i.image[e].image
                  : i.image[e]
                : m(i.image[e], !1, !0, l);
          const h = u[0],
            d = g(h) || o,
            p = s.convert(i.format),
            f = s.convert(i.type),
            x = y(i.internalFormat, p, f, i.encoding);
          let b;
          if ((A(34067, i, d), a)) {
            for (let e = 0; e < 6; e++) {
              b = u[e].mipmaps;
              for (let t = 0; t < b.length; t++) {
                const r = b[t];
                1023 !== i.format && 1022 !== i.format
                  ? null !== p &&
                    n.compressedTexImage2D(
                      34069 + e,
                      t,
                      x,
                      r.width,
                      r.height,
                      0,
                      r.data
                    )
                  : n.texImage2D(
                      34069 + e,
                      t,
                      x,
                      r.width,
                      r.height,
                      0,
                      p,
                      f,
                      r.data
                    );
              }
            }
            t.__maxMipLevel = b.length - 1;
          } else {
            b = i.mipmaps;
            for (let e = 0; e < 6; e++)
              if (c) {
                n.texImage2D(
                  34069 + e,
                  0,
                  x,
                  u[e].width,
                  u[e].height,
                  0,
                  p,
                  f,
                  u[e].data
                );
                for (let t = 0; t < b.length; t++) {
                  const i = b[t].image[e].image;
                  n.texImage2D(
                    34069 + e,
                    t + 1,
                    x,
                    i.width,
                    i.height,
                    0,
                    p,
                    f,
                    i.data
                  );
                }
              } else {
                n.texImage2D(34069 + e, 0, x, p, f, u[e]);
                for (let t = 0; t < b.length; t++) {
                  const i = b[t];
                  n.texImage2D(34069 + e, t + 1, x, p, f, i.image[e]);
                }
              }
            t.__maxMipLevel = b.length;
          }
          v(i, d) && _(34067, i, h.width, h.height);
          (t.__version = i.version), i.onUpdate && i.onUpdate(i);
        })(a, t, r)
      : (n.activeTexture(33984 + r), n.bindTexture(34067, a.__webglTexture));
  }
  const C = { 1e3: 10497, 1001: 33071, 1002: 33648 },
    E = {
      1003: 9728,
      1004: 9984,
      1005: 9986,
      1006: 9729,
      1007: 9985,
      1008: 9987,
    };
  function A(n, s, a) {
    if (
      (a
        ? (e.texParameteri(n, 10242, C[s.wrapS]),
          e.texParameteri(n, 10243, C[s.wrapT]),
          (32879 !== n && 35866 !== n) || e.texParameteri(n, 32882, C[s.wrapR]),
          e.texParameteri(n, 10240, E[s.magFilter]),
          e.texParameteri(n, 10241, E[s.minFilter]))
        : (e.texParameteri(n, 10242, 33071),
          e.texParameteri(n, 10243, 33071),
          (32879 !== n && 35866 !== n) || e.texParameteri(n, 32882, 33071),
          1001 !== s.wrapS || s.wrapT,
          e.texParameteri(n, 10240, x(s.magFilter)),
          e.texParameteri(n, 10241, x(s.minFilter)),
          1003 !== s.minFilter && s.minFilter),
      !0 === t.has("EXT_texture_filter_anisotropic"))
    ) {
      const a = t.get("EXT_texture_filter_anisotropic");
      if (1015 === s.type && !1 === t.has("OES_texture_float_linear")) return;
      if (
        !1 === o &&
        1016 === s.type &&
        !1 === t.has("OES_texture_half_float_linear")
      )
        return;
      (s.anisotropy > 1 || i.get(s).__currentAnisotropy) &&
        (e.texParameterf(
          n,
          a.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(s.anisotropy, r.getMaxAnisotropy())
        ),
        (i.get(s).__currentAnisotropy = s.anisotropy));
    }
  }
  function P(t, n) {
    void 0 === t.__webglInit &&
      ((t.__webglInit = !0),
      n.addEventListener("dispose", b),
      (t.__webglTexture = e.createTexture()),
      a.memory.textures++);
  }
  function L(t, i, r) {
    let a = 3553;
    i.isDataTexture2DArray && (a = 35866),
      i.isDataTexture3D && (a = 32879),
      P(t, i),
      n.activeTexture(33984 + r),
      n.bindTexture(a, t.__webglTexture),
      e.pixelStorei(37440, i.flipY),
      e.pixelStorei(37441, i.premultiplyAlpha),
      e.pixelStorei(3317, i.unpackAlignment),
      e.pixelStorei(37443, 0);
    const l =
        (function (e) {
          return (
            !o &&
            (1001 !== e.wrapS ||
              1001 !== e.wrapT ||
              (1003 !== e.minFilter && 1006 !== e.minFilter))
          );
        })(i) && !1 === g(i.image),
      u = m(i.image, l, !1, c),
      h = g(u) || o,
      d = s.convert(i.format);
    let p,
      f = s.convert(i.type),
      x = y(i.internalFormat, d, f, i.encoding);
    A(a, i, h);
    const b = i.mipmaps;
    if (i.isDepthTexture)
      (x = 6402),
        o
          ? (x =
              1015 === i.type
                ? 36012
                : 1014 === i.type
                ? 33190
                : 1020 === i.type
                ? 35056
                : 33189)
          : i.type,
        1026 === i.format &&
          6402 === x &&
          1012 !== i.type &&
          1014 !== i.type &&
          ((i.type = 1012), (f = s.convert(i.type))),
        1027 === i.format &&
          6402 === x &&
          ((x = 34041),
          1020 !== i.type && ((i.type = 1020), (f = s.convert(i.type)))),
        n.texImage2D(3553, 0, x, u.width, u.height, 0, d, f, null);
    else if (i.isDataTexture)
      if (b.length > 0 && h) {
        for (let e = 0, t = b.length; e < t; e++)
          (p = b[e]),
            n.texImage2D(3553, e, x, p.width, p.height, 0, d, f, p.data);
        (i.generateMipmaps = !1), (t.__maxMipLevel = b.length - 1);
      } else
        n.texImage2D(3553, 0, x, u.width, u.height, 0, d, f, u.data),
          (t.__maxMipLevel = 0);
    else if (i.isCompressedTexture) {
      for (let e = 0, t = b.length; e < t; e++)
        (p = b[e]),
          1023 !== i.format && 1022 !== i.format
            ? null !== d &&
              n.compressedTexImage2D(3553, e, x, p.width, p.height, 0, p.data)
            : n.texImage2D(3553, e, x, p.width, p.height, 0, d, f, p.data);
      t.__maxMipLevel = b.length - 1;
    } else if (i.isDataTexture2DArray)
      n.texImage3D(35866, 0, x, u.width, u.height, u.depth, 0, d, f, u.data),
        (t.__maxMipLevel = 0);
    else if (i.isDataTexture3D)
      n.texImage3D(32879, 0, x, u.width, u.height, u.depth, 0, d, f, u.data),
        (t.__maxMipLevel = 0);
    else if (b.length > 0 && h) {
      for (let e = 0, t = b.length; e < t; e++)
        (p = b[e]), n.texImage2D(3553, e, x, d, f, p);
      (i.generateMipmaps = !1), (t.__maxMipLevel = b.length - 1);
    } else n.texImage2D(3553, 0, x, d, f, u), (t.__maxMipLevel = 0);
    v(i, h) && _(a, i, u.width, u.height),
      (t.__version = i.version),
      i.onUpdate && i.onUpdate(i);
  }
  function I(t, r, a, o, l) {
    const c = s.convert(a.format),
      u = s.convert(a.type),
      h = y(a.internalFormat, c, u, a.encoding);
    32879 === l || 35866 === l
      ? n.texImage3D(l, 0, h, r.width, r.height, r.depth, 0, c, u, null)
      : n.texImage2D(l, 0, h, r.width, r.height, 0, c, u, null),
      n.bindFramebuffer(36160, t),
      e.framebufferTexture2D(36160, o, l, i.get(a).__webglTexture, 0),
      n.bindFramebuffer(36160, null);
  }
  function R(t, n, i) {
    if ((e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer)) {
      let r = 33189;
      if (i) {
        const t = n.depthTexture;
        t &&
          t.isDepthTexture &&
          (1015 === t.type ? (r = 36012) : 1014 === t.type && (r = 33190));
        const i = k(n);
        e.renderbufferStorageMultisample(36161, i, r, n.width, n.height);
      } else e.renderbufferStorage(36161, r, n.width, n.height);
      e.framebufferRenderbuffer(36160, 36096, 36161, t);
    } else if (n.depthBuffer && n.stencilBuffer) {
      if (i) {
        const t = k(n);
        e.renderbufferStorageMultisample(36161, t, 35056, n.width, n.height);
      } else e.renderbufferStorage(36161, 34041, n.width, n.height);
      e.framebufferRenderbuffer(36160, 33306, 36161, t);
    } else {
      const t =
          !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture,
        r = s.convert(t.format),
        a = s.convert(t.type),
        o = y(t.internalFormat, r, a, t.encoding);
      if (i) {
        const t = k(n);
        e.renderbufferStorageMultisample(36161, t, o, n.width, n.height);
      } else e.renderbufferStorage(36161, o, n.width, n.height);
    }
    e.bindRenderbuffer(36161, null);
  }
  function D(t) {
    const r = i.get(t),
      s = !0 === t.isWebGLCubeRenderTarget;
    if (t.depthTexture) {
      if (s)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      !(function (t, r) {
        if (r && r.isWebGLCubeRenderTarget)
          throw new Error(
            "Depth Texture with cube render targets is not supported"
          );
        if (
          (n.bindFramebuffer(36160, t),
          !r.depthTexture || !r.depthTexture.isDepthTexture)
        )
          throw new Error(
            "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
          );
        (i.get(r.depthTexture).__webglTexture &&
          r.depthTexture.image.width === r.width &&
          r.depthTexture.image.height === r.height) ||
          ((r.depthTexture.image.width = r.width),
          (r.depthTexture.image.height = r.height),
          (r.depthTexture.needsUpdate = !0)),
          M(r.depthTexture, 0);
        const s = i.get(r.depthTexture).__webglTexture;
        if (1026 === r.depthTexture.format)
          e.framebufferTexture2D(36160, 36096, 3553, s, 0);
        else {
          if (1027 !== r.depthTexture.format)
            throw new Error("Unknown depthTexture format");
          e.framebufferTexture2D(36160, 33306, 3553, s, 0);
        }
      })(r.__webglFramebuffer, t);
    } else if (s) {
      r.__webglDepthbuffer = [];
      for (let i = 0; i < 6; i++)
        n.bindFramebuffer(36160, r.__webglFramebuffer[i]),
          (r.__webglDepthbuffer[i] = e.createRenderbuffer()),
          R(r.__webglDepthbuffer[i], t, !1);
    } else
      n.bindFramebuffer(36160, r.__webglFramebuffer),
        (r.__webglDepthbuffer = e.createRenderbuffer()),
        R(r.__webglDepthbuffer, t, !1);
    n.bindFramebuffer(36160, null);
  }
  function k(e) {
    return o && e.isWebGLMultisampleRenderTarget ? Math.min(u, e.samples) : 0;
  }
  let N = !1,
    O = !1;
  (this.allocateTextureUnit = function () {
    const e = S;
    return (S += 1), e;
  }),
    (this.resetTextureUnits = function () {
      S = 0;
    }),
    (this.setTexture2D = M),
    (this.setTexture2DArray = function (e, t) {
      const r = i.get(e);
      e.version > 0 && r.__version !== e.version
        ? L(r, e, t)
        : (n.activeTexture(33984 + t), n.bindTexture(35866, r.__webglTexture));
    }),
    (this.setTexture3D = function (e, t) {
      const r = i.get(e);
      e.version > 0 && r.__version !== e.version
        ? L(r, e, t)
        : (n.activeTexture(33984 + t), n.bindTexture(32879, r.__webglTexture));
    }),
    (this.setTextureCube = T),
    (this.setupRenderTarget = function (t) {
      const l = t.texture,
        c = i.get(t),
        u = i.get(l);
      t.addEventListener("dispose", w),
        !0 !== t.isWebGLMultipleRenderTargets &&
          ((u.__webglTexture = e.createTexture()),
          (u.__version = l.version),
          a.memory.textures++);
      const h = !0 === t.isWebGLCubeRenderTarget,
        d = !0 === t.isWebGLMultipleRenderTargets,
        p = !0 === t.isWebGLMultisampleRenderTarget,
        f = l.isDataTexture3D || l.isDataTexture2DArray,
        m = g(t) || o;
      if (
        (!o ||
          1022 !== l.format ||
          (1015 !== l.type && 1016 !== l.type) ||
          (l.format = 1023),
        h)
      ) {
        c.__webglFramebuffer = [];
        for (let t = 0; t < 6; t++)
          c.__webglFramebuffer[t] = e.createFramebuffer();
      } else if (((c.__webglFramebuffer = e.createFramebuffer()), d)) {
        if (r.drawBuffers) {
          const n = t.texture;
          for (let t = 0, r = n.length; t < r; t++) {
            const r = i.get(n[t]);
            void 0 === r.__webglTexture &&
              ((r.__webglTexture = e.createTexture()), a.memory.textures++);
          }
        }
      } else if (p && o) {
        (c.__webglMultisampledFramebuffer = e.createFramebuffer()),
          (c.__webglColorRenderbuffer = e.createRenderbuffer()),
          e.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
        const i = s.convert(l.format),
          r = s.convert(l.type),
          a = y(l.internalFormat, i, r, l.encoding),
          o = k(t);
        e.renderbufferStorageMultisample(36161, o, a, t.width, t.height),
          n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer),
          e.framebufferRenderbuffer(
            36160,
            36064,
            36161,
            c.__webglColorRenderbuffer
          ),
          e.bindRenderbuffer(36161, null),
          t.depthBuffer &&
            ((c.__webglDepthRenderbuffer = e.createRenderbuffer()),
            R(c.__webglDepthRenderbuffer, t, !0)),
          n.bindFramebuffer(36160, null);
      }
      if (h) {
        n.bindTexture(34067, u.__webglTexture), A(34067, l, m);
        for (let e = 0; e < 6; e++)
          I(c.__webglFramebuffer[e], t, l, 36064, 34069 + e);
        v(l, m) && _(34067, l, t.width, t.height), n.unbindTexture();
      } else if (d) {
        const e = t.texture;
        for (let r = 0, s = e.length; r < s; r++) {
          const s = e[r],
            a = i.get(s);
          n.bindTexture(3553, a.__webglTexture),
            A(3553, s, m),
            I(c.__webglFramebuffer, t, s, 36064 + r, 3553),
            v(s, m) && _(3553, s, t.width, t.height);
        }
        n.unbindTexture();
      } else {
        let e = 3553;
        if (f && o) {
          e = l.isDataTexture3D ? 32879 : 35866;
        }
        n.bindTexture(e, u.__webglTexture),
          A(e, l, m),
          I(c.__webglFramebuffer, t, l, 36064, e),
          v(l, m) && _(e, l, t.width, t.height, t.depth),
          n.unbindTexture();
      }
      t.depthBuffer && D(t);
    }),
    (this.updateRenderTargetMipmap = function (e) {
      const t = g(e) || o,
        r = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
      for (let s = 0, a = r.length; s < a; s++) {
        const a = r[s];
        if (v(a, t)) {
          const t = e.isWebGLCubeRenderTarget ? 34067 : 3553,
            r = i.get(a).__webglTexture;
          n.bindTexture(t, r), _(t, a, e.width, e.height), n.unbindTexture();
        }
      }
    }),
    (this.updateMultisampleRenderTarget = function (t) {
      if (t.isWebGLMultisampleRenderTarget && o) {
        const r = t.width,
          s = t.height;
        let a = 16384;
        t.depthBuffer && (a |= 256), t.stencilBuffer && (a |= 1024);
        const o = i.get(t);
        n.bindFramebuffer(36008, o.__webglMultisampledFramebuffer),
          n.bindFramebuffer(36009, o.__webglFramebuffer),
          e.blitFramebuffer(0, 0, r, s, 0, 0, r, s, a, 9728),
          n.bindFramebuffer(36008, null),
          n.bindFramebuffer(36009, o.__webglMultisampledFramebuffer);
      }
    }),
    (this.safeSetTexture2D = function (e, t) {
      e && e.isWebGLRenderTarget && (!1 === N && (N = !0), (e = e.texture)),
        M(e, t);
    }),
    (this.safeSetTextureCube = function (e, t) {
      e && e.isWebGLCubeRenderTarget && (!1 === O && (O = !0), (e = e.texture)),
        T(e, t);
    });
}
function CT(e, t, n) {
  const i = n.isWebGL2;
  return {
    convert: function (e) {
      let n;
      if (1009 === e) return 5121;
      if (1017 === e) return 32819;
      if (1018 === e) return 32820;
      if (1019 === e) return 33635;
      if (1010 === e) return 5120;
      if (1011 === e) return 5122;
      if (1012 === e) return 5123;
      if (1013 === e) return 5124;
      if (1014 === e) return 5125;
      if (1015 === e) return 5126;
      if (1016 === e)
        return i
          ? 5131
          : ((n = t.get("OES_texture_half_float")),
            null !== n ? n.HALF_FLOAT_OES : null);
      if (1021 === e) return 6406;
      if (1022 === e) return 6407;
      if (1023 === e) return 6408;
      if (1024 === e) return 6409;
      if (1025 === e) return 6410;
      if (1026 === e) return 6402;
      if (1027 === e) return 34041;
      if (1028 === e) return 6403;
      if (1029 === e) return 36244;
      if (1030 === e) return 33319;
      if (1031 === e) return 33320;
      if (1032 === e) return 36248;
      if (1033 === e) return 36249;
      if (33776 === e || 33777 === e || 33778 === e || 33779 === e) {
        if (((n = t.get("WEBGL_compressed_texture_s3tc")), null === n))
          return null;
        if (33776 === e) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (33777 === e) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (33778 === e) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (33779 === e) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      }
      if (35840 === e || 35841 === e || 35842 === e || 35843 === e) {
        if (((n = t.get("WEBGL_compressed_texture_pvrtc")), null === n))
          return null;
        if (35840 === e) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (35841 === e) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (35842 === e) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (35843 === e) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      }
      if (36196 === e)
        return (
          (n = t.get("WEBGL_compressed_texture_etc1")),
          null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null
        );
      if (
        (37492 === e || 37496 === e) &&
        ((n = t.get("WEBGL_compressed_texture_etc")), null !== n)
      ) {
        if (37492 === e) return n.COMPRESSED_RGB8_ETC2;
        if (37496 === e) return n.COMPRESSED_RGBA8_ETC2_EAC;
      }
      return 37808 === e ||
        37809 === e ||
        37810 === e ||
        37811 === e ||
        37812 === e ||
        37813 === e ||
        37814 === e ||
        37815 === e ||
        37816 === e ||
        37817 === e ||
        37818 === e ||
        37819 === e ||
        37820 === e ||
        37821 === e ||
        37840 === e ||
        37841 === e ||
        37842 === e ||
        37843 === e ||
        37844 === e ||
        37845 === e ||
        37846 === e ||
        37847 === e ||
        37848 === e ||
        37849 === e ||
        37850 === e ||
        37851 === e ||
        37852 === e ||
        37853 === e
        ? ((n = t.get("WEBGL_compressed_texture_astc")), null !== n ? e : null)
        : 36492 === e
        ? ((n = t.get("EXT_texture_compression_bptc")), null !== n ? e : null)
        : 1020 === e
        ? i
          ? 34042
          : ((n = t.get("WEBGL_depth_texture")),
            null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null)
        : void 0;
    },
  };
}
class ET extends Ow {
  constructor(e = []) {
    super(), (this.cameras = e);
  }
}
ET.prototype.isArrayCamera = !0;
class AT extends Ab {
  constructor() {
    super(), (this.type = "Group");
  }
}
AT.prototype.isGroup = !0;
const PT = { type: "move" };
class LT {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      null === this._hand &&
        ((this._hand = new AT()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      null === this._targetRay &&
        ((this._targetRay = new AT()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new Cx()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new Cx())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      null === this._grip &&
        ((this._grip = new AT()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new Cx()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new Cx())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      null !== this._targetRay && this._targetRay.dispatchEvent(e),
      null !== this._grip && this._grip.dispatchEvent(e),
      null !== this._hand && this._hand.dispatchEvent(e),
      this
    );
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      null !== this._targetRay && (this._targetRay.visible = !1),
      null !== this._grip && (this._grip.visible = !1),
      null !== this._hand && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, n) {
    let i = null,
      r = null,
      s = null;
    const a = this._targetRay,
      o = this._grip,
      l = this._hand;
    if (e && "visible-blurred" !== t.session.visibilityState)
      if (
        (null !== a &&
          ((i = t.getPose(e.targetRaySpace, n)),
          null !== i &&
            (a.matrix.fromArray(i.transform.matrix),
            a.matrix.decompose(a.position, a.rotation, a.scale),
            i.linearVelocity
              ? ((a.hasLinearVelocity = !0),
                a.linearVelocity.copy(i.linearVelocity))
              : (a.hasLinearVelocity = !1),
            i.angularVelocity
              ? ((a.hasAngularVelocity = !0),
                a.angularVelocity.copy(i.angularVelocity))
              : (a.hasAngularVelocity = !1),
            this.dispatchEvent(PT))),
        l && e.hand)
      ) {
        s = !0;
        for (const s of e.hand.values()) {
          const e = t.getJointPose(s, n);
          if (void 0 === l.joints[s.jointName]) {
            const e = new AT();
            (e.matrixAutoUpdate = !1),
              (e.visible = !1),
              (l.joints[s.jointName] = e),
              l.add(e);
          }
          const i = l.joints[s.jointName];
          null !== e &&
            (i.matrix.fromArray(e.transform.matrix),
            i.matrix.decompose(i.position, i.rotation, i.scale),
            (i.jointRadius = e.radius)),
            (i.visible = null !== e);
        }
        const i = l.joints["index-finger-tip"],
          r = l.joints["thumb-tip"],
          a = i.position.distanceTo(r.position),
          o = 0.02,
          c = 0.005;
        l.inputState.pinching && a > o + c
          ? ((l.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !l.inputState.pinching &&
            a <= o - c &&
            ((l.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        null !== o &&
          e.gripSpace &&
          ((r = t.getPose(e.gripSpace, n)),
          null !== r &&
            (o.matrix.fromArray(r.transform.matrix),
            o.matrix.decompose(o.position, o.rotation, o.scale),
            r.linearVelocity
              ? ((o.hasLinearVelocity = !0),
                o.linearVelocity.copy(r.linearVelocity))
              : (o.hasLinearVelocity = !1),
            r.angularVelocity
              ? ((o.hasAngularVelocity = !0),
                o.angularVelocity.copy(r.angularVelocity))
              : (o.hasAngularVelocity = !1)));
    return (
      null !== a && (a.visible = null !== i),
      null !== o && (o.visible = null !== r),
      null !== l && (l.visible = null !== s),
      this
    );
  }
}
class IT extends rx {
  constructor(e, t) {
    super();
    const n = this,
      i = e.state;
    let r = null,
      s = 1,
      a = null,
      o = "local-floor",
      l = null,
      c = null,
      u = null,
      h = null,
      d = null,
      p = !1,
      f = null,
      m = null,
      g = null,
      v = null,
      _ = null,
      y = null;
    const x = e.extensions.has("EXT_multisampled_render_to_texture");
    let b = null;
    const w = [],
      S = new Map(),
      M = new Ow();
    M.layers.enable(1), (M.viewport = new wx());
    const T = new Ow();
    T.layers.enable(2), (T.viewport = new wx());
    const C = [M, T],
      E = new ET();
    E.layers.enable(1), E.layers.enable(2);
    let A = null,
      P = null;
    function L(e) {
      const t = S.get(e.inputSource);
      t && t.dispatchEvent({ type: e.type, data: e.inputSource });
    }
    function I() {
      S.forEach(function (e, t) {
        e.disconnect(t);
      }),
        S.clear(),
        (A = null),
        (P = null),
        i.bindXRFramebuffer(null),
        e.setRenderTarget(e.getRenderTarget()),
        u && t.deleteFramebuffer(u),
        f && t.deleteFramebuffer(f),
        m && t.deleteRenderbuffer(m),
        g && t.deleteRenderbuffer(g),
        (u = null),
        (f = null),
        (m = null),
        (g = null),
        (d = null),
        (h = null),
        (c = null),
        (r = null),
        F.stop(),
        (n.isPresenting = !1),
        n.dispatchEvent({ type: "sessionend" });
    }
    function R(e) {
      const t = r.inputSources;
      for (let n = 0; n < w.length; n++) S.set(t[n], w[n]);
      for (let n = 0; n < e.removed.length; n++) {
        const t = e.removed[n],
          i = S.get(t);
        i && (i.dispatchEvent({ type: "disconnected", data: t }), S.delete(t));
      }
      for (let n = 0; n < e.added.length; n++) {
        const t = e.added[n],
          i = S.get(t);
        i && i.dispatchEvent({ type: "connected", data: t });
      }
    }
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (e) {
        let t = w[e];
        return (
          void 0 === t && ((t = new LT()), (w[e] = t)), t.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (e) {
        let t = w[e];
        return void 0 === t && ((t = new LT()), (w[e] = t)), t.getGripSpace();
      }),
      (this.getHand = function (e) {
        let t = w[e];
        return void 0 === t && ((t = new LT()), (w[e] = t)), t.getHandSpace();
      }),
      (this.setFramebufferScaleFactor = function (e) {
        (s = e), n.isPresenting;
      }),
      (this.setReferenceSpaceType = function (e) {
        (o = e), n.isPresenting;
      }),
      (this.getReferenceSpace = function () {
        return a;
      }),
      (this.getBaseLayer = function () {
        return null !== h ? h : d;
      }),
      (this.getBinding = function () {
        return c;
      }),
      (this.getFrame = function () {
        return v;
      }),
      (this.getSession = function () {
        return r;
      }),
      (this.setSession = async function (l) {
        if (((r = l), null !== r)) {
          r.addEventListener("select", L),
            r.addEventListener("selectstart", L),
            r.addEventListener("selectend", L),
            r.addEventListener("squeeze", L),
            r.addEventListener("squeezestart", L),
            r.addEventListener("squeezeend", L),
            r.addEventListener("end", I),
            r.addEventListener("inputsourceschange", R);
          const l = t.getContextAttributes();
          if (
            (!0 !== l.xrCompatible && (await t.makeXRCompatible()),
            void 0 === r.renderState.layers)
          ) {
            const e = {
              antialias: l.antialias,
              alpha: l.alpha,
              depth: l.depth,
              stencil: l.stencil,
              framebufferScaleFactor: s,
            };
            (d = new XRWebGLLayer(r, t, e)),
              r.updateRenderState({ baseLayer: d });
          } else if (t instanceof WebGLRenderingContext) {
            const e = {
              antialias: !0,
              alpha: l.alpha,
              depth: l.depth,
              stencil: l.stencil,
              framebufferScaleFactor: s,
            };
            (d = new XRWebGLLayer(r, t, e)),
              r.updateRenderState({ layers: [d] });
          } else {
            p = l.antialias;
            let n = null;
            l.depth &&
              ((y = 256),
              l.stencil && (y |= 1024),
              (_ = l.stencil ? 33306 : 36096),
              (n = l.stencil ? 35056 : 33190));
            const a = {
              colorFormat: l.alpha ? 32856 : 32849,
              depthFormat: n,
              scaleFactor: s,
            };
            (c = new XRWebGLBinding(r, t)),
              (h = c.createProjectionLayer(a)),
              (u = t.createFramebuffer()),
              r.updateRenderState({ layers: [h] }),
              p && x
                ? (b = e.extensions.get("EXT_multisampled_render_to_texture"))
                : p &&
                  ((f = t.createFramebuffer()),
                  (m = t.createRenderbuffer()),
                  t.bindRenderbuffer(36161, m),
                  t.renderbufferStorageMultisample(
                    36161,
                    4,
                    32856,
                    h.textureWidth,
                    h.textureHeight
                  ),
                  i.bindFramebuffer(36160, f),
                  t.framebufferRenderbuffer(36160, 36064, 36161, m),
                  t.bindRenderbuffer(36161, null),
                  null !== n &&
                    ((g = t.createRenderbuffer()),
                    t.bindRenderbuffer(36161, g),
                    t.renderbufferStorageMultisample(
                      36161,
                      4,
                      n,
                      h.textureWidth,
                      h.textureHeight
                    ),
                    t.framebufferRenderbuffer(36160, _, 36161, g),
                    t.bindRenderbuffer(36161, null)),
                  i.bindFramebuffer(36160, null));
          }
          (a = await r.requestReferenceSpace(o)),
            F.setContext(r),
            F.start(),
            (n.isPresenting = !0),
            n.dispatchEvent({ type: "sessionstart" });
        }
      });
    const D = new Cx(),
      k = new Cx();
    function N(e, t) {
      null === t
        ? e.matrixWorld.copy(e.matrix)
        : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
        e.matrixWorldInverse.copy(e.matrixWorld).invert();
    }
    (this.updateCamera = function (e) {
      if (null === r) return;
      (E.near = T.near = M.near = e.near),
        (E.far = T.far = M.far = e.far),
        (A === E.near && P === E.far) ||
          (r.updateRenderState({ depthNear: E.near, depthFar: E.far }),
          (A = E.near),
          (P = E.far));
      const t = e.parent,
        n = E.cameras;
      N(E, t);
      for (let r = 0; r < n.length; r++) N(n[r], t);
      E.matrixWorld.decompose(E.position, E.quaternion, E.scale),
        e.position.copy(E.position),
        e.quaternion.copy(E.quaternion),
        e.scale.copy(E.scale),
        e.matrix.copy(E.matrix),
        e.matrixWorld.copy(E.matrixWorld);
      const i = e.children;
      for (let r = 0, s = i.length; r < s; r++) i[r].updateMatrixWorld(!0);
      2 === n.length
        ? (function (e, t, n) {
            D.setFromMatrixPosition(t.matrixWorld),
              k.setFromMatrixPosition(n.matrixWorld);
            const i = D.distanceTo(k),
              r = t.projectionMatrix.elements,
              s = n.projectionMatrix.elements,
              a = r[14] / (r[10] - 1),
              o = r[14] / (r[10] + 1),
              l = (r[9] + 1) / r[5],
              c = (r[9] - 1) / r[5],
              u = (r[8] - 1) / r[0],
              h = (s[8] + 1) / s[0],
              d = a * u,
              p = a * h,
              f = i / (-u + h),
              m = f * -u;
            t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
              e.translateX(m),
              e.translateZ(f),
              e.matrixWorld.compose(e.position, e.quaternion, e.scale),
              e.matrixWorldInverse.copy(e.matrixWorld).invert();
            const g = a + f,
              v = o + f,
              _ = d - m,
              y = p + (i - m),
              x = ((l * o) / v) * g,
              b = ((c * o) / v) * g;
            e.projectionMatrix.makePerspective(_, y, x, b, g, v);
          })(E, M, T)
        : E.projectionMatrix.copy(M.projectionMatrix);
    }),
      (this.getCamera = function () {
        return E;
      }),
      (this.getFoveation = function () {
        return null !== h
          ? h.fixedFoveation
          : null !== d
          ? d.fixedFoveation
          : void 0;
      }),
      (this.setFoveation = function (e) {
        null !== h && (h.fixedFoveation = e),
          null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = e);
      });
    let O = null;
    const F = new Yw();
    F.setAnimationLoop(function (e, n) {
      if (((l = n.getViewerPose(a)), (v = n), null !== l)) {
        const e = l.views;
        null !== d && i.bindXRFramebuffer(d.framebuffer);
        let n = !1;
        e.length !== E.cameras.length && ((E.cameras.length = 0), (n = !0));
        for (let r = 0; r < e.length; r++) {
          const s = e[r];
          let a = null;
          if (null !== d) a = d.getViewport(s);
          else {
            const e = c.getViewSubImage(h, s);
            i.bindXRFramebuffer(u),
              p && x
                ? (void 0 !== e.depthStencilTexture &&
                    b.framebufferTexture2DMultisampleEXT(
                      36160,
                      _,
                      3553,
                      e.depthStencilTexture,
                      0,
                      4
                    ),
                  b.framebufferTexture2DMultisampleEXT(
                    36160,
                    36064,
                    3553,
                    e.colorTexture,
                    0,
                    4
                  ))
                : (void 0 !== e.depthStencilTexture &&
                    t.framebufferTexture2D(
                      36160,
                      _,
                      3553,
                      e.depthStencilTexture,
                      0
                    ),
                  t.framebufferTexture2D(
                    36160,
                    36064,
                    3553,
                    e.colorTexture,
                    0
                  )),
              (a = e.viewport);
          }
          const o = C[r];
          o.matrix.fromArray(s.transform.matrix),
            o.projectionMatrix.fromArray(s.projectionMatrix),
            o.viewport.set(a.x, a.y, a.width, a.height),
            0 === r && E.matrix.copy(o.matrix),
            !0 === n && E.cameras.push(o);
        }
        p && !x && (i.bindXRFramebuffer(f), null !== y && t.clear(y));
      }
      const s = r.inputSources;
      for (let t = 0; t < w.length; t++) {
        const e = w[t],
          i = s[t];
        e.update(i, n, a);
      }
      if ((O && O(e, n), p && !x)) {
        const e = h.textureWidth,
          n = h.textureHeight;
        i.bindFramebuffer(36008, f),
          i.bindFramebuffer(36009, u),
          t.invalidateFramebuffer(36008, [_]),
          t.invalidateFramebuffer(36009, [_]),
          t.blitFramebuffer(0, 0, e, n, 0, 0, e, n, 16384, 9728),
          t.invalidateFramebuffer(36008, [36064]),
          i.bindFramebuffer(36008, null),
          i.bindFramebuffer(36009, null),
          i.bindFramebuffer(36160, f);
      }
      v = null;
    }),
      (this.setAnimationLoop = function (e) {
        O = e;
      }),
      (this.dispose = function () {});
  }
}
function RT(e) {
  function t(t, n) {
    (t.opacity.value = n.opacity),
      n.color && t.diffuse.value.copy(n.color),
      n.emissive &&
        t.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),
      n.map && (t.map.value = n.map),
      n.alphaMap && (t.alphaMap.value = n.alphaMap),
      n.specularMap && (t.specularMap.value = n.specularMap),
      n.alphaTest > 0 && (t.alphaTest.value = n.alphaTest);
    const i = e.get(n).envMap;
    if (i) {
      (t.envMap.value = i),
        (t.flipEnvMap.value =
          i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1),
        (t.reflectivity.value = n.reflectivity),
        (t.ior.value = n.ior),
        (t.refractionRatio.value = n.refractionRatio);
      const r = e.get(i).__maxMipLevel;
      void 0 !== r && (t.maxMipLevel.value = r);
    }
    let r, s;
    n.lightMap &&
      ((t.lightMap.value = n.lightMap),
      (t.lightMapIntensity.value = n.lightMapIntensity)),
      n.aoMap &&
        ((t.aoMap.value = n.aoMap),
        (t.aoMapIntensity.value = n.aoMapIntensity)),
      n.map
        ? (r = n.map)
        : n.specularMap
        ? (r = n.specularMap)
        : n.displacementMap
        ? (r = n.displacementMap)
        : n.normalMap
        ? (r = n.normalMap)
        : n.bumpMap
        ? (r = n.bumpMap)
        : n.roughnessMap
        ? (r = n.roughnessMap)
        : n.metalnessMap
        ? (r = n.metalnessMap)
        : n.alphaMap
        ? (r = n.alphaMap)
        : n.emissiveMap
        ? (r = n.emissiveMap)
        : n.clearcoatMap
        ? (r = n.clearcoatMap)
        : n.clearcoatNormalMap
        ? (r = n.clearcoatNormalMap)
        : n.clearcoatRoughnessMap
        ? (r = n.clearcoatRoughnessMap)
        : n.specularIntensityMap
        ? (r = n.specularIntensityMap)
        : n.specularTintMap
        ? (r = n.specularTintMap)
        : n.transmissionMap
        ? (r = n.transmissionMap)
        : n.thicknessMap && (r = n.thicknessMap),
      void 0 !== r &&
        (r.isWebGLRenderTarget && (r = r.texture),
        !0 === r.matrixAutoUpdate && r.updateMatrix(),
        t.uvTransform.value.copy(r.matrix)),
      n.aoMap ? (s = n.aoMap) : n.lightMap && (s = n.lightMap),
      void 0 !== s &&
        (s.isWebGLRenderTarget && (s = s.texture),
        !0 === s.matrixAutoUpdate && s.updateMatrix(),
        t.uv2Transform.value.copy(s.matrix));
  }
  function n(t, n) {
    (t.roughness.value = n.roughness),
      (t.metalness.value = n.metalness),
      n.roughnessMap && (t.roughnessMap.value = n.roughnessMap),
      n.metalnessMap && (t.metalnessMap.value = n.metalnessMap),
      n.emissiveMap && (t.emissiveMap.value = n.emissiveMap),
      n.bumpMap &&
        ((t.bumpMap.value = n.bumpMap),
        (t.bumpScale.value = n.bumpScale),
        1 === n.side && (t.bumpScale.value *= -1)),
      n.normalMap &&
        ((t.normalMap.value = n.normalMap),
        t.normalScale.value.copy(n.normalScale),
        1 === n.side && t.normalScale.value.negate()),
      n.displacementMap &&
        ((t.displacementMap.value = n.displacementMap),
        (t.displacementScale.value = n.displacementScale),
        (t.displacementBias.value = n.displacementBias));
    e.get(n).envMap && (t.envMapIntensity.value = n.envMapIntensity);
  }
  return {
    refreshFogUniforms: function (e, t) {
      e.fogColor.value.copy(t.color),
        t.isFog
          ? ((e.fogNear.value = t.near), (e.fogFar.value = t.far))
          : t.isFogExp2 && (e.fogDensity.value = t.density);
    },
    refreshMaterialUniforms: function (e, i, r, s, a) {
      i.isMeshBasicMaterial
        ? t(e, i)
        : i.isMeshLambertMaterial
        ? (t(e, i),
          (function (e, t) {
            t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
          })(e, i))
        : i.isMeshToonMaterial
        ? (t(e, i),
          (function (e, t) {
            t.gradientMap && (e.gradientMap.value = t.gradientMap);
            t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
            t.bumpMap &&
              ((e.bumpMap.value = t.bumpMap),
              (e.bumpScale.value = t.bumpScale),
              1 === t.side && (e.bumpScale.value *= -1));
            t.normalMap &&
              ((e.normalMap.value = t.normalMap),
              e.normalScale.value.copy(t.normalScale),
              1 === t.side && e.normalScale.value.negate());
            t.displacementMap &&
              ((e.displacementMap.value = t.displacementMap),
              (e.displacementScale.value = t.displacementScale),
              (e.displacementBias.value = t.displacementBias));
          })(e, i))
        : i.isMeshPhongMaterial
        ? (t(e, i),
          (function (e, t) {
            e.specular.value.copy(t.specular),
              (e.shininess.value = Math.max(t.shininess, 1e-4)),
              t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
            t.bumpMap &&
              ((e.bumpMap.value = t.bumpMap),
              (e.bumpScale.value = t.bumpScale),
              1 === t.side && (e.bumpScale.value *= -1));
            t.normalMap &&
              ((e.normalMap.value = t.normalMap),
              e.normalScale.value.copy(t.normalScale),
              1 === t.side && e.normalScale.value.negate());
            t.displacementMap &&
              ((e.displacementMap.value = t.displacementMap),
              (e.displacementScale.value = t.displacementScale),
              (e.displacementBias.value = t.displacementBias));
          })(e, i))
        : i.isMeshStandardMaterial
        ? (t(e, i),
          i.isMeshPhysicalMaterial
            ? (function (e, t, i) {
                n(e, t),
                  (e.ior.value = t.ior),
                  t.sheen > 0 &&
                    (e.sheenTint.value
                      .copy(t.sheenTint)
                      .multiplyScalar(t.sheen),
                    (e.sheenRoughness.value = t.sheenRoughness));
                t.clearcoat > 0 &&
                  ((e.clearcoat.value = t.clearcoat),
                  (e.clearcoatRoughness.value = t.clearcoatRoughness),
                  t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap),
                  t.clearcoatRoughnessMap &&
                    (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap),
                  t.clearcoatNormalMap &&
                    (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),
                    (e.clearcoatNormalMap.value = t.clearcoatNormalMap),
                    1 === t.side && e.clearcoatNormalScale.value.negate()));
                t.transmission > 0 &&
                  ((e.transmission.value = t.transmission),
                  (e.transmissionSamplerMap.value = i.texture),
                  e.transmissionSamplerSize.value.set(i.width, i.height),
                  t.transmissionMap &&
                    (e.transmissionMap.value = t.transmissionMap),
                  (e.thickness.value = t.thickness),
                  t.thicknessMap && (e.thicknessMap.value = t.thicknessMap),
                  (e.attenuationDistance.value = t.attenuationDistance),
                  e.attenuationTint.value.copy(t.attenuationTint));
                (e.specularIntensity.value = t.specularIntensity),
                  e.specularTint.value.copy(t.specularTint),
                  t.specularIntensityMap &&
                    (e.specularIntensityMap.value = t.specularIntensityMap);
                t.specularTintMap &&
                  (e.specularTintMap.value = t.specularTintMap);
              })(e, i, a)
            : n(e, i))
        : i.isMeshMatcapMaterial
        ? (t(e, i),
          (function (e, t) {
            t.matcap && (e.matcap.value = t.matcap);
            t.bumpMap &&
              ((e.bumpMap.value = t.bumpMap),
              (e.bumpScale.value = t.bumpScale),
              1 === t.side && (e.bumpScale.value *= -1));
            t.normalMap &&
              ((e.normalMap.value = t.normalMap),
              e.normalScale.value.copy(t.normalScale),
              1 === t.side && e.normalScale.value.negate());
            t.displacementMap &&
              ((e.displacementMap.value = t.displacementMap),
              (e.displacementScale.value = t.displacementScale),
              (e.displacementBias.value = t.displacementBias));
          })(e, i))
        : i.isMeshDepthMaterial
        ? (t(e, i),
          (function (e, t) {
            t.displacementMap &&
              ((e.displacementMap.value = t.displacementMap),
              (e.displacementScale.value = t.displacementScale),
              (e.displacementBias.value = t.displacementBias));
          })(e, i))
        : i.isMeshDistanceMaterial
        ? (t(e, i),
          (function (e, t) {
            t.displacementMap &&
              ((e.displacementMap.value = t.displacementMap),
              (e.displacementScale.value = t.displacementScale),
              (e.displacementBias.value = t.displacementBias));
            e.referencePosition.value.copy(t.referencePosition),
              (e.nearDistance.value = t.nearDistance),
              (e.farDistance.value = t.farDistance);
          })(e, i))
        : i.isMeshNormalMaterial
        ? (t(e, i),
          (function (e, t) {
            t.bumpMap &&
              ((e.bumpMap.value = t.bumpMap),
              (e.bumpScale.value = t.bumpScale),
              1 === t.side && (e.bumpScale.value *= -1));
            t.normalMap &&
              ((e.normalMap.value = t.normalMap),
              e.normalScale.value.copy(t.normalScale),
              1 === t.side && e.normalScale.value.negate());
            t.displacementMap &&
              ((e.displacementMap.value = t.displacementMap),
              (e.displacementScale.value = t.displacementScale),
              (e.displacementBias.value = t.displacementBias));
          })(e, i))
        : i.isLineBasicMaterial
        ? ((function (e, t) {
            e.diffuse.value.copy(t.color), (e.opacity.value = t.opacity);
          })(e, i),
          i.isLineDashedMaterial &&
            (function (e, t) {
              (e.dashSize.value = t.dashSize),
                (e.totalSize.value = t.dashSize + t.gapSize),
                (e.scale.value = t.scale);
            })(e, i))
        : i.isPointsMaterial
        ? (function (e, t, n, i) {
            e.diffuse.value.copy(t.color),
              (e.opacity.value = t.opacity),
              (e.size.value = t.size * n),
              (e.scale.value = 0.5 * i),
              t.map && (e.map.value = t.map);
            t.alphaMap && (e.alphaMap.value = t.alphaMap);
            t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest);
            let r;
            t.map ? (r = t.map) : t.alphaMap && (r = t.alphaMap);
            void 0 !== r &&
              (!0 === r.matrixAutoUpdate && r.updateMatrix(),
              e.uvTransform.value.copy(r.matrix));
          })(e, i, r, s)
        : i.isSpriteMaterial
        ? (function (e, t) {
            e.diffuse.value.copy(t.color),
              (e.opacity.value = t.opacity),
              (e.rotation.value = t.rotation),
              t.map && (e.map.value = t.map);
            t.alphaMap && (e.alphaMap.value = t.alphaMap);
            t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest);
            let n;
            t.map ? (n = t.map) : t.alphaMap && (n = t.alphaMap);
            void 0 !== n &&
              (!0 === n.matrixAutoUpdate && n.updateMatrix(),
              e.uvTransform.value.copy(n.matrix));
          })(e, i)
        : i.isShadowMaterial
        ? (e.color.value.copy(i.color), (e.opacity.value = i.opacity))
        : i.isShaderMaterial && (i.uniformsNeedUpdate = !1);
    },
  };
}
function DT(e = {}) {
  const t =
      void 0 !== e.canvas
        ? e.canvas
        : (function () {
            const e = vx("canvas");
            return (e.style.display = "block"), e;
          })(),
    n = void 0 !== e.context ? e.context : null,
    i = void 0 !== e.alpha && e.alpha,
    r = void 0 === e.depth || e.depth,
    s = void 0 === e.stencil || e.stencil,
    a = void 0 !== e.antialias && e.antialias,
    o = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
    l = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
    c = void 0 !== e.powerPreference ? e.powerPreference : "default",
    u =
      void 0 !== e.failIfMajorPerformanceCaveat &&
      e.failIfMajorPerformanceCaveat;
  let h = null,
    d = null;
  const p = [],
    f = [];
  (this.domElement = t),
    (this.debug = { checkShaderErrors: !0 }),
    (this.autoClear = !0),
    (this.autoClearColor = !0),
    (this.autoClearDepth = !0),
    (this.autoClearStencil = !0),
    (this.sortObjects = !0),
    (this.clippingPlanes = []),
    (this.localClippingEnabled = !1),
    (this.gammaFactor = 2),
    (this.outputEncoding = 3e3),
    (this.physicallyCorrectLights = !1),
    (this.toneMapping = 0),
    (this.toneMappingExposure = 1);
  const m = this;
  let g = !1,
    v = 0,
    _ = 0,
    y = null,
    x = -1,
    b = null;
  const w = new wx(),
    S = new wx();
  let M = null,
    T = t.width,
    C = t.height,
    E = 1,
    A = null,
    P = null;
  const L = new wx(0, 0, T, C),
    I = new wx(0, 0, T, C);
  let R = !1;
  const D = [],
    k = new jw();
  let N = !1,
    O = !1,
    F = null;
  const z = new ib(),
    U = new Cx(),
    B = {
      background: null,
      fog: null,
      environment: null,
      overrideMaterial: null,
      isScene: !0,
    };
  function V() {
    return null === y ? E : 1;
  }
  let H,
    G,
    W,
    q,
    j,
    Y,
    X,
    $,
    Z,
    K,
    J,
    Q,
    ee,
    te,
    ne,
    ie,
    re,
    se,
    ae,
    oe,
    le,
    ce,
    ue,
    he = n;
  function de(e, n) {
    for (let i = 0; i < e.length; i++) {
      const r = e[i],
        s = t.getContext(r, n);
      if (null !== s) return s;
    }
    return null;
  }
  try {
    const e = {
      alpha: i,
      depth: r,
      stencil: s,
      antialias: a,
      premultipliedAlpha: o,
      preserveDrawingBuffer: l,
      powerPreference: c,
      failIfMajorPerformanceCaveat: u,
    };
    if (
      (t.addEventListener("webglcontextlost", me, !1),
      t.addEventListener("webglcontextrestored", ge, !1),
      null === he)
    ) {
      const t = ["webgl2", "webgl", "experimental-webgl"];
      if (
        (!0 === m.isWebGL1Renderer && t.shift(), (he = de(t, e)), null === he)
      )
        throw de(t)
          ? new Error(
              "Error creating WebGL context with your selected attributes."
            )
          : new Error("Error creating WebGL context.");
    }
    void 0 === he.getShaderPrecisionFormat &&
      (he.getShaderPrecisionFormat = function () {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
  } catch (Pe) {
    throw Pe;
  }
  function pe() {
    (H = new LS(he)),
      (G = new nS(he, H, e)),
      H.init(G),
      (ce = new CT(he, H, G)),
      (W = new MT(he, H, G)),
      (D[0] = 1029),
      (q = new DS(he)),
      (j = new uT()),
      (Y = new TT(he, H, W, j, G, ce, q)),
      (X = new rS(m)),
      ($ = new PS(m)),
      (Z = new Xw(he, G)),
      (ue = new eS(he, H, Z, G)),
      (K = new IS(he, Z, q, ue)),
      (J = new US(he, K, Z, q)),
      (ae = new zS(he, G, Y)),
      (ie = new iS(j)),
      (Q = new cT(m, X, $, H, G, ue, ie)),
      (ee = new RT(j)),
      (te = new fT(j)),
      (ne = new xT(H, G)),
      (se = new Qw(m, X, W, J, o)),
      (re = new ST(m, J, G)),
      (oe = new tS(he, H, q, G)),
      (le = new RS(he, H, q, G)),
      (q.programs = Q.programs),
      (m.capabilities = G),
      (m.extensions = H),
      (m.properties = j),
      (m.renderLists = te),
      (m.shadowMap = re),
      (m.state = W),
      (m.info = q);
  }
  pe();
  const fe = new IT(m, he);
  function me(e) {
    e.preventDefault(), (g = !0);
  }
  function ge() {
    g = !1;
    const e = q.autoReset,
      t = re.enabled,
      n = re.autoUpdate,
      i = re.needsUpdate,
      r = re.type;
    pe(),
      (q.autoReset = e),
      (re.enabled = t),
      (re.autoUpdate = n),
      (re.needsUpdate = i),
      (re.type = r);
  }
  function ve(e) {
    const t = e.target;
    t.removeEventListener("dispose", ve),
      (function (e) {
        (function (e) {
          const t = j.get(e).programs;
          void 0 !== t &&
            t.forEach(function (e) {
              Q.releaseProgram(e);
            });
        })(e),
          j.remove(e);
      })(t);
  }
  (this.xr = fe),
    (this.getContext = function () {
      return he;
    }),
    (this.getContextAttributes = function () {
      return he.getContextAttributes();
    }),
    (this.forceContextLoss = function () {
      const e = H.get("WEBGL_lose_context");
      e && e.loseContext();
    }),
    (this.forceContextRestore = function () {
      const e = H.get("WEBGL_lose_context");
      e && e.restoreContext();
    }),
    (this.getPixelRatio = function () {
      return E;
    }),
    (this.setPixelRatio = function (e) {
      void 0 !== e && ((E = e), this.setSize(T, C, !1));
    }),
    (this.getSize = function (e) {
      return e.set(T, C);
    }),
    (this.setSize = function (e, n, i) {
      fe.isPresenting ||
        ((T = e),
        (C = n),
        (t.width = Math.floor(e * E)),
        (t.height = Math.floor(n * E)),
        !1 !== i && ((t.style.width = e + "px"), (t.style.height = n + "px")),
        this.setViewport(0, 0, e, n));
    }),
    (this.getDrawingBufferSize = function (e) {
      return e.set(T * E, C * E).floor();
    }),
    (this.setDrawingBufferSize = function (e, n, i) {
      (T = e),
        (C = n),
        (E = i),
        (t.width = Math.floor(e * i)),
        (t.height = Math.floor(n * i)),
        this.setViewport(0, 0, e, n);
    }),
    (this.getCurrentViewport = function (e) {
      return e.copy(w);
    }),
    (this.getViewport = function (e) {
      return e.copy(L);
    }),
    (this.setViewport = function (e, t, n, i) {
      e.isVector4 ? L.set(e.x, e.y, e.z, e.w) : L.set(e, t, n, i),
        W.viewport(w.copy(L).multiplyScalar(E).floor());
    }),
    (this.getScissor = function (e) {
      return e.copy(I);
    }),
    (this.setScissor = function (e, t, n, i) {
      e.isVector4 ? I.set(e.x, e.y, e.z, e.w) : I.set(e, t, n, i),
        W.scissor(S.copy(I).multiplyScalar(E).floor());
    }),
    (this.getScissorTest = function () {
      return R;
    }),
    (this.setScissorTest = function (e) {
      W.setScissorTest((R = e));
    }),
    (this.setOpaqueSort = function (e) {
      A = e;
    }),
    (this.setTransparentSort = function (e) {
      P = e;
    }),
    (this.getClearColor = function (e) {
      return e.copy(se.getClearColor());
    }),
    (this.setClearColor = function () {
      se.setClearColor.apply(se, arguments);
    }),
    (this.getClearAlpha = function () {
      return se.getClearAlpha();
    }),
    (this.setClearAlpha = function () {
      se.setClearAlpha.apply(se, arguments);
    }),
    (this.clear = function (e, t, n) {
      let i = 0;
      (void 0 === e || e) && (i |= 16384),
        (void 0 === t || t) && (i |= 256),
        (void 0 === n || n) && (i |= 1024),
        he.clear(i);
    }),
    (this.clearColor = function () {
      this.clear(!0, !1, !1);
    }),
    (this.clearDepth = function () {
      this.clear(!1, !0, !1);
    }),
    (this.clearStencil = function () {
      this.clear(!1, !1, !0);
    }),
    (this.dispose = function () {
      t.removeEventListener("webglcontextlost", me, !1),
        t.removeEventListener("webglcontextrestored", ge, !1),
        te.dispose(),
        ne.dispose(),
        j.dispose(),
        X.dispose(),
        $.dispose(),
        J.dispose(),
        ue.dispose(),
        fe.dispose(),
        fe.removeEventListener("sessionstart", ye),
        fe.removeEventListener("sessionend", xe),
        F && (F.dispose(), (F = null)),
        be.stop();
    }),
    (this.renderBufferImmediate = function (e, t) {
      ue.initAttributes();
      const n = j.get(e);
      e.hasPositions && !n.position && (n.position = he.createBuffer()),
        e.hasNormals && !n.normal && (n.normal = he.createBuffer()),
        e.hasUvs && !n.uv && (n.uv = he.createBuffer()),
        e.hasColors && !n.color && (n.color = he.createBuffer());
      const i = t.getAttributes();
      e.hasPositions &&
        (he.bindBuffer(34962, n.position),
        he.bufferData(34962, e.positionArray, 35048),
        ue.enableAttribute(i.position.location),
        he.vertexAttribPointer(i.position.location, 3, 5126, !1, 0, 0)),
        e.hasNormals &&
          (he.bindBuffer(34962, n.normal),
          he.bufferData(34962, e.normalArray, 35048),
          ue.enableAttribute(i.normal.location),
          he.vertexAttribPointer(i.normal.location, 3, 5126, !1, 0, 0)),
        e.hasUvs &&
          (he.bindBuffer(34962, n.uv),
          he.bufferData(34962, e.uvArray, 35048),
          ue.enableAttribute(i.uv.location),
          he.vertexAttribPointer(i.uv.location, 2, 5126, !1, 0, 0)),
        e.hasColors &&
          (he.bindBuffer(34962, n.color),
          he.bufferData(34962, e.colorArray, 35048),
          ue.enableAttribute(i.color.location),
          he.vertexAttribPointer(i.color.location, 3, 5126, !1, 0, 0)),
        ue.disableUnusedAttributes(),
        he.drawArrays(4, 0, e.count),
        (e.count = 0);
    }),
    (this.renderBufferDirect = function (e, t, n, i, r, s) {
      null === t && (t = B);
      const a = r.isMesh && r.matrixWorld.determinant() < 0,
        o = Ae(e, t, i, r);
      W.setMaterial(i, a);
      let l = n.index;
      const c = n.attributes.position;
      if (null === l) {
        if (void 0 === c || 0 === c.count) return;
      } else if (0 === l.count) return;
      let u,
        h = 1;
      !0 === i.wireframe && ((l = K.getWireframeAttribute(n)), (h = 2)),
        (void 0 === n.morphAttributes.position &&
          void 0 === n.morphAttributes.normal) ||
          ae.update(r, n, i, o),
        ue.setup(r, i, o, n, l);
      let d = oe;
      null !== l && ((u = Z.get(l)), (d = le), d.setIndex(u));
      const p = null !== l ? l.count : c.count,
        f = n.drawRange.start * h,
        m = n.drawRange.count * h,
        g = null !== s ? s.start * h : 0,
        v = null !== s ? s.count * h : Infinity,
        _ = Math.max(f, g),
        y = Math.min(p, f + m, g + v) - 1,
        x = Math.max(0, y - _ + 1);
      if (0 !== x) {
        if (r.isMesh)
          !0 === i.wireframe
            ? (W.setLineWidth(i.wireframeLinewidth * V()), d.setMode(1))
            : d.setMode(4);
        else if (r.isLine) {
          let e = i.linewidth;
          void 0 === e && (e = 1),
            W.setLineWidth(e * V()),
            r.isLineSegments
              ? d.setMode(1)
              : r.isLineLoop
              ? d.setMode(2)
              : d.setMode(3);
        } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
        if (r.isInstancedMesh) d.renderInstances(_, x, r.count);
        else if (n.isInstancedBufferGeometry) {
          const e = Math.min(n.instanceCount, n._maxInstanceCount);
          d.renderInstances(_, x, e);
        } else d.render(_, x);
      }
    }),
    (this.compile = function (e, t) {
      (d = ne.get(e)),
        d.init(),
        f.push(d),
        e.traverseVisible(function (e) {
          e.isLight &&
            e.layers.test(t.layers) &&
            (d.pushLight(e), e.castShadow && d.pushShadow(e));
        }),
        d.setupLights(m.physicallyCorrectLights),
        e.traverse(function (t) {
          const n = t.material;
          if (n)
            if (Array.isArray(n))
              for (let i = 0; i < n.length; i++) {
                Ce(n[i], e, t);
              }
            else Ce(n, e, t);
        }),
        f.pop(),
        (d = null);
    });
  let _e = null;
  function ye() {
    be.stop();
  }
  function xe() {
    be.start();
  }
  const be = new Yw();
  function we(e, t, n, i) {
    if (!1 === e.visible) return;
    if (e.layers.test(t.layers))
      if (e.isGroup) n = e.renderOrder;
      else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
      else if (e.isLight) d.pushLight(e), e.castShadow && d.pushShadow(e);
      else if (e.isSprite) {
        if (!e.frustumCulled || k.intersectsSprite(e)) {
          i && U.setFromMatrixPosition(e.matrixWorld).applyMatrix4(z);
          const t = J.update(e),
            r = e.material;
          r.visible && h.push(e, t, r, n, U.z, null);
        }
      } else if (e.isImmediateRenderObject)
        i && U.setFromMatrixPosition(e.matrixWorld).applyMatrix4(z),
          h.push(e, null, e.material, n, U.z, null);
      else if (
        (e.isMesh || e.isLine || e.isPoints) &&
        (e.isSkinnedMesh &&
          e.skeleton.frame !== q.render.frame &&
          (e.skeleton.update(), (e.skeleton.frame = q.render.frame)),
        !e.frustumCulled || k.intersectsObject(e))
      ) {
        i && U.setFromMatrixPosition(e.matrixWorld).applyMatrix4(z);
        const t = J.update(e),
          r = e.material;
        if (Array.isArray(r)) {
          const i = t.groups;
          for (let s = 0, a = i.length; s < a; s++) {
            const a = i[s],
              o = r[a.materialIndex];
            o && o.visible && h.push(e, t, o, n, U.z, a);
          }
        } else r.visible && h.push(e, t, r, n, U.z, null);
      }
    const r = e.children;
    for (let s = 0, a = r.length; s < a; s++) we(r[s], t, n, i);
  }
  function Se(e, t, n, i) {
    const r = e.opaque,
      s = e.transmissive,
      o = e.transparent;
    d.setupLightsView(n),
      s.length > 0 &&
        (function (e, t, n) {
          if (null === F) {
            const e = !0 === a && !0 === G.isWebGL2;
            F = new (e ? Mx : Sx)(1024, 1024, {
              generateMipmaps: !0,
              type: null !== ce.convert(1016) ? 1016 : 1009,
              minFilter: 1008,
              magFilter: 1003,
              wrapS: 1001,
              wrapT: 1001,
            });
          }
          const i = m.getRenderTarget();
          m.setRenderTarget(F), m.clear();
          const r = m.toneMapping;
          (m.toneMapping = 0),
            Me(e, t, n),
            (m.toneMapping = r),
            Y.updateMultisampleRenderTarget(F),
            Y.updateRenderTargetMipmap(F),
            m.setRenderTarget(i);
        })(r, t, n),
      i && W.viewport(w.copy(i)),
      r.length > 0 && Me(r, t, n),
      s.length > 0 && Me(s, t, n),
      o.length > 0 && Me(o, t, n);
  }
  function Me(e, t, n) {
    const i = !0 === t.isScene ? t.overrideMaterial : null;
    for (let r = 0, s = e.length; r < s; r++) {
      const s = e[r],
        a = s.object,
        o = s.geometry,
        l = null === i ? s.material : i,
        c = s.group;
      a.layers.test(n.layers) && Te(a, t, n, o, l, c);
    }
  }
  function Te(e, t, n, i, r, s) {
    if (
      (e.onBeforeRender(m, t, n, i, r, s),
      e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld),
      e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
      r.onBeforeRender(m, t, n, i, e, s),
      e.isImmediateRenderObject)
    ) {
      const i = Ae(n, t, r, e);
      W.setMaterial(r),
        ue.reset(),
        (function (e, t) {
          e.render(function (e) {
            m.renderBufferImmediate(e, t);
          });
        })(e, i);
    } else
      !0 === r.transparent && 2 === r.side
        ? ((r.side = 1),
          (r.needsUpdate = !0),
          m.renderBufferDirect(n, t, i, r, e, s),
          (r.side = 0),
          (r.needsUpdate = !0),
          m.renderBufferDirect(n, t, i, r, e, s),
          (r.side = 2))
        : m.renderBufferDirect(n, t, i, r, e, s);
    e.onAfterRender(m, t, n, i, r, s);
  }
  function Ce(e, t, n) {
    !0 !== t.isScene && (t = B);
    const i = j.get(e),
      r = d.state.lights,
      s = d.state.shadowsArray,
      a = r.state.version,
      o = Q.getParameters(e, r.state, s, t, n),
      l = Q.getProgramCacheKey(o);
    let c = i.programs;
    (i.environment = e.isMeshStandardMaterial ? t.environment : null),
      (i.fog = t.fog),
      (i.envMap = (e.isMeshStandardMaterial ? $ : X).get(
        e.envMap || i.environment
      )),
      void 0 === c &&
        (e.addEventListener("dispose", ve), (c = new Map()), (i.programs = c));
    let u = c.get(l);
    if (void 0 !== u) {
      if (i.currentProgram === u && i.lightsStateVersion === a)
        return Ee(e, o), u;
    } else
      (o.uniforms = Q.getUniforms(e)),
        e.onBuild(o, m),
        e.onBeforeCompile(o, m),
        (u = Q.acquireProgram(o, l)),
        c.set(l, u),
        (i.uniforms = o.uniforms);
    const h = i.uniforms;
    ((e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping) ||
      (h.clippingPlanes = ie.uniform),
      Ee(e, o),
      (i.needsLights = (function (e) {
        return (
          e.isMeshLambertMaterial ||
          e.isMeshToonMaterial ||
          e.isMeshPhongMaterial ||
          e.isMeshStandardMaterial ||
          e.isShadowMaterial ||
          (e.isShaderMaterial && !0 === e.lights)
        );
      })(e)),
      (i.lightsStateVersion = a),
      i.needsLights &&
        ((h.ambientLightColor.value = r.state.ambient),
        (h.lightProbe.value = r.state.probe),
        (h.directionalLights.value = r.state.directional),
        (h.directionalLightShadows.value = r.state.directionalShadow),
        (h.spotLights.value = r.state.spot),
        (h.spotLightShadows.value = r.state.spotShadow),
        (h.rectAreaLights.value = r.state.rectArea),
        (h.ltc_1.value = r.state.rectAreaLTC1),
        (h.ltc_2.value = r.state.rectAreaLTC2),
        (h.pointLights.value = r.state.point),
        (h.pointLightShadows.value = r.state.pointShadow),
        (h.hemisphereLights.value = r.state.hemi),
        (h.directionalShadowMap.value = r.state.directionalShadowMap),
        (h.directionalShadowMatrix.value = r.state.directionalShadowMatrix),
        (h.spotShadowMap.value = r.state.spotShadowMap),
        (h.spotShadowMatrix.value = r.state.spotShadowMatrix),
        (h.pointShadowMap.value = r.state.pointShadowMap),
        (h.pointShadowMatrix.value = r.state.pointShadowMatrix));
    const p = u.getUniforms(),
      f = HM.seqWithValue(p.seq, h);
    return (i.currentProgram = u), (i.uniformsList = f), u;
  }
  function Ee(e, t) {
    const n = j.get(e);
    (n.outputEncoding = t.outputEncoding),
      (n.instancing = t.instancing),
      (n.skinning = t.skinning),
      (n.morphTargets = t.morphTargets),
      (n.morphNormals = t.morphNormals),
      (n.morphTargetsCount = t.morphTargetsCount),
      (n.numClippingPlanes = t.numClippingPlanes),
      (n.numIntersection = t.numClipIntersection),
      (n.vertexAlphas = t.vertexAlphas),
      (n.vertexTangents = t.vertexTangents);
  }
  function Ae(e, t, n, i) {
    !0 !== t.isScene && (t = B), Y.resetTextureUnits();
    const r = t.fog,
      s = n.isMeshStandardMaterial ? t.environment : null,
      a = null === y ? m.outputEncoding : y.texture.encoding,
      o = (n.isMeshStandardMaterial ? $ : X).get(n.envMap || s),
      l =
        !0 === n.vertexColors &&
        !!i.geometry &&
        !!i.geometry.attributes.color &&
        4 === i.geometry.attributes.color.itemSize,
      c = !!n.normalMap && !!i.geometry && !!i.geometry.attributes.tangent,
      u = !!i.geometry && !!i.geometry.morphAttributes.position,
      h = !!i.geometry && !!i.geometry.morphAttributes.normal,
      p =
        i.geometry && i.geometry.morphAttributes.position
          ? i.geometry.morphAttributes.position.length
          : 0,
      f = j.get(n),
      g = d.state.lights;
    if (!0 === N && (!0 === O || e !== b)) {
      const t = e === b && n.id === x;
      ie.setState(n, e, t);
    }
    let v = !1;
    n.version === f.__version
      ? (f.needsLights && f.lightsStateVersion !== g.state.version) ||
        f.outputEncoding !== a ||
        (i.isInstancedMesh && !1 === f.instancing)
        ? (v = !0)
        : i.isInstancedMesh || !0 !== f.instancing
        ? i.isSkinnedMesh && !1 === f.skinning
          ? (v = !0)
          : i.isSkinnedMesh || !0 !== f.skinning
          ? f.envMap !== o || (n.fog && f.fog !== r)
            ? (v = !0)
            : void 0 === f.numClippingPlanes ||
              (f.numClippingPlanes === ie.numPlanes &&
                f.numIntersection === ie.numIntersection)
            ? (f.vertexAlphas !== l ||
                f.vertexTangents !== c ||
                f.morphTargets !== u ||
                f.morphNormals !== h ||
                (!0 === G.isWebGL2 && f.morphTargetsCount !== p)) &&
              (v = !0)
            : (v = !0)
          : (v = !0)
        : (v = !0)
      : ((v = !0), (f.__version = n.version));
    let _ = f.currentProgram;
    !0 === v && (_ = Ce(n, t, i));
    let w = !1,
      S = !1,
      M = !1;
    const T = _.getUniforms(),
      A = f.uniforms;
    if (
      (W.useProgram(_.program) && ((w = !0), (S = !0), (M = !0)),
      n.id !== x && ((x = n.id), (S = !0)),
      w || b !== e)
    ) {
      if (
        (T.setValue(he, "projectionMatrix", e.projectionMatrix),
        G.logarithmicDepthBuffer &&
          T.setValue(he, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)),
        b !== e && ((b = e), (S = !0), (M = !0)),
        n.isShaderMaterial ||
          n.isMeshPhongMaterial ||
          n.isMeshToonMaterial ||
          n.isMeshStandardMaterial ||
          n.envMap)
      ) {
        const t = T.map.cameraPosition;
        void 0 !== t && t.setValue(he, U.setFromMatrixPosition(e.matrixWorld));
      }
      (n.isMeshPhongMaterial ||
        n.isMeshToonMaterial ||
        n.isMeshLambertMaterial ||
        n.isMeshBasicMaterial ||
        n.isMeshStandardMaterial ||
        n.isShaderMaterial) &&
        T.setValue(he, "isOrthographic", !0 === e.isOrthographicCamera),
        (n.isMeshPhongMaterial ||
          n.isMeshToonMaterial ||
          n.isMeshLambertMaterial ||
          n.isMeshBasicMaterial ||
          n.isMeshStandardMaterial ||
          n.isShaderMaterial ||
          n.isShadowMaterial ||
          i.isSkinnedMesh) &&
          T.setValue(he, "viewMatrix", e.matrixWorldInverse);
    }
    if (i.isSkinnedMesh) {
      T.setOptional(he, i, "bindMatrix"),
        T.setOptional(he, i, "bindMatrixInverse");
      const e = i.skeleton;
      e &&
        (G.floatVertexTextures
          ? (null === e.boneTexture && e.computeBoneTexture(),
            T.setValue(he, "boneTexture", e.boneTexture, Y),
            T.setValue(he, "boneTextureSize", e.boneTextureSize))
          : T.setOptional(he, e, "boneMatrices"));
    }
    var P, L;
    return (
      (S || f.receiveShadow !== i.receiveShadow) &&
        ((f.receiveShadow = i.receiveShadow),
        T.setValue(he, "receiveShadow", i.receiveShadow)),
      S &&
        (T.setValue(he, "toneMappingExposure", m.toneMappingExposure),
        f.needsLights &&
          ((L = M),
          ((P = A).ambientLightColor.needsUpdate = L),
          (P.lightProbe.needsUpdate = L),
          (P.directionalLights.needsUpdate = L),
          (P.directionalLightShadows.needsUpdate = L),
          (P.pointLights.needsUpdate = L),
          (P.pointLightShadows.needsUpdate = L),
          (P.spotLights.needsUpdate = L),
          (P.spotLightShadows.needsUpdate = L),
          (P.rectAreaLights.needsUpdate = L),
          (P.hemisphereLights.needsUpdate = L)),
        r && n.fog && ee.refreshFogUniforms(A, r),
        ee.refreshMaterialUniforms(A, n, E, C, F),
        HM.upload(he, f.uniformsList, A, Y)),
      n.isShaderMaterial &&
        !0 === n.uniformsNeedUpdate &&
        (HM.upload(he, f.uniformsList, A, Y), (n.uniformsNeedUpdate = !1)),
      n.isSpriteMaterial && T.setValue(he, "center", i.center),
      T.setValue(he, "modelViewMatrix", i.modelViewMatrix),
      T.setValue(he, "normalMatrix", i.normalMatrix),
      T.setValue(he, "modelMatrix", i.matrixWorld),
      _
    );
  }
  be.setAnimationLoop(function (e) {
    _e && _e(e);
  }),
    "undefined" != typeof window && be.setContext(window),
    (this.setAnimationLoop = function (e) {
      (_e = e), fe.setAnimationLoop(e), null === e ? be.stop() : be.start();
    }),
    fe.addEventListener("sessionstart", ye),
    fe.addEventListener("sessionend", xe),
    (this.render = function (e, t) {
      if (void 0 !== t && !0 !== t.isCamera) return;
      if (!0 === g) return;
      !0 === e.autoUpdate && e.updateMatrixWorld(),
        null === t.parent && t.updateMatrixWorld(),
        !0 === fe.enabled &&
          !0 === fe.isPresenting &&
          (!0 === fe.cameraAutoUpdate && fe.updateCamera(t),
          (t = fe.getCamera())),
        !0 === e.isScene && e.onBeforeRender(m, e, t, y),
        (d = ne.get(e, f.length)),
        d.init(),
        f.push(d),
        z.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
        k.setFromProjectionMatrix(z),
        (O = this.localClippingEnabled),
        (N = ie.init(this.clippingPlanes, O, t)),
        (h = te.get(e, p.length)),
        h.init(),
        p.push(h),
        we(e, t, 0, m.sortObjects),
        h.finish(),
        !0 === m.sortObjects && h.sort(A, P),
        !0 === N && ie.beginShadows();
      const n = d.state.shadowsArray;
      if (
        (re.render(n, e, t),
        !0 === N && ie.endShadows(),
        !0 === this.info.autoReset && this.info.reset(),
        se.render(h, e),
        d.setupLights(m.physicallyCorrectLights),
        t.isArrayCamera)
      ) {
        const n = t.cameras;
        for (let t = 0, i = n.length; t < i; t++) {
          const i = n[t];
          Se(h, e, i, i.viewport);
        }
      } else Se(h, e, t);
      null !== y &&
        (Y.updateMultisampleRenderTarget(y), Y.updateRenderTargetMipmap(y)),
        !0 === e.isScene && e.onAfterRender(m, e, t),
        W.buffers.depth.setTest(!0),
        W.buffers.depth.setMask(!0),
        W.buffers.color.setMask(!0),
        W.setPolygonOffset(!1),
        ue.resetDefaultState(),
        (x = -1),
        (b = null),
        f.pop(),
        (d = f.length > 0 ? f[f.length - 1] : null),
        p.pop(),
        (h = p.length > 0 ? p[p.length - 1] : null);
    }),
    (this.getActiveCubeFace = function () {
      return v;
    }),
    (this.getActiveMipmapLevel = function () {
      return _;
    }),
    (this.getRenderTarget = function () {
      return y;
    }),
    (this.setRenderTarget = function (e, t = 0, n = 0) {
      (y = e),
        (v = t),
        (_ = n),
        e && void 0 === j.get(e).__webglFramebuffer && Y.setupRenderTarget(e);
      let i = null,
        r = !1,
        s = !1;
      if (e) {
        const n = e.texture;
        (n.isDataTexture3D || n.isDataTexture2DArray) && (s = !0);
        const a = j.get(e).__webglFramebuffer;
        e.isWebGLCubeRenderTarget
          ? ((i = a[t]), (r = !0))
          : (i = e.isWebGLMultisampleRenderTarget
              ? j.get(e).__webglMultisampledFramebuffer
              : a),
          w.copy(e.viewport),
          S.copy(e.scissor),
          (M = e.scissorTest);
      } else
        w.copy(L).multiplyScalar(E).floor(),
          S.copy(I).multiplyScalar(E).floor(),
          (M = R);
      if (W.bindFramebuffer(36160, i) && G.drawBuffers) {
        let t = !1;
        if (e)
          if (e.isWebGLMultipleRenderTargets) {
            const n = e.texture;
            if (D.length !== n.length || 36064 !== D[0]) {
              for (let e = 0, t = n.length; e < t; e++) D[e] = 36064 + e;
              (D.length = n.length), (t = !0);
            }
          } else
            (1 === D.length && 36064 === D[0]) ||
              ((D[0] = 36064), (D.length = 1), (t = !0));
        else
          (1 === D.length && 1029 === D[0]) ||
            ((D[0] = 1029), (D.length = 1), (t = !0));
        t &&
          (G.isWebGL2
            ? he.drawBuffers(D)
            : H.get("WEBGL_draw_buffers").drawBuffersWEBGL(D));
      }
      if ((W.viewport(w), W.scissor(S), W.setScissorTest(M), r)) {
        const i = j.get(e.texture);
        he.framebufferTexture2D(36160, 36064, 34069 + t, i.__webglTexture, n);
      } else if (s) {
        const i = j.get(e.texture),
          r = t || 0;
        he.framebufferTextureLayer(36160, 36064, i.__webglTexture, n || 0, r);
      }
      x = -1;
    }),
    (this.readRenderTargetPixels = function (e, t, n, i, r, s, a) {
      if (!e || !e.isWebGLRenderTarget) return;
      let o = j.get(e).__webglFramebuffer;
      if ((e.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o)) {
        W.bindFramebuffer(36160, o);
        try {
          const a = e.texture,
            o = a.format,
            l = a.type;
          if (1023 !== o && ce.convert(o) !== he.getParameter(35739)) return;
          const c =
            1016 === l &&
            (H.has("EXT_color_buffer_half_float") ||
              (G.isWebGL2 && H.has("EXT_color_buffer_float")));
          if (
            !(
              1009 === l ||
              ce.convert(l) === he.getParameter(35738) ||
              (1015 === l &&
                (G.isWebGL2 ||
                  H.has("OES_texture_float") ||
                  H.has("WEBGL_color_buffer_float"))) ||
              c
            )
          )
            return;
          36053 === he.checkFramebufferStatus(36160) &&
            t >= 0 &&
            t <= e.width - i &&
            n >= 0 &&
            n <= e.height - r &&
            he.readPixels(t, n, i, r, ce.convert(o), ce.convert(l), s);
        } finally {
          const e = null !== y ? j.get(y).__webglFramebuffer : null;
          W.bindFramebuffer(36160, e);
        }
      }
    }),
    (this.copyFramebufferToTexture = function (e, t, n = 0) {
      const i = Math.pow(2, -n),
        r = Math.floor(t.image.width * i),
        s = Math.floor(t.image.height * i);
      let a = ce.convert(t.format);
      G.isWebGL2 && (6407 === a && (a = 32849), 6408 === a && (a = 32856)),
        Y.setTexture2D(t, 0),
        he.copyTexImage2D(3553, n, a, e.x, e.y, r, s, 0),
        W.unbindTexture();
    }),
    (this.copyTextureToTexture = function (e, t, n, i = 0) {
      const r = t.image.width,
        s = t.image.height,
        a = ce.convert(n.format),
        o = ce.convert(n.type);
      Y.setTexture2D(n, 0),
        he.pixelStorei(37440, n.flipY),
        he.pixelStorei(37441, n.premultiplyAlpha),
        he.pixelStorei(3317, n.unpackAlignment),
        t.isDataTexture
          ? he.texSubImage2D(3553, i, e.x, e.y, r, s, a, o, t.image.data)
          : t.isCompressedTexture
          ? he.compressedTexSubImage2D(
              3553,
              i,
              e.x,
              e.y,
              t.mipmaps[0].width,
              t.mipmaps[0].height,
              a,
              t.mipmaps[0].data
            )
          : he.texSubImage2D(3553, i, e.x, e.y, a, o, t.image),
        0 === i && n.generateMipmaps && he.generateMipmap(3553),
        W.unbindTexture();
    }),
    (this.copyTextureToTexture3D = function (e, t, n, i, r = 0) {
      if (m.isWebGL1Renderer) return;
      const s = e.max.x - e.min.x + 1,
        a = e.max.y - e.min.y + 1,
        o = e.max.z - e.min.z + 1,
        l = ce.convert(i.format),
        c = ce.convert(i.type);
      let u;
      if (i.isDataTexture3D) Y.setTexture3D(i, 0), (u = 32879);
      else {
        if (!i.isDataTexture2DArray) return;
        Y.setTexture2DArray(i, 0), (u = 35866);
      }
      he.pixelStorei(37440, i.flipY),
        he.pixelStorei(37441, i.premultiplyAlpha),
        he.pixelStorei(3317, i.unpackAlignment);
      const h = he.getParameter(3314),
        d = he.getParameter(32878),
        p = he.getParameter(3316),
        f = he.getParameter(3315),
        g = he.getParameter(32877),
        v = n.isCompressedTexture ? n.mipmaps[0] : n.image;
      he.pixelStorei(3314, v.width),
        he.pixelStorei(32878, v.height),
        he.pixelStorei(3316, e.min.x),
        he.pixelStorei(3315, e.min.y),
        he.pixelStorei(32877, e.min.z),
        n.isDataTexture || n.isDataTexture3D
          ? he.texSubImage3D(u, r, t.x, t.y, t.z, s, a, o, l, c, v.data)
          : n.isCompressedTexture
          ? he.compressedTexSubImage3D(u, r, t.x, t.y, t.z, s, a, o, l, v.data)
          : he.texSubImage3D(u, r, t.x, t.y, t.z, s, a, o, l, c, v),
        he.pixelStorei(3314, h),
        he.pixelStorei(32878, d),
        he.pixelStorei(3316, p),
        he.pixelStorei(3315, f),
        he.pixelStorei(32877, g),
        0 === r && i.generateMipmaps && he.generateMipmap(u),
        W.unbindTexture();
    }),
    (this.initTexture = function (e) {
      Y.setTexture2D(e, 0), W.unbindTexture();
    }),
    (this.resetState = function () {
      (v = 0), (_ = 0), (y = null), W.reset(), ue.reset();
    }),
    "undefined" != typeof __THREE_DEVTOOLS__ &&
      __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent("observe", { detail: this })
      );
}
class kT {
  constructor(e, t = 1, n = 1e3) {
    (this.name = ""), (this.color = new Xb(e)), (this.near = t), (this.far = n);
  }
  clone() {
    return new kT(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
kT.prototype.isFog = !0;
class NT extends Ab {
  constructor() {
    super(),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.overrideMaterial = null),
      (this.autoUpdate = !0),
      "undefined" != typeof __THREE_DEVTOOLS__ &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      null !== e.background && (this.background = e.background.clone()),
      null !== e.environment && (this.environment = e.environment.clone()),
      null !== e.fog && (this.fog = e.fog.clone()),
      null !== e.overrideMaterial &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.autoUpdate = e.autoUpdate),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return null !== this.fog && (t.object.fog = this.fog.toJSON()), t;
  }
}
NT.prototype.isScene = !0;
class OT {
  constructor(e, t) {
    (this.array = e),
      (this.stride = t),
      (this.count = void 0 !== e ? e.length / t : 0),
      (this.usage = 35044),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0),
      (this.uuid = cx());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    !0 === e && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, n) {
    (e *= this.stride), (n *= t.stride);
    for (let i = 0, r = this.stride; i < r; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
      void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = cx()),
      void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      n = new this.constructor(t, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
      void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = cx()),
      void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
OT.prototype.isInterleavedBuffer = !0;
const FT = new Cx();
class zT {
  constructor(e, t, n, i = !1) {
    (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = n),
      (this.normalized = !0 === i);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.data.count; t < n; t++)
      (FT.x = this.getX(t)),
        (FT.y = this.getY(t)),
        (FT.z = this.getZ(t)),
        FT.applyMatrix4(e),
        this.setXYZ(t, FT.x, FT.y, FT.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      (FT.x = this.getX(t)),
        (FT.y = this.getY(t)),
        (FT.z = this.getZ(t)),
        FT.applyNormalMatrix(e),
        this.setXYZ(t, FT.x, FT.y, FT.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      (FT.x = this.getX(t)),
        (FT.y = this.getY(t)),
        (FT.z = this.getZ(t)),
        FT.transformDirection(e),
        this.setXYZ(t, FT.x, FT.y, FT.z);
    return this;
  }
  setX(e, t) {
    return (this.data.array[e * this.data.stride + this.offset] = t), this;
  }
  setY(e, t) {
    return (this.data.array[e * this.data.stride + this.offset + 1] = t), this;
  }
  setZ(e, t) {
    return (this.data.array[e * this.data.stride + this.offset + 2] = t), this;
  }
  setW(e, t) {
    return (this.data.array[e * this.data.stride + this.offset + 3] = t), this;
  }
  getX(e) {
    return this.data.array[e * this.data.stride + this.offset];
  }
  getY(e) {
    return this.data.array[e * this.data.stride + this.offset + 1];
  }
  getZ(e) {
    return this.data.array[e * this.data.stride + this.offset + 2];
  }
  getW(e) {
    return this.data.array[e * this.data.stride + this.offset + 3];
  }
  setXY(e, t, n) {
    return (
      (e = e * this.data.stride + this.offset),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      this
    );
  }
  setXYZ(e, t, n, i) {
    return (
      (e = e * this.data.stride + this.offset),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      (this.data.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, n, i, r) {
    return (
      (e = e * this.data.stride + this.offset),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      (this.data.array[e + 2] = i),
      (this.data.array[e + 3] = r),
      this
    );
  }
  clone(e) {
    if (void 0 === e) {
      const e = [];
      for (let t = 0; t < this.count; t++) {
        const n = t * this.data.stride + this.offset;
        for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t]);
      }
      return new Jb(
        new this.array.constructor(e),
        this.itemSize,
        this.normalized
      );
    }
    return (
      void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
      void 0 === e.interleavedBuffers[this.data.uuid] &&
        (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
      new zT(
        e.interleavedBuffers[this.data.uuid],
        this.itemSize,
        this.offset,
        this.normalized
      )
    );
  }
  toJSON(e) {
    if (void 0 === e) {
      const e = [];
      for (let t = 0; t < this.count; t++) {
        const n = t * this.data.stride + this.offset;
        for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: e,
        normalized: this.normalized,
      };
    }
    return (
      void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
      void 0 === e.interleavedBuffers[this.data.uuid] &&
        (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
      {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized,
      }
    );
  }
}
zT.prototype.isInterleavedBufferAttribute = !0;
const UT = new Cx(),
  BT = new wx(),
  VT = new wx(),
  HT = new Cx(),
  GT = new ib();
class WT extends Aw {
  constructor(e, t) {
    super(e, t),
      (this.type = "SkinnedMesh"),
      (this.bindMode = "attached"),
      (this.bindMatrix = new ib()),
      (this.bindMatrixInverse = new ib());
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      this
    );
  }
  bind(e, t) {
    (this.skeleton = e),
      void 0 === t &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new wx(),
      t = this.geometry.attributes.skinWeight;
    for (let n = 0, i = t.count; n < i; n++) {
      (e.x = t.getX(n)),
        (e.y = t.getY(n)),
        (e.z = t.getZ(n)),
        (e.w = t.getW(n));
      const i = 1 / e.manhattanLength();
      Infinity !== i ? e.multiplyScalar(i) : e.set(1, 0, 0, 0),
        t.setXYZW(n, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      "attached" === this.bindMode
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : "detached" === this.bindMode &&
          this.bindMatrixInverse.copy(this.bindMatrix).invert();
  }
  boneTransform(e, t) {
    const n = this.skeleton,
      i = this.geometry;
    BT.fromBufferAttribute(i.attributes.skinIndex, e),
      VT.fromBufferAttribute(i.attributes.skinWeight, e),
      UT.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0);
    for (let r = 0; r < 4; r++) {
      const e = VT.getComponent(r);
      if (0 !== e) {
        const i = BT.getComponent(r);
        GT.multiplyMatrices(n.bones[i].matrixWorld, n.boneInverses[i]),
          t.addScaledVector(HT.copy(UT).applyMatrix4(GT), e);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
WT.prototype.isSkinnedMesh = !0;
class qT extends Ab {
  constructor() {
    super(), (this.type = "Bone");
  }
}
qT.prototype.isBone = !0;
class jT extends xx {
  constructor(e = null, t = 1, n = 1, i, r, s, a, o, l = 1003, c = 1003, u, h) {
    super(null, s, a, o, l, c, i, r, u, h),
      (this.image = { data: e, width: t, height: n }),
      (this.magFilter = l),
      (this.minFilter = c),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.needsUpdate = !0);
  }
}
jT.prototype.isDataTexture = !0;
const YT = new ib(),
  XT = new ib();
class $T {
  constructor(e = [], t = []) {
    (this.uuid = cx()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      (this.boneTextureSize = 0),
      (this.frame = -1),
      this.init();
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(16 * e.length)), 0 === t.length))
      this.calculateInverses();
    else if (e.length !== t.length) {
      this.boneInverses = [];
      for (let e = 0, t = this.bones.length; e < t; e++)
        this.boneInverses.push(new ib());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const t = new ib();
      this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(t);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const t = this.bones[e];
      t && t.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const t = this.bones[e];
      t &&
        (t.parent && t.parent.isBone
          ? (t.matrix.copy(t.parent.matrixWorld).invert(),
            t.matrix.multiply(t.matrixWorld))
          : t.matrix.copy(t.matrixWorld),
        t.matrix.decompose(t.position, t.quaternion, t.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      n = this.boneMatrices,
      i = this.boneTexture;
    for (let r = 0, s = e.length; r < s; r++) {
      const i = e[r] ? e[r].matrixWorld : XT;
      YT.multiplyMatrices(i, t[r]), YT.toArray(n, 16 * r);
    }
    null !== i && (i.needsUpdate = !0);
  }
  clone() {
    return new $T(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(4 * this.bones.length);
    var t;
    (t = e),
      (e = Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))),
      (e = Math.max(e, 4));
    const n = new Float32Array(e * e * 4);
    n.set(this.boneMatrices);
    const i = new jT(n, e, e, 1023, 1015);
    return (
      (this.boneMatrices = n),
      (this.boneTexture = i),
      (this.boneTextureSize = e),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, n = this.bones.length; t < n; t++) {
      const n = this.bones[t];
      if (n.name === e) return n;
    }
  }
  dispose() {
    null !== this.boneTexture &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let n = 0, i = e.bones.length; n < i; n++) {
      let i = t[e.bones[n]];
      void 0 === i && (i = new qT()),
        this.bones.push(i),
        this.boneInverses.push(new ib().fromArray(e.boneInverses[n]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const t = this.bones,
      n = this.boneInverses;
    for (let i = 0, r = t.length; i < r; i++) {
      const r = t[i];
      e.bones.push(r.uuid);
      const s = n[i];
      e.boneInverses.push(s.toArray());
    }
    return e;
  }
}
class ZT extends Jb {
  constructor(e, t, n, i = 1) {
    "number" == typeof n && ((i = n), (n = !1)),
      super(e, t, n),
      (this.meshPerAttribute = i);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
ZT.prototype.isInstancedBufferAttribute = !0;
const KT = new ib(),
  JT = new ib(),
  QT = [],
  eC = new Aw();
class tC extends Aw {
  constructor(e, t, n) {
    super(e, t),
      (this.instanceMatrix = new ZT(new Float32Array(16 * n), 16)),
      (this.instanceColor = null),
      (this.count = n),
      (this.frustumCulled = !1);
  }
  copy(e) {
    return (
      super.copy(e),
      this.instanceMatrix.copy(e.instanceMatrix),
      null !== e.instanceColor &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, 3 * e);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, 16 * e);
  }
  raycast(e, t) {
    const n = this.matrixWorld,
      i = this.count;
    if (
      ((eC.geometry = this.geometry),
      (eC.material = this.material),
      void 0 !== eC.material)
    )
      for (let r = 0; r < i; r++) {
        this.getMatrixAt(r, KT),
          JT.multiplyMatrices(n, KT),
          (eC.matrixWorld = JT),
          eC.raycast(e, QT);
        for (let e = 0, n = QT.length; e < n; e++) {
          const n = QT[e];
          (n.instanceId = r), (n.object = this), t.push(n);
        }
        QT.length = 0;
      }
  }
  setColorAt(e, t) {
    null === this.instanceColor &&
      (this.instanceColor = new ZT(
        new Float32Array(3 * this.instanceMatrix.count),
        3
      )),
      t.toArray(this.instanceColor.array, 3 * e);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, 16 * e);
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
tC.prototype.isInstancedMesh = !0;
class nC extends Vb {
  constructor(e) {
    super(),
      (this.type = "LineBasicMaterial"),
      (this.color = new Xb(16777215)),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      this
    );
  }
}
nC.prototype.isLineBasicMaterial = !0;
const iC = new Cx(),
  rC = new Cx(),
  sC = new ib(),
  aC = new nb(),
  oC = new Xx();
class lC extends Ab {
  constructor(e = new uw(), t = new nC()) {
    super(),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.isBufferGeometry) {
      if (null === e.index) {
        const t = e.attributes.position,
          n = [0];
        for (let e = 1, i = t.count; e < i; e++)
          iC.fromBufferAttribute(t, e - 1),
            rC.fromBufferAttribute(t, e),
            (n[e] = n[e - 1]),
            (n[e] += iC.distanceTo(rC));
        e.setAttribute("lineDistance", new nw(n, 1));
      }
    } else e.isGeometry;
    return this;
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.matrixWorld,
      r = e.params.Line.threshold,
      s = n.drawRange;
    if (
      (null === n.boundingSphere && n.computeBoundingSphere(),
      oC.copy(n.boundingSphere),
      oC.applyMatrix4(i),
      (oC.radius += r),
      !1 === e.ray.intersectsSphere(oC))
    )
      return;
    sC.copy(i).invert(), aC.copy(e.ray).applyMatrix4(sC);
    const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      o = a * a,
      l = new Cx(),
      c = new Cx(),
      u = new Cx(),
      h = new Cx(),
      d = this.isLineSegments ? 2 : 1;
    if (n.isBufferGeometry) {
      const i = n.index,
        r = n.attributes.position;
      if (null !== i) {
        for (
          let n = Math.max(0, s.start),
            a = Math.min(i.count, s.start + s.count) - 1;
          n < a;
          n += d
        ) {
          const s = i.getX(n),
            a = i.getX(n + 1);
          l.fromBufferAttribute(r, s), c.fromBufferAttribute(r, a);
          if (aC.distanceSqToSegment(l, c, h, u) > o) continue;
          h.applyMatrix4(this.matrixWorld);
          const d = e.ray.origin.distanceTo(h);
          d < e.near ||
            d > e.far ||
            t.push({
              distance: d,
              point: u.clone().applyMatrix4(this.matrixWorld),
              index: n,
              face: null,
              faceIndex: null,
              object: this,
            });
        }
      } else {
        for (
          let n = Math.max(0, s.start),
            i = Math.min(r.count, s.start + s.count) - 1;
          n < i;
          n += d
        ) {
          l.fromBufferAttribute(r, n), c.fromBufferAttribute(r, n + 1);
          if (aC.distanceSqToSegment(l, c, h, u) > o) continue;
          h.applyMatrix4(this.matrixWorld);
          const i = e.ray.origin.distanceTo(h);
          i < e.near ||
            i > e.far ||
            t.push({
              distance: i,
              point: u.clone().applyMatrix4(this.matrixWorld),
              index: n,
              face: null,
              faceIndex: null,
              object: this,
            });
        }
      }
    } else n.isGeometry;
  }
  updateMorphTargets() {
    const e = this.geometry;
    if (e.isBufferGeometry) {
      const t = e.morphAttributes,
        n = Object.keys(t);
      if (n.length > 0) {
        const e = t[n[0]];
        if (void 0 !== e) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let t = 0, n = e.length; t < n; t++) {
            const n = e[t].name || String(t);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[n] = t);
          }
        }
      }
    } else {
      const t = e.morphTargets;
      void 0 !== t && t.length;
    }
  }
}
lC.prototype.isLine = !0;
const cC = new Cx(),
  uC = new Cx();
class hC extends lC {
  constructor(e, t) {
    super(e, t), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.isBufferGeometry) {
      if (null === e.index) {
        const t = e.attributes.position,
          n = [];
        for (let e = 0, i = t.count; e < i; e += 2)
          cC.fromBufferAttribute(t, e),
            uC.fromBufferAttribute(t, e + 1),
            (n[e] = 0 === e ? 0 : n[e - 1]),
            (n[e + 1] = n[e] + cC.distanceTo(uC));
        e.setAttribute("lineDistance", new nw(n, 1));
      }
    } else e.isGeometry;
    return this;
  }
}
hC.prototype.isLineSegments = !0;
class dC extends lC {
  constructor(e, t) {
    super(e, t), (this.type = "LineLoop");
  }
}
dC.prototype.isLineLoop = !0;
class pC extends Vb {
  constructor(e) {
    super(),
      (this.type = "PointsMaterial"),
      (this.color = new Xb(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      this
    );
  }
}
pC.prototype.isPointsMaterial = !0;
const fC = new ib(),
  mC = new nb(),
  gC = new Xx(),
  vC = new Cx();
class _C extends Ab {
  constructor(e = new uw(), t = new pC()) {
    super(),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.matrixWorld,
      r = e.params.Points.threshold,
      s = n.drawRange;
    if (
      (null === n.boundingSphere && n.computeBoundingSphere(),
      gC.copy(n.boundingSphere),
      gC.applyMatrix4(i),
      (gC.radius += r),
      !1 === e.ray.intersectsSphere(gC))
    )
      return;
    fC.copy(i).invert(), mC.copy(e.ray).applyMatrix4(fC);
    const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      o = a * a;
    if (n.isBufferGeometry) {
      const r = n.index,
        a = n.attributes.position;
      if (null !== r) {
        for (
          let n = Math.max(0, s.start),
            l = Math.min(r.count, s.start + s.count);
          n < l;
          n++
        ) {
          const s = r.getX(n);
          vC.fromBufferAttribute(a, s), yC(vC, s, o, i, e, t, this);
        }
      } else {
        for (
          let n = Math.max(0, s.start),
            r = Math.min(a.count, s.start + s.count);
          n < r;
          n++
        )
          vC.fromBufferAttribute(a, n), yC(vC, n, o, i, e, t, this);
      }
    }
  }
  updateMorphTargets() {
    const e = this.geometry;
    if (e.isBufferGeometry) {
      const t = e.morphAttributes,
        n = Object.keys(t);
      if (n.length > 0) {
        const e = t[n[0]];
        if (void 0 !== e) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let t = 0, n = e.length; t < n; t++) {
            const n = e[t].name || String(t);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[n] = t);
          }
        }
      }
    } else {
      const t = e.morphTargets;
      void 0 !== t && t.length;
    }
  }
}
function yC(e, t, n, i, r, s, a) {
  const o = mC.distanceSqToPoint(e);
  if (o < n) {
    const n = new Cx();
    mC.closestPointToPoint(e, n), n.applyMatrix4(i);
    const l = r.ray.origin.distanceTo(n);
    if (l < r.near || l > r.far) return;
    s.push({
      distance: l,
      distanceToRay: Math.sqrt(o),
      point: n,
      index: t,
      face: null,
      object: a,
    });
  }
}
_C.prototype.isPoints = !0;
class xC {
  constructor() {
    (this.type = "Curve"), (this.arcLengthDivisions = 200);
  }
  getPoint() {
    return null;
  }
  getPointAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getPoint(n, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let n,
      i = this.getPoint(0),
      r = 0;
    t.push(0);
    for (let s = 1; s <= e; s++)
      (n = this.getPoint(s / e)), (r += n.distanceTo(i)), t.push(r), (i = n);
    return (this.cacheArcLengths = t), t;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(e, t) {
    const n = this.getLengths();
    let i = 0;
    const r = n.length;
    let s;
    s = t || e * n[r - 1];
    let a,
      o = 0,
      l = r - 1;
    for (; o <= l; )
      if (((i = Math.floor(o + (l - o) / 2)), (a = n[i] - s), a < 0)) o = i + 1;
      else {
        if (!(a > 0)) {
          l = i;
          break;
        }
        l = i - 1;
      }
    if (((i = l), n[i] === s)) return i / (r - 1);
    const c = n[i];
    return (i + (s - c) / (n[i + 1] - c)) / (r - 1);
  }
  getTangent(e, t) {
    const n = 1e-4;
    let i = e - n,
      r = e + n;
    i < 0 && (i = 0), r > 1 && (r = 1);
    const s = this.getPoint(i),
      a = this.getPoint(r),
      o = t || (s.isVector2 ? new fx() : new Cx());
    return o.copy(a).sub(s).normalize(), o;
  }
  getTangentAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getTangent(n, t);
  }
  computeFrenetFrames(e, t) {
    const n = new Cx(),
      i = [],
      r = [],
      s = [],
      a = new Cx(),
      o = new ib();
    for (let d = 0; d <= e; d++) {
      const t = d / e;
      i[d] = this.getTangentAt(t, new Cx());
    }
    (r[0] = new Cx()), (s[0] = new Cx());
    let l = Number.MAX_VALUE;
    const c = Math.abs(i[0].x),
      u = Math.abs(i[0].y),
      h = Math.abs(i[0].z);
    c <= l && ((l = c), n.set(1, 0, 0)),
      u <= l && ((l = u), n.set(0, 1, 0)),
      h <= l && n.set(0, 0, 1),
      a.crossVectors(i[0], n).normalize(),
      r[0].crossVectors(i[0], a),
      s[0].crossVectors(i[0], r[0]);
    for (let d = 1; d <= e; d++) {
      if (
        ((r[d] = r[d - 1].clone()),
        (s[d] = s[d - 1].clone()),
        a.crossVectors(i[d - 1], i[d]),
        a.length() > Number.EPSILON)
      ) {
        a.normalize();
        const e = Math.acos(ux(i[d - 1].dot(i[d]), -1, 1));
        r[d].applyMatrix4(o.makeRotationAxis(a, e));
      }
      s[d].crossVectors(i[d], r[d]);
    }
    if (!0 === t) {
      let t = Math.acos(ux(r[0].dot(r[e]), -1, 1));
      (t /= e), i[0].dot(a.crossVectors(r[0], r[e])) > 0 && (t = -t);
      for (let n = 1; n <= e; n++)
        r[n].applyMatrix4(o.makeRotationAxis(i[n], t * n)),
          s[n].crossVectors(i[n], r[n]);
    }
    return { tangents: i, normals: r, binormals: s };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
  toJSON() {
    const e = {
      metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e
    );
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
}
class bC extends xC {
  constructor(
    e = 0,
    t = 0,
    n = 1,
    i = 1,
    r = 0,
    s = 2 * Math.PI,
    a = !1,
    o = 0
  ) {
    super(),
      (this.type = "EllipseCurve"),
      (this.aX = e),
      (this.aY = t),
      (this.xRadius = n),
      (this.yRadius = i),
      (this.aStartAngle = r),
      (this.aEndAngle = s),
      (this.aClockwise = a),
      (this.aRotation = o);
  }
  getPoint(e, t) {
    const n = t || new fx(),
      i = 2 * Math.PI;
    let r = this.aEndAngle - this.aStartAngle;
    const s = Math.abs(r) < Number.EPSILON;
    for (; r < 0; ) r += i;
    for (; r > i; ) r -= i;
    r < Number.EPSILON && (r = s ? 0 : i),
      !0 !== this.aClockwise || s || (r === i ? (r = -i) : (r -= i));
    const a = this.aStartAngle + e * r;
    let o = this.aX + this.xRadius * Math.cos(a),
      l = this.aY + this.yRadius * Math.sin(a);
    if (0 !== this.aRotation) {
      const e = Math.cos(this.aRotation),
        t = Math.sin(this.aRotation),
        n = o - this.aX,
        i = l - this.aY;
      (o = n * e - i * t + this.aX), (l = n * t + i * e + this.aY);
    }
    return n.set(o, l);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
}
bC.prototype.isEllipseCurve = !0;
class wC extends bC {
  constructor(e, t, n, i, r, s) {
    super(e, t, n, n, i, r, s), (this.type = "ArcCurve");
  }
}
function SC() {
  let e = 0,
    t = 0,
    n = 0,
    i = 0;
  function r(r, s, a, o) {
    (e = r),
      (t = a),
      (n = -3 * r + 3 * s - 2 * a - o),
      (i = 2 * r - 2 * s + a + o);
  }
  return {
    initCatmullRom: function (e, t, n, i, s) {
      r(t, n, s * (n - e), s * (i - t));
    },
    initNonuniformCatmullRom: function (e, t, n, i, s, a, o) {
      let l = (t - e) / s - (n - e) / (s + a) + (n - t) / a,
        c = (n - t) / a - (i - t) / (a + o) + (i - n) / o;
      (l *= a), (c *= a), r(t, n, l, c);
    },
    calc: function (r) {
      const s = r * r;
      return e + t * r + n * s + i * (s * r);
    },
  };
}
wC.prototype.isArcCurve = !0;
const MC = new Cx(),
  TC = new SC(),
  CC = new SC(),
  EC = new SC();
class AC extends xC {
  constructor(e = [], t = !1, n = "centripetal", i = 0.5) {
    super(),
      (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = t),
      (this.curveType = n),
      (this.tension = i);
  }
  getPoint(e, t = new Cx()) {
    const n = t,
      i = this.points,
      r = i.length,
      s = (r - (this.closed ? 0 : 1)) * e;
    let a,
      o,
      l = Math.floor(s),
      c = s - l;
    this.closed
      ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r)
      : 0 === c && l === r - 1 && ((l = r - 2), (c = 1)),
      this.closed || l > 0
        ? (a = i[(l - 1) % r])
        : (MC.subVectors(i[0], i[1]).add(i[0]), (a = MC));
    const u = i[l % r],
      h = i[(l + 1) % r];
    if (
      (this.closed || l + 2 < r
        ? (o = i[(l + 2) % r])
        : (MC.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), (o = MC)),
      "centripetal" === this.curveType || "chordal" === this.curveType)
    ) {
      const e = "chordal" === this.curveType ? 0.5 : 0.25;
      let t = Math.pow(a.distanceToSquared(u), e),
        n = Math.pow(u.distanceToSquared(h), e),
        i = Math.pow(h.distanceToSquared(o), e);
      n < 1e-4 && (n = 1),
        t < 1e-4 && (t = n),
        i < 1e-4 && (i = n),
        TC.initNonuniformCatmullRom(a.x, u.x, h.x, o.x, t, n, i),
        CC.initNonuniformCatmullRom(a.y, u.y, h.y, o.y, t, n, i),
        EC.initNonuniformCatmullRom(a.z, u.z, h.z, o.z, t, n, i);
    } else
      "catmullrom" === this.curveType &&
        (TC.initCatmullRom(a.x, u.x, h.x, o.x, this.tension),
        CC.initCatmullRom(a.y, u.y, h.y, o.y, this.tension),
        EC.initCatmullRom(a.z, u.z, h.z, o.z, this.tension));
    return n.set(TC.calc(c), CC.calc(c), EC.calc(c)), n;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, n = e.points.length; t < n; t++) {
      const n = e.points[t];
      this.points.push(n.clone());
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const n = this.points[t];
      e.points.push(n.toArray());
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    );
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, n = e.points.length; t < n; t++) {
      const n = e.points[t];
      this.points.push(new Cx().fromArray(n));
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
}
function PC(e, t, n, i, r) {
  const s = 0.5 * (i - t),
    a = 0.5 * (r - n),
    o = e * e;
  return (
    (2 * n - 2 * i + s + a) * (e * o) +
    (-3 * n + 3 * i - 2 * s - a) * o +
    s * e +
    n
  );
}
function LC(e, t, n, i) {
  return (
    (function (e, t) {
      const n = 1 - e;
      return n * n * t;
    })(e, t) +
    (function (e, t) {
      return 2 * (1 - e) * e * t;
    })(e, n) +
    (function (e, t) {
      return e * e * t;
    })(e, i)
  );
}
function IC(e, t, n, i, r) {
  return (
    (function (e, t) {
      const n = 1 - e;
      return n * n * n * t;
    })(e, t) +
    (function (e, t) {
      const n = 1 - e;
      return 3 * n * n * e * t;
    })(e, n) +
    (function (e, t) {
      return 3 * (1 - e) * e * e * t;
    })(e, i) +
    (function (e, t) {
      return e * e * e * t;
    })(e, r)
  );
}
AC.prototype.isCatmullRomCurve3 = !0;
class RC extends xC {
  constructor(e = new fx(), t = new fx(), n = new fx(), i = new fx()) {
    super(),
      (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n),
      (this.v3 = i);
  }
  getPoint(e, t = new fx()) {
    const n = t,
      i = this.v0,
      r = this.v1,
      s = this.v2,
      a = this.v3;
    return n.set(IC(e, i.x, r.x, s.x, a.x), IC(e, i.y, r.y, s.y, a.y)), n;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
RC.prototype.isCubicBezierCurve = !0;
class DC extends xC {
  constructor(e = new Cx(), t = new Cx(), n = new Cx(), i = new Cx()) {
    super(),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n),
      (this.v3 = i);
  }
  getPoint(e, t = new Cx()) {
    const n = t,
      i = this.v0,
      r = this.v1,
      s = this.v2,
      a = this.v3;
    return (
      n.set(
        IC(e, i.x, r.x, s.x, a.x),
        IC(e, i.y, r.y, s.y, a.y),
        IC(e, i.z, r.z, s.z, a.z)
      ),
      n
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
DC.prototype.isCubicBezierCurve3 = !0;
class kC extends xC {
  constructor(e = new fx(), t = new fx()) {
    super(), (this.type = "LineCurve"), (this.v1 = e), (this.v2 = t);
  }
  getPoint(e, t = new fx()) {
    const n = t;
    return (
      1 === e
        ? n.copy(this.v2)
        : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)),
      n
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t) {
    const n = t || new fx();
    return n.copy(this.v2).sub(this.v1).normalize(), n;
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
kC.prototype.isLineCurve = !0;
class NC extends xC {
  constructor(e = new fx(), t = new fx(), n = new fx()) {
    super(),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n);
  }
  getPoint(e, t = new fx()) {
    const n = t,
      i = this.v0,
      r = this.v1,
      s = this.v2;
    return n.set(LC(e, i.x, r.x, s.x), LC(e, i.y, r.y, s.y)), n;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
NC.prototype.isQuadraticBezierCurve = !0;
class OC extends xC {
  constructor(e = new Cx(), t = new Cx(), n = new Cx()) {
    super(),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n);
  }
  getPoint(e, t = new Cx()) {
    const n = t,
      i = this.v0,
      r = this.v1,
      s = this.v2;
    return (
      n.set(LC(e, i.x, r.x, s.x), LC(e, i.y, r.y, s.y), LC(e, i.z, r.z, s.z)), n
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
OC.prototype.isQuadraticBezierCurve3 = !0;
class FC extends xC {
  constructor(e = []) {
    super(), (this.type = "SplineCurve"), (this.points = e);
  }
  getPoint(e, t = new fx()) {
    const n = t,
      i = this.points,
      r = (i.length - 1) * e,
      s = Math.floor(r),
      a = r - s,
      o = i[0 === s ? s : s - 1],
      l = i[s],
      c = i[s > i.length - 2 ? i.length - 1 : s + 1],
      u = i[s > i.length - 3 ? i.length - 1 : s + 2];
    return n.set(PC(a, o.x, l.x, c.x, u.x), PC(a, o.y, l.y, c.y, u.y)), n;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, n = e.points.length; t < n; t++) {
      const n = e.points[t];
      this.points.push(n.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const n = this.points[t];
      e.points.push(n.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, n = e.points.length; t < n; t++) {
      const n = e.points[t];
      this.points.push(new fx().fromArray(n));
    }
    return this;
  }
}
FC.prototype.isSplineCurve = !0;
var zC = Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  ArcCurve: wC,
  CatmullRomCurve3: AC,
  CubicBezierCurve: RC,
  CubicBezierCurve3: DC,
  EllipseCurve: bC,
  LineCurve: kC,
  LineCurve3: class extends xC {
    constructor(e = new Cx(), t = new Cx()) {
      super(),
        (this.type = "LineCurve3"),
        (this.isLineCurve3 = !0),
        (this.v1 = e),
        (this.v2 = t);
    }
    getPoint(e, t = new Cx()) {
      const n = t;
      return (
        1 === e
          ? n.copy(this.v2)
          : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)),
        n
      );
    }
    getPointAt(e, t) {
      return this.getPoint(e, t);
    }
    copy(e) {
      return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
    }
    toJSON() {
      const e = super.toJSON();
      return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
    }
    fromJSON(e) {
      return (
        super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
      );
    }
  },
  QuadraticBezierCurve: NC,
  QuadraticBezierCurve3: OC,
  SplineCurve: FC,
});
class UC extends xC {
  constructor() {
    super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1);
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      t = this.curves[this.curves.length - 1].getPoint(1);
    e.equals(t) || this.curves.push(new kC(t, e));
  }
  getPoint(e, t) {
    const n = e * this.getLength(),
      i = this.getCurveLengths();
    let r = 0;
    for (; r < i.length; ) {
      if (i[r] >= n) {
        const e = i[r] - n,
          s = this.curves[r],
          a = s.getLength(),
          o = 0 === a ? 0 : 1 - e / a;
        return s.getPointAt(o, t);
      }
      r++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let n = 0, i = this.curves.length; n < i; n++)
      (t += this.curves[n].getLength()), e.push(t);
    return (this.cacheLengths = e), e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let n;
    for (let i = 0, r = this.curves; i < r.length; i++) {
      const s = r[i],
        a =
          s && s.isEllipseCurve
            ? 2 * e
            : s && (s.isLineCurve || s.isLineCurve3)
            ? 1
            : s && s.isSplineCurve
            ? e * s.points.length
            : e,
        o = s.getPoints(a);
      for (let e = 0; e < o.length; e++) {
        const i = o[e];
        (n && n.equals(i)) || (t.push(i), (n = i));
      }
    }
    return (
      this.autoClose &&
        t.length > 1 &&
        !t[t.length - 1].equals(t[0]) &&
        t.push(t[0]),
      t
    );
  }
  copy(e) {
    super.copy(e), (this.curves = []);
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const n = e.curves[t];
      this.curves.push(n.clone());
    }
    return (this.autoClose = e.autoClose), this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.autoClose = this.autoClose), (e.curves = []);
    for (let t = 0, n = this.curves.length; t < n; t++) {
      const n = this.curves[t];
      e.curves.push(n.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const n = e.curves[t];
      this.curves.push(new zC[n.type]().fromJSON(n));
    }
    return this;
  }
}
class BC extends Vb {
  constructor(e) {
    super(),
      (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new Xb(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Xb(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = 0),
      (this.normalScale = new fx(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.envMapIntensity = e.envMapIntensity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
BC.prototype.isMeshStandardMaterial = !0;
class VC extends BC {
  constructor(e) {
    super(),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new fx(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return ux((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (e) {
          this.ior = (1 + 0.4 * e) / (1 - 0.4 * e);
        },
      }),
      (this.sheenTint = new Xb(0)),
      (this.sheenRoughness = 1),
      (this.transmissionMap = null),
      (this.thickness = 0.01),
      (this.thicknessMap = null),
      (this.attenuationDistance = 0),
      (this.attenuationTint = new Xb(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularTint = new Xb(1, 1, 1)),
      (this.specularTintMap = null),
      (this._sheen = 0),
      (this._clearcoat = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.ior = e.ior),
      (this.sheen = e.sheen),
      this.sheenTint.copy(e.sheenTint),
      (this.sheenRoughness = e.sheenRoughness),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationTint.copy(e.attenuationTint),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularTint.copy(e.specularTint),
      (this.specularTintMap = e.specularTintMap),
      this
    );
  }
}
VC.prototype.isMeshPhysicalMaterial = !0;
class HC extends Vb {
  constructor(e) {
    super(),
      (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = 0),
      (this.normalScale = new fx(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.flatShading = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
HC.prototype.isMeshNormalMaterial = !0;
const GC = {
  arraySlice: function (e, t, n) {
    return GC.isTypedArray(e)
      ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length))
      : e.slice(t, n);
  },
  convertArray: function (e, t, n) {
    return !e || (!n && e.constructor === t)
      ? e
      : "number" == typeof t.BYTES_PER_ELEMENT
      ? new t(e)
      : Array.prototype.slice.call(e);
  },
  isTypedArray: function (e) {
    return ArrayBuffer.isView(e) && !(e instanceof DataView);
  },
  getKeyframeOrder: function (e) {
    const t = e.length,
      n = new Array(t);
    for (let i = 0; i !== t; ++i) n[i] = i;
    return (
      n.sort(function (t, n) {
        return e[t] - e[n];
      }),
      n
    );
  },
  sortedArray: function (e, t, n) {
    const i = e.length,
      r = new e.constructor(i);
    for (let s = 0, a = 0; a !== i; ++s) {
      const i = n[s] * t;
      for (let n = 0; n !== t; ++n) r[a++] = e[i + n];
    }
    return r;
  },
  flattenJSON: function (e, t, n, i) {
    let r = 1,
      s = e[0];
    for (; void 0 !== s && void 0 === s[i]; ) s = e[r++];
    if (void 0 === s) return;
    let a = s[i];
    if (void 0 !== a)
      if (Array.isArray(a))
        do {
          (a = s[i]),
            void 0 !== a && (t.push(s.time), n.push.apply(n, a)),
            (s = e[r++]);
        } while (void 0 !== s);
      else if (void 0 !== a.toArray)
        do {
          (a = s[i]),
            void 0 !== a && (t.push(s.time), a.toArray(n, n.length)),
            (s = e[r++]);
        } while (void 0 !== s);
      else
        do {
          (a = s[i]), void 0 !== a && (t.push(s.time), n.push(a)), (s = e[r++]);
        } while (void 0 !== s);
  },
  subclip: function (e, t, n, i, r = 30) {
    const s = e.clone();
    s.name = t;
    const a = [];
    for (let l = 0; l < s.tracks.length; ++l) {
      const e = s.tracks[l],
        t = e.getValueSize(),
        o = [],
        c = [];
      for (let s = 0; s < e.times.length; ++s) {
        const a = e.times[s] * r;
        if (!(a < n || a >= i)) {
          o.push(e.times[s]);
          for (let n = 0; n < t; ++n) c.push(e.values[s * t + n]);
        }
      }
      0 !== o.length &&
        ((e.times = GC.convertArray(o, e.times.constructor)),
        (e.values = GC.convertArray(c, e.values.constructor)),
        a.push(e));
    }
    s.tracks = a;
    let o = Infinity;
    for (let l = 0; l < s.tracks.length; ++l)
      o > s.tracks[l].times[0] && (o = s.tracks[l].times[0]);
    for (let l = 0; l < s.tracks.length; ++l) s.tracks[l].shift(-1 * o);
    return s.resetDuration(), s;
  },
  makeClipAdditive: function (e, t = 0, n = e, i = 30) {
    i <= 0 && (i = 30);
    const r = n.tracks.length,
      s = t / i;
    for (let a = 0; a < r; ++a) {
      const t = n.tracks[a],
        i = t.ValueTypeName;
      if ("bool" === i || "string" === i) continue;
      const r = e.tracks.find(function (e) {
        return e.name === t.name && e.ValueTypeName === i;
      });
      if (void 0 === r) continue;
      let o = 0;
      const l = t.getValueSize();
      t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
        (o = l / 3);
      let c = 0;
      const u = r.getValueSize();
      r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
        (c = u / 3);
      const h = t.times.length - 1;
      let d;
      if (s <= t.times[0]) {
        const e = o,
          n = l - o;
        d = GC.arraySlice(t.values, e, n);
      } else if (s >= t.times[h]) {
        const e = h * l + o,
          n = e + l - o;
        d = GC.arraySlice(t.values, e, n);
      } else {
        const e = t.createInterpolant(),
          n = o,
          i = l - o;
        e.evaluate(s), (d = GC.arraySlice(e.resultBuffer, n, i));
      }
      if ("quaternion" === i) {
        new Tx().fromArray(d).normalize().conjugate().toArray(d);
      }
      const p = r.times.length;
      for (let e = 0; e < p; ++e) {
        const t = e * u + c;
        if ("quaternion" === i)
          Tx.multiplyQuaternionsFlat(r.values, t, d, 0, r.values, t);
        else {
          const e = u - 2 * c;
          for (let n = 0; n < e; ++n) r.values[t + n] -= d[n];
        }
      }
    }
    return (e.blendMode = 2501), e;
  },
};
class WC {
  constructor(e, t, n, i) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = void 0 !== i ? i : new t.constructor(n)),
      (this.sampleValues = t),
      (this.valueSize = n),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let n = this._cachedIndex,
      i = t[n],
      r = t[n - 1];
    e: {
      t: {
        let s;
        n: {
          i: if (!(e < i)) {
            for (let s = n + 2; ; ) {
              if (void 0 === i) {
                if (e < r) break i;
                return (
                  (n = t.length),
                  (this._cachedIndex = n),
                  this.afterEnd_(n - 1, e, r)
                );
              }
              if (n === s) break;
              if (((r = i), (i = t[++n]), e < i)) break t;
            }
            s = t.length;
            break n;
          }
          if (e >= r) break e;
          {
            const a = t[1];
            e < a && ((n = 2), (r = a));
            for (let s = n - 2; ; ) {
              if (void 0 === r)
                return (this._cachedIndex = 0), this.beforeStart_(0, e, i);
              if (n === s) break;
              if (((i = r), (r = t[--n - 1]), e >= r)) break t;
            }
            (s = n), (n = 0);
          }
        }
        for (; n < s; ) {
          const i = (n + s) >>> 1;
          e < t[i] ? (s = i) : (n = i + 1);
        }
        if (((i = t[n]), (r = t[n - 1]), void 0 === r))
          return (this._cachedIndex = 0), this.beforeStart_(0, e, i);
        if (void 0 === i)
          return (
            (n = t.length), (this._cachedIndex = n), this.afterEnd_(n - 1, r, e)
          );
      }
      (this._cachedIndex = n), this.intervalChanged_(n, r, i);
    }
    return this.interpolate_(n, r, e, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      n = this.sampleValues,
      i = this.valueSize,
      r = e * i;
    for (let s = 0; s !== i; ++s) t[s] = n[r + s];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
(WC.prototype.beforeStart_ = WC.prototype.copySampleValue_),
  (WC.prototype.afterEnd_ = WC.prototype.copySampleValue_);
class qC extends WC {
  constructor(e, t, n, i) {
    super(e, t, n, i),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: 2400, endingEnd: 2400 });
  }
  intervalChanged_(e, t, n) {
    const i = this.parameterPositions;
    let r = e - 2,
      s = e + 1,
      a = i[r],
      o = i[s];
    if (void 0 === a)
      switch (this.getSettings_().endingStart) {
        case 2401:
          (r = e), (a = 2 * t - n);
          break;
        case 2402:
          (r = i.length - 2), (a = t + i[r] - i[r + 1]);
          break;
        default:
          (r = e), (a = n);
      }
    if (void 0 === o)
      switch (this.getSettings_().endingEnd) {
        case 2401:
          (s = e), (o = 2 * n - t);
          break;
        case 2402:
          (s = 1), (o = n + i[1] - i[0]);
          break;
        default:
          (s = e - 1), (o = t);
      }
    const l = 0.5 * (n - t),
      c = this.valueSize;
    (this._weightPrev = l / (t - a)),
      (this._weightNext = l / (o - n)),
      (this._offsetPrev = r * c),
      (this._offsetNext = s * c);
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer,
      s = this.sampleValues,
      a = this.valueSize,
      o = e * a,
      l = o - a,
      c = this._offsetPrev,
      u = this._offsetNext,
      h = this._weightPrev,
      d = this._weightNext,
      p = (n - t) / (i - t),
      f = p * p,
      m = f * p,
      g = -h * m + 2 * h * f - h * p,
      v = (1 + h) * m + (-1.5 - 2 * h) * f + (-0.5 + h) * p + 1,
      _ = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
      y = d * m - d * f;
    for (let x = 0; x !== a; ++x)
      r[x] = g * s[c + x] + v * s[l + x] + _ * s[o + x] + y * s[u + x];
    return r;
  }
}
class jC extends WC {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer,
      s = this.sampleValues,
      a = this.valueSize,
      o = e * a,
      l = o - a,
      c = (n - t) / (i - t),
      u = 1 - c;
    for (let h = 0; h !== a; ++h) r[h] = s[l + h] * u + s[o + h] * c;
    return r;
  }
}
class YC extends WC {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class XC {
  constructor(e, t, n, i) {
    if (void 0 === e)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (void 0 === t || 0 === t.length)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = GC.convertArray(t, this.TimeBufferType)),
      (this.values = GC.convertArray(n, this.ValueBufferType)),
      this.setInterpolation(i || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let n;
    if (t.toJSON !== this.toJSON) n = t.toJSON(e);
    else {
      n = {
        name: e.name,
        times: GC.convertArray(e.times, Array),
        values: GC.convertArray(e.values, Array),
      };
      const t = e.getInterpolation();
      t !== e.DefaultInterpolation && (n.interpolation = t);
    }
    return (n.type = e.ValueTypeName), n;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new YC(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new jC(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new qC(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case 2300:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case 2301:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case 2302:
        t = this.InterpolantFactoryMethodSmooth;
    }
    if (void 0 === t) {
      const t =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (void 0 === this.createInterpolant) {
        if (e === this.DefaultInterpolation) throw new Error(t);
        this.setInterpolation(this.DefaultInterpolation);
      }
      return this;
    }
    return (this.createInterpolant = t), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return 2300;
      case this.InterpolantFactoryMethodLinear:
        return 2301;
      case this.InterpolantFactoryMethodSmooth:
        return 2302;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (0 !== e) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n) t[n] += e;
    }
    return this;
  }
  scale(e) {
    if (1 !== e) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e;
    }
    return this;
  }
  trim(e, t) {
    const n = this.times,
      i = n.length;
    let r = 0,
      s = i - 1;
    for (; r !== i && n[r] < e; ) ++r;
    for (; -1 !== s && n[s] > t; ) --s;
    if ((++s, 0 !== r || s !== i)) {
      r >= s && ((s = Math.max(s, 1)), (r = s - 1));
      const e = this.getValueSize();
      (this.times = GC.arraySlice(n, r, s)),
        (this.values = GC.arraySlice(this.values, r * e, s * e));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) != 0 && (e = !1);
    const n = this.times,
      i = this.values,
      r = n.length;
    0 === r && (e = !1);
    let s = null;
    for (let a = 0; a !== r; a++) {
      const t = n[a];
      if ("number" == typeof t && isNaN(t)) {
        e = !1;
        break;
      }
      if (null !== s && s > t) {
        e = !1;
        break;
      }
      s = t;
    }
    if (void 0 !== i && GC.isTypedArray(i))
      for (let a = 0, o = i.length; a !== o; ++a) {
        const t = i[a];
        if (isNaN(t)) {
          e = !1;
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = GC.arraySlice(this.times),
      t = GC.arraySlice(this.values),
      n = this.getValueSize(),
      i = 2302 === this.getInterpolation(),
      r = e.length - 1;
    let s = 1;
    for (let a = 1; a < r; ++a) {
      let r = !1;
      const o = e[a];
      if (o !== e[a + 1] && (1 !== a || o !== e[0]))
        if (i) r = !0;
        else {
          const e = a * n,
            i = e - n,
            s = e + n;
          for (let a = 0; a !== n; ++a) {
            const n = t[e + a];
            if (n !== t[i + a] || n !== t[s + a]) {
              r = !0;
              break;
            }
          }
        }
      if (r) {
        if (a !== s) {
          e[s] = e[a];
          const i = a * n,
            r = s * n;
          for (let e = 0; e !== n; ++e) t[r + e] = t[i + e];
        }
        ++s;
      }
    }
    if (r > 0) {
      e[s] = e[r];
      for (let e = r * n, i = s * n, a = 0; a !== n; ++a) t[i + a] = t[e + a];
      ++s;
    }
    return (
      s !== e.length
        ? ((this.times = GC.arraySlice(e, 0, s)),
          (this.values = GC.arraySlice(t, 0, s * n)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = GC.arraySlice(this.times, 0),
      t = GC.arraySlice(this.values, 0),
      n = new (0, this.constructor)(this.name, e, t);
    return (n.createInterpolant = this.createInterpolant), n;
  }
}
(XC.prototype.TimeBufferType = Float32Array),
  (XC.prototype.ValueBufferType = Float32Array),
  (XC.prototype.DefaultInterpolation = 2301);
class $C extends XC {}
($C.prototype.ValueTypeName = "bool"),
  ($C.prototype.ValueBufferType = Array),
  ($C.prototype.DefaultInterpolation = 2300),
  ($C.prototype.InterpolantFactoryMethodLinear = void 0),
  ($C.prototype.InterpolantFactoryMethodSmooth = void 0);
class ZC extends XC {}
ZC.prototype.ValueTypeName = "color";
class KC extends XC {}
KC.prototype.ValueTypeName = "number";
class JC extends WC {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer,
      s = this.sampleValues,
      a = this.valueSize,
      o = (n - t) / (i - t);
    let l = e * a;
    for (let c = l + a; l !== c; l += 4) Tx.slerpFlat(r, 0, s, l - a, s, l, o);
    return r;
  }
}
class QC extends XC {
  InterpolantFactoryMethodLinear(e) {
    return new JC(this.times, this.values, this.getValueSize(), e);
  }
}
(QC.prototype.ValueTypeName = "quaternion"),
  (QC.prototype.DefaultInterpolation = 2301),
  (QC.prototype.InterpolantFactoryMethodSmooth = void 0);
class eE extends XC {}
(eE.prototype.ValueTypeName = "string"),
  (eE.prototype.ValueBufferType = Array),
  (eE.prototype.DefaultInterpolation = 2300),
  (eE.prototype.InterpolantFactoryMethodLinear = void 0),
  (eE.prototype.InterpolantFactoryMethodSmooth = void 0);
class tE extends XC {}
tE.prototype.ValueTypeName = "vector";
class nE {
  constructor(e, t = -1, n, i = 2500) {
    (this.name = e),
      (this.tracks = n),
      (this.duration = t),
      (this.blendMode = i),
      (this.uuid = cx()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [],
      n = e.tracks,
      i = 1 / (e.fps || 1);
    for (let s = 0, a = n.length; s !== a; ++s) t.push(iE(n[s]).scale(i));
    const r = new this(e.name, e.duration, t, e.blendMode);
    return (r.uuid = e.uuid), r;
  }
  static toJSON(e) {
    const t = [],
      n = e.tracks,
      i = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let r = 0, s = n.length; r !== s; ++r) t.push(XC.toJSON(n[r]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, t, n, i) {
    const r = t.length,
      s = [];
    for (let a = 0; a < r; a++) {
      let e = [],
        o = [];
      e.push((a + r - 1) % r, a, (a + 1) % r), o.push(0, 1, 0);
      const l = GC.getKeyframeOrder(e);
      (e = GC.sortedArray(e, 1, l)),
        (o = GC.sortedArray(o, 1, l)),
        i || 0 !== e[0] || (e.push(r), o.push(o[0])),
        s.push(
          new KC(".morphTargetInfluences[" + t[a].name + "]", e, o).scale(1 / n)
        );
    }
    return new this(e, -1, s);
  }
  static findByName(e, t) {
    let n = e;
    if (!Array.isArray(e)) {
      const t = e;
      n = (t.geometry && t.geometry.animations) || t.animations;
    }
    for (let i = 0; i < n.length; i++) if (n[i].name === t) return n[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, n) {
    const i = {},
      r = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, o = e.length; a < o; a++) {
      const t = e[a],
        n = t.name.match(r);
      if (n && n.length > 1) {
        const e = n[1];
        let r = i[e];
        r || (i[e] = r = []), r.push(t);
      }
    }
    const s = [];
    for (const a in i)
      s.push(this.CreateFromMorphTargetSequence(a, i[a], t, n));
    return s;
  }
  static parseAnimation(e, t) {
    if (!e) return null;
    const n = function (e, t, n, i, r) {
        if (0 !== n.length) {
          const s = [],
            a = [];
          GC.flattenJSON(n, s, a, i), 0 !== s.length && r.push(new e(t, s, a));
        }
      },
      i = [],
      r = e.name || "default",
      s = e.fps || 30,
      a = e.blendMode;
    let o = e.length || -1;
    const l = e.hierarchy || [];
    for (let c = 0; c < l.length; c++) {
      const e = l[c].keys;
      if (e && 0 !== e.length)
        if (e[0].morphTargets) {
          const t = {};
          let n;
          for (n = 0; n < e.length; n++)
            if (e[n].morphTargets)
              for (let i = 0; i < e[n].morphTargets.length; i++)
                t[e[n].morphTargets[i]] = -1;
          for (const r in t) {
            const t = [],
              s = [];
            for (let i = 0; i !== e[n].morphTargets.length; ++i) {
              const i = e[n];
              t.push(i.time), s.push(i.morphTarget === r ? 1 : 0);
            }
            i.push(new KC(".morphTargetInfluence[" + r + "]", t, s));
          }
          o = t.length * (s || 1);
        } else {
          const r = ".bones[" + t[c].name + "]";
          n(tE, r + ".position", e, "pos", i),
            n(QC, r + ".quaternion", e, "rot", i),
            n(tE, r + ".scale", e, "scl", i);
        }
    }
    if (0 === i.length) return null;
    return new this(r, o, i, a);
  }
  resetDuration() {
    let e = 0;
    for (let t = 0, n = this.tracks.length; t !== n; ++t) {
      const n = this.tracks[t];
      e = Math.max(e, n.times[n.times.length - 1]);
    }
    return (this.duration = e), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function iE(e) {
  if (void 0 === e.type)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const t = (function (e) {
    switch (e.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return KC;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return tE;
      case "color":
        return ZC;
      case "quaternion":
        return QC;
      case "bool":
      case "boolean":
        return $C;
      case "string":
        return eE;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e);
  })(e.type);
  if (void 0 === e.times) {
    const t = [],
      n = [];
    GC.flattenJSON(e.keys, t, n, "value"), (e.times = t), (e.values = n);
  }
  return void 0 !== t.parse
    ? t.parse(e)
    : new t(e.name, e.times, e.values, e.interpolation);
}
const rE = {
  enabled: !1,
  files: {},
  add: function (e, t) {
    !1 !== this.enabled && (this.files[e] = t);
  },
  get: function (e) {
    if (!1 !== this.enabled) return this.files[e];
  },
  remove: function (e) {
    delete this.files[e];
  },
  clear: function () {
    this.files = {};
  },
};
const sE = new (class {
  constructor(e, t, n) {
    const i = this;
    let r,
      s = !1,
      a = 0,
      o = 0;
    const l = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = n),
      (this.itemStart = function (e) {
        o++, !1 === s && void 0 !== i.onStart && i.onStart(e, a, o), (s = !0);
      }),
      (this.itemEnd = function (e) {
        a++,
          void 0 !== i.onProgress && i.onProgress(e, a, o),
          a === o && ((s = !1), void 0 !== i.onLoad && i.onLoad());
      }),
      (this.itemError = function (e) {
        void 0 !== i.onError && i.onError(e);
      }),
      (this.resolveURL = function (e) {
        return r ? r(e) : e;
      }),
      (this.setURLModifier = function (e) {
        return (r = e), this;
      }),
      (this.addHandler = function (e, t) {
        return l.push(e, t), this;
      }),
      (this.removeHandler = function (e) {
        const t = l.indexOf(e);
        return -1 !== t && l.splice(t, 2), this;
      }),
      (this.getHandler = function (e) {
        for (let t = 0, n = l.length; t < n; t += 2) {
          const n = l[t],
            i = l[t + 1];
          if ((n.global && (n.lastIndex = 0), n.test(e))) return i;
        }
        return null;
      });
  }
})();
class aE {
  constructor(e) {
    (this.manager = void 0 !== e ? e : sE),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    const n = this;
    return new Promise(function (i, r) {
      n.load(e, i, t, r);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
const oE = {};
class lE extends aE {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    void 0 === e && (e = ""),
      void 0 !== this.path && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const r = this,
      s = rE.get(e);
    if (void 0 !== s)
      return (
        r.manager.itemStart(e),
        setTimeout(function () {
          t && t(s), r.manager.itemEnd(e);
        }, 0),
        s
      );
    if (void 0 !== oE[e])
      return void oE[e].push({ onLoad: t, onProgress: n, onError: i });
    const a = e.match(/^data:(.*?)(;base64)?,(.*)$/);
    let o;
    if (a) {
      const n = a[1],
        s = !!a[2];
      let o = a[3];
      (o = decodeURIComponent(o)), s && (o = atob(o));
      try {
        let i;
        const s = (this.responseType || "").toLowerCase();
        switch (s) {
          case "arraybuffer":
          case "blob":
            const e = new Uint8Array(o.length);
            for (let n = 0; n < o.length; n++) e[n] = o.charCodeAt(n);
            i = "blob" === s ? new Blob([e.buffer], { type: n }) : e.buffer;
            break;
          case "document":
            const t = new DOMParser();
            i = t.parseFromString(o, n);
            break;
          case "json":
            i = JSON.parse(o);
            break;
          default:
            i = o;
        }
        setTimeout(function () {
          t && t(i), r.manager.itemEnd(e);
        }, 0);
      } catch (l) {
        setTimeout(function () {
          i && i(l), r.manager.itemError(e), r.manager.itemEnd(e);
        }, 0);
      }
    } else {
      (oE[e] = []),
        oE[e].push({ onLoad: t, onProgress: n, onError: i }),
        (o = new XMLHttpRequest()),
        o.open("GET", e, !0),
        o.addEventListener(
          "load",
          function (t) {
            const n = this.response,
              i = oE[e];
            if ((delete oE[e], 200 === this.status || 0 === this.status)) {
              this.status, rE.add(e, n);
              for (let e = 0, t = i.length; e < t; e++) {
                const t = i[e];
                t.onLoad && t.onLoad(n);
              }
              r.manager.itemEnd(e);
            } else {
              for (let e = 0, n = i.length; e < n; e++) {
                const n = i[e];
                n.onError && n.onError(t);
              }
              r.manager.itemError(e), r.manager.itemEnd(e);
            }
          },
          !1
        ),
        o.addEventListener(
          "progress",
          function (t) {
            const n = oE[e];
            for (let e = 0, i = n.length; e < i; e++) {
              const i = n[e];
              i.onProgress && i.onProgress(t);
            }
          },
          !1
        ),
        o.addEventListener(
          "error",
          function (t) {
            const n = oE[e];
            delete oE[e];
            for (let e = 0, i = n.length; e < i; e++) {
              const i = n[e];
              i.onError && i.onError(t);
            }
            r.manager.itemError(e), r.manager.itemEnd(e);
          },
          !1
        ),
        o.addEventListener(
          "abort",
          function (t) {
            const n = oE[e];
            delete oE[e];
            for (let e = 0, i = n.length; e < i; e++) {
              const i = n[e];
              i.onError && i.onError(t);
            }
            r.manager.itemError(e), r.manager.itemEnd(e);
          },
          !1
        ),
        void 0 !== this.responseType && (o.responseType = this.responseType),
        void 0 !== this.withCredentials &&
          (o.withCredentials = this.withCredentials),
        o.overrideMimeType &&
          o.overrideMimeType(
            void 0 !== this.mimeType ? this.mimeType : "text/plain"
          );
      for (const e in this.requestHeader)
        o.setRequestHeader(e, this.requestHeader[e]);
      o.send(null);
    }
    return r.manager.itemStart(e), o;
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class cE extends aE {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    void 0 !== this.path && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const r = this,
      s = rE.get(e);
    if (void 0 !== s)
      return (
        r.manager.itemStart(e),
        setTimeout(function () {
          t && t(s), r.manager.itemEnd(e);
        }, 0),
        s
      );
    const a = vx("img");
    function o() {
      a.removeEventListener("load", o, !1),
        a.removeEventListener("error", l, !1),
        rE.add(e, this),
        t && t(this),
        r.manager.itemEnd(e);
    }
    function l(t) {
      a.removeEventListener("load", o, !1),
        a.removeEventListener("error", l, !1),
        i && i(t),
        r.manager.itemError(e),
        r.manager.itemEnd(e);
    }
    return (
      a.addEventListener("load", o, !1),
      a.addEventListener("error", l, !1),
      "data:" !== e.substr(0, 5) &&
        void 0 !== this.crossOrigin &&
        (a.crossOrigin = this.crossOrigin),
      r.manager.itemStart(e),
      (a.src = e),
      a
    );
  }
}
class uE extends aE {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = new xx(),
      s = new cE(this.manager);
    return (
      s.setCrossOrigin(this.crossOrigin),
      s.setPath(this.path),
      s.load(
        e,
        function (e) {
          (r.image = e), (r.needsUpdate = !0), void 0 !== t && t(r);
        },
        n,
        i
      ),
      r
    );
  }
}
class hE extends Ab {
  constructor(e, t = 1) {
    super(),
      (this.type = "Light"),
      (this.color = new Xb(e)),
      (this.intensity = t);
  }
  dispose() {}
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      void 0 !== this.groundColor &&
        (t.object.groundColor = this.groundColor.getHex()),
      void 0 !== this.distance && (t.object.distance = this.distance),
      void 0 !== this.angle && (t.object.angle = this.angle),
      void 0 !== this.decay && (t.object.decay = this.decay),
      void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
      void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
      t
    );
  }
}
hE.prototype.isLight = !0;
const dE = new ib(),
  pE = new Cx(),
  fE = new Cx();
class mE {
  constructor(e) {
    (this.camera = e),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new fx(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new ib()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new jw()),
      (this._frameExtents = new fx(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new wx(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      n = this.matrix;
    pE.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(pE),
      fE.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(fE),
      t.updateMatrixWorld(),
      dE.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(dE),
      n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      n.multiply(t.projectionMatrix),
      n.multiply(t.matrixWorldInverse);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      0 !== this.bias && (e.bias = this.bias),
      0 !== this.normalBias && (e.normalBias = this.normalBias),
      1 !== this.radius && (e.radius = this.radius),
      (512 === this.mapSize.x && 512 === this.mapSize.y) ||
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class gE extends mE {
  constructor() {
    super(new Ow(50, 1, 0.5, 500)), (this.focus = 1);
  }
  updateMatrices(e) {
    const t = this.camera,
      n = 2 * ax * e.angle * this.focus,
      i = this.mapSize.width / this.mapSize.height,
      r = e.distance || t.far;
    (n === t.fov && i === t.aspect && r === t.far) ||
      ((t.fov = n), (t.aspect = i), (t.far = r), t.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
gE.prototype.isSpotLightShadow = !0;
class vE extends hE {
  constructor(e, t, n = 0, i = Math.PI / 3, r = 0, s = 1) {
    super(e, t),
      (this.type = "SpotLight"),
      this.position.copy(Ab.DefaultUp),
      this.updateMatrix(),
      (this.target = new Ab()),
      (this.distance = n),
      (this.angle = i),
      (this.penumbra = r),
      (this.decay = s),
      (this.shadow = new gE());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
vE.prototype.isSpotLight = !0;
const _E = new ib(),
  yE = new Cx(),
  xE = new Cx();
class bE extends mE {
  constructor() {
    super(new Ow(90, 1, 0.5, 500)),
      (this._frameExtents = new fx(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new wx(2, 1, 1, 1),
        new wx(0, 1, 1, 1),
        new wx(3, 1, 1, 1),
        new wx(1, 1, 1, 1),
        new wx(3, 0, 1, 1),
        new wx(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new Cx(1, 0, 0),
        new Cx(-1, 0, 0),
        new Cx(0, 0, 1),
        new Cx(0, 0, -1),
        new Cx(0, 1, 0),
        new Cx(0, -1, 0),
      ]),
      (this._cubeUps = [
        new Cx(0, 1, 0),
        new Cx(0, 1, 0),
        new Cx(0, 1, 0),
        new Cx(0, 1, 0),
        new Cx(0, 0, 1),
        new Cx(0, 0, -1),
      ]);
  }
  updateMatrices(e, t = 0) {
    const n = this.camera,
      i = this.matrix,
      r = e.distance || n.far;
    r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
      yE.setFromMatrixPosition(e.matrixWorld),
      n.position.copy(yE),
      xE.copy(n.position),
      xE.add(this._cubeDirections[t]),
      n.up.copy(this._cubeUps[t]),
      n.lookAt(xE),
      n.updateMatrixWorld(),
      i.makeTranslation(-yE.x, -yE.y, -yE.z),
      _E.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(_E);
  }
}
bE.prototype.isPointLightShadow = !0;
class wE extends hE {
  constructor(e, t, n = 0, i = 1) {
    super(e, t),
      (this.type = "PointLight"),
      (this.distance = n),
      (this.decay = i),
      (this.shadow = new bE());
  }
  get power() {
    return 4 * this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
wE.prototype.isPointLight = !0;
class SE extends mE {
  constructor() {
    super(new sS(-5, 5, 5, -5, 0.5, 500));
  }
}
SE.prototype.isDirectionalLightShadow = !0;
class ME extends hE {
  constructor(e, t) {
    super(e, t),
      (this.type = "DirectionalLight"),
      this.position.copy(Ab.DefaultUp),
      this.updateMatrix(),
      (this.target = new Ab()),
      (this.shadow = new SE());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
ME.prototype.isDirectionalLight = !0;
class TE extends hE {
  constructor(e, t) {
    super(e, t), (this.type = "AmbientLight");
  }
}
TE.prototype.isAmbientLight = !0;
class CE {
  static decodeText(e) {
    if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(e);
    let t = "";
    for (let i = 0, r = e.length; i < r; i++) t += String.fromCharCode(e[i]);
    try {
      return decodeURIComponent(escape(t));
    } catch (n) {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return -1 === t ? "./" : e.substr(0, t + 1);
  }
}
class EE extends uw {
  constructor() {
    super(),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = Infinity);
  }
  copy(e) {
    return super.copy(e), (this.instanceCount = e.instanceCount), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = super.toJSON(this);
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    );
  }
}
EE.prototype.isInstancedBufferGeometry = !0;
class AE extends aE {
  constructor(e) {
    super(e), (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, t, n, i) {
    void 0 === e && (e = ""),
      void 0 !== this.path && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const r = this,
      s = rE.get(e);
    if (void 0 !== s)
      return (
        r.manager.itemStart(e),
        setTimeout(function () {
          t && t(s), r.manager.itemEnd(e);
        }, 0),
        s
      );
    const a = {};
    (a.credentials =
      "anonymous" === this.crossOrigin ? "same-origin" : "include"),
      (a.headers = this.requestHeader),
      fetch(e, a)
        .then(function (e) {
          return e.blob();
        })
        .then(function (e) {
          return createImageBitmap(
            e,
            Object.assign(r.options, { colorSpaceConversion: "none" })
          );
        })
        .then(function (n) {
          rE.add(e, n), t && t(n), r.manager.itemEnd(e);
        })
        .catch(function (t) {
          i && i(t), r.manager.itemError(e), r.manager.itemEnd(e);
        }),
      r.manager.itemStart(e);
  }
}
AE.prototype.isImageBitmapLoader = !0;
const PE = new RegExp("[\\[\\]\\.:\\/]", "g"),
  LE = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
  IE = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
  RE = /(WCOD+)?/.source.replace("WCOD", LE),
  DE = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
  kE = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
  NE = new RegExp("^" + IE + RE + DE + kE + "$"),
  OE = ["material", "materials", "bones"];
class FE {
  constructor(e, t, n) {
    (this.path = t),
      (this.parsedPath = n || FE.parseTrackName(t)),
      (this.node = FE.findNode(e, this.parsedPath.nodeName) || e),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, t, n) {
    return e && e.isAnimationObjectGroup
      ? new FE.Composite(e, t, n)
      : new FE(e, t, n);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(PE, "");
  }
  static parseTrackName(e) {
    const t = NE.exec(e);
    if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const n = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      i = n.nodeName && n.nodeName.lastIndexOf(".");
    if (void 0 !== i && -1 !== i) {
      const e = n.nodeName.substring(i + 1);
      -1 !== OE.indexOf(e) &&
        ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = e));
    }
    if (null === n.propertyName || 0 === n.propertyName.length)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      );
    return n;
  }
  static findNode(e, t) {
    if (!t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid)
      return e;
    if (e.skeleton) {
      const n = e.skeleton.getBoneByName(t);
      if (void 0 !== n) return n;
    }
    if (e.children) {
      const n = function (e) {
          for (let i = 0; i < e.length; i++) {
            const r = e[i];
            if (r.name === t || r.uuid === t) return r;
            const s = n(r.children);
            if (s) return s;
          }
          return null;
        },
        i = n(e.children);
      if (i) return i;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i) e[t++] = n[i];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      n = t.objectName,
      i = t.propertyName;
    let r = t.propertyIndex;
    if (
      (e ||
        ((e = FE.findNode(this.rootNode, t.nodeName) || this.rootNode),
        (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    )
      return;
    if (n) {
      let i = t.objectIndex;
      switch (n) {
        case "materials":
          if (!e.material) return;
          if (!e.material.materials) return;
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) return;
          e = e.skeleton.bones;
          for (let t = 0; t < e.length; t++)
            if (e[t].name === i) {
              i = t;
              break;
            }
          break;
        default:
          if (void 0 === e[n]) return;
          e = e[n];
      }
      if (void 0 !== i) {
        if (void 0 === e[i]) return;
        e = e[i];
      }
    }
    const s = e[i];
    if (void 0 === s) {
      t.nodeName;
      return;
    }
    let a = this.Versioning.None;
    (this.targetObject = e),
      void 0 !== e.needsUpdate
        ? (a = this.Versioning.NeedsUpdate)
        : void 0 !== e.matrixWorldNeedsUpdate &&
          (a = this.Versioning.MatrixWorldNeedsUpdate);
    let o = this.BindingType.Direct;
    if (void 0 !== r) {
      if ("morphTargetInfluences" === i) {
        if (!e.geometry) return;
        if (!e.geometry.isBufferGeometry) return;
        if (!e.geometry.morphAttributes) return;
        void 0 !== e.morphTargetDictionary[r] &&
          (r = e.morphTargetDictionary[r]);
      }
      (o = this.BindingType.ArrayElement),
        (this.resolvedProperty = s),
        (this.propertyIndex = r);
    } else
      void 0 !== s.fromArray && void 0 !== s.toArray
        ? ((o = this.BindingType.HasFromToArray), (this.resolvedProperty = s))
        : Array.isArray(s)
        ? ((o = this.BindingType.EntireArray), (this.resolvedProperty = s))
        : (this.propertyName = i);
    (this.getValue = this.GetterByBindingType[o]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[o][a]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
(FE.Composite = class {
  constructor(e, t, n) {
    const i = n || FE.parseTrackName(t);
    (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
  }
  getValue(e, t) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_,
      i = this._bindings[n];
    void 0 !== i && i.getValue(e, t);
  }
  setValue(e, t) {
    const n = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
      n[i].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].unbind();
  }
}),
  (FE.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3,
  }),
  (FE.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2,
  }),
  (FE.prototype.GetterByBindingType = [
    FE.prototype._getValue_direct,
    FE.prototype._getValue_array,
    FE.prototype._getValue_arrayElement,
    FE.prototype._getValue_toArray,
  ]),
  (FE.prototype.SetterByBindingTypeAndVersioning = [
    [
      FE.prototype._setValue_direct,
      FE.prototype._setValue_direct_setNeedsUpdate,
      FE.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
    ],
    [
      FE.prototype._setValue_array,
      FE.prototype._setValue_array_setNeedsUpdate,
      FE.prototype._setValue_array_setMatrixWorldNeedsUpdate,
    ],
    [
      FE.prototype._setValue_arrayElement,
      FE.prototype._setValue_arrayElement_setNeedsUpdate,
      FE.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
    ],
    [
      FE.prototype._setValue_fromArray,
      FE.prototype._setValue_fromArray_setNeedsUpdate,
      FE.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
    ],
  ]);
class zE extends OT {
  constructor(e, t, n = 1) {
    super(e, t), (this.meshPerAttribute = n);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  clone(e) {
    const t = super.clone(e);
    return (t.meshPerAttribute = this.meshPerAttribute), t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.isInstancedInterleavedBuffer = !0),
      (t.meshPerAttribute = this.meshPerAttribute),
      t
    );
  }
}
zE.prototype.isInstancedInterleavedBuffer = !0;
const UE = new Cx(),
  BE = new Cx();
class VE {
  constructor(e = new Cx(), t = new Cx()) {
    (this.start = e), (this.end = t);
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    UE.subVectors(e, this.start), BE.subVectors(this.end, this.start);
    const n = BE.dot(BE);
    let i = BE.dot(UE) / n;
    return t && (i = ux(i, 0, 1)), i;
  }
  closestPointToPoint(e, t, n) {
    const i = this.closestPointToPointParameter(e, t);
    return this.delta(n).multiplyScalar(i).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class HE extends lC {
  constructor(e, t = 1, n = 16776960) {
    const i = n,
      r = new uw();
    r.setAttribute(
      "position",
      new nw(
        [
          1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1,
          1, 1, 1, 0, 0, 1, 0, 0, 0,
        ],
        3
      )
    ),
      r.computeBoundingSphere(),
      super(r, new nC({ color: i, toneMapped: !1 })),
      (this.type = "PlaneHelper"),
      (this.plane = e),
      (this.size = t);
    const s = new uw();
    s.setAttribute(
      "position",
      new nw([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)
    ),
      s.computeBoundingSphere(),
      this.add(
        new Aw(
          s,
          new $b({
            color: i,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1,
          })
        )
      );
  }
  updateMatrixWorld(e) {
    let t = -this.plane.constant;
    Math.abs(t) < 1e-8 && (t = 1e-8),
      this.scale.set(0.5 * this.size, 0.5 * this.size, t),
      (this.children[0].material.side = t < 0 ? 1 : 0),
      this.lookAt(this.plane.normal),
      super.updateMatrixWorld(e);
  }
}
function GE(e) {
  let t;
  const n = new Xb(16711680),
    i = _d(new fx()),
    r = _d(1);
  let s = 1,
    a = 2;
  const o = {
      antialias: !1,
      alpha: !1,
      depth: !0,
      stencil: !1,
      preserveDrawingBuffer: !1,
      powerPreference: "high-performance",
      premultipliedAlpha: !1,
    },
    l = { beforeInit: ud(), afterInit: ud() };
  e.renderer = {
    init: function () {
      (o.canvas = e.options.canvas),
        l.beforeInit.emit(),
        (t = new DT(o)),
        (e.renderer.instance = t),
        (e.threeRenderer = t),
        t.getDrawingBufferSize(i.value),
        h(),
        t.setClearColor(n),
        (t.autoClear = !0),
        (t.shadowMap.enabled = !1),
        (t.shadowMap.type = 0),
        (t.info.autoReset = !1),
        e.hooks.beforeFrame.watch(() => t.info.reset()),
        l.afterInit.emit(),
        e.viewport.changed.watch(h);
    },
    options: o,
    hooks: l,
    clearColor: n,
    resize: h,
    setMinPixelRatio: function (e) {
      if (s === e) return;
      (s = e), u();
    },
    setMaxPixelRatio: function (e) {
      if (a === e) return;
      (a = e), u();
    },
    drawingBufferSize: i,
    pixelRatio: r,
  };
  let c = !1;
  function u() {
    c || ((c = !0), e.hooks.beforeFrame.watchOnce(h));
  }
  function h() {
    c = !1;
    const n = wy(e.viewport.pixelRatio.value, s, a),
      o = e.viewport.size.value,
      l = fx.get();
    t.getSize(l),
      t.getPixelRatio() !== n && t.setPixelRatio(n),
      l.equals(o) || t.setSize(o.x, o.y),
      (function () {
        const e = i.value,
          n = fx.get();
        t.getDrawingBufferSize(n), xd(), n.equals(e) || i.set(e.copy(n), !0);
        r.set(t.getPixelRatio()), n.release(), bd();
      })(),
      l.release();
  }
}
const WE = Number.MAX_SAFE_INTEGER;
function qE(e) {
  let t = 16.67,
    n = !1,
    i = performance.now(),
    r = 16.6667,
    s = 0,
    a = 0,
    o = 0;
  let l = 0,
    c = 0;
  e.hooks.afterInit.watchOnce(() => {
    e.viewport && e.viewport.visible.watch(() => (n = !0));
  }),
    e.hooks.afterFrame.watchOnce(() => {
      n = !0;
    });
  const u = (e.time = {
    clampedDt: 0,
    stableDt: 16.6667,
    dt: 0,
    elapsed: 0,
    frameNum: 0,
    paused: !0,
    init: function () {
      Uc.add(h), (u.paused = !1);
    },
    start: function () {
      u.paused = !1;
    },
    pause: function () {
      u.paused = !0;
    },
    clampTo60Fps: !0,
  });
  function h(h) {
    const d = i;
    if (
      ((i = performance.now()),
      0 === (h = i - d) && (h = 16.6667),
      n &&
        ((h = 16.6667), (o = !0), (a = 0), (s = 0), (n = !1), (l = 0), (c = 0)),
      u.clampTo60Fps)
    ) {
      if (((l += h), c++, l < 13)) return;
      c > 1 && (h = 16.666667), (l = 0), (c = 0);
    }
    (a += h),
      a >= 1e3 ? ((o = !1), (r = (1 / s) * 1e3), (a = 0), (s = 0)) : s++,
      (t = wy(o ? h : r, 4, 130)),
      t > 30.303030303030305 && t < 37.03703703703704
        ? (t = 33.3333334)
        : t > 15.873015873015872 && t < 17.543859649122805
        ? (t = 16.6666667)
        : t > 8 && t < 9.09090909090909 && (t = 8.3333334),
      (u.stableDt = Cy(u.stableDt, t, n ? 1 : 0.08)),
      (u.clampedDt = wy(void 0 === h ? 16.6667 : h, 1, 130)),
      (u.dt = h),
      u.paused ||
        ((u.elapsed += h), (u.frameNum = (u.frameNum + 1) % WE), e.frame());
  }
}
function jE(e) {
  const t = Gi() ? Yt("viewport") : Ky,
    n = _d(new fx(t.width.value, t.height.value)),
    i = _d(n.value.x / n.value.y),
    r = _d(t.pixelRatio.value),
    s = _d(t.visible.value),
    a = ud();
  e.viewport = { size: n, visible: s, pixelRatio: r, changed: a };
  let o = 0,
    l = 0,
    c = 0;
  const u = uu(
    () => (
      (o = t.width.value), (l = t.height.value), void (c = t.pixelRatio.value)
    ),
    150
  );
  Sr(
    [t.width, t.height, t.pixelRatio],
    () => {
      (e.options.canvas.style.width = t.width.value + "px"),
        (e.options.canvas.style.height = t.height.value + "px"),
        u();
    },
    { immediate: !0 }
  ),
    Mr(
      () => {
        s.set(t.visible.value);
      },
      null,
      { flush: "sync" }
    ),
    e.hooks.beforeFrame.watch(() => {
      const e = n.value,
        t = e.x !== o || e.y !== l,
        s = r.value !== c;
      (t || s) &&
        (xd(),
        t && (e.set(o, l), n.set(e, !0), i.set(e.x / e.y)),
        s && r.set(c),
        a.emit(),
        bd());
    });
}
function YE(e) {
  const t = "webgl_quality",
    n = 300;
  let i = 58,
    r = 52,
    s = 30,
    a = n,
    o = n,
    l = 0,
    c = 0,
    u = !1,
    h = !1,
    d = 0,
    p = 10;
  const f = new Float64Array(3);
  let m = 0;
  const g = _d(0),
    v = _d(60),
    _ = _d(60),
    y = _d(1),
    x = ud();
  e.hooks.afterInit.watchOnce(function () {
    const n = El().$device,
      i = (n && n.gpu ? n.gpu.qualityIndex : 2) + 1,
      r = (function () {
        const e = localStorage.getItem(t);
        return null == e || isNaN(e) ? null : 0 | e;
      })(),
      s = null !== r ? r : i;
    y.watch((e) => {
      n && n.updateQuality(e),
        (function (e) {
          localStorage.setItem(t, e);
        })(e);
    }),
      y.set(s, !0),
      (d = s),
      e.hooks.beforeFrame.watch(w);
  }),
    e.hooks.beforeStart.watchOnce(async function () {
      e.viewport.visible.watch(() => b()),
        e.viewport.changed.watch(() => b(!0, n, !0)),
        x.watch(() => b(!0, 300));
    });
  return (e.quality = {
    pingPong: g,
    fps: v,
    fpsAverage: _,
    quality: y,
    reset: x,
    current: y,
    setThresholds: function (e = {}) {
      e.high && (i = e.high);
      e.low && (r = e.low);
      e.critical && (s = e.critical);
    },
  });
  function b(e, t, n) {
    (u = !0), (h = h || e), n && g.set(0), t && (a = t);
  }
  function w() {
    if (p > 0) return p--;
    const t = e.time.dt;
    if (!(g.value >= 2)) {
      if (
        (u &&
          ((l = 0), (c = 0), h && (m = 0), (o = a || n), (u = h = !1), (a = n)),
        o > 0)
      )
        return (o -= t);
      (l += t),
        c++,
        l >= 1e3 &&
          ((f[m++] = c),
          v.set(c),
          (c = 0),
          (l %= 1e3),
          m > f.length &&
            (function () {
              const e = (function (e = []) {
                const t = e.slice(0).sort((e, t) => e - t),
                  n = Math.floor(t.length / 2);
                return t.length % 2 == 0 ? (t[n] + t[n - 1]) / 2 : t[n];
              })(f);
              let t = y.value;
              e <= s ? (t -= 2) : e < r ? (t -= 1) : e > i && (t += 1),
                (t = wy(t, 0, 5));
              const n = y.value;
              t === n
                ? g.set(Math.max(0, g.value - 0.2))
                : t !== n && t !== d
                ? g.set(0)
                : t === d && g.set(g.value + 1),
                g.value >= 2 && (t = Math.min(d, n)),
                (d = n),
                y.set(t),
                _.set(e),
                b(!0);
            })());
    }
  }
}
function XE(e) {
  !(function (e) {
    const t = e.renderLists;
    if (t._patched) return;
    t._patched = !0;
    const n = t.get;
    t.get = function (e, t) {
      const i = n(e, t);
      return (
        i._patched ||
          (function (e) {
            e._patched = !0;
            const t = e.push,
              n = e.unshift;
            (e.push = function (e, n, i, r, s, a) {
              const o = i.transparent && i.forceOpaque;
              o && (i.transparent = !1),
                t(e, n, i, r, s, a),
                o && (i.transparent = !0);
            }),
              (e.unshift = function (e, t, i, r, s, a) {
                const o = i.transparent && i.forceOpaque;
                o && (i.transparent = !1),
                  n(e, t, i, r, s, a),
                  o && (i.transparent = !0);
              });
          })(i),
        i
      );
    };
  })(e);
}
const $E = new sS(-1, 1, 1, -1, 0, 1);
$E.parent = !0;
var ZE = $E;
const KE = new Float32Array([-2, 0, 0, -2, 2, 2]),
  JE = new uw();
JE.setAttribute("position", new Jb(KE, 2));
const QE = [
  "precision highp float;",
  "attribute vec2 position;",
  "varying vec2 vUv;",
  "void main() {",
  "vUv = position;",
  "gl_Position =  vec4(2.0 * position - 1.0, 0.,  1);",
  "}",
].join("");
let eA;
function tA(e) {
  const t = e.renderer;
  delete e.renderer;
  const n = new aS(
    Object.assign(
      {},
      {
        vertexShader: QE,
        fragmentShader: "void() { gl_FragColor = vec4(); }",
        depthTest: !1,
        depthWrite: !1,
        transparent: !0,
      },
      e
    )
  );
  eA ||
    ((eA = new Aw(JE, n)), (eA.frustumCulled = !1), (eA.matrixAutoUpdate = !1));
  return {
    cam: ZE,
    screen: eA,
    material: n,
    uniforms: n.uniforms,
    u: n.uniforms,
    render() {
      const e = t.sortObjects,
        i = t.shadowMap.enabled,
        r = t.autoclear;
      (t.sortObjects = !1),
        (t.shadowMap.enabled = !1),
        (t.autoclear = !1),
        (eA.material = n),
        t.render(eA, ZE),
        (t.sortObjects = e),
        (t.shadowMap.enabled = i),
        (t.autoclear = r);
    },
  };
}
function nA(e, t, n) {
  return {
    vs: e,
    fs: t,
    use: (n) => {
      (n.fragmentShader = t), (n.vertexShader = e);
    },
    unuse: () => {},
  };
}
var iA = nA(
  "precision highp float;attribute vec2 position;void main(){gl_Position=vec4(2.0*position-1.0,0.,1);}",
  "precision highp float;\n#include <bg_pars>\nvoid main(){\n#include <bg>\ngl_FragColor=vec4(bgColor,1.);}"
);
const rA = { res: { value: new fx() }, bgCamRotation: { value: new fx() } },
  sA = new Cx(),
  aA = new Cx();
function oA() {
  const e = kl(),
    t = tA({ renderer: e.threeRenderer, transparent: !1, uniforms: rA });
  return (
    (rA.res = e.renderer.drawingBufferSize),
    iA.use(t.material),
    (t.update = function () {
      const t = e.scene.currentCamera.cam,
        n = t.getWorldDirection(sA),
        i = t.localToWorld(aA.set(1, 0, 0)).sub(t.position),
        r = n.y,
        s = -i.y;
      rA.bgCamRotation.value.set(r, s);
    }),
    t
  );
}
oA.uniforms = rA;
class lA {
  constructor(e) {
    (this.isComponent = !0),
      (this.components = []),
      (this.dynamicComponents = []),
      (this.refs = {}),
      (this.tweens = {}),
      (this.timers = []),
      (this.props = e);
  }
  bind(e, t = 0) {
    return (this[e] = nx(e, this, t)), this[e];
  }
  init() {}
  beforeDestroy() {}
  add(e) {
    return this.base.add(e), e;
  }
  remove(e) {
    return this.base.remove(e), null;
  }
  addComponent(e, t) {
    t || (t = {});
    const n = t.mountTo || this.base;
    return (
      e.isComponent || (e = new e(t)),
      ~this.components.indexOf(e) ||
        ~this.dynamicComponents.indexOf(e) ||
        (e.parentComponent && e.parentComponent.removeComponent(e),
        (e.parentComponent = this),
        e.static || this.dynamicComponents.push(e),
        this.components.push(e),
        n && e.base && n.add(e.base),
        e.added && e.added(this)),
      e
    );
  }
  removeComponent(e) {
    const t = this.components.indexOf(e),
      n = this.dynamicComponents.indexOf(e);
    if (~t)
      return (
        (e.parentComponent = null),
        this.components.splice(t, 1),
        ~n && this.dynamicComponents.splice(n, 1),
        this.base && e.base && this.base.remove(e.base),
        e.removed && e.removed(this),
        null
      );
  }
  update(e) {
    if ((this.updateTimers(e), !this.destroyed))
      for (let t = 0, n = this.dynamicComponents.length; t < n; t++)
        this.dynamicComponents[t] && this.dynamicComponents[t].update(e);
  }
  updateTimers(e) {
    let t = this.timers.length;
    const n = this.timers;
    for (; t--; )
      n[t].update(e), n._stopped && (n[t].dispose(), n.splice(t, 1));
  }
  wait(e) {
    return this.timer(e);
  }
  timer(e, t) {
    if (!this.destroyed) {
      if (t) {
        const n = Vc(e, t);
        return this.timers.push(n), n;
      }
      return new Promise((t) => {
        const n = Vc(e, t);
        this.timers.push(n);
      });
    }
  }
  clearTimers() {
    for (let e = 0, t = this.timers.length; e < t; e++)
      this.timers[e].dispose();
    this.timers.length = 0;
  }
  destroy() {
    if (!this.destroyed) {
      (this.hiding = !0),
        this.beforeDestroy(),
        this.clearTimers(),
        this.parentComponent && this.parentComponent.removeComponent(this);
      for (let e = this.components.length - 1; e >= 0; e--)
        this.components[e].destroy();
      if (this.base)
        for (let e = this.base.children.length - 1; e >= 0; e--)
          this.base.remove(this.base.children[e]);
      for (const e in this.tweens) this.tweens[e] && this.tweens[e].kill();
      (this.tweens = null),
        this.base && this.base.parent && this.base.parent.remove(this.base),
        (this.refs = null),
        (this.props = null),
        (this.base = null),
        (this.destroyed = !0),
        (this.components = null),
        (this.dynamicComponents = null),
        (this.anims = null),
        (this.timers = null);
    }
  }
}
class cA extends lA {
  constructor(e = {}) {
    var t;
    super(e),
      (this.isCamera = !0),
      e.noInit || this.init(e),
      this.props || (this.props = e),
      this.base ||
        (((t = this).cam = new Ow(
          55,
          window.innerWidth / window.innerHeight,
          0.1,
          100
        )),
        (t.base = t.cam),
        t.base.position.set(0, 0.2, 1).multiplyScalar(5),
        t.base.lookAt(new Cx(0, 0, 0)));
    const n = kl().renderer.drawingBufferSize;
    (this.unwatchResize = n.watch(this.resize, this)),
      this.resize(n.value),
      (this.used = !1);
  }
  afterEnable() {}
  afterDisable() {}
  update() {}
  resize(e) {
    (this.cam.aspect = e.x / e.y), this.cam.updateProjectionMatrix();
  }
  beforeDestroy() {
    this.unwatchResize();
  }
  destroy() {
    (this.cam = null), super.destroy();
  }
}
const uA = function (e, t) {
  e && e.used != t && ((e.used = !!t), t ? e.afterEnable() : e.afterDisable());
};
class hA extends lA {
  constructor(e = {}) {
    super(e),
      (this.isScene = !0),
      (this.scene = this.base = new NT()),
      (this.background = new Xb(0, 0, 0)),
      e.noInit || this.init(e),
      this.props || (this.props = e),
      this.currentCamera || this.fallbackCamera();
  }
  fallbackCamera() {
    this.defaultCamera || (this.defaultCamera = this.addComponent(new cA())),
      this.useCamera(this.defaultCamera);
  }
  useCamera(e) {
    return (
      this.currentCamera && (this.previousCamera = this.currentCamera),
      (this.currentCamera = e),
      this.previousCamera !== this.currentCamera && uA(this.previousCamera, !1),
      uA(this.currentCamera, !0),
      this.currentCamera || this.fallbackCamera(),
      e
    );
  }
  usePreviousCamera() {
    const e = this.currentCamera;
    (this.currentCamera = this.previousCamera),
      (this.previousCamera = e),
      this.previousCamera !== this.currentCamera && uA(this.previousCamera, !1),
      uA(this.currentCamera, !0),
      this.currentCamera || this.fallbackCamera();
  }
  enter() {}
  exit() {}
  render() {
    kl().threeRenderer.render(this.base, this.currentCamera.cam);
  }
}
var dA = function (e) {
  function t(t) {
    (e = (0 | t) % 2147483647) <= 0 && (e += 2147483646);
  }
  function n() {
    return (e = (48271 * e) % 2147483647);
  }
  return (
    t(e),
    {
      seed: t,
      nextInt: n,
      nextFloat: function () {
        return (n() - 1) / 2147483646;
      },
    }
  );
};
var pA = (function (e = 0) {
  let t = dA(e);
  return (
    t.nextFloat(),
    t.nextFloat(),
    {
      setSeed: function (n) {
        t = dA((e = n));
      },
      random: function () {
        return t.nextFloat();
      },
      randomFloat: function (e = 0, n = 1) {
        return t.nextFloat() * (n - e) + e;
      },
      randomInt: function (e, n) {
        return Math.floor(t.nextFloat() * (n - e + 1)) + e;
      },
      hash2d: n,
      hash2dInt: function (e, t, i, r) {
        return Math.floor(n(e, t) * (r - i + 1)) + i;
      },
    }
  );
  function n(e, t) {
    return (function (e) {
      return e - Math.floor(e);
    })(43758.5453 * Math.sin(e * 78.233 - 12.9898 * t));
  }
})(Date.now());
const fA = (3 - Math.sqrt(3)) / 6,
  mA = [
    [1, 1],
    [-1, 1],
    [1, -1],
    [-1, -1],
    [1, 0],
    [-1, 0],
    [1, 0],
    [-1, 0],
    [0, 1],
    [0, -1],
    [0, 1],
    [0, -1],
  ];
function gA(e = Math.random) {
  const t = new Uint8Array(256);
  for (let a = 0; a < 256; a++) t[a] = a;
  let n, i;
  for (let a = 255; a > 0; a--)
    (n = Math.floor((a + 1) * e())), (i = t[a]), (t[a] = t[n]), (t[n] = i);
  const r = new Uint8Array(512),
    s = new Uint8Array(512);
  for (let a = 0; a < 512; a++) (r[a] = t[255 & a]), (s[a] = r[a] % 12);
  return (e, t) => {
    const n = 0.5 * (e + t) * (Math.sqrt(3) - 1),
      i = Math.floor(e + n),
      a = Math.floor(t + n),
      o = (i + a) * fA,
      l = e - (i - o),
      c = t - (a - o),
      u = l > c ? 1 : 0,
      h = l > c ? 0 : 1,
      d = l - u + fA,
      p = c - h + fA,
      f = l - 1 + 2 * fA,
      m = c - 1 + 2 * fA,
      g = 255 & i,
      v = 255 & a,
      _ = mA[s[g + r[v]]],
      y = mA[s[g + u + r[v + h]]],
      x = mA[s[g + 1 + r[v + 1]]],
      b = 0.5 - l * l - c * c,
      w = 0.5 - d * d - p * p,
      S = 0.5 - f * f - m * m;
    return (
      70.14805770653952 *
      ((b < 0 ? 0 : Math.pow(b, 4) * (_[0] * l + _[1] * c)) +
        (w < 0 ? 0 : Math.pow(w, 4) * (y[0] * d + y[1] * p)) +
        (S < 0 ? 0 : Math.pow(S, 4) * (x[0] * f + x[1] * m)))
    );
  };
}
function vA(e) {
  const t = kl().time.stableDt;
  let n = 1;
  return (
    t > 39
      ? (n = 1.4)
      : t > 32
      ? (n = 1.3)
      : t > 24
      ? (n = 1.2)
      : t > 19
      ? (n = 1.1)
      : t > 16 && (n = 1),
    e * n
  );
}
const _A = gA(),
  yA = new Cx(),
  xA = new Cx(),
  bA = new Cx(),
  wA = new Cx(),
  SA = new Cx(),
  MA = new Cx(),
  TA = new Tx(),
  CA = new Tx();
let EA, AA;
class PA extends cA {
  init() {
    (EA = kl()),
      (AA = EA.game),
      (EA.gameCam = AA.gameCam = this),
      (this.turbolineActive = !0),
      (this.cloudParticlesActive = !0);
    const e = (this.cam = new Ow(40, 1, 0.2, 180));
    (this.base = this.cam),
      (this.isGameCamera = !0),
      this.cam.position.set(0, 3, 10),
      this.cam.lookAt(new Cx(0, 0, 0)),
      this.cam.updateProjectionMatrix(),
      (this.minVel = 10),
      (this.maxVel = 40),
      (this.minFov = 30),
      (this.maxFov = 50),
      (this.targetFov = this.cam.fov),
      (this.baseCam = { pos: e.position.clone(), qt: e.quaternion.clone() }),
      (this.target = { pos: new Cx(), qt: new Tx() }),
      (this.targetLerp1 = { pos: new Cx(), qt: new Tx() }),
      (this.targetLerp2 = { pos: new Cx(), qt: new Tx() }),
      (this.road = AA.createFrameData()),
      (this.veryForwardRoad = AA.createFrameData()),
      (this.forwardRoad = AA.createFrameData()),
      (this.behindRoad = AA.createFrameData()),
      (this.plane = new Gw()),
      (this.forwardLine = new VE()),
      (this.carTranslation = 0),
      (this.activeInfluence = 0),
      (this.shakeState = {
        shaking: !1,
        maxDuration: 0,
        maxAmplitude: 0,
        currentDuration: 0,
        currentAmplitude: 0,
        freqMult: 1,
        value: [0, 0],
        pos: [0, 0],
        speed: [0.006, 1e-4],
      }),
      (this.hitPoint = new Ab()),
      (this.camPoint = new Ab()),
      EA.viewport.changed.watch(this.updateBaseDistance, this),
      AA.hooks.reset.watch(this.reset, this),
      this.reset(),
      AA.turbo.active.watch((e) => {
        (this.shakeTurboTarget = e ? 1 : 0),
          e &&
            ((this.shakeTurbo = this.shakeTurboTarget),
            this.shake(800, -0.15, !0, !0, 1.1));
      }),
      AA.ended.watch((e) => {
        this.endedInfluence = 0;
      });
  }
  updateBaseDistance() {
    const e = EA.viewport.size.value,
      t = e.x / e.y;
    this.baseDistance = Cy(1.65, 1.4, wy(Sy(t, 0.55, 0.85), 0, 1));
  }
  afterEnable() {
    this.reset();
  }
  afterDisable() {
    (this.activeInfluenceTarget = 0), (this.activeInfluence = 0);
  }
  reset() {
    (this.baseDistance = 1.6),
      this.updateBaseDistance(),
      (this.turboInfluence = 0),
      (this.shakeTurbo = this.shakeTurboTarget = 0),
      (this.targetFovSmooth = this.targetFov = 70),
      (this.autoInfluence = 0),
      (this.endedInfluence = 0),
      (this.activeInfluence = 0),
      (this.activeInfluenceTarget = this.used ? 1 : 0),
      "game" === Pl.$route.name &&
        ((this.forwardInfluence = 1), (this.forwardInfluenceRotate = 1)),
      this.update(!0);
  }
  updateMatrix() {
    const e = this.cam;
    e.updateMatrix(), e.matrixWorld.copy(e.matrix);
  }
  updateUp(e) {
    this.cam.up.copy(wA.set(0, 1, 0).applyQuaternion(e || this.cam.quaternion));
  }
  update(e) {
    AA.resetting && (e = !0);
    const t = EA.time.stableDt,
      n = AA.turbo.active.value;
    (this.turboInfluence = Ay(
      this.turboInfluence,
      n ? 1 : 0,
      n ? 0.1 : 0.06,
      t
    )),
      (this.distance =
        this.baseDistance + 0.15 * this.baseDistance * this.turboInfluence),
      (this.activeInfluence = Py(
        this.activeInfluence,
        this.activeInfluenceTarget,
        0.08,
        t,
        1e-5
      )),
      (this.autoInfluence = Cy(
        this.autoInfluence,
        AA.autopilot.value ? 1 : 0,
        AA.autopilot.value ? 0.05 : 0.08
      ));
    const i = this.cam,
      r = this.baseCam,
      s = this.target,
      a = this.targetLerp1,
      o = this.targetLerp2,
      l = this.road,
      c = this.behindRoad,
      u = this.forwardRoad,
      h = this.veryForwardRoad;
    i.position.copy(r.pos), i.quaternion.copy(r.qt), this.updateMatrix();
    const d = Cy(2, 15, this.autoInfluence),
      p = Cy(8, 30, this.autoInfluence);
    let f = 0;
    const m = AA.checkpoints.list.finish + 7;
    AA.ended.value &&
      AA.progress > m &&
      ((this.activeInfluenceTarget = 0),
      (this.endedInfluence = Ay(this.endedInfluence, 1, 0.02, t)),
      (f = Cy(
        0,
        m + 8 * this.endedInfluence - AA.progress,
        this.endedInfluence
      ))),
      AA.getRelativeRoadData(0 + f, l),
      AA.getRelativeRoadData(d + f, u),
      AA.getRelativeRoadData(p + f, h),
      AA.getRelativeRoadData(-this.distance + f, c);
    const g = yA.copy(h.position),
      v = bA.copy(l.position).sub(g).normalize(),
      _ = xA.copy(v).multiplyScalar(this.distance).add(l.position);
    this.forwardLine.start.copy(u.position),
      this.forwardLine.end.copy(_),
      this.hitPoint.position.copy(_),
      this.hitPoint.quaternion.copy(l.quaternion),
      this.hitPoint.updateWorldMatrix(!0),
      this.camPoint.position.copy(c.position),
      this.camPoint.quaternion.copy(c.quaternion),
      this.camPoint.updateWorldMatrix(!0),
      this.camPoint.worldToLocal(SA.copy(this.hitPoint.position)),
      this.camPoint.translateX(SA.x),
      this.camPoint.translateY(wy(SA.y, 0, 10)),
      this.camPoint.translateZ(SA.z),
      this.camPoint.quaternion.copy(this.hitPoint.quaternion),
      this.camPoint.updateWorldMatrix(!0),
      i.position.copy(this.camPoint.position),
      i.quaternion.copy(this.camPoint.quaternion),
      this.updateUp(),
      i.translateY(Cy(-0.1, -0.3, this.autoInfluence));
    const y = SA.y;
    i.translateY(-y),
      i.lookAt(l.position),
      TA.copy(i.quaternion),
      i.translateY(y),
      i.lookAt(u.position),
      CA.copy(i.quaternion),
      i.quaternion.copy(CA),
      i.quaternion.slerp(TA, Cy(0.15 * -y, 0, this.autoInfluence)),
      s.pos.copy(i.position),
      s.qt.copy(i.quaternion),
      i.position.copy(r.pos),
      i.quaternion.copy(r.qt);
    const x = vA;
    a.pos.lerp(s.pos, e ? 1 : x(0.2)),
      a.qt.slerp(s.qt, e ? 1 : x(0.2)),
      o.pos.lerp(a.pos, e ? 1 : x(0.15)),
      o.qt.slerp(a.qt, e ? 1 : x(0.15)),
      i.position.lerp(o.pos, e ? 1 : x(0.1)),
      i.quaternion.slerp(o.qt, e ? 1 : x(0.1)),
      e && i.translateY(0.45),
      SA.copy(l.position).sub(i.position).normalize();
    const b = MA.copy(SA).multiplyScalar(-this.distance).add(l.position);
    i.position.copy(b),
      i.translateY(My((AA.velocity * t) / 16.6667, 0, 10, 0.05, 0.08)),
      r.pos.copy(i.position),
      r.qt.copy(i.quaternion);
    const w = EA.scene.road.car;
    (this.carTranslation = Cy(
      this.carTranslation,
      w.base.position.z,
      e ? 1 : x(0.2)
    )),
      i.rotateZ(-0.025 * this.carTranslation),
      i.translateX(this.carTranslation),
      i.rotateZ(-0.025 * this.carTranslation);
    const S = AA.velocity;
    (this.targetFov = wy(My(S, 6, 10, 70, 79), 70, 95)),
      (this.targetFov *= 1 + 0.015 * n);
    const M = e ? 1 : 0.09 + 0.2 * this.turboInfluence;
    if (
      ((this.targetFovSmooth = Cy(i.fov, this.targetFov, M)),
      (i.fov = Cy(i.fov, this.targetFovSmooth, M)),
      this.cam.updateProjectionMatrix(),
      this.forwardInfluence > 1e-5 &&
        (this.cam.translateY(-0.2 * this.forwardInfluence),
        this.cam.translateZ(-3 * this.forwardInfluence)),
      this.forwardInfluenceRotate > 1e-5 &&
        (this.cam.rotateZ(-0.2 * this.forwardInfluenceRotate),
        this.cam.rotateX(-0.4 * this.forwardInfluenceRotate)),
      AA.paused.value)
    )
      return;
    this.forwardInfluence > 1e-5 &&
      (this.forwardInfluence = Ay(this.forwardInfluence, 0, 0.07, t)),
      this.forwardInfluenceRotate > 1e-5 &&
        (this.forwardInfluenceRotate = Ay(
          this.forwardInfluenceRotate,
          0,
          0.03,
          t
        ));
    const T = this.shakeState;
    if (T.shaking) {
      const e = 1 - T.currentDuration / T.maxDuration;
      let n = Cy(T.speed[0], T.speed[1], e);
      (n *= T.freqMult),
        (T.currentAmplitude = Cy(T.maxAmplitude, 0, e)),
        (T.pos[0] += t * n),
        (T.pos[1] += t * n),
        (T.value[0] = Math.cos(9 * T.pos[0]) * T.currentAmplitude * 0.6),
        (T.value[1] = _A(10, T.pos[1]) * T.currentAmplitude);
      const i = 0.9 * T.value[0],
        r = 0.3 * T.value[1],
        s = T.vertical ? r : i,
        a = T.vertical ? i : r;
      this.base.translateY(a),
        this.base.translateX(s),
        this.base.rotateZ(0.5 * a),
        this.base.rotateY(0.5 * s),
        (T.currentDuration = Math.max(0, T.currentDuration - t)),
        0 === T.currentDuration &&
          ((T.maxAmplitude = 0), (T.maxDuration = 0), (T.shaking = !1));
    }
    const C = EA.game.elapsed;
    if (w.dipShake > 0.001) {
      const e = Math.cos(0.09 * C) * w.dipShake + w.dipShake;
      this.base.translateX(0.9 * e), this.base.rotateX(0.3 * e);
    }
    if (this.shakeTurbo > 0.001) {
      this.shakeTurbo = Ay(this.shakeTurbo, this.shakeTurboTarget, 0.08, t);
      const e = (0.5 * Math.cos(0.079 * C) + 0.5) * this.shakeTurbo * 0.01;
      this.base.translateY(1 * e), this.base.rotateZ(1.4 * e);
    }
  }
  shake(e = 500, t = 0.1, n = !1, i = !1, r = 1) {
    const s = this.shakeState;
    (t *= 1.07),
      (s.vertical = n),
      (i || !s.shaking || e > s.maxDuration) &&
        ((s.maxDuration = e), (s.currentDuration = e)),
      (i || !s.shaking || t > s.maxAmplitude) &&
        ((s.maxAmplitude = t), (s.currentAmplitude = t), (s.freqMult = r)),
      (e || t) && (s.shaking = !0),
      (s.pos[0] = 200 * Math.PI),
      (s.pos[1] = 500 * Math.random());
  }
  devtools() {
    const e = EA.scene,
      t = new Lw();
    t.scale(0.06, 0.06, 0.06),
      (this.forwardRuler = e.addComponent(LineHelper, {
        line: this.forwardLine,
      })),
      (this.planeHelper = e.add(new HE(this.plane, 1e3))),
      (this.cameraHelper = e.add(new CameraHelper(this.cam))),
      (this.hitPoint = e.add(new Aw(t, new $b({ color: 16776960 })))),
      (this.camPoint = e.add(new Aw(t, new $b({ color: 16777215 })))),
      (this.showHelper = yd(_d(!1), "cam_helper", { type: Boolean })),
      requestAnimationFrame(() => {
        EA.scene.gui
          .addButton({ title: "Shake", label: "Game Camera" })
          .on("click", () => this.shake()),
          EA.scene.gui.addInput(this, "showHelper", {
            label: "Cam Helpers",
            index: 1,
          });
      }),
      this.showHelper.watchImmediate((e) => {
        this.cameraHelper.visible =
          this.forwardRuler.visible =
          this.planeHelper.visible =
          this.camPoint.visible =
          this.hitPoint.visible =
            e;
      });
  }
}
var LA = [
  {
    fromPos: [282.891704, -18.581829, -50.960995],
    fromQt: [-0.02241292, 0.97635353, -0.12517048, -0.17482507],
    toPos: [299.941729, -5.772501, -4.877451],
    toQt: [-0.02241292, 0.97635353, -0.12517048, -0.17482507],
    carProgress: 845,
    minDuration: 3e3,
    maxDuration: 3e3,
    portrait: !0,
  },
  {
    fromPos: [175.216669, -0.036465, 11.9629],
    fromQt: [0.02326362, 0.92994943, -0.05975366, 0.36205297],
    toPos: [167.658131, 2.232513, 20.198758],
    toQt: [0.02326362, 0.92994943, -0.05975366, 0.36205297],
    carProgress: 450,
    minDuration: 2e3,
    maxDuration: 2e3,
    shotDuration: 4e3,
    engineMult: 1.02,
    portrait: !0,
  },
  {
    fromPos: [187.853648, 1.957363, 48.003604],
    fromQt: [0.01508246, 0.86160589, -0.02564635, 0.50670512],
    toPos: [183.340058, 2.267299, 49.875425],
    toQt: [0.01670806, 0.85731853, -0.02788102, 0.51375911],
    carProgress: 490,
    minDuration: 2700,
    maxDuration: 2700,
    engineMult: 1.1,
    carTowardsCam: !0,
  },
  {
    fromPos: [128.718036, 4.103217, 3.850563],
    fromQt: [-0.02500299, 0.09774558, 0.00245647, 0.99489428],
    toPos: [125.773766, 5.079072, -5.987887],
    toQt: [0.04454532, -0.36356677, 0.01740783, 0.93033966],
    carProgress: 330,
    minDuration: 2e3,
    maxDuration: 2e3,
    portrait: !0,
    selfieMode: !0,
  },
  {
    fromPos: [128.718036, 4.103217, 3.850563],
    fromQt: [-0.02500299, 0.09774558, 0.00245647, 0.99489428],
    toPos: [125.773766, 5.079072, -5.987887],
    toQt: [0.04454532, -0.36356677, 0.01740783, 0.93033966],
    carProgress: 340,
    minDuration: 2e3,
    maxDuration: 2e3,
  },
  {
    fromPos: [225.97637, -0.396231, -31.212934],
    fromQt: [-0.00207845, 0.99464626, -0.02041174, -0.10128113],
    toPos: [228.390101, 0.091184, -19.913308],
    toQt: [0.00430996, 0.99565115, 0.06124577, -0.07006551],
    carProgress: 592,
    minDuration: 1700,
    maxDuration: 1700,
    shotDuration: 1700,
    carTowardsCam: !0,
    portrait: !0,
  },
  {
    fromPos: [227.461658, -0.290387, -21.434235],
    fromQt: [-0.05747906, -0.0279098, -0.00160752, 0.99795522],
    toPos: [222.675706, -0.038329, -63.153271],
    toQt: [0.0892923, -0.0343194, 0.00307859, 0.99540926],
    carProgress: 605,
    minDuration: 4e3,
    maxDuration: 4e3,
    engineMult: 0.95,
    portrait: !0,
  },
  {
    fromPos: [88.076076, 6.250712, 32.666098],
    fromQt: [-0.00314254, 0.40548705, 0.00139402, 0.91409432],
    toPos: [84.67264, 5.274827, 21.484648],
    toQt: [-0.0034374, -0.01624803, -5586e-8, 0.99986208],
    carProgress: 220,
    minDuration: 2e3,
    maxDuration: 2e3,
    shotDuration: 2500,
    carTowardsCam: !0,
    engineMult: 1.1,
  },
  {
    fromPos: [103.419212, -0.721882, 52.708181],
    fromQt: [-0.11709994, -0.53352681, -0.07488577, 0.83428344],
    toPos: [111.952886, -1.969951, 47.591677],
    toQt: [-0.05274749, -0.4966684, -0.03025847, 0.8658075],
    carProgress: 135,
    minDuration: 2e3,
    maxDuration: 2e3,
    engineMult: 1.04,
  },
  {
    fromPos: [123.084511, -0.299156, 19.813292],
    fromQt: [0.00560572, 0.95071188, 0.01721688, -0.30954655],
    toPos: [115.367267, 0.175733, 9.218633],
    toQt: [0.00560572, 0.95071188, 0.01721688, -0.30954655],
    carProgress: 160,
    minDuration: 2500,
    maxDuration: 2500,
    shotDuration: 2500,
    carTowardsCam: !0,
    portrait: !0,
  },
  {
    fromPos: [123.084511, -0.299156, 19.813292],
    fromQt: [0.00560572, 0.95071188, 0.01721688, -0.30954655],
    toPos: [115.367267, 0.175733, 9.218633],
    toQt: [0.00560572, 0.95071188, 0.01721688, -0.30954655],
    carProgress: 160,
    minDuration: 2500,
    maxDuration: 2500,
    shotDuration: 2500,
    carTowardsCam: !0,
    portrait: !0,
    selfieMode: !0,
  },
  {
    fromPos: [254.197647, -0.5098, -94.872706],
    fromQt: [-0.02720285, 0.33842121, 0.00978791, 0.94055052],
    toPos: [244.776459, -0.59221, -96.238816],
    toQt: [0.0086017, 0.52566449, -0.00531559, 0.85063188],
    carProgress: 700,
    minDuration: 1200,
    maxDuration: 1200,
    carTowardsCam: !0,
    engineMult: 1.1,
    portrait: !0,
  },
  {
    fromPos: [18.68355, 0.305625, -0.552699],
    fromQt: [0.05793902, -0.75217683, 0.06673793, 0.65300776],
    toPos: [36.576095, 1.201599, -0.9713],
    toQt: [0.01251986, -0.8333603, 0.01889228, 0.55226529],
    carProgress: 18,
    minDuration: 3e3,
    maxDuration: 3e3,
    shotDuration: 3e3,
    engineMult: 1.07,
    portrait: !0,
  },
];
function IA(e) {
  return e[((t = 0), (n = e.length), Math.floor(Math.random() * (n - t)) + t)];
  var t, n;
}
gA();
const RA = new Cx(),
  DA = new Cx();
new Cx(), new Tx(), new Tx();
const kA = new Ab();
let NA, OA;
class FA extends cA {
  init() {
    (NA = kl()),
      (OA = NA.game),
      (this.cam = new Ow(55, 1, 0.2, 180)),
      (this.base = this.cam),
      (this.forceCarAutopilot = !0),
      (this.forceCarVelocity = 8),
      (this.isIdleCamera = !0),
      this.cam.position.set(0, 3, 10),
      this.cam.lookAt(new Cx(0, 0, 0)),
      this.cam.updateProjectionMatrix(),
      (this.enabled = _d(!1)),
      (this.shot = {
        fromPos: new Cx(),
        toPos: new Cx(),
        fromQt: new Tx(),
        toQt: new Tx(),
        lookAt: new Cx(),
        useLookAt: !1,
        towardsCam: !1,
        seflieMode: !1,
      }),
      this.reset();
  }
  reset() {
    (this.index = -1),
      this.shot.fromPos.setScalar(0),
      this.shot.toPos.setScalar(0),
      (this.shot.useLookAt = !1),
      this.nextShot(),
      this.update(!0);
  }
  updateMatrix() {
    const e = this.cam;
    e.updateMatrix(), e.matrixWorld.copy(e.matrix);
  }
  updateUp(e) {
    const t = RA.set(0, 1, 0).applyQuaternion(e || this.cam.quaternion);
    this.cam.up.copy(t);
  }
  nextShot(e) {
    const t = (this.index + 1) % LA.length,
      n = LA[e || t];
    if (
      (n.fromPos && this.shot.fromPos.fromArray(n.fromPos),
      n.toPos && this.shot.toPos.fromArray(n.toPos),
      n.fromQt && this.shot.fromQt.fromArray(n.fromQt),
      n.toQt && this.shot.toQt.fromArray(n.toQt),
      n.lookAt && this.shot.lookAt.fromArray(n.lookAt),
      (this.shot.selfieMode = !!n.selfieMode),
      (this.carTowardsCam = !!n.carTowardsCam),
      (this.engineMult =
        null != n.engineMult ? n.engineMult : pA.randomFloat(0.98, 1.03)),
      (this.shot.useLookAt = n.lookAt),
      (this.index = t),
      (this.time = 0),
      (this.shotDuration = n.shotDuration || 1e4),
      (this.duration = pA.randomFloat(
        n.minDuration || 3e3,
        n.maxDuration || 5e3
      )),
      this.used)
    ) {
      const e = n.carProgress || 0;
      OA.progress = e;
    }
  }
  afterEnable() {
    this.reset(), "result" === Pl.$route.name && this.nextShot(1);
  }
  afterDisable() {
    this.reset();
  }
  update(e) {
    if (((this.visible = this.used), !e && !this.visible)) return;
    const t = e ? 0 : NA.time.stableDt;
    this.time += t;
    const n = this.shot,
      i = this.cam,
      r = wy(this.time / this.shotDuration, 0, 1);
    n.selfieMode
      ? this.selfieMode(i)
      : (i.position.lerpVectors(n.fromPos, n.toPos, r),
        n.useLookAt
          ? i.lookAt(n.lookAt)
          : i.quaternion.slerpQuaternions(n.fromQt, n.toQt, r)),
      this.time >= this.duration && this.nextShot();
  }
  selfieMode(e) {
    const t = NA.game.getRelativeRoadData(1),
      n = OA.pointer.base;
    kA.position.copy(t.position),
      kA.quaternion.copy(n.quaternion),
      kA.lookAt(n.position),
      kA.rotateY(Math.PI),
      kA.updateMatrixWorld();
    const i = kA.localToWorld(DA.set(0, 0.26, 0));
    kA.position.copy(i),
      e.position.copy(kA.position),
      e.quaternion.copy(kA.quaternion);
  }
}
class zA extends lA {
  constructor(e = {}) {
    super(e),
      e.noInit || this.init(e),
      this.props || (this.props = e),
      this.base || (this.base = new Ab()),
      void 0 === this.static && (this.static = !1);
  }
  destroy() {
    super.destroy();
  }
}
var UA = nA(
  "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main(){\n#include <uv_vertex>\n#include <beginnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#include <project_vertex>\nvViewPosition=-mvPosition.xyz;\n#include <worldpos_vertex>\n#include <envmap_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n}",
  "#define PHONG\n#define NEON\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <bg_fog_pars>\n#include <conditionals>\n#include <luma>\nuniform vec3 diffuse;uniform vec3 emissive;uniform vec3 specular;uniform float shininess;uniform float opacity;uniform float speedInfluence;uniform sampler2D data;uniform sampler2D matcaps;void main(){vec3 data=texture2D(data,vUv).rgb;float speedLineInfluence=clamp(smoothstep(0.1,1.,gl_FragCoord.w),0.,1.)*data.b*speedInfluence;vec4 diffuseColor=vec4(diffuse,opacity);float rimLightPower=2.5;float rimLightStrength=0.9;float rightLight=rimLightPower*abs(dot(vNormal,normalize(vViewPosition)));rightLight=1.-smoothstep(.0,1.,rightLight);diffuseColor.rgb+=diffuseColor.rgb*vec3(rightLight*rimLightStrength)*0.5;diffuseColor.rgb+=clamp(vNormal.x*0.9,-1.,0.)*0.7;diffuseColor.rgb-=vNormal.z*0.2;ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));vec3 totalEmissiveRadiance=emissive;\n#include <map_fragment>\nfloat specularStrength=1.0;specularStrength=data.g*10.+speedLineInfluence*8.;\n#include <normal_fragment_begin>\n#include <lights_phong_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\nvec3 outgoingLight=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+reflectedLight.directSpecular+reflectedLight.indirectSpecular+totalEmissiveRadiance;outgoingLight=mix(outgoingLight,outgoingLight*0.5+vec3(1.),speedLineInfluence*1.);float neonIntensity=data.r;outgoingLight.rgb=min(vec3(1.),outgoingLight.rgb+vec3(neonIntensity));\n#include <output_fragment>\n#include <neon_encode>\n#include <bg_fog>\n}"
);
let BA,
  VA,
  HA = null;
class GA extends kw {
  constructor(e = {}) {
    super(e);
    const t = (this.uniforms = l(
      o(
        o({}, Dw.merge([Kw.common, Kw.specularmap, Kw.fog, Kw.lights])),
        oA.uniforms
      ),
      {
        map: { value: Nl.textures.roadDiffuse },
        data: { value: Nl.textures.roadData },
        specular: { value: new Xb(1118481) },
        shininess: { value: 130 },
        speedInfluence: { value: 0 },
      }
    ));
    (this.map = t.map.value),
      UA.use(this),
      (this.lights = !0),
      (this.fog = !0),
      (this.type = "ShaderMaterial"),
      (this.isShaderMaterial = !0);
  }
}
GA.get = (e) => (HA = HA || new GA(e));
class WA extends zA {
  init() {
    (BA = kl()), (VA = BA.game), (VA.pointer = this), (this.base = new Ab());
  }
  update() {
    const e = VA.getRoadData();
    this.base.position.copy(e.position),
      this.base.quaternion.copy(e.quaternion),
      this.base.updateMatrixWorld();
  }
}
var qA = nA(
  "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main(){\n#include <uv_vertex>\n#include <beginnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#include <project_vertex>\nvViewPosition=-mvPosition.xyz;\n#include <worldpos_vertex>\n#include <envmap_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n}",
  "#define PHONG\n#define NEON\n#define TANGENTSPACE_NORMALMAP\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bg_fog_pars>\n#include <conditionals>\n#include <luma>\n#include <remap>\n#include <linearstep>\nuniform vec3 diffuse;uniform vec3 emissive;uniform vec3 specular;uniform float shininess;uniform float opacity;uniform float bloomStrength;uniform float turboProgress;uniform vec3 turboColor;uniform sampler2D data;uniform sampler2D matcaps;uniform sampler2D prevFrame;uniform vec2 size;void main(){vec4 diffuseColor=vec4(diffuse,opacity);ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));vec3 totalEmissiveRadiance=emissive;vec2 ruv=gl_FragCoord.xy/size;ruv.x+=vNormal.x*0.3;ruv.y+=-0.13+vNormal.y*0.3;vec2 testb=texture2D(prevFrame,ruv).rb;float test2=smoothstep(testb.r,0.,0.8)*1.9;test2+=smoothstep(testb.g,-0.4,0.7)*9.9;float test=test2*0.8;\n#include <map_fragment>\nif(diffuseColor.a<0.95)discard;float specularStrength=1.0;\n#include <normal_fragment_begin>\nvec3 mapN=texture2D(normalMap,vUv*50.).xyz*2.0-1.0;float scale=1.3;mapN*=vec3(scale,scale,1.);vec3 normalFlakes=perturbNormal2Arb(-vViewPosition,normal,mapN,faceDirection);\n#include <lights_phong_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\nvec3 outgoingLight=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+reflectedLight.directSpecular+reflectedLight.indirectSpecular+totalEmissiveRadiance;\n#include <envmap_fragment>\n#include <output_fragment>\nvec2 uv=vUv;float data=texture2D(data,uv).r;float id=floor(data*8.);float id_x=mod(id,4.)/4.+0.0001;float id_y=(floor(id/4.)/2.)+0.0001;vec2 start=vec2(id_x,id_y);vec2 size=vec2(0.25,0.5);vec3 viewDir=normalize(vViewPosition);vec3 x=normalize(vec3(viewDir.z,0.0,-viewDir.x));vec3 y=cross(viewDir,x);vec2 matcapUV=vec2(dot(x,normal),dot(y,normal))*0.499+0.5;matcapUV.y=1.-matcapUV.y;matcapUV.xy=matcapUV.xy*size+start;vec3 matcapColor=texture2D(matcaps,matcapUV).rgb;vec2 matcapUVFlakes=vec2(dot(x,normalFlakes),dot(y,normalFlakes))*0.499+0.5;matcapUVFlakes.y=1.-matcapUVFlakes.y;matcapUVFlakes.xy=matcapUVFlakes.xy*size+start;vec3 matcapColorFlakes=texture2D(matcaps,matcapUVFlakes).rgb;matcapColor=mix(matcapColor,matcapColorFlakes,smoothstep(0.4,0.,luma(matcapColor))*when_eq(id,4.));float isNotTire=1.-when_eq(id,6.);float isGlass=when_eq(id,5.);float rimLightPower=5.2;float rimLightStrength=0.4*isNotTire;vec3 rimColor=vec3(1.,0.,0.);float rightLight=rimLightPower*abs(dot(vNormal,normalize(vViewPosition)));rightLight=1.-smoothstep(.0,1.,rightLight);matcapColor+=matcapColor*vec3(rightLight*rimLightStrength)*0.5;vec3 rim=mix(matcapColor,rimColor,rightLight*rimLightStrength);float glass=luma(envColor.rgb)*(0.55+isGlass*1.8);test+=glass;matcapColor=mix(rim,matcapColor,0.1+0.6*smoothstep(0.2,0.8,luma(matcapColor)));vec3 lMatcapColor=matcapColor*smoothstep(0.,0.06,(luma(reflectedLight.directDiffuse)));matcapColor=mix(lMatcapColor,matcapColor,(0.4+0.6*smoothstep(0.,0.4,luma(matcapColor)))+reflectedLight.directSpecular*3.+isGlass*test*0.6+test*0.12);matcapColor+=test*0.013*isGlass+test*0.02+glass*0.07;float turbo=step(turboProgress,uv.y);vec3 turboShape=mix(vec3(0.357,0.012,0.035)*0.1,turboColor,turbo);float isTurbo=when_eq(id,1.)*when_gt(vUv.x,0.11)*when_lt(vUv.x,0.14);matcapColor=mix(matcapColor,turboShape,isTurbo);float neonIntensity=when_eq(id,1.)*0.7*bloomStrength;gl_FragColor.rgb=matcapColor;\n#include <neon_encode>\n#include <bg_fog>\n}"
);
let jA = null;
class YA extends kw {
  constructor(e = {}) {
    super(e), (this.envMap = null), (this.envMapIntensity = 1);
    const t = (this.uniforms = l(
      o(
        o(
          {},
          Dw.merge([Kw.common, Kw.envmap, Kw.normalmap, Kw.fog, Kw.lights])
        ),
        oA.uniforms
      ),
      {
        size: Nl.renderer.drawingBufferSize,
        prevFrame: Nl.previousFrame,
        data: { value: Nl.textures.carData },
        matcaps: { value: Nl.textures.matcaps },
        specular: { value: new Xb(5592405) },
        turboProgress: { value: 0 },
        turboColor: { value: new Xb() },
        bloomStrength: { value: 0.5 },
        shininess: { value: 100 },
        reflectivity: { value: 1 },
      }
    ));
    (this.envMap = t.envMap.value = Nl.textures.envMap2),
      (this.normalMap = t.normalMap.value = Nl.textures.flakes),
      (this.normalScale = t.normalScale.value = new fx(1)),
      (this.extensions.derivatives = { derivatives: !0 }),
      qA.use(this),
      (this.lights = !0),
      (this.fog = !0),
      (this.type = "ShaderMaterial"),
      (this.isShaderMaterial = !0);
  }
}
YA.get = (e) => (jA = jA || new YA(e));
const XA = function () {};
class $A {
  constructor({
    atlas: e,
    id: t,
    group: n,
    sequence: i,
    loop: r,
    autoplay: s,
    frame: a,
    onUpdate: o,
    onEnd: l,
    onEndOnce: c,
    frameDuration: u,
    category: h,
  }) {
    (this.frames = []),
      (this.onUpdate = o || XA),
      (this.onEndOnce = c || XA),
      (this.onEnd = l || XA),
      (this.id = void 0 !== t ? t : n + "/" + i),
      (this.group = ""),
      (this.sequence = ""),
      (this.loop = !!r),
      (this.autoplay = !!s),
      (this.frame = a || 0),
      (this.frameCount = 0),
      (this.frameDuration = u || 48),
      (this.frameTimer = 60 * Math.random()),
      (this.currentFrameIndex = 0),
      (this.paused = !1),
      (this.ended = !1),
      (this.category = h || "atlas"),
      (this.atlas = e),
      e &&
        (this.setAtlas(e),
        this.change({
          id: this.id,
          frameDuration: this.frameDuration,
          autoplay: this.autoplay,
          loop: this.loop,
          frame: this.frame,
        }));
  }
  setAtlas(e) {
    e && (this.sprites = e.sprites || e);
  }
  change({
    id: e = "circle",
    group: t,
    sequence: n,
    frame: i,
    frameDuration: r,
    autoplay: s,
    loop: a,
  }) {
    if (this.sprites[e]) {
      if (void 0 !== e) {
        this.id = e;
        const t = this.id.split("/");
        (this.sequence = t.pop()), (this.group = t.join("/"));
      } else
        void 0 !== n &&
          (void 0 !== t && (this.group = t),
          (this.sequence = n),
          (this.id = this.group + "/" + this.sequence));
      (this.frames = this.sprites[this.id]),
        (this.frameCount = this.frames.length),
        (this.currentFrameIndex = Math.min(i || 0, this.frameCount - 1)),
        (this.frame = this.frames[this.currentFrameIndex]),
        (this.loop = !!a),
        (this.autoplay = !!s),
        (this.frameDuration = r || 48),
        (this.paused = !this.autoplay),
        this.frameCount < 2 ? this.end() : (this.ended = !1),
        this.onUpdate(this.frame);
    }
  }
  end() {
    (this.ended = !0),
      this.onEndOnce(this.frame),
      (this.onEndOnce = XA),
      this.onEnd(this.frame);
  }
  play() {
    (this.paused = !1), (this.isBackwards = !1), (this.ended = !1);
  }
  playBackwards() {
    (this.paused = !1), (this.isBackwards = !0), (this.ended = !1);
  }
  reset() {
    (this.ended = !1), (this.paused = !1), (this.currentFrameIndex = 0);
  }
  resetFrame() {
    (this.currentFrameIndex = 0),
      (this.frame = this.frames[this.currentFrameIndex]);
  }
  pause() {
    this.paused = !0;
  }
  nextFrame() {
    let e = this.currentFrameIndex + 1;
    if (e >= this.frameCount) {
      if (!this.loop) return void this.end();
      e = 0;
    }
    e !== this.currentFrameIndex &&
      ((this.currentFrameIndex = e),
      (this.frame = this.frames[this.currentFrameIndex]),
      !this.loop && e + 1 >= this.frameCount && this.end());
  }
  previousFrame() {
    let e = this.currentFrameIndex - 1;
    if (e < 0) {
      if (!this.loop) return void this.end();
      e = this.frameCount;
    }
    e !== this.currentFrameIndex &&
      ((this.currentFrameIndex = e),
      (this.frame = this.frames[this.currentFrameIndex]),
      !this.loop && e - 1 < 0 && this.end());
  }
  update(e) {
    this.ended ||
      this.paused ||
      (this.frameTimer <= 0 &&
        ((this.frameTimer = Math.max(0, this.frameDuration + this.frameTimer)),
        this.isBackwards ? this.previousFrame() : this.nextFrame()),
      (this.frameTimer -= e));
  }
  destroy() {
    this.sprites = this.frames = this.frame = this.onUpdate = null;
  }
}
const ZA = new Ab();
let KA, JA, QA, eP, tP;
class nP {
  constructor(e) {
    KA || (KA = kl()),
      (this.isComponent = !0),
      e.batcher &&
        ((this.batcher = e.batcher),
        (e.atlas = this.batcher.atlas),
        (e.batcher = null)),
      (this.dummy = ZA),
      (this.position = new Cx()),
      (this.scale = new fx(1, 1)),
      (this.quaternion = new Tx()),
      (this.color = new Xb(16777215)),
      e.useEuler && ((this.useEuler = !0), (this.rotation = new pb())),
      (this.alpha = null != e.alpha ? e.alpha : 1),
      (this.initialAlpha = this.alpha),
      (this.visible = !0),
      (this.parent = e.parent || null),
      (this.billboard = !!e.billboard),
      (this.angle = 0),
      e.position && this.position.copy(e.position),
      null != e.color &&
        ("number" == typeof e.color
          ? this.color.set(e.color)
          : this.color.copy(e.color)),
      e.scale &&
        ("number" == typeof e.scale
          ? this.scale.setScalar(e.scale)
          : this.scale.copy(e.scale)),
      e.quaternion && this.quaternion.copy(e.quaternion),
      (this.sprite = new $A(l(o({}, e), { id: e.sprite || e.id }))),
      this.batcher && this.batcher.addInstance(this),
      this.init(e),
      this.sprite.update(1);
  }
  init() {}
  update() {
    const e = KA.time.stableDt;
    this.sprite.update(e);
  }
  destroy() {
    this.batcher && this.batcher.removeInstance(this),
      this.parentComponent && this.parentComponent.removeComponent(this),
      this.sprite.destroy(),
      (this.sprite = this.batcher = null),
      (this.props = null);
  }
}
class iP extends nP {
  constructor(e) {
    (JA = kl()),
      (QA = JA.game),
      super({
        sprite: "raysA",
        batcher: JA.particles.batcherDepth,
        parent: e.car.base,
        useEuler: !0,
        scale: 2.5,
        alpha: 0,
      }),
      (this.bright = new Xb(16777215)),
      (this.dark = new Xb(0)),
      this.color.copy(this.dark),
      (this.car = e.car.base),
      (this.rotation.y = -Math.PI / 2),
      this.position.set(0.36, 0.05, 0),
      (this.opacity = 0),
      (this.targetOpacity = 1),
      JA.game.hooks.reset.watch(this.reset, this);
  }
  reset() {
    (this.opacity = 0), (this.targetOpacity = 0);
  }
  update() {
    const e = QA.turbo.hover,
      t = JA.turboline.getZAt(QA.progress + 0.2);
    this.targetOpacity = e ? 1 : 0;
    const n = wy(Sy(Math.abs(t - this.car.position.z), 0.28, 0.1), 0, 1);
    (this.targetOpacity *= n),
      (this.opacity = Cy(this.opacity, this.targetOpacity, e ? 0.08 : 0.12)),
      (this.alpha = 1 - this.opacity),
      this.color.lerpColors(this.dark, this.bright, this.opacity),
      (this.position.z = t - this.car.position.z),
      (this.rotation.x += 0.02);
  }
}
const rP = new Cx(),
  sP = new Cx(),
  aP = new Cx(),
  oP = new fx();
new Tx();
class lP extends zA {
  init({ car: e }) {
    (eP = kl()),
      (tP = eP.game),
      (this.car = e),
      (this.base = null),
      this.addComponent(iP, { car: e }),
      tP.turbo.active.watch(this.onTurbo, this),
      tP.hooks.reset.watch(this.reset, this),
      this.reset();
  }
  reset() {
    (this.hoverInfluence = 0), (this.turboInfluence = 0);
  }
  onTurbo(e) {
    e &&
      (eP.car.base.getWorldPosition(rP),
      tP.particles.emit("flash", {
        amount: 1,
        position: rP.set(-0.7, 0.1, 0),
        scale: oP.set(5, 3),
        duration: 1200,
        parent: eP.car.base,
        power: 1,
        sprite: "raysA",
      }));
  }
  lineEmit() {
    const e = tP.state.hasEnded() && eP.gameCam.activeInfluence < 0.68,
      t = tP.turbo.active.value,
      n = tP.turbo.hover,
      i = e || t ? 1 : this.hoverInfluence;
    if (!e && !n && !t) return;
    if (!(eP.quality.current.value >= 4 || eP.time.frameNum % 3)) return;
    const r = eP.car.base;
    let s = (Math.random() > 0.5 ? eP.car.ltl : eP.car.rtl).getWorldPosition(
      aP
    );
    if (e) {
      const e =
        0.015 +
        0.3 *
          wy(
            Sy(eP.game.progress - eP.game.checkpoints.list.finish, 10, 22),
            0,
            1
          );
      return void tP.particles.emit("line", {
        position: aP,
        sprite: "particleA",
        scale: oP.setScalar(e),
        billboard: !0,
        opacity: 0.7,
        velDrag: 0.99,
        velocity: rP.set(0, 0.002, 0),
      });
    }
    s = r.worldToLocal(rP.copy(aP));
    const a = 0.015;
    (s.x -= 0.01),
      (s.y += pA.randomFloat(-0.015, a)),
      (s.z += pA.randomFloat(-0.015, a));
    const o = sP.set(t ? 3 : 1, 0, eP.car.zVelocity * tP.velocity * 0.02),
      l = t
        ? oP.set(pA.randomFloat(0.03, 0.05), 0.06)
        : oP.set(pA.randomFloat(0.03, 0.05), 0.05);
    i > 1e-4 &&
      tP.particles.emit("line", {
        position: s,
        parent: r,
        sprite: "particleA",
        scale: l,
        billboard: !0,
        opacity: i,
        velDrag: 0.99,
        velocity: o,
      });
  }
  tireSmoke() {
    if (eP.quality.current.value < 4) return;
    const e = eP.car.base,
      t = Math.random() > 0.5,
      n = t ? eP.car.ltl : eP.car.rtl,
      i =
        Sy(Math.abs(eP.controls.turn), 0.3, 1) *
        wy(Sy(Math.abs(eP.car.base.rotation.y), 0.03, 0.08), 0, 1) *
        0.5,
      r =
        wy(Sy(tP.velocity, 5, 15), 0, 1) *
        wy(tP.turbo.progress, 0.4, 1) *
        this.hoverInfluence;
    let s = Math.max(i, r);
    (tP.turbo.active.value ||
      (t && eP.car.dipLeft) ||
      (!t && eP.car.dipRight)) &&
      (s = 1),
      n.getWorldPosition(rP);
    const a = e.worldToLocal(rP),
      o = pA.randomFloat(1, 6.5);
    (a.x -= 0.05 * o),
      (a.y += pA.randomFloat(-0.02, 0.02)),
      (a.z += pA.randomFloat(-0.04, 0.04)),
      (a.y -= 0.03),
      (a.z += t ? -0.02 : 0.02);
    const l = sP.set(1.5, 0, 4 * eP.car.zVelocity);
    l.multiplyScalar(0.005 * tP.velocity);
    const c = tP.turbo.active.value ? 0.1 : 0.8;
    tP.particles.emit("smoke", {
      position: a,
      parent: e,
      sprite: "smoke",
      scale: oP.setScalar(pA.randomFloat(0.2, 1)),
      billboard: !0,
      angle: pA.randomFloat(0, Math.PI),
      opacity: 0.18 * s,
      velDrag: 0.95,
      velocity: l.set(3, -c, 0).multiplyScalar(0.02),
    });
  }
  update() {
    super.update();
    const e = eP.time.stableDt;
    (this.hoverInfluence = Py(
      this.hoverInfluence,
      tP.turbo.hover ? 1 : 0,
      0.2,
      e,
      0.001
    )),
      (this.turboInfluence = Ay(
        this.turboInfluence,
        tP.turbo.active.value ? 1 : 0,
        0.15,
        e
      )),
      tP.turbo.active.value && (this.hoverInfluence = 1);
    const t = eP.scene.currentCamera;
    t && t.isGameCamera && (this.lineEmit(), this.tireSmoke());
  }
}
let cP, uP;
const hP = new Xb(3355443),
  dP = new Xb(0);
gA();
const pP = new Cx(0.4, 0, 1.01),
  fP = new Cx(-0.47, 0, 1.01),
  mP = new Cx();
class gP extends zA {
  init() {
    (cP = kl()),
      (uP = cP.game),
      (this.flare = this.addComponent(nP, {
        sprite: "particleA",
        parent: cP.pointer.base,
        position: fP,
        alpha: 0.6,
        color: hP,
        scale: 2.5,
        batcher: uP.particles.batcher,
        billboard: !0,
      })),
      this.reset(),
      uP.hooks.reset.watch(this.reset, this);
  }
  reset() {
    (this.now = this.lastEmit = this.lastFlash = cP.game.elapsed),
      (this.bigFlashed = !1),
      (this.flareOpacity = this.flareOpacityTarget = 0);
  }
  emit() {
    const e = cP.car,
      t = Cy(0.06, 0.1, wy(e.dipStrength + e.userDip, 0, 1)),
      n = mP.lerpVectors(fP, pP, e.dipStrength);
    e.dipLeft && (n.z = -n.z),
      (this.lastEmit = this.now),
      uP.particles.emit("hitSparkles", {
        amount: 2,
        position: n,
        parent: cP.pointer.base,
        sprite: "particleA",
        scale: t,
        velDrag: 0.99,
      });
  }
  bigFlash() {
    const e = cP.car,
      t = mP.lerpVectors(fP, pP, e.dipStrength);
    e.dipLeft && (t.z = -t.z);
    const n = e.userDip ? 2 : 1,
      i = wy(Sy(e.dipStrength * n * uP.velocity, 2, 14), 0, 1),
      r = Cy(5, 9, i),
      s = Cy(500, 800, i);
    (this.bigFlashed = !0),
      uP.particles.emit("flash", {
        amount: 1,
        position: t,
        scale: r,
        duration: s,
        parent: cP.pointer.base,
        power: i,
        sprite: "particleA",
      });
  }
  update() {
    const e = cP.time.stableDt,
      t = cP.car,
      n = t.userDip ? 20 : 85;
    (this.now = cP.game.elapsed),
      t.dip && t.dipStrength > 0.1 && !this.bigFlashed && this.bigFlash(),
      t.dip && this.now - this.lastEmit > n && this.emit(),
      t.dip || (this.bigFlashed = !1),
      (this.flareOpacityTarget = 0),
      t.dip &&
        ((this.flareOpacityTarget =
          1 - 0.12 * Math.cos(0.07 * cP.game.elapsed)),
        t.userDip || (this.flareOpacityTarget *= 0.4),
        (this.flare.position.z = (t.dipRight ? 1 : -1) * fP.z)),
      (this.flareOpacity = Ay(
        this.flareOpacity,
        this.flareOpacityTarget,
        t.dip ? 0.3 : 0.1,
        e
      )),
      (this.flare.alpha = Cy(1, 0.5, this.flareOpacity)),
      this.flare.color.lerpColors(dP, hP, this.flareOpacity),
      (this.flare.visible = this.flareOpacity > 0.001);
  }
}
let vP, _P;
gA();
const yP = 2 * Math.PI,
  xP = new Cx();
new Cx(), new Tx();
const bP = new Xb(16777215),
  wP = new Xb(11158596);
sl(0.295, 0.03, 0.99, 0.555);
const SP = sl(0, 0.59, 0.29, 1);
sl(0.16, 0.035, 0.29, 0.96);
class MP extends zA {
  init() {
    (vP = kl()),
      (_P = vP.game),
      (vP.car = _P.car = this),
      (this.base = vP.meshes.car);
    const e = (this.body = this.base.body),
      t = (this.wheels = this.base.wheels);
    e.frustumCulled = t.frustumCulled = !1;
    (e.position.x = t.position.x = -0.18),
      (e.origPosition = e.position.clone()),
      (t.material = e.material = YA.get()),
      (t.renderOrder = e.renderOrder = vP.store.renderOrder.car),
      (t.castShadow = e.castShadow = !0),
      (t.receiveShadow = e.receiveShadow = !1),
      (e.rotation.x = 0),
      (this.dumWheels = this.base.dummyWheels),
      this.initWheels(),
      this.addComponent(lP, { car: this }),
      (this.hitFx = this.addComponent(gP, { car: this })),
      (this.ltl = new Ab()),
      (this.ltl.rotation.y = -0.5 * Math.PI),
      this.ltl.position.set(-0.65, 0.145, -0.135),
      this.ltl.scale.setScalar(0.2),
      (this.rtl = new Ab()),
      (this.rtl.rotation.y = -0.5 * Math.PI),
      this.rtl.position.set(-0.65, 0.145, 0.135),
      this.rtl.scale.setScalar(0.2),
      this.body.add(this.ltl),
      this.body.add(this.rtl),
      (this.dipStrength = 0),
      (this.bbw = 0.3 * e.scale.z),
      (this.hitline = new VE()),
      (this.turboline = new VE()),
      (this.baseQuaternion = this.base.quaternion.clone()),
      (this.prevWorldPos = new Cx()),
      (this.velocity = new Cx()),
      this.reset(),
      _P.hooks.reset.watch(this.reset, this),
      _P.turbo.active.watch(this.onTurbo, this),
      vP.store.shadowActive.watchImmediate((n) => {
        t.castShadow = e.castShadow = n;
      }),
      _P.paused.watch(() => this.resetFrictionSample());
  }
  resetFrictionSample() {
    this.frictionSample && this.frictionSample.stop(),
      (this.frictionSample = null),
      (this.lastFrictionDate = 0);
  }
  reset() {
    (_P.velocity = 0),
      this.prevWorldPos.setScalar(0),
      this.velocity.setScalar(0),
      (this.prevZ = 0),
      (this.zVelocity = 0),
      this.resetFrictionSample(),
      (this.frictionVolume = 1),
      (this.bloom = 0.5),
      (this.bloomTarget = 0.5),
      (this.dipShake = this.targetDipShake = 0),
      (this.dipStrength = 0),
      (this.userDip = !1),
      (this.dip = !1),
      (this.camHitShake = !1),
      (this.turboInfluence = 0),
      (this.autoInfluence = 0),
      (this.accumRotation = 0),
      (this.wheelSteering = 0),
      (this.bodySteer = 0),
      (this.wheelSpin = 0),
      (this.wheelSteer = 0),
      (this.wheelSpinSpeed = 0),
      (this.controlsSteer = 0),
      this.base.position.set(0, 0, 0),
      (this.noDipTime = 0),
      this.last,
      (this.acceleration = 0.03),
      (this.maxVel = _P.minVelocity),
      (this.lastTurbo = -1e5),
      this.update();
  }
  onTurbo(e) {
    e || (this.lastTurbo = vP.game.elapsed);
  }
  updateVelocity() {
    const e = vP.time.stableDt,
      t = vP.scene.currentCamera;
    if (t.forceCarVelocity) return void (_P.velocity = t.forceCarVelocity);
    if (_P.state.current < _P.state.ACTIVE) return void (_P.velocity = 0);
    const n = _P.turbo.active.value,
      i = !n && !_P.turbo.cooldownActive,
      r = _P.turbo.hover;
    if (
      ((this.acceleration = Ay(this.acceleration, n ? 0.08 : 0.03, 0.1, e)), !n)
    ) {
      const t = Cy(_P.minVelocity, _P.maxVelocity, _P.turbo.velProgress);
      ((!r && i) || _P.turbo.ended || t > this.maxVel) &&
        (this.maxVel = Ay(this.maxVel, t, 0.1, e));
    }
    let s = this.maxVel;
    if ((n && (s = _P.turboVelocity), this.dip && !n && i)) {
      const e = wy(My(this.dipStrength, 0.01, 0.02, 0, 1), 0, 1);
      if (e) {
        const t = 0.75,
          n = wy(My(_P.velocity, 2, _P.maxVelocity, 1, t), t, 1);
        s = this.maxVel = Cy(this.maxVel, this.maxVel * n, e);
      } else s *= this.userDip ? 0.92 : 0.97;
    }
    const a = vP.time.stableDt / 16.6667;
    _P.velocity < s
      ? (_P.velocity += this.acceleration * a)
      : (_P.velocity = Ay(_P.velocity, s, 0.1, e));
  }
  update() {
    if (_P.isPaused()) return;
    const e = _P.getRoadData(),
      t = _P.velocity;
    this.autoInfluence = Cy(
      this.autoInfluence,
      _P.autopilot.value ? 1 : 0,
      _P.autopilot.value ? 0.07 : 0.14
    );
    const n = 1 - this.autoInfluence;
    this.base.quaternion.copy(this.baseQuaternion);
    const i = _P.velocity / 10,
      r = wy(t / 10, 0, 1),
      s = 1 - SP(wy(t / 4, 0, 1)),
      a = SP(wy(t / 3, 0, 1)),
      o = wy(t / 3, 0, 1),
      l = vP.controls.keyboard
        ? vP.controls.steeringMultKeyboard
        : vP.controls.steeringMultTouch,
      c = a * (My(t / 10, 0, 1, 0, 0.015) + 0.004 * s) * l,
      u =
        0.15 *
        a *
        (vP.controls.keyboard
          ? vP.controls.rotationMultKeyboard
          : vP.controls.rotationMultTouch),
      h = _P.getRelativeRoadData(0.9);
    _P.pointer.base.worldToLocal(xP.copy(h.position));
    const d = vP.time.stableDt,
      p = d / 16.6667,
      f = Math.atan2(xP.z, xP.x) * p;
    (this.accumRotation += 0.16 * f * i * n),
      (this.base.rotation.y += this.accumRotation);
    let m = wy(-1 + this.base.rotation.y, -1, 0),
      g = wy(1 + this.base.rotation.y, 0, 1);
    this.dipRight && (g = 0), this.dipLeft && (m = 0);
    let v = vP.controls.turn * n;
    (v = wy(v * c, m, g)),
      (this.accumRotation -= v),
      (this.base.rotation.y -= v),
      (this.base.position.z += this.base.rotation.y * -u * i * p),
      (this.base.rotation.y += 0.5 * v),
      (this.wheelSteering = v);
    const _ = 0.5 * e.scale.y - this.bbw;
    this.dipStrength = wy(Sy(Math.abs(this.accumRotation), 0, 0.7), 0, 1);
    const y = vP.controls.turnTarget;
    if (
      ((this.dipLeft = this.base.position.z < -_ - 0),
      (this.dipRight = this.base.position.z > _ + 0),
      (this.dip = this.dipLeft || this.dipRight),
      (this.userDip = (this.dipLeft && y) < 0 || (this.dipRight && y > 0)),
      this.dip && this.dipStrength > 0.04 && !this.didImpact
        ? ((this.didImpact = !0),
          vP.audio.playSound("Car_Impact", {
            volume: Cy(0.4, 1.15, this.dipStrength),
          }))
        : this.dip || (this.didImpact = !1),
      this.dip ? (this.noDipTime = 0) : (this.noDipTime += d),
      this.dip &&
        !this.camHitShake &&
        this.dipStrength > 0.007 &&
        !_P.turbo.active.value)
    ) {
      this.camHitShake = !0;
      const e = Math.min(
        0.22 * this.dipStrength * i * 1 * (this.userDip ? 1.2 : 0.9),
        this.userDip ? 1.25 : 0.75
      );
      vP.gameCam.shake(400 + 200 * e, e, !1, !0);
    } else this.dip || (this.camHitShake = !1);
    if (
      (this.dip &&
      !this.frictionSample &&
      vP.game.elapsed - this.lastFrictionDate > 500
        ? (this.frictionSample = vP.audio.playSound("Car_Friction_Loop"))
        : this.noDipTime > 200 &&
          this.frictionSample &&
          (this.resetFrictionSample(),
          (this.lastFrictionDate = vP.game.elapsed)),
      this.frictionSample &&
        (this.frictionSample.volume = Cy(
          this.frictionSample.volume,
          this.userDip ? 1.5 : 0.9,
          0.1
        )),
      Math.abs(this.base.position.z) > _ &&
        (this.accumRotation += -0.18 * this.base.rotation.y * i),
      this.dip)
    ) {
      const e = this.base.position.z;
      this.base.position.z = wy(e, -_, _);
    }
    this.autoInfluence > 0.01 &&
      ((this.accumRotation -=
        0.02 * this.accumRotation * i * this.autoInfluence),
      (this.base.position.z -=
        0.01 * this.base.position.z * this.autoInfluence)),
      vP.store.carShadow.set(0.5 * this.base.position.z, this.base.rotation.y),
      this.base.updateMatrixWorld(),
      this.updateHitLine(),
      (this.wheelSteer = Cy(
        this.wheelSteer,
        0.26 * vP.controls.turn,
        vP.controls.active ? Cy(0.05, 0.5, r) : 0.9
      )),
      (this.bodySteer = Cy(
        this.bodySteer,
        vP.controls.turn * Cy(0.05, 0.06, r) * o,
        Cy(0.05, 0.15, r)
      )),
      (this.body.rotation.x = wy(this.bodySteer, -0.07, 0.07)),
      (this.body.rotation.z = wy(this.body.rotation.z, -0.025, 0.04)),
      (this.wheelSpinSpeed = 0.015 * t),
      (this.wheelSteer = wy(this.wheelSteer, -0.5, 0.5)),
      (this.wheelSpinSpeed = wy(this.wheelSpinSpeed, -0.1, 0.1)),
      (this.wheelSpin = (this.wheelSpin + this.wheelSpinSpeed) % yP),
      this.updateWheels(),
      this.body.position.copy(this.body.origPosition);
    const x = vP.game.elapsed,
      b = wy(Sy(_P.velocity, 6, 15), 0, 1),
      w = 0.01 * Sy(_P.velocity, 7, 15),
      S = 0.0035 * (0.5 * Math.cos(x * (0.07 + w)) + 0.5) * b;
    if ((this.body.translateY(S), this.dip || this.dipShake > 0.001)) {
      const e = this.dip ? (this.userDip ? 0.0038 : 0.0015) : 0;
      (this.targetDipShake = e),
        (this.dipShake = Cy(
          this.dipShake,
          this.targetDipShake,
          this.dip ? 0.1 : 0.25
        ));
      const t = Math.cos(0.09 * x) * this.dipShake + this.dipShake;
      this.body.translateY(t);
    }
    (this.zVelocity = this.base.position.z - this.prevZ),
      (this.prevZ = this.base.position.z),
      this.updateMaterial(),
      super.update();
  }
  updateHitLine() {
    this.base.localToWorld(xP.set(0.4, 0, -this.bbw - 0.04)),
      this.hitline.start.copy(xP),
      this.base.localToWorld(xP.set(0.4, 0, this.bbw - -0.04)),
      this.hitline.end.copy(xP),
      vP.turboline.testCollision(this.hitline);
  }
  initWheels() {
    for (let e = 0, t = this.dumWheels.length; e < t; e++) {
      const t = this.dumWheels[e];
      (t.steerMult = 2 === e ? 1 : 3 === e ? -1 : 0), t.rotation.reorder("XZY");
    }
  }
  updateWheels() {
    for (let e = 0, t = this.dumWheels.length; e < t; e++) {
      const t = this.dumWheels[e],
        n = t.rotation,
        i = this.wheelSteer * t.steerMult;
      (n.y += this.wheelSpin),
        (n.z += i),
        t.updateWorldMatrix(!0, !1),
        this.wheels.setMatrixAt(e, t.matrixWorld),
        (n.y -= this.wheelSpin),
        (n.z -= i);
    }
    this.wheels.instanceMatrix.needsUpdate = !0;
  }
  updateMaterial() {
    const e = vP.time.stableDt,
      t = this.body.material.uniforms,
      n = _P.turbo.progress;
    (t.turboProgress.value = My(n, 0, 1, 0.983, 0.9489)),
      t.turboColor.value.lerpColors(wP, bP, n);
    const i = _P.state.hasEnded() && vP.gameCam.activeInfluence < 0.7;
    (vP.scene.currentCamera && !vP.scene.currentCamera.isGameCamera) ||
    i ||
    _P.turbo.hover ||
    _P.turbo.active.value
      ? (this.bloomTarget = 1)
      : (this.bloomTarget = 0.4),
      (this.bloom = Ay(this.bloom, this.bloomTarget, 0.08, e)),
      (t.bloomStrength.value = this.bloom);
  }
}
var TP = nA(
  "#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvarying vec2 vUv;void main(){vUv=uv;\n#include <beginnormal_vertex>\n#include <defaultnormal_vertex>\n#include <begin_vertex>\n#include <project_vertex>\n#include <worldpos_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n}",
  "#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvarying vec2 vUv;uniform float scale;uniform float dirOpacity;uniform vec2 car;vec2 rotate(vec2 v,float a){float s=sin(a);float c=cos(a);mat2 m=mat2(c,-s,s,c);return m*v;}float fakeShadow(vec2 center,vec2 size,float radius){return length(max(abs(center)-size+radius,0.0))-radius;}void main(){vec2 uv=vUv;vec3 color=vec3(0.459,0.2,0.157);float shadow=1.*(1.0-getShadowMask());shadow*=0.2*min(smoothstep(0.5,0.3,abs(uv.x-0.5)),smoothstep(0.5,0.45,abs(uv.y-0.5)))*dirOpacity;vec2 pivot=vec2(0.5,0.5-car.x);vec2 box=rotate(vUv-pivot,car.y)+0.5;box-=vec2(0.431,0.5);float ao=fakeShadow(box,vec2(-0.126,-0.24),-0.28);ao=smoothstep(0.42,0.22,ao)*0.8+smoothstep(0.35,0.3,ao)*0.6;shadow+=ao;color=vec3(1.-shadow);gl_FragColor=vec4(color,1.);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n}"
);
let CP,
  EP,
  AP = null;
class PP extends kw {
  constructor(e = {}) {
    super(e),
      (this.uniforms = o(
        o(
          {
            scale: { value: 0 },
            car: { value: Nl.store.carShadow },
            dirOpacity: { value: 1 },
          },
          e.uniforms || {}
        ),
        Dw.clone(Jw.shadow.uniforms)
      )),
      TP.use(this),
      (this.blending = 4),
      (this.opacity = 0.2),
      (this.color = new Xb(0)),
      (this.forceOpaque = !0),
      (this.depthTest = !1),
      (this.depthWrite = !1),
      (this.lights = !0),
      (this.isShaderMaterial = !0);
  }
}
PP.get = (e) => (AP = AP || new PP(e));
class LP extends zA {
  init() {
    (CP = kl()),
      (EP = CP.game),
      (this.base = new Aw(CP.geometries.plane, PP.get())),
      (this.base.renderOrder = CP.store.renderOrder.carShadow),
      (this.base.receiveShadow = !0),
      (this.base.position.y += 0.001),
      this.base.rotateX(-0.5 * Math.PI);
    const e = 3 * this.props.car.body.scale.x;
    this.base.scale.x = e;
  }
  update() {
    const e = EP.getRoadData().scale.y;
    (this.base.scale.y = e), (this.base.material.uniforms.scale.value = e / 2);
  }
}
function IP(e) {
  (e.blending = 5),
    (e.blendEquation = 100),
    (e.blendSrc = 201),
    (e.blendDst = 201),
    (e.blendEquationAlpha = 103);
}
var RP = nA(
  "attribute float progress;attribute float side;varying float vProgress;varying float vX;void main(){vProgress=progress;vX=side;vec3 transformed=vec3(position);gl_Position=projectionMatrix*modelViewMatrix*vec4(transformed,1.0);}",
  "varying float vProgress;varying float vX;uniform float time;uniform float globalProgress;uniform float width;uniform float opacity;uniform vec2 hitA;uniform vec2 hitB;uniform vec2 clamping;\n#include <conditionals>\nfloat between(float x,vec2 hit){return min(1.,smoothstep(hit.x+0.25,hit.x-0.25,x)+smoothstep(hit.y-0.25,hit.y+0.25,x));}void main(){float x=vX;vec2 uv=vec2(vX,mod(vProgress/width*0.15,1.));vec3 c=vec3(uv,0.);float w=0.1;float alpha=1.;alpha*=(1.-abs(uv.x-0.5)*2.);alpha*=between(vProgress,hitA)*between(vProgress,hitB);alpha*=smoothstep(clamping.x,clamping.x+3.,vProgress);alpha*=smoothstep(clamping.y,clamping.y-5.,vProgress);float fog=(globalProgress-vProgress)*0.05+2.8;alpha*=fog;alpha*=opacity;float intensity=max(0.,alpha-gl_FragCoord.w*1.);gl_FragColor=vec4(vec3(1.,1.,1.)*alpha,1.-intensity);}"
);
let DP = null;
class kP extends kw {
  constructor(e = {}) {
    super(e),
      (this.uniforms = o(
        {
          width: { value: 0.2 },
          globalProgress: { value: 0 },
          opacity: { value: 1 },
          time: { value: 0 },
          hitA: { value: [0, 1] },
          hitB: { value: [0, 1] },
          clamping: { value: [0, 1] },
        },
        e.uniforms || {}
      )),
      (this.side = 2),
      IP(this),
      (this.color = new Xb()),
      (this.transparent = 1),
      (this.forceOpaque = !0),
      RP.use(this),
      (this.isShaderMaterial = !0);
  }
  set width(e) {
    this.uniforms.width.value = e;
  }
  get width() {
    return this.uniforms.width.value;
  }
}
kP.get = (e) => (DP = DP || new kP(e));
const NP = gA(() => 35410);
let OP, FP;
const zP = new Cx(),
  UP = new Cx();
new Tx();
class BP extends zA {
  init() {
    (OP = kl()),
      (FP = OP.game),
      (OP.turboline = FP.turboline = this),
      (this.line = new VE()),
      (this.lastProgress = -100),
      (this.y = 0.04),
      (this.segments = 120),
      (this.step = 0.5),
      (this.offset = -3),
      (this.width = 0.033);
    const e = 2 * this.segments,
      t = (this.vertices = e + 2);
    (this.geo = new uw()),
      (this.buffer = new Float32Array(4 * t)),
      (this.ibuffer = new OT(this.buffer, 4)),
      this.ibuffer.setUsage(35048),
      this.geo.setAttribute("position", new zT(this.ibuffer, 3, 0, !1)),
      this.geo.setAttribute("progress", new zT(this.ibuffer, 1, 3, !1)),
      this.geo.setAttribute("side", new Qb(t, 1)),
      this.geo.setIndex(new Array(3 * e)),
      (this.pts = this.geo.attributes.position.array),
      (this.indexes = this.geo.index.array),
      (this.sides = this.geo.attributes.side.array),
      this.initGeo(),
      this.updateGeo(),
      (this.geo.needsUpdate = !0),
      (this.base = new Aw(this.geo, kP.get())),
      (this.base.frustumCulled = !1),
      (this.base.renderOrder = OP.store.renderOrder.turboLine),
      (this.base.material.width = this.width),
      (this.collideUniforms = [
        this.base.material.uniforms.hitA.value,
        this.base.material.uniforms.hitB.value,
      ]),
      (this.currentCollideUniform = 0),
      (this.colliding = !1),
      FP.hooks.reset.watch(this.reset, this),
      this.reset(),
      FP.turbo.active.watch(this.onTurboActive, this);
    let n = !1;
    OP.hooks.beforePrerender.watchOnce(() => {
      (n = this.base.visible), (this.base.visible = !0);
    }),
      OP.hooks.afterPrerender.watchOnce(() => {
        this.base.visible = n;
      });
  }
  stopHitSample() {
    this.hitSample && this.hitSample.stop(), (this.hitSample = null);
  }
  reset() {
    this.stopHitSample(),
      (this.hitSampleVolume = 0),
      (this.turboCount = 0),
      (FP.turbo.ended = !1);
    for (const t of this.collideUniforms) (t[0] = 0), (t[1] = 0);
    const e = FP.checkpoints.list;
    (this.base.material.uniforms.clamping.value[0] = e.start + 20),
      (this.base.material.uniforms.clamping.value[1] = e.finish - 20),
      (this.currentCollideUniform = 0),
      (this.colliding = !1),
      this.update(!0),
      (this.resetting = !0);
  }
  initGeo() {
    const e = this.indexes;
    for (let n = 0, i = 0; n < e.length; n += 3, i++) {
      const t = i % 2;
      (e[n] = t ? i + 2 : i), (e[n + 1] = i + 1), (e[n + 2] = t ? i : i + 2);
    }
    const t = this.sides;
    for (let n = 0; n < this.vertices; n += 2) (t[n] = 0), (t[n + 1] = 1);
  }
  getZAt(e) {
    const t = 0.4 * wy(Sy(this.turboCount, 2, 6), 0, 1);
    return 0.05 * Math.cos(0.1 * e) + NP(e * (0.02 + 0.01 * t), 1) * t;
  }
  updateGeo(e) {
    const t = FP.progress - (FP.progress % (this.offset * this.step));
    if (!e && t === this.lastProgress) return;
    this.lastProgress = t;
    const n = this.offset,
      i = this.step,
      r = this.pts;
    for (let s = 0, a = 0; s < this.pts.length; s += 8, a += 1) {
      const e = t + (a + n) * i,
        o = FP.normalizeProgress(e),
        l = FP.getAbsoluteRoadData(o),
        c = this.width,
        u = this.y,
        h = this.getZAt(e),
        d = zP
          .set(0, u, -c + h)
          .applyQuaternion(l.quaternion)
          .add(l.position),
        p = UP.set(0, u, c + h)
          .applyQuaternion(l.quaternion)
          .add(l.position);
      (r[s] = d.x),
        (r[s + 1] = d.y),
        (r[s + 2] = d.z),
        (r[s + 3] = e),
        (r[s + 4] = p.x),
        (r[s + 5] = p.y),
        (r[s + 6] = p.z),
        (r[s + 7] = e);
    }
    this.geo.attributes.position.needsUpdate = !0;
  }
  update(e) {
    this.resetting
      ? ((this.turboCount = 0), (this.resetting = !1), this.updateGeo(!0))
      : this.updateGeo();
    const t = OP.scene.currentCamera && OP.scene.currentCamera.turbolineActive;
    (this.base.visible = !!t),
      FP.turbo.hover !== this.hit &&
        ((this.hit = FP.turbo.hover),
        this.hit ? this.startCollision() : this.endCollision());
    const n = this.base.material.uniforms;
    if (
      ((n.globalProgress.value = OP.game.progress),
      (n.time.value = OP.game.elapsed),
      this.hit)
    ) {
      const e = this.collideUniforms[this.currentCollideUniform],
        t = OP.game.progress + 0.5,
        n = t - e[1];
      OP.game.turbo.addHitDistance(n), (e[1] = t);
    }
    if (
      (!this.hit &&
        this.hitSample &&
        this.hitSample.volume < 1e-4 &&
        this.stopHitSample(),
      this.hit &&
        !this.hitSample &&
        (this.hitSample = OP.audio.playSound("Boost_Line_Loop", {
          volume: 0.05,
        })),
      this.hitSample)
    ) {
      const e = this.hit && !OP.game.paused.value;
      (this.hitSampleVolume = e ? 1.2 : 0),
        (this.hitSample.volume = Cy(
          this.hitSample.volume,
          this.hitSampleVolume,
          e ? 0.12 : 0.07
        ));
    }
    const i = FP.turbo.active.value || FP.turbo.ended;
    n.opacity.value = Cy(n.opacity.value, i ? 0 : 1, e ? 1 : 0.1);
  }
  startCollision() {
    const e = this.collideUniforms[this.currentCollideUniform],
      t = OP.game.progress + 0.5;
    (e[0] = t), (e[1] = t);
  }
  endCollision() {
    this.currentCollideUniform =
      (this.currentCollideUniform + 1) % this.collideUniforms.length;
  }
  onTurboActive(e) {
    if (e) return;
    this.turboCount++;
    const t = FP.progress,
      n = this.base.material.uniforms.clamping.value;
    (n[0] = t + FP.turbo.cooldown),
      Math.abs(n[0] - n[1]) < FP.turbo.distanceToFill && (FP.turbo.ended = !0),
      this.updateGeo(!0);
  }
  testCollision(e) {
    const t = FP.progress,
      n = t - 0.1,
      i = t + 0.8,
      r = this.getZAt(n),
      s = this.getZAt(i),
      a = this.base.material.uniforms.clamping.value;
    if (
      !this.base.visible ||
      FP.turbo.active.value ||
      t < a[0] - 1 ||
      t > a[1] + 1 ||
      FP.turbo.ended
    )
      return (FP.turbo.hover = !1);
    const o = FP.getAbsoluteRoadData(FP.normalizeProgress(n));
    this.line.start.set(0, 0, r).applyQuaternion(o.quaternion).add(o.position);
    const l = FP.getAbsoluteRoadData(FP.normalizeProgress(i));
    this.line.end.set(0, 0, s).applyQuaternion(l.quaternion).add(l.position);
    const c = e,
      u = this.line;
    return (FP.turbo.hover = (function (e, t, n, i, r, s, a, o) {
      let l, c;
      const u = (n - e) * (o - s) - (a - r) * (i - t);
      return (
        0 !== u &&
        ((c = ((o - s) * (a - e) + (r - a) * (o - t)) / u),
        (l = ((t - i) * (a - e) + (n - e) * (o - t)) / u),
        0 < c && c < 1 && 0 < l && l < 1)
      );
    })(
      c.start.x,
      c.start.z,
      c.end.x,
      c.end.z,
      u.start.x,
      u.start.z,
      u.end.x,
      u.end.z
    ));
  }
}
var VP = nA(
  "attribute float dist;attribute float side;varying float vSide;varying float vDist;void main(){vSide=side;vDist=dist;vec3 transformed=vec3(position);gl_Position=projectionMatrix*modelViewMatrix*vec4(transformed,1.0);}",
  "varying float vDist;varying float vSide;uniform float progress;uniform float time;uniform float maxDist;uniform sampler2D noise;uniform float trailLength;void main(){vec3 noiseTexel=texture2D(noise,vec2(vSide*0.2,vDist*0.1+progress*-0.04)).rgb;float len=trailLength;float len2=min(len*1.5,len+0.25);float m=smoothstep(0.4,0.1,noiseTexel.b)*0.5*smoothstep(len2,len2-0.4,vDist);float fallin=smoothstep(0.05,0.1,vDist);float falloff=smoothstep(trailLength+m,trailLength-0.4,vDist);float falloff2=smoothstep(maxDist+0.6,0.,vDist);float size=1.*falloff2;size+=-0.3+cos(time*-0.03+vDist*20.*vDist)*0.07;float offset=(1.-size)*0.5;float side=clamp((vSide-offset)/size,0.,1.);float p=progress*10.;float lim=abs(side-0.5)*2.;float border=pow(lim,3.)*0.5;float lim2=(1.-step(1.,side))*(1.-step(side,0.));float matter=smoothstep(0.4,0.0,noiseTexel.r)*0.5;float matter2=smoothstep(0.9,0.5,noiseTexel.g)*smoothstep(0.4,0.0,vDist);float intensity=max(0.,border+matter*1.+matter2*0.8)*lim2*falloff*fallin;vec3 diffuse=vec3(1.,0.2,0.2)*intensity*5.;float glow=1.-intensity*0.2;gl_FragColor=vec4(diffuse,glow);}"
);
let HP,
  GP,
  WP = null;
class qP extends kw {
  constructor(e = {}) {
    super(e),
      (this.uniforms = {
        time: { value: 0 },
        progress: { value: 0 },
        maxDist: { value: 0 },
        trailLength: { value: 0 },
        noise: { value: Nl.textures.blueNoise },
      }),
      IP(this),
      (this.color = new Xb()),
      (this.transparent = 1),
      (this.forceOpaque = !0),
      VP.use(this),
      (this.isShaderMaterial = !0);
  }
}
qP.get = (e) => (WP = WP || new qP(e));
const jP = new Cx(),
  YP = new Cx(),
  XP = (e) =>
    Array.from(new Array(e)).map(() => ({ qt: new Tx(), pos: new Cx() }));
class $P extends zA {
  init() {
    (HP = kl()),
      (GP = HP.game),
      (this.turboInfluence = this.hoverInfluence = 0),
      (this.car = this.props.car),
      (this.geo = new uw()),
      (this.iterations = 0),
      (this.segments = 8);
    const e = 2 * this.segments * 2,
      t = (this.vertices = e + 4);
    (this.ptsIndex = 0),
      (this.leftPts = XP(t / 4)),
      (this.rightPts = XP(this.leftPts.length));
    const n = (this.bufferDims = 4);
    (this.buffer = new Float32Array(t * n)),
      (this.ibuffer = new OT(this.buffer, n)),
      this.geo.setAttribute("position", new zT(this.ibuffer, 3, 0, !1)),
      this.geo.setAttribute("dist", new zT(this.ibuffer, 1, 3, !1)),
      this.ibuffer.setUsage(35048),
      this.geo.setAttribute("side", new Qb(t, 1)),
      this.geo.setIndex(new Array(3 * e)),
      (this.indexes = this.geo.index.array),
      (this.sides = this.geo.attributes.side.array),
      this.initGeo(false),
      this.initGeo(true),
      (this.mat = qP.get()),
      (this.base = new Aw(this.geo, this.mat)),
      (this.base.renderOrder = HP.store.renderOrder.carTrails),
      (this.base.frustumCulled = !1),
      (this.maxDist = 0),
      HP.game.hooks.reset.watch(this.reset, this),
      this.reset();
    let i = !1;
    HP.hooks.beforePrerender.watchOnce(() => {
      (i = this.base.visible), (this.base.visible = !0);
    }),
      HP.hooks.afterPrerender.watchOnce(() => {
        this.base.visible = i;
      });
  }
  reset(e) {
    this.car.ltl.updateWorldMatrix(!0, !0),
      this.car.rtl.updateWorldMatrix(!0, !0);
    for (let t = 0; t < this.leftPts.length; t++)
      this.appendPts(), this.updateGeo(false), this.updateGeo(true);
    this.reseting = !e;
  }
  initGeo(e) {
    const t = this.indexes,
      n = t.length / 2,
      i = e ? n : 0,
      r = e ? this.vertices / 2 : 0;
    for (let a = i, o = r; a < n + i; a += 3, o++) {
      const e = o % 2;
      (t[a] = e ? o + 2 : o), (t[a + 1] = o + 1), (t[a + 2] = e ? o : o + 2);
    }
    const s = this.sides;
    for (let a = r; a < this.vertices / 2 + r; a += 2)
      (s[a] = 0), (s[a + 1] = 1);
  }
  updateLastPts() {
    const e = 0 === this.ptsIndex ? this.leftPts.length - 1 : this.ptsIndex - 1,
      t = this.leftPts[e],
      n = this.rightPts[e];
    this.car.ltl.getWorldPosition(t.pos),
      this.car.ltl.getWorldQuaternion(t.qt),
      this.car.rtl.getWorldPosition(n.pos),
      this.car.rtl.getWorldQuaternion(n.qt);
  }
  appendPts() {
    let e = 0.014 + 0.021 * GP.turbo.progress;
    e = Cy(e, 0.12, this.turboInfluence);
    GP.state.hasEnded() &&
      HP.gameCam.activeInfluence < 0.75 &&
      (e = Math.max(e, 0.028));
    const t = this.leftPts[this.ptsIndex],
      n = this.rightPts[this.ptsIndex];
    this.car.ltl.getWorldPosition(t.pos),
      this.car.ltl.getWorldQuaternion(t.qt),
      this.car.rtl.getWorldPosition(n.pos),
      this.car.rtl.getWorldQuaternion(n.qt),
      (t.width = n.width = e),
      (this.ptsIndex = (this.ptsIndex + 1) % this.leftPts.length);
  }
  updateGeo(e) {
    const t = e ? this.rightPts : this.leftPts,
      n = e ? this.buffer.length / 2 : 0,
      i = this.buffer,
      r = t.length,
      s = r - 1,
      a = !e;
    let o = 0;
    for (let l = s; l >= 0; l--) {
      const e = (this.ptsIndex + l) % r,
        c = t[e];
      if (a)
        if (l < s) {
          (o += t[(this.ptsIndex + l + 1) % r].pos.distanceTo(c.pos)),
            (c.dist = o);
        } else c.dist = 0;
      else c.dist = this.leftPts[e].dist;
      let u = n + 2 * l * this.bufferDims;
      const h = jP.set(-c.width, 0, 0).applyQuaternion(c.qt).add(c.pos),
        d = YP.set(c.width, 0, 0).applyQuaternion(c.qt).add(c.pos);
      (i[u++] = h.x),
        (i[u++] = h.y),
        (i[u++] = h.z),
        (i[u++] = c.dist),
        (i[u++] = d.x),
        (i[u++] = d.y),
        (i[u++] = d.z),
        (i[u++] = c.dist);
    }
    a && (this.maxDist = o), (this.geo.attributes.position.needsUpdate = !0);
  }
  update() {
    this.reseting && this.reset(!0);
    const e = HP.scene.currentCamera;
    if (!e || !e.isGameCamera)
      return (this.base.visible = !1), void (this.visible = !1);
    (this.base.visible = !0),
      (this.visible = !0),
      this.appendPts(),
      this.updateGeo(false),
      this.updateGeo(true);
    const t = HP.time.stableDt,
      n = this.mat.uniforms;
    (n.time.value = GP.elapsed),
      (n.progress.value = GP.progress),
      (n.maxDist.value = this.maxDist);
    const i = GP.turbo.hover,
      r = GP.turbo.active.value,
      s = GP.state.hasEnded() && HP.gameCam.activeInfluence < 0.5;
    n.trailLength.value = s
      ? Ay(n.trailLength.value, 3.5, 0.019, t)
      : Ay(
          n.trailLength.value,
          r ? 1 : i ? 0.35 + 0.1 * GP.turbo.progress : 0,
          r ? 0.3 : i ? 0.1 : 0.02,
          t
        );
  }
}
let ZP;
class KP extends zA {
  init() {
    (ZP = kl()),
      (ZP.road = this),
      (this.base = new Ab()),
      (ZP.getRoadDataAt = nx("getRoadDataAt", this, 2)),
      (this.curve = ZP.curves.road),
      (this.road = this.add(ZP.meshes.road)),
      (this.road.material = GA.get()),
      (this.road.renderOrder = ZP.store.renderOrder.road),
      (this.road.castShadow = !1),
      (this.road.receiveShadow = !1),
      (this.pointer = this.addComponent(WA)),
      (ZP.pointer = ZP.game.pointer = this.pointer),
      (this.line = this.addComponent(BP)),
      (this.car = this.addComponent(MP, { mountTo: this.pointer })),
      (this.carShadow = this.addComponent(LP, {
        mountTo: this.pointer,
        car: this.car,
      })),
      (this.carTrails = this.addComponent($P, { car: this.car })),
      (this.alphaInfluence = 1);
  }
  update() {
    super.update();
    this.road.material.uniforms.speedInfluence.value =
      wy(Sy(ZP.game.velocity, 7.3, 14), 0, 1) *
      ZP.scene.gameCam.activeInfluence;
  }
}
const JP = new Cx(),
  QP = new Cx();
class eL extends zA {
  constructor(e) {
    super(e), (this.base = null);
  }
  init(e) {
    (this.dirLightPos = new Cx(0, 0.4, 1).multiplyScalar(2)),
      (this.shadowSize = 0.85);
    const t = (this.ambLight = new TE(16777215, 1)),
      n = (this.dirLight = new ME(16019554, 0.5));
    n.position.copy(this.dirLightPos),
      (n.castShadow = !0),
      (n.shadow.camera.near = 0.4),
      (n.shadow.camera.far = 10),
      (n.shadow.camera.fov = 50),
      (n.shadow.camera.top = this.shadowSize),
      (n.shadow.camera.bottom = -this.shadowSize),
      (n.shadow.camera.left = this.shadowSize),
      (n.shadow.camera.right = -this.shadowSize),
      this.setShadowSize(128),
      e.scene.add(t),
      e.scene.add(n);
  }
  setShadowSize(e = 128) {
    this.dirLight.shadow.mapSize.width !== e &&
      ((this.dirLight.shadow.mapSize.width = e),
      (this.dirLight.shadow.mapSize.height = e),
      this.dirLight.shadow.map &&
        (this.dirLight.shadow.map.dispose(),
        (this.dirLight.shadow.map = null)));
  }
  toggleShadow(e) {
    const t = Nl.threeRenderer;
    Nl.store.shadowActive.set(e), (t.shadowMapAutoUpdate = e);
    const n = t.getRenderTarget();
    t.setRenderTarget(this.dirLight.shadow.map),
      t.clear(),
      t.setRenderTarget(n);
  }
  update() {
    const e = this.props.scene.road.car.base,
      t = this.props.scene.road.carShadow.base;
    (this.dirLight.target = e),
      this.dirLight.position.copy(e.getWorldPosition(JP)).add(this.dirLightPos),
      t.worldToLocal(QP.copy(this.dirLight.position));
    const n = wy(Sy(QP.z, 0.04, 0.6), 0, 1);
    t.material.uniforms.dirOpacity.value = n;
  }
}
var tL = nA(
  "#define PHONG\nvarying vec3 vViewPosition;varying float vY;\n#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main(){\n#include <uv_vertex>\n#include <beginnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#include <project_vertex>\nvViewPosition=-mvPosition.xyz;\n#include <worldpos_vertex>\nvY=worldPosition.y;\n#include <envmap_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n}",
  "#define PHONG\n#define NEON\n#define STRUCTURE\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <bg_fog_pars>\n#include <conditionals>\n#include <luma>\nuniform vec3 diffuse;uniform vec3 emissive;uniform vec3 specular;uniform float shininess;uniform float opacity;uniform sampler2D data;uniform sampler2D matcaps;void main(){vec3 texelData=texture2D(data,vUv).rgb;vec4 diffuseColor=vec4(diffuse,opacity);ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));vec3 totalEmissiveRadiance=emissive;\n#include <map_fragment>\nfloat specularStrength=texelData.b;\n#include <normal_fragment_begin>\n#include <lights_phong_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\nvec3 outgoingLight=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+reflectedLight.directSpecular+reflectedLight.indirectSpecular+totalEmissiveRadiance;\n#include <output_fragment>\nvec2 uv=vUv;float id=floor(texelData.g*8.);float id_x=mod(id,4.)/4.+0.0001;float id_y=(floor(id/4.)/2.)+0.0001;vec2 start=vec2(id_x,id_y);vec2 size=vec2(0.25,0.5);float hasMatcap=min(id,1.);vec3 viewDir=normalize(vViewPosition);vec3 x=normalize(vec3(viewDir.z,0.0,-viewDir.x));vec3 y=cross(viewDir,x);vec2 matcapUV=vec2(dot(x,normal),dot(y,normal))*0.499+0.5;matcapUV.y=1.-matcapUV.y;matcapUV.xy=matcapUV.xy*size+start;vec3 matcapColor=texture2D(matcaps,matcapUV).rgb;vec3 lMatcapColor=matcapColor*smoothstep(0.,0.06,(luma(reflectedLight.directDiffuse)));matcapColor=mix(lMatcapColor,matcapColor,0.4+0.6*smoothstep(0.,0.4,luma(matcapColor)))+reflectedLight.directSpecular;gl_FragColor.rgb=mix(gl_FragColor.rgb,matcapColor,hasMatcap);float neonIntensity=texelData.r;\n#include <neon_encode>\n#include <bg_fog>\n}"
);
let nL = null;
class iL extends kw {
  constructor(e = {}) {
    super(e);
    const t = (this.uniforms = l(
      o(
        o({}, Dw.merge([Kw.common, Kw.specularmap, Kw.fog, Kw.lights])),
        oA.uniforms
      ),
      {
        data: { value: Nl.textures.structureData },
        matcaps: { value: Nl.textures.matcaps },
        specular: { value: new Xb(16720418) },
        shininess: { value: 10 },
      }
    ));
    (this.map = t.map.value = Nl.textures.structureDiffuse),
      tL.use(this),
      (this.lights = !0),
      (this.fog = !0),
      (this.type = "ShaderMaterial"),
      (this.isShaderMaterial = !0);
  }
}
iL.get = (e) => (nL = nL || new iL(e));
class rL extends zA {
  init() {
    (this.base = Nl.meshes.structure),
      (this.base.material = iL.get()),
      (this.base.castShadow = !1),
      (this.base.receiveShadow = !1),
      (this.base.renderOrder = Nl.store.renderOrder.structure),
      (this.base.frustumCulled = !1);
    let e = !1;
    Nl.hooks.beforePrerender.watchOnce(() => {
      (e = this.base.visible), (this.base.visible = !0);
    }),
      Nl.hooks.afterPrerender.watchOnce(() => {
        this.base.visible = e;
      });
  }
}
var sL = nA(
  "precision highp float;attribute vec3 instancePos;attribute float aOffset;uniform float uTime;uniform float uHalfBoxSize;uniform vec3 uBoxPosition;uniform float uGameVelocity;varying float vFade;varying vec2 vUv;const float DURATION=100.;void main(){vec3 pos=position;float boxSize=uHalfBoxSize*2.;vec3 translation=uBoxPosition-mod(instancePos+uBoxPosition,boxSize)+uHalfBoxSize;float loop=mod((uTime*.0005)+aOffset*DURATION,DURATION)/DURATION;translation.z+=cos(uTime*(0.0004+instancePos.z*0.0005)+instancePos.y*2.2)*(0.02+instancePos.x*0.02);translation.y+=sin(4.+uTime*(0.0003+instancePos.x*0.00005)+instancePos.z*2.2)*(0.02+instancePos.y*0.02);translation.y+=-2.5+(1.-loop)*(10.+translation.y)*(1.+abs((uTime*.0001+aOffset))*.01);vec4 mvPosition=modelViewMatrix*vec4(translation,1.0);mvPosition.xyz+=pos.xyz;float fade=1.;fade*=.3-smoothstep(.05,.75,(.05*distance(uBoxPosition,translation)));fade*=smoothstep(1.,.75,loop)*smoothstep(.0,.25,loop);fade*=1.-smoothstep(6.,14.,uGameVelocity);vFade=fade;vUv=uv;gl_Position=projectionMatrix*mvPosition;}",
  "precision highp float;uniform float uActiveInfluence;uniform float uGameVelocity;uniform vec3 uBoxPosition;uniform vec3 uColor;uniform vec2 uResolution;uniform float uPixelRatio;varying float vFade;varying vec2 vUv;void main(){vec2 uv=vUv;vec2 res=gl_FragCoord.xy/uResolution.xy;res/=uPixelRatio;float strength=(.5+(uGameVelocity*.01))/(distance(uv,vec2(.5)));vec3 color=uColor;color*=strength;color*=smoothstep(1.,10.,color);float center=.1/distance(res,vec2(.5,.45));color*=vFade*0.4;color*=uActiveInfluence;float alpha=mix(1.,.85,vFade);gl_FragColor=vec4(color,alpha);}"
);
let aL;
class oL extends kw {
  constructor(e = {}) {
    super(e),
      IP(this),
      (this.uniforms = {
        uBoxPosition: { value: new Cx() },
        uHalfBoxSize: { value: 5 },
        uGameVelocity: { value: 0 },
        uTime: { value: 0 },
        uColor: { value: new Xb(16777215) },
        uActiveInfluence: { value: Nl.scene.gameCam.activeInfluence },
        uResolution: { value: new fx(window.innerWidth, window.innerHeight) },
        uPixelRatio: { value: window.devicePixelRatio },
      }),
      (this.depthTest = !0),
      (this.depthWrite = !1),
      sL.use(this);
  }
}
oL.get = (e) => (aL = aL || new oL(e));
const lL = new $w();
let cL, uL, hL, dL, pL, fL, mL;
class gL extends zA {
  init() {
    (cL = kl()),
      (uL = cL.game),
      (this.material = oL.get()),
      this.initGeometry(2500),
      (this.base = new Aw(this.geo, this.material)),
      (this.base.renderOrder = cL.store.renderOrder.cloudParticles),
      (this.base.frustumCulled = !1),
      (this.position = new Cx());
    let e = !1;
    cL.hooks.beforePrerender.watchOnce(() => {
      (e = this.base.visible), (this.base.visible = !0);
    }),
      cL.hooks.afterPrerender.watchOnce(() => {
        this.base.visible = e;
      });
  }
  initGeometry(e) {
    if (e === this.count) return;
    (this.count = e),
      this.geo && this.geo.dispose(),
      (this.geo = new EE()),
      (this.geo.index = lL.index),
      (this.geo.attributes.position = lL.attributes.position),
      (this.geo.attributes.uv = lL.attributes.uv),
      this.geo.scale(0.03, 0.03, 0.03),
      (this.stride = 4),
      (this.buffer = new Float32Array(this.count * this.stride));
    const t = (this.interleavedBuffer = new zE(this.buffer, this.stride));
    this.geo.setAttribute("instancePos", new zT(t, 3, 0, !1)),
      this.geo.setAttribute("aOffset", new zT(t, 1, 3, !1));
    const n = this.buffer;
    for (let i = 0; i < this.count; i++)
      (n[i + 0] = pA.randomFloat(-4.8, 4.8)),
        (n[i + 1] = pA.randomFloat(-4.8, 4.8)),
        (n[i + 2] = pA.randomFloat(-4.8, 4.8)),
        (n[i + 3] = pA.randomFloat(-4.8, 4.8));
    (this.interleavedBuffer.needsUpdate = !0),
      (this.material.uniforms.uHalfBoxSize.value = 4.8),
      this.base &&
        ((this.base.geometry = this.geo), (this.base.needsUpdate = !0));
  }
  update() {
    (this.material.uniforms.uGameVelocity.value = uL.velocity),
      (this.material.uniforms.uTime.value = cL.game.elapsed),
      (this.material.uniforms.uActiveInfluence.value =
        cL.scene.gameCam.activeInfluence);
    const e = this.material.uniforms.uBoxPosition.value;
    let t = cL.scene.currentCamera;
    (this.base.visible = !!t.cloudParticlesActive),
      this.base.visible && e.copy(t.base.position);
  }
}
class vL extends lA {
  constructor(e) {
    super(e),
      (hL = uN()),
      (dL = hL.game),
      (this.emitterOptions = { amount: 1, depthTest: !0 });
  }
  update() {
    const e = hL.scene.currentCamera;
    !e ||
      !e.isGameCamera ||
      e.activeInfluence < 0.002 ||
      dL.velocity < dL.minVelocity ||
      dL.particles.emit("dashline", this.emitterOptions);
  }
}
const _L = new fx(),
  yL = new Cx(),
  xL = new Cx();
new Tx();
class bL extends hA {
  init() {
    (mL = Pl),
      (pL = kl()),
      (fL = pL.game),
      (pL.scene = this),
      pL.particles.init(this),
      (this.road = this.addComponent(KP)),
      (pL.gameCam = fL.gameCam = this.gameCam = this.addComponent(PA)),
      (this.idleCam = this.addComponent(FA)),
      this.useCamera(this.gameCam),
      (this.lightning = this.addComponent(eL, { scene: this })),
      (this.structures = this.addComponent(rL)),
      (this.cloudParticles = this.addComponent(gL)),
      (this.dashLines = this.addComponent(vL));
    let e = null;
    pL.hooks.beforePrerender.watchOnce(() => {
      (e = this.currentCamera), this.useCamera(this.gameCam);
    }),
      pL.hooks.afterPrerender.watchOnce(() => {
        this.useCamera(e);
      }),
      this.initFog();
  }
  initFog() {
    (this.clearColor = yd(_d("#8b0300"), "scene_clear_color")),
      (this.fog = this.base.fog = new kT()),
      this.clearColor.watchImmediate((e) => pL.threeRenderer.setClearColor(e)),
      this.clearColor.watchImmediate((e) => this.fog.color.set(e));
  }
  setFar(e) {
    (this.gameCam.cam.far = e),
      this.gameCam.cam.updateProjectionMatrix(),
      (this.idleCam.cam.far = e),
      this.idleCam.cam.updateProjectionMatrix(),
      (this.fog.near = Math.max(0, e - 160)),
      (this.fog.far = e);
  }
  setNear(e) {
    (this.gameCam.cam.near = e),
      this.gameCam.cam.updateProjectionMatrix(),
      (this.idleCam.cam.near = e),
      this.idleCam.cam.updateProjectionMatrix();
  }
  emitFirework() {
    const e = fL.normalizeProgress(fL.checkpoints.list.finish + 30),
      t = fL.getAbsoluteRoadData(e),
      n = pL.viewport.size.value,
      i = wy(Sy(n.x / n.y, 0.5, 1.5), 0, 1),
      r = Cy(pA.randomFloat(-50, 40), pA.randomFloat(-120, 40), i),
      s = yL
        .set(r, pA.randomFloat(-19, 45), pA.randomFloat(0, 2))
        .applyQuaternion(
          t.quaternion.fromArray([
            -0.10036272, 0.24738172, 0.02577216, 0.96336151,
          ])
        )
        .add(xL.fromArray([356.666661, 12.856385, 67.333084]));
    pL.particles.emit("fireworksFlash", {
      amount: 1,
      position: s,
      scale: _L.set(100, 100),
      duration: 900,
      power: 0.9,
      powerMult: 0.92,
      glowMult: 1,
      depthTest: !0,
      rotation: pA.randomFloat(0, 2 * Math.PI),
      gravityY: 0.2,
      sprite: "smoke",
    }),
      pL.particles.emit("fireworksFlash", {
        amount: 1,
        position: s,
        scale: _L.set(500, 500),
        duration: 250,
        power: 0.001,
        depthTest: !0,
        powerMult: 0.02,
        glowMult: 0.07,
        sprite: "particleA",
      }),
      pL.particles.emit("fireworksFlash", {
        amount: 1,
        position: s,
        scale: _L.set(220, 220),
        duration: 200,
        power: 0.55,
        depthTest: !0,
        powerMult: 0.9,
        glowMult: 0.01,
        sprite: "particleA",
      }),
      pL.particles.emit("fireworksBurst", {
        amount: pA.randomInt(8, 15),
        position: s,
        scale: _L.set(35, 9),
        duration: 800,
        opacity: 0.3,
        depthTest: !0,
        sprite: "raysA",
      }),
      pL.particles.emit("fireworksBurstFall", {
        amount: pA.randomInt(4, 6),
        position: s,
        scale: _L.set(6, 4),
        duration: 1100,
        opacity: 0.9,
        depthTest: !0,
        velocity: 0.6,
        sprite: "particleA",
      });
  }
  update() {
    let e = "game" !== mL.$route.name && "webgl" !== mL.$route.name,
      t = !e && !this.idleCam.enabled.value;
    (e || this.idleCam.enabled.value) && this.currentCamera !== this.idleCam
      ? this.useCamera(this.idleCam)
      : t &&
        this.currentCamera !== this.gameCam &&
        this.useCamera(this.gameCam),
      super.update(),
      pL.particles.update();
  }
}
const wL = {
  "./bg.glsl": Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default:
      "vec2 bgUV=bgRot(gl_FragCoord.xy/res.xy,bgCamRotation.y);float bgProgress=smoothstep(1.,0.,bgUV.y+bgCamRotation.x*1.+0.11);vec3 bgColor=mix(bgTopColor,bgBottomColor,bgProgress);",
  }),
  "./bg_fog.glsl": Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default:
      "float _fogNear=fogNear;\n#ifdef NEON\n_fogNear+=(fogFar-fogNear)*0.6*neonIntensity;\n#endif\nfloat fogFactor=smoothstep(_fogNear,fogFar,vFogDepth);\n#ifdef STRUCTURE\nfogFactor=max(fogFactor,smoothstep(-90.,-143.,vY)+smoothstep(75.,112.,vY));\n#endif\n#include <bg>\n#ifdef NEON\ngl_FragColor.a=mix(gl_FragColor.a,1.,fogFactor);\n#endif\ngl_FragColor.rgb=mix(gl_FragColor.rgb,bgColor,fogFactor);",
  }),
  "./bg_fog_pars.glsl": Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default:
      "uniform float fogNear;uniform float fogFar;varying float vFogDepth;\n#ifdef STRUCTURE\nvarying float vY;\n#endif\n#include <bg_pars>",
  }),
  "./bg_pars.glsl": Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default:
      "uniform vec2 res;uniform vec2 bgCamRotation;const vec3 bgTopColor=vec3(0.208,0.008,0.012)*0.95;const vec3 bgBottomColor=vec3(0.6,0.,0.);vec2 bgRot(vec2 v,float a){float s=sin(a);float c=cos(a);mat2 m=mat2(c,-s,s,c);return(m*v-0.5)+0.5;}",
  }),
  "./blend_add.glsl": Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default:
      "float blendScreen(float base,float blend){return 1.0-((1.0-base)*(1.0-blend));}vec3 blendAdd(vec3 base,vec3 blend){return vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));}",
  }),
  "./conditionals.glsl": Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default:
      "float when_gt(float x,float y){return max(sign(x-y),0.0);}float when_lt(float x,float y){return max(sign(y-x),0.0);}float when_ge(float x,float y){return 1.0-when_lt(x,y);}float when_eq(float x,float y){return 1.0-abs(sign(x-y));}",
  }),
  "./equals.glsl": Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default: "float equals(float x,float y){return 1.0-abs(sign(x-y));}",
  }),
  "./get_instance_matrix.glsl": Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default:
      "mat4 getInstanceMatrix(vec3 p,vec4 q,vec3 s){mat4 m;float x=q.x;float y=q.y;float z=q.z;float w=q.w;float x2=x+x;float y2=y+y;float z2=z+z;float xx=x*x2;float xy=x*y2;float xz=x*z2;float yy=y*y2;float yz=y*z2;float zz=z*z2;float wx=w*x2;float wy=w*y2;float wz=w*z2;float sx=s.x;float sy=s.y;float sz=s.z;m[0][0]=(1.-(yy+zz))*sx;m[0][1]=(xy+wz)*sx;m[0][2]=(xz-wy)*sx;m[0][3]=0.;m[1][0]=(xy-wz)*sy;m[1][1]=(1.-(xx+zz))*sy;m[1][2]=(yz+wx)*sy;m[1][3]=0.;m[2][0]=(xz+wy)*sz;m[2][1]=(yz-wx)*sz;m[2][2]=(1.-(xx+yy))*sz;m[2][3]=0.;m[3][0]=p.x;m[3][1]=p.y;m[3][2]=p.z;m[3][3]=1.;return m;}",
  }),
  "./linearstep.glsl": Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default:
      "float linearstep(float start,float end,float value){return(clamp(value,start,end)-start)/(end-start);}",
  }),
  "./luma.glsl": Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default:
      "float luma(vec3 color){return dot(color,vec3(0.299,0.587,0.114));}",
  }),
  "./neon_encode.glsl": Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default: "gl_FragColor.a=1.-neonIntensity;",
  }),
  "./neon_pars.glsl": Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default:
      "const float neonx=1.0/255.0;vec4 decodeNeon(float v){vec4 enc=vec2(1.0,255.0)*v;enc=fract(enc);enc-=enc.yzww*vec2(neonx,neonx,neonx,0.0);return enc;}float encodeNeon(vec2 rg){return dot(rg,vec2(1.0,neonx));}",
  }),
  "./remap.glsl": Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default:
      "float remap(float value,float min1,float max1,float min2,float max2){return min2+(value-min1)*(max2-min2)/(max1-min1);}",
  }),
};
const SL = { default: !0, webp: !1, avif: !1 };
async function ML(e) {
  const t = "image/" + e,
    n = document.createElement("picture"),
    i = document.createElement("img"),
    r = document.createElement("source");
  (r.srcset = "data:,x"),
    (r.type = t),
    n.appendChild(r),
    n.appendChild(i),
    await 0;
  const s = !!i.currentSrc;
  return (SL[e] = s), s;
}
var TL = {
  test: async function () {
    await Promise.all([ML("webp"), ML("avif")]);
  },
  select: function (e, t, n) {
    return (
      "object" == typeof e && ((n = e.avif), (t = e.webp), (e = e.default)),
      SL.avif && n ? n : SL.webp && t ? t : e
    );
  },
  supports: SL,
};
const CL = (function () {
  let e = {};
  return {
    get: function (t, n = !0) {
      if (e[t]) return e[t];
      if (!n) return;
      for (const i in e) if (i.match(t)) return e[i];
    },
    add: function (t, n) {
      e[t] = n;
    },
    clear: function () {
      e = {};
    },
    list: function () {
      return e;
    },
  };
})();
const EL = {},
  AL = {};
var PL = {
  get: function (e, t) {
    return CL.get(e, t);
  },
  list: function () {
    return CL.list();
  },
  load: function (e, t = {}) {
    if (CL.get(e)) return Promise.resolve();
    if (AL[e]) return AL[e];
    let n;
    return (
      e.startsWith("http") || e.startsWith("/") || (e = "/" + e),
      (n =
        t.loader && EL[t.loader]
          ? EL[t.loader].function(e, t)
          : (function (e, t) {
              for (const n in EL) {
                const i = EL[n];
                if (i.extensions) {
                  const n = i.extensions;
                  for (let r = 0; r < n.length; r++) {
                    const s = n[r];
                    if (e.endsWith(s)) return i.function(e, t);
                  }
                } else if (i.test && i.test(e, t)) return i.function(e, t);
              }
              return (function (e, t = {}) {
                return new Promise((n, i) => {
                  const r = new XMLHttpRequest();
                  (r.responseType = t.responseType || "arraybuffer"),
                    (r.onreadystatechange = () => {
                      4 === r.readyState &&
                        (4 === r.readyState && 200 === r.status
                          ? (t.noCache || CL.add(e, r.response),
                            t.onLoad && t.onLoad(r.response),
                            n(r.response, r.status))
                          : i(r.status));
                    }),
                    r.open("GET", e, !0),
                    r.send();
                });
              })(e, t);
            })(e, t)),
      n && (AL[e] = n),
      n
    );
  },
  registerLoader: function (e) {
    e.loader && (e = e.loader), (EL[e.name] = e);
  },
};
function LL(e, t) {
  return new Promise((n) => {
    const i = new Image();
    (i.onload = () => {
      const r = { node: i, url: e };
      t.onLoad && t.onLoad(r), CL.add(e, r), n(r);
    }),
      (i.decoding = "async"),
      i.setAttribute("decoding", "async"),
      (i.src = e);
  });
}
LL.loader = {
  name: "image",
  extensions: [".jpg", ".png", ".webp", ".avif", ".gif", ".jpeg"],
  function: LL,
};
function IL() {
  let e = {};
  return {
    get: function (t) {
      return e[t];
    },
    add: function (t, n) {
      e[t] = n;
    },
    remove: function (t) {
      delete e[t];
    },
    removeAll: function () {
      e = {};
    },
  };
}
const RL = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
};
class DL {
  constructor(e) {
    (this.parser = e),
      (this.name = RL.KHR_LIGHTS_PUNCTUAL),
      (this.cache = { refs: {}, uses: {} });
  }
  _markDefs() {
    const e = this.parser,
      t = this.parser.json.nodes || [];
    for (let n = 0, i = t.length; n < i; n++) {
      const i = t[n];
      i.extensions &&
        i.extensions[this.name] &&
        void 0 !== i.extensions[this.name].light &&
        e._addNodeRef(this.cache, i.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser,
      n = "light:" + e;
    let i = t.cache.get(n);
    if (i) return i;
    const r = t.json,
      s = (((r.extensions && r.extensions[this.name]) || {}).lights || [])[e];
    let a;
    const o = new Xb(16777215);
    void 0 !== s.color && o.fromArray(s.color);
    const l = void 0 !== s.range ? s.range : 0;
    switch (s.type) {
      case "directional":
        (a = new ME(o)), a.target.position.set(0, 0, -1), a.add(a.target);
        break;
      case "point":
        (a = new wE(o)), (a.distance = l);
        break;
      case "spot":
        (a = new vE(o)),
          (a.distance = l),
          (s.spot = s.spot || {}),
          (s.spot.innerConeAngle =
            void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0),
          (s.spot.outerConeAngle =
            void 0 !== s.spot.outerConeAngle
              ? s.spot.outerConeAngle
              : Math.PI / 4),
          (a.angle = s.spot.outerConeAngle),
          (a.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle),
          a.target.position.set(0, 0, -1),
          a.add(a.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + s.type);
    }
    return (
      a.position.set(0, 0, 0),
      (a.decay = 2),
      void 0 !== s.intensity && (a.intensity = s.intensity),
      (a.name = t.createUniqueName(s.name || "light_" + e)),
      (i = Promise.resolve(a)),
      t.cache.add(n, i),
      i
    );
  }
  createNodeAttachment(e) {
    const t = this,
      n = this.parser,
      i = n.json.nodes[e],
      r = ((i.extensions && i.extensions[this.name]) || {}).light;
    return void 0 === r
      ? null
      : this._loadLight(r).then(function (e) {
          return n._getNodeRef(t.cache, r, e);
        });
  }
}
class kL {
  constructor() {
    this.name = RL.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return $b;
  }
  extendParams(e, t, n) {
    const i = [];
    (e.color = new Xb(1, 1, 1)), (e.opacity = 1);
    const r = t.pbrMetallicRoughness;
    if (r) {
      if (Array.isArray(r.baseColorFactor)) {
        const t = r.baseColorFactor;
        e.color.fromArray(t), (e.opacity = t[3]);
      }
      void 0 !== r.baseColorTexture &&
        i.push(n.assignTexture(e, "map", r.baseColorTexture));
    }
    return Promise.all(i);
  }
}
class NL {
  constructor(e) {
    (this.parser = e), (this.name = RL.KHR_MATERIALS_CLEARCOAT);
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? VC : null;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const r = [],
      s = i.extensions[this.name];
    if (
      (void 0 !== s.clearcoatFactor && (t.clearcoat = s.clearcoatFactor),
      void 0 !== s.clearcoatTexture &&
        r.push(n.assignTexture(t, "clearcoatMap", s.clearcoatTexture)),
      void 0 !== s.clearcoatRoughnessFactor &&
        (t.clearcoatRoughness = s.clearcoatRoughnessFactor),
      void 0 !== s.clearcoatRoughnessTexture &&
        r.push(
          n.assignTexture(
            t,
            "clearcoatRoughnessMap",
            s.clearcoatRoughnessTexture
          )
        ),
      void 0 !== s.clearcoatNormalTexture &&
        (r.push(
          n.assignTexture(t, "clearcoatNormalMap", s.clearcoatNormalTexture)
        ),
        void 0 !== s.clearcoatNormalTexture.scale))
    ) {
      const e = s.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new fx(e, -e);
    }
    return Promise.all(r);
  }
}
class OL {
  constructor(e) {
    (this.parser = e), (this.name = RL.KHR_MATERIALS_TRANSMISSION);
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? VC : null;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const r = [],
      s = i.extensions[this.name];
    return (
      void 0 !== s.transmissionFactor &&
        (t.transmission = s.transmissionFactor),
      void 0 !== s.transmissionTexture &&
        r.push(n.assignTexture(t, "transmissionMap", s.transmissionTexture)),
      Promise.all(r)
    );
  }
}
class FL {
  constructor(e) {
    (this.parser = e), (this.name = RL.KHR_TEXTURE_BASISU);
  }
  loadTexture(e) {
    const t = this.parser,
      n = t.json,
      i = n.textures[e];
    if (!i.extensions || !i.extensions[this.name]) return null;
    const r = i.extensions[this.name],
      s = n.images[r.source],
      a = t.options.ktx2Loader;
    if (!a) {
      if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
        );
      return null;
    }
    return t.loadTextureImage(e, s, a);
  }
}
class zL {
  constructor(e) {
    (this.parser = e),
      (this.name = RL.EXT_TEXTURE_WEBP),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      n = this.parser,
      i = n.json,
      r = i.textures[e];
    if (!r.extensions || !r.extensions[t]) return null;
    const s = r.extensions[t],
      a = i.images[s.source];
    let o = n.textureLoader;
    if (a.uri) {
      const e = n.options.manager.getHandler(a.uri);
      null !== e && (o = e);
    }
    return this.detectSupport().then(function (r) {
      if (r) return n.loadTextureImage(e, a, o);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: WebP required by asset but unsupported."
        );
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
            (t.onload = t.onerror =
              function () {
                e(1 === t.height);
              });
        })),
      this.isSupported
    );
  }
}
class UL {
  constructor(e) {
    (this.name = RL.EXT_MESHOPT_COMPRESSION), (this.parser = e);
  }
  loadBufferView(e) {
    const t = this.parser.json,
      n = t.bufferViews[e];
    if (n.extensions && n.extensions[this.name]) {
      const e = n.extensions[this.name],
        i = this.parser.getDependency("buffer", e.buffer),
        r = this.parser.options.meshoptDecoder;
      if (!r || !r.supported) {
        if (
          t.extensionsRequired &&
          t.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
          );
        return null;
      }
      return Promise.all([i, r.ready]).then(function (t) {
        const n = e.byteOffset || 0,
          i = e.byteLength || 0,
          s = e.count,
          a = e.byteStride,
          o = new ArrayBuffer(s * a),
          l = new Uint8Array(t[0], n, i);
        return (
          r.decodeGltfBuffer(new Uint8Array(o), s, a, l, e.mode, e.filter), o
        );
      });
    }
    return null;
  }
}
const BL = "glTF",
  VL = 1313821514,
  HL = 5130562;
class GL {
  constructor(e) {
    (this.name = RL.KHR_BINARY_GLTF), (this.content = null), (this.body = null);
    const t = new DataView(e, 0, 12);
    if (
      ((this.header = {
        magic: CE.decodeText(new Uint8Array(e.slice(0, 4))),
        version: t.getUint32(4, !0),
        length: t.getUint32(8, !0),
      }),
      this.header.magic !== BL)
    )
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const n = this.header.length - 12,
      i = new DataView(e, 12);
    let r = 0;
    for (; r < n; ) {
      const t = i.getUint32(r, !0);
      r += 4;
      const n = i.getUint32(r, !0);
      if (((r += 4), n === VL)) {
        const n = new Uint8Array(e, 12 + r, t);
        this.content = CE.decodeText(n);
      } else if (n === HL) {
        const n = 12 + r;
        this.body = e.slice(n, n + t);
      }
      r += t;
    }
    if (null === this.content)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class WL {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    (this.name = RL.KHR_DRACO_MESH_COMPRESSION),
      (this.json = e),
      (this.dracoLoader = t),
      this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const n = this.json,
      i = this.dracoLoader,
      r = e.extensions[this.name].bufferView,
      s = e.extensions[this.name].attributes,
      a = {},
      o = {},
      l = {};
    for (const c in s) {
      const e = oI[c] || c.toLowerCase();
      a[e] = s[c];
    }
    for (const c in e.attributes) {
      const t = oI[c] || c.toLowerCase();
      if (void 0 !== s[c]) {
        const i = n.accessors[e.attributes[c]],
          r = iI[i.componentType];
        (l[t] = r), (o[t] = !0 === i.normalized);
      }
    }
    return t.getDependency("bufferView", r).then(function (e) {
      return new Promise(function (t) {
        i.decodeDracoFile(
          e,
          function (e) {
            for (const t in e.attributes) {
              const n = e.attributes[t],
                i = o[t];
              void 0 !== i && (n.normalized = i);
            }
            t(e);
          },
          a,
          l
        );
      });
    });
  }
}
class qL {
  constructor() {
    this.name = RL.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (
      t.texCoord,
      (void 0 === t.offset && void 0 === t.rotation && void 0 === t.scale) ||
        ((e = e.clone()),
        void 0 !== t.offset && e.offset.fromArray(t.offset),
        void 0 !== t.rotation && (e.rotation = t.rotation),
        void 0 !== t.scale && e.repeat.fromArray(t.scale),
        (e.needsUpdate = !0)),
      e
    );
  }
}
class jL extends BC {
  constructor(e) {
    super(), (this.isGLTFSpecularGlossinessMaterial = !0);
    const t = [
        "#ifdef USE_SPECULARMAP",
        "\tuniform sampler2D specularMap;",
        "#endif",
      ].join("\n"),
      n = [
        "#ifdef USE_GLOSSINESSMAP",
        "\tuniform sampler2D glossinessMap;",
        "#endif",
      ].join("\n"),
      i = [
        "vec3 specularFactor = specular;",
        "#ifdef USE_SPECULARMAP",
        "\tvec4 texelSpecular = texture2D( specularMap, vUv );",
        "\ttexelSpecular = sRGBToLinear( texelSpecular );",
        "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
        "\tspecularFactor *= texelSpecular.rgb;",
        "#endif",
      ].join("\n"),
      r = [
        "float glossinessFactor = glossiness;",
        "#ifdef USE_GLOSSINESSMAP",
        "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );",
        "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
        "\tglossinessFactor *= texelGlossiness.a;",
        "#endif",
      ].join("\n"),
      s = [
        "PhysicalMaterial material;",
        "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
        "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
        "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
        "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
        "material.specularRoughness += geometryRoughness;",
        "material.specularRoughness = min( material.specularRoughness, 1.0 );",
        "material.specularColor = specularFactor;",
      ].join("\n"),
      a = {
        specular: { value: new Xb().setHex(16777215) },
        glossiness: { value: 1 },
        specularMap: { value: null },
        glossinessMap: { value: null },
      };
    (this._extraUniforms = a),
      (this.onBeforeCompile = function (e) {
        for (const t in a) e.uniforms[t] = a[t];
        e.fragmentShader = e.fragmentShader
          .replace("uniform float roughness;", "uniform vec3 specular;")
          .replace("uniform float metalness;", "uniform float glossiness;")
          .replace("#include <roughnessmap_pars_fragment>", t)
          .replace("#include <metalnessmap_pars_fragment>", n)
          .replace("#include <roughnessmap_fragment>", i)
          .replace("#include <metalnessmap_fragment>", r)
          .replace("#include <lights_physical_fragment>", s);
      }),
      Object.defineProperties(this, {
        specular: {
          get: function () {
            return a.specular.value;
          },
          set: function (e) {
            a.specular.value = e;
          },
        },
        specularMap: {
          get: function () {
            return a.specularMap.value;
          },
          set: function (e) {
            (a.specularMap.value = e),
              e
                ? (this.defines.USE_SPECULARMAP = "")
                : delete this.defines.USE_SPECULARMAP;
          },
        },
        glossiness: {
          get: function () {
            return a.glossiness.value;
          },
          set: function (e) {
            a.glossiness.value = e;
          },
        },
        glossinessMap: {
          get: function () {
            return a.glossinessMap.value;
          },
          set: function (e) {
            (a.glossinessMap.value = e),
              e
                ? ((this.defines.USE_GLOSSINESSMAP = ""),
                  (this.defines.USE_UV = ""))
                : (delete this.defines.USE_GLOSSINESSMAP,
                  delete this.defines.USE_UV);
          },
        },
      }),
      delete this.metalness,
      delete this.roughness,
      delete this.metalnessMap,
      delete this.roughnessMap,
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.specularMap = e.specularMap),
      this.specular.copy(e.specular),
      (this.glossinessMap = e.glossinessMap),
      (this.glossiness = e.glossiness),
      delete this.metalness,
      delete this.roughness,
      delete this.metalnessMap,
      delete this.roughnessMap,
      this
    );
  }
}
class YL {
  constructor() {
    (this.name = RL.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS),
      (this.specularGlossinessParams = [
        "color",
        "map",
        "lightMap",
        "lightMapIntensity",
        "aoMap",
        "aoMapIntensity",
        "emissive",
        "emissiveIntensity",
        "emissiveMap",
        "bumpMap",
        "bumpScale",
        "normalMap",
        "normalMapType",
        "displacementMap",
        "displacementScale",
        "displacementBias",
        "specularMap",
        "specular",
        "glossinessMap",
        "glossiness",
        "alphaMap",
        "envMap",
        "envMapIntensity",
        "refractionRatio",
      ]);
  }
  getMaterialType() {
    return jL;
  }
  extendParams(e, t, n) {
    const i = t.extensions[this.name];
    (e.color = new Xb(1, 1, 1)), (e.opacity = 1);
    const r = [];
    if (Array.isArray(i.diffuseFactor)) {
      const t = i.diffuseFactor;
      e.color.fromArray(t), (e.opacity = t[3]);
    }
    if (
      (void 0 !== i.diffuseTexture &&
        r.push(n.assignTexture(e, "map", i.diffuseTexture)),
      (e.emissive = new Xb(0, 0, 0)),
      (e.glossiness = void 0 !== i.glossinessFactor ? i.glossinessFactor : 1),
      (e.specular = new Xb(1, 1, 1)),
      Array.isArray(i.specularFactor) && e.specular.fromArray(i.specularFactor),
      void 0 !== i.specularGlossinessTexture)
    ) {
      const t = i.specularGlossinessTexture;
      r.push(n.assignTexture(e, "glossinessMap", t)),
        r.push(n.assignTexture(e, "specularMap", t));
    }
    return Promise.all(r);
  }
  createMaterial(e) {
    const t = new jL(e);
    return (
      (t.fog = !0),
      (t.color = e.color),
      (t.map = void 0 === e.map ? null : e.map),
      (t.lightMap = null),
      (t.lightMapIntensity = 1),
      (t.aoMap = void 0 === e.aoMap ? null : e.aoMap),
      (t.aoMapIntensity = 1),
      (t.emissive = e.emissive),
      (t.emissiveIntensity = 1),
      (t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap),
      (t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap),
      (t.bumpScale = 1),
      (t.normalMap = void 0 === e.normalMap ? null : e.normalMap),
      (t.normalMapType = 0),
      e.normalScale && (t.normalScale = e.normalScale),
      (t.displacementMap = null),
      (t.displacementScale = 1),
      (t.displacementBias = 0),
      (t.specularMap = void 0 === e.specularMap ? null : e.specularMap),
      (t.specular = e.specular),
      (t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap),
      (t.glossiness = e.glossiness),
      (t.alphaMap = null),
      (t.envMap = void 0 === e.envMap ? null : e.envMap),
      (t.envMapIntensity = 1),
      (t.refractionRatio = 0.98),
      t
    );
  }
}
class XL {
  constructor() {
    this.name = RL.KHR_MESH_QUANTIZATION;
  }
}
class $L extends WC {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      n = this.sampleValues,
      i = this.valueSize,
      r = e * i * 3 + i;
    for (let s = 0; s !== i; s++) t[s] = n[r + s];
    return t;
  }
}
($L.prototype.beforeStart_ = $L.prototype.copySampleValue_),
  ($L.prototype.afterEnd_ = $L.prototype.copySampleValue_),
  ($L.prototype.interpolate_ = function (e, t, n, i) {
    const r = this.resultBuffer,
      s = this.sampleValues,
      a = this.valueSize,
      o = 2 * a,
      l = 3 * a,
      c = i - t,
      u = (n - t) / c,
      h = u * u,
      d = h * u,
      p = e * l,
      f = p - l,
      m = -2 * d + 3 * h,
      g = d - h,
      v = 1 - m,
      _ = g - h + u;
    for (let y = 0; y !== a; y++) {
      const e = s[f + y + a],
        t = s[f + y + o] * c,
        n = s[p + y + a],
        i = s[p + y] * c;
      r[y] = v * e + _ * t + m * n + g * i;
    }
    return r;
  });
const ZL = 0,
  KL = 1,
  JL = 2,
  QL = 3,
  eI = 4,
  tI = 5,
  nI = 6,
  iI = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  rI = {
    9728: 1003,
    9729: 1006,
    9984: 1004,
    9985: 1007,
    9986: 1005,
    9987: 1008,
  },
  sI = { 33071: 1001, 33648: 1002, 10497: 1e3 },
  aI = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
  oI = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex",
  },
  lI = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences",
  },
  cI = { CUBICSPLINE: void 0, LINEAR: 2301, STEP: 2300 },
  uI = "OPAQUE",
  hI = "MASK",
  dI = "BLEND";
function pI(e, t) {
  return "string" != typeof e || "" === e
    ? ""
    : (/^https?:\/\//i.test(t) &&
        /^\//.test(e) &&
        (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
      /^(https?:)?\/\//i.test(e) ||
      /^data:.*,.*$/i.test(e) ||
      /^blob:.*$/i.test(e)
        ? e
        : t + e);
}
function fI(e, t, n) {
  for (const i in n.extensions)
    void 0 === e[i] &&
      ((t.userData.gltfExtensions = t.userData.gltfExtensions || {}),
      (t.userData.gltfExtensions[i] = n.extensions[i]));
}
function mI(e, t) {
  void 0 !== t.extras &&
    "object" == typeof t.extras &&
    Object.assign(e.userData, t.extras);
}
function gI(e, t) {
  if ((e.updateMorphTargets(), void 0 !== t.weights))
    for (let n = 0, i = t.weights.length; n < i; n++)
      e.morphTargetInfluences[n] = t.weights[n];
  if (t.extras && Array.isArray(t.extras.targetNames)) {
    const n = t.extras.targetNames;
    if (e.morphTargetInfluences.length === n.length) {
      e.morphTargetDictionary = {};
      for (let t = 0, i = n.length; t < i; t++)
        e.morphTargetDictionary[n[t]] = t;
    }
  }
}
function vI(e) {
  const t = e.extensions && e.extensions[RL.KHR_DRACO_MESH_COMPRESSION];
  let n;
  return (
    (n = t
      ? "draco:" + t.bufferView + ":" + t.indices + ":" + _I(t.attributes)
      : e.indices + ":" + _I(e.attributes) + ":" + e.mode),
    n
  );
}
function _I(e) {
  let t = "";
  const n = Object.keys(e).sort();
  for (let i = 0, r = n.length; i < r; i++) t += n[i] + ":" + e[n[i]] + ";";
  return t;
}
function yI(e) {
  switch (e) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error(
        "THREE.GLTFLoader: Unsupported normalized accessor component type."
      );
  }
}
class xI {
  constructor(e = {}, t = {}) {
    (this.json = e),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = t),
      (this.cache = new IL()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {}),
      "undefined" != typeof createImageBitmap &&
      !1 === /Firefox/.test(navigator.userAgent)
        ? (this.textureLoader = new AE(this.options.manager))
        : (this.textureLoader = new uE(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new lE(this.options.manager)),
      this.fileLoader.setResponseType("arraybuffer"),
      "use-credentials" === this.options.crossOrigin &&
        this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const n = this,
      i = this.json,
      r = this.extensions;
    this.cache.removeAll(),
      this._invokeAll(function (e) {
        return e._markDefs && e._markDefs();
      }),
      Promise.all(
        this._invokeAll(function (e) {
          return e.beforeRoot && e.beforeRoot();
        })
      )
        .then(function () {
          return Promise.all([
            n.getDependencies("scene"),
            n.getDependencies("animation"),
            n.getDependencies("camera"),
          ]);
        })
        .then(function (t) {
          const s = {
            scene: t[0][i.scene || 0],
            scenes: t[0],
            animations: t[1],
            cameras: t[2],
            asset: i.asset,
            parser: n,
            userData: {},
          };
          fI(r, s, i),
            mI(s, i),
            Promise.all(
              n._invokeAll(function (e) {
                return e.afterRoot && e.afterRoot(s);
              })
            ).then(function () {
              e(s);
            });
        })
        .catch(t);
  }
  _markDefs() {
    const e = this.json.nodes || [],
      t = this.json.skins || [],
      n = this.json.meshes || [];
    for (let i = 0, r = t.length; i < r; i++) {
      const n = t[i].joints;
      for (let t = 0, i = n.length; t < i; t++) e[n[t]].isBone = !0;
    }
    for (let i = 0, r = e.length; i < r; i++) {
      const t = e[i];
      void 0 !== t.mesh &&
        (this._addNodeRef(this.meshCache, t.mesh),
        void 0 !== t.skin && (n[t.mesh].isSkinnedMesh = !0)),
        void 0 !== t.camera && this._addNodeRef(this.cameraCache, t.camera);
    }
  }
  _addNodeRef(e, t) {
    void 0 !== t &&
      (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  _getNodeRef(e, t, n) {
    if (e.refs[t] <= 1) return n;
    const i = n.clone();
    return (i.name += "_instance_" + e.uses[t]++), i;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let n = 0; n < t.length; n++) {
      const i = e(t[n]);
      if (i) return i;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const n = [];
    for (let i = 0; i < t.length; i++) {
      const r = e(t[i]);
      r && n.push(r);
    }
    return n;
  }
  getDependency(e, t) {
    const n = e + ":" + t;
    let i = this.cache.get(n);
    if (!i) {
      switch (e) {
        case "scene":
          i = this.loadScene(t);
          break;
        case "node":
          i = this.loadNode(t);
          break;
        case "mesh":
          i = this._invokeOne(function (e) {
            return e.loadMesh && e.loadMesh(t);
          });
          break;
        case "accessor":
          i = this.loadAccessor(t);
          break;
        case "bufferView":
          i = this._invokeOne(function (e) {
            return e.loadBufferView && e.loadBufferView(t);
          });
          break;
        case "buffer":
          i = this.loadBuffer(t);
          break;
        case "material":
          i = this._invokeOne(function (e) {
            return e.loadMaterial && e.loadMaterial(t);
          });
          break;
        case "texture":
          i = this._invokeOne(function (e) {
            return e.loadTexture && e.loadTexture(t);
          });
          break;
        case "skin":
          i = this.loadSkin(t);
          break;
        case "animation":
          i = this.loadAnimation(t);
          break;
        case "camera":
          i = this.loadCamera(t);
          break;
        default:
          throw new Error("Unknown type: " + e);
      }
      this.cache.add(n, i);
    }
    return i;
  }
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const n = this,
        i = this.json[e + ("mesh" === e ? "es" : "s")] || [];
      (t = Promise.all(
        i.map(function (t, i) {
          return n.getDependency(e, i);
        })
      )),
        this.cache.add(e, t);
    }
    return t;
  }
  loadBuffer(e) {
    const t = this.json.buffers[e],
      n = this.fileLoader;
    if (t.type && "arraybuffer" !== t.type)
      throw new Error(
        "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
      );
    if (void 0 === t.uri && 0 === e)
      return Promise.resolve(this.extensions[RL.KHR_BINARY_GLTF].body);
    const i = this.options;
    return new Promise(function (e, r) {
      n.load(pI(t.uri, i.path), e, void 0, function () {
        r(
          new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')
        );
      });
    });
  }
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function (e) {
      const n = t.byteLength || 0,
        i = t.byteOffset || 0;
      return e.slice(i, i + n);
    });
  }
  loadAccessor(e) {
    const t = this,
      n = this.json,
      i = this.json.accessors[e];
    if (void 0 === i.bufferView && void 0 === i.sparse)
      return Promise.resolve(null);
    const r = [];
    return (
      void 0 !== i.bufferView
        ? r.push(this.getDependency("bufferView", i.bufferView))
        : r.push(null),
      void 0 !== i.sparse &&
        (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)),
        r.push(this.getDependency("bufferView", i.sparse.values.bufferView))),
      Promise.all(r).then(function (e) {
        const r = e[0],
          s = aI[i.type],
          a = iI[i.componentType],
          o = a.BYTES_PER_ELEMENT,
          l = o * s,
          c = i.byteOffset || 0,
          u =
            void 0 !== i.bufferView
              ? n.bufferViews[i.bufferView].byteStride
              : void 0,
          h = !0 === i.normalized;
        let d, p;
        if (u && u !== l) {
          const e = Math.floor(c / u),
            n =
              "InterleavedBuffer:" +
              i.bufferView +
              ":" +
              i.componentType +
              ":" +
              e +
              ":" +
              i.count;
          let l = t.cache.get(n);
          l ||
            ((d = new a(r, e * u, (i.count * u) / o)),
            (l = new OT(d, u / o)),
            t.cache.add(n, l)),
            (p = new zT(l, s, (c % u) / o, h));
        } else (d = null === r ? new a(i.count * s) : new a(r, c, i.count * s)), (p = new Jb(d, s, h));
        if (void 0 !== i.sparse) {
          const t = aI.SCALAR,
            n = iI[i.sparse.indices.componentType],
            o = i.sparse.indices.byteOffset || 0,
            l = i.sparse.values.byteOffset || 0,
            c = new n(e[1], o, i.sparse.count * t),
            u = new a(e[2], l, i.sparse.count * s);
          null !== r && (p = new Jb(p.array.slice(), p.itemSize, p.normalized));
          for (let e = 0, i = c.length; e < i; e++) {
            const t = c[e];
            if (
              (p.setX(t, u[e * s]),
              s >= 2 && p.setY(t, u[e * s + 1]),
              s >= 3 && p.setZ(t, u[e * s + 2]),
              s >= 4 && p.setW(t, u[e * s + 3]),
              s >= 5)
            )
              throw new Error(
                "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
              );
          }
        }
        return p;
      })
    );
  }
  loadTexture(e) {
    const t = this.json,
      n = this.options,
      i = t.textures[e],
      r = t.images[i.source];
    let s = this.textureLoader;
    if (r.uri) {
      const e = n.manager.getHandler(r.uri);
      null !== e && (s = e);
    }
    return this.loadTextureImage(e, r, s);
  }
  loadTextureImage(e, t, n) {
    const i = this,
      r = this.json,
      s = this.options,
      a = r.textures[e],
      o = (t.uri || t.bufferView) + ":" + a.sampler;
    if (this.textureCache[o]) return this.textureCache[o];
    const l = self.URL || self.webkitURL;
    let c = t.uri || "",
      u = !1,
      h = !0;
    const d =
      c.search(/\.jpe?g($|\?)/i) > 0 || 0 === c.search(/^data\:image\/jpeg/);
    if (
      (("image/jpeg" === t.mimeType || d) && (h = !1), void 0 !== t.bufferView)
    )
      c = i.getDependency("bufferView", t.bufferView).then(function (e) {
        if ("image/png" === t.mimeType) {
          const t = new DataView(e, 25, 1).getUint8(0, !1);
          h = 6 === t || 4 === t || 3 === t;
        }
        u = !0;
        const n = new Blob([e], { type: t.mimeType });
        return (c = l.createObjectURL(n)), c;
      });
    else if (void 0 === t.uri)
      throw new Error(
        "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
      );
    const p = Promise.resolve(c)
      .then(function (e) {
        return new Promise(function (t, i) {
          let r = t;
          !0 === n.isImageBitmapLoader &&
            (r = function (e) {
              const n = new xx(e);
              (n.needsUpdate = !0), t(n);
            }),
            n.load(pI(e, s.path), r, void 0, i);
        });
      })
      .then(function (t) {
        !0 === u && l.revokeObjectURL(c),
          (t.flipY = !1),
          a.name && (t.name = a.name),
          h || (t.format = 1022);
        const n = (r.samplers || {})[a.sampler] || {};
        return (
          (t.magFilter = rI[n.magFilter] || 1006),
          (t.minFilter = rI[n.minFilter] || 1008),
          (t.wrapS = sI[n.wrapS] || 1e3),
          (t.wrapT = sI[n.wrapT] || 1e3),
          i.associations.set(t, { type: "textures", index: e }),
          t
        );
      })
      .catch(function () {
        return null;
      });
    return (this.textureCache[o] = p), p;
  }
  assignTexture(e, t, n) {
    const i = this;
    return this.getDependency("texture", n.index).then(function (r) {
      if (
        (void 0 !== n.texCoord &&
          0 != n.texCoord &&
          ("aoMap" !== t || n.texCoord),
        i.extensions[RL.KHR_TEXTURE_TRANSFORM])
      ) {
        const e =
          void 0 !== n.extensions
            ? n.extensions[RL.KHR_TEXTURE_TRANSFORM]
            : void 0;
        if (e) {
          const t = i.associations.get(r);
          (r = i.extensions[RL.KHR_TEXTURE_TRANSFORM].extendTexture(r, e)),
            i.associations.set(r, t);
        }
      }
      e[t] = r;
    });
  }
  assignFinalMaterial(e) {
    const t = e.geometry;
    let n = e.material;
    const i = void 0 !== t.attributes.tangent,
      r = void 0 !== t.attributes.color,
      s = void 0 === t.attributes.normal,
      a = Object.keys(t.morphAttributes).length > 0,
      o = a && void 0 !== t.morphAttributes.normal;
    if (e.isPoints) {
      const e = "PointsMaterial:" + n.uuid;
      let t = this.cache.get(e);
      t ||
        ((t = new pC()),
        Vb.prototype.copy.call(t, n),
        t.color.copy(n.color),
        (t.map = n.map),
        (t.sizeAttenuation = !1),
        this.cache.add(e, t)),
        (n = t);
    } else if (e.isLine) {
      const e = "LineBasicMaterial:" + n.uuid;
      let t = this.cache.get(e);
      t ||
        ((t = new nC()),
        Vb.prototype.copy.call(t, n),
        t.color.copy(n.color),
        this.cache.add(e, t)),
        (n = t);
    }
    if (i || r || s || a) {
      let e = "ClonedMaterial:" + n.uuid + ":";
      n.isGLTFSpecularGlossinessMaterial && (e += "specular-glossiness:"),
        i && (e += "vertex-tangents:"),
        r && (e += "vertex-colors:"),
        s && (e += "flat-shading:"),
        a && (e += "morph-targets:"),
        o && (e += "morph-normals:");
      let t = this.cache.get(e);
      t ||
        ((t = n.clone()),
        r && (t.vertexColors = !0),
        s && (t.flatShading = !0),
        a && (t.morphTargets = !0),
        o && (t.morphNormals = !0),
        i &&
          ((t.vertexTangents = !0),
          t.normalScale && (t.normalScale.y *= -1),
          t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)),
        this.cache.add(e, t),
        this.associations.set(t, this.associations.get(n))),
        (n = t);
    }
    n.aoMap &&
      void 0 === t.attributes.uv2 &&
      void 0 !== t.attributes.uv &&
      t.setAttribute("uv2", t.attributes.uv),
      (e.material = n);
  }
  getMaterialType() {
    return BC;
  }
  loadMaterial(e) {
    const t = this,
      n = this.json,
      i = this.extensions,
      r = n.materials[e];
    let s;
    const a = {},
      o = r.extensions || {},
      l = [];
    if (o[RL.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
      const e = i[RL.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
      (s = e.getMaterialType()), l.push(e.extendParams(a, r, t));
    } else if (o[RL.KHR_MATERIALS_UNLIT]) {
      const e = i[RL.KHR_MATERIALS_UNLIT];
      (s = e.getMaterialType()), l.push(e.extendParams(a, r, t));
    } else {
      const n = r.pbrMetallicRoughness || {};
      if (
        ((a.color = new Xb(1, 1, 1)),
        (a.opacity = 1),
        Array.isArray(n.baseColorFactor))
      ) {
        const e = n.baseColorFactor;
        a.color.fromArray(e), (a.opacity = e[3]);
      }
      void 0 !== n.baseColorTexture &&
        l.push(t.assignTexture(a, "map", n.baseColorTexture)),
        (a.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1),
        (a.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1),
        void 0 !== n.metallicRoughnessTexture &&
          (l.push(
            t.assignTexture(a, "metalnessMap", n.metallicRoughnessTexture)
          ),
          l.push(
            t.assignTexture(a, "roughnessMap", n.metallicRoughnessTexture)
          )),
        (s = this._invokeOne(function (t) {
          return t.getMaterialType && t.getMaterialType(e);
        })),
        l.push(
          Promise.all(
            this._invokeAll(function (t) {
              return t.extendMaterialParams && t.extendMaterialParams(e, a);
            })
          )
        );
    }
    !0 === r.doubleSided && (a.side = 2);
    const c = r.alphaMode || uI;
    return (
      c === dI
        ? ((a.transparent = !0), (a.depthWrite = !1))
        : ((a.transparent = !1),
          c === hI &&
            (a.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : 0.5)),
      void 0 !== r.normalTexture &&
        s !== $b &&
        (l.push(t.assignTexture(a, "normalMap", r.normalTexture)),
        (a.normalScale = new fx(1, -1)),
        void 0 !== r.normalTexture.scale &&
          a.normalScale.set(r.normalTexture.scale, -r.normalTexture.scale)),
      void 0 !== r.occlusionTexture &&
        s !== $b &&
        (l.push(t.assignTexture(a, "aoMap", r.occlusionTexture)),
        void 0 !== r.occlusionTexture.strength &&
          (a.aoMapIntensity = r.occlusionTexture.strength)),
      void 0 !== r.emissiveFactor &&
        s !== $b &&
        (a.emissive = new Xb().fromArray(r.emissiveFactor)),
      void 0 !== r.emissiveTexture &&
        s !== $b &&
        l.push(t.assignTexture(a, "emissiveMap", r.emissiveTexture)),
      Promise.all(l).then(function () {
        let n;
        return (
          (n =
            s === jL
              ? i[RL.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a)
              : new s(a)),
          r.name && (n.name = r.name),
          n.map && (n.map.encoding = 3001),
          n.emissiveMap && (n.emissiveMap.encoding = 3001),
          mI(n, r),
          t.associations.set(n, { type: "materials", index: e }),
          r.extensions && fI(i, n, r),
          n
        );
      })
    );
  }
  createUniqueName(e) {
    const t = FE.sanitizeNodeName(e || "");
    let n = t;
    for (let i = 1; this.nodeNamesUsed[n]; ++i) n = t + "_" + i;
    return (this.nodeNamesUsed[n] = !0), n;
  }
  loadGeometries(e) {
    const t = this,
      n = this.extensions,
      i = this.primitiveCache;
    function r(e) {
      return n[RL.KHR_DRACO_MESH_COMPRESSION]
        .decodePrimitive(e, t)
        .then(function (n) {
          return wI(n, e, t);
        });
    }
    const s = [];
    for (let a = 0, o = e.length; a < o; a++) {
      const n = e[a],
        o = vI(n),
        l = i[o];
      if (l) s.push(l.promise);
      else {
        let e;
        (e =
          n.extensions && n.extensions[RL.KHR_DRACO_MESH_COMPRESSION]
            ? r(n)
            : wI(new uw(), n, t)),
          (i[o] = { primitive: n, promise: e }),
          s.push(e);
      }
    }
    return Promise.all(s);
  }
  loadMesh(e) {
    const t = this,
      n = this.json,
      i = this.extensions,
      r = n.meshes[e],
      s = r.primitives,
      a = [];
    for (let l = 0, c = s.length; l < c; l++) {
      const e =
        void 0 === s[l].material
          ? (void 0 === (o = this.cache).DefaultMaterial &&
              (o.DefaultMaterial = new BC({
                color: 16777215,
                emissive: 0,
                metalness: 1,
                roughness: 1,
                transparent: !1,
                depthTest: !0,
                side: 0,
              })),
            o.DefaultMaterial)
          : this.getDependency("material", s[l].material);
      a.push(e);
    }
    var o;
    return (
      a.push(t.loadGeometries(s)),
      Promise.all(a).then(function (n) {
        const a = n.slice(0, n.length - 1),
          o = n[n.length - 1],
          l = [];
        for (let u = 0, h = o.length; u < h; u++) {
          const n = o[u],
            c = s[u];
          let h;
          const d = a[u];
          if (
            c.mode === eI ||
            c.mode === tI ||
            c.mode === nI ||
            void 0 === c.mode
          )
            (h = !0 === r.isSkinnedMesh ? new WT(n, d) : new Aw(n, d)),
              !0 !== h.isSkinnedMesh ||
                h.geometry.attributes.skinWeight.normalized ||
                h.normalizeSkinWeights(),
              c.mode === tI
                ? (h.geometry = SI(h.geometry, 1))
                : c.mode === nI && (h.geometry = SI(h.geometry, 2));
          else if (c.mode === KL) h = new hC(n, d);
          else if (c.mode === QL) h = new lC(n, d);
          else if (c.mode === JL) h = new dC(n, d);
          else {
            if (c.mode !== ZL)
              throw new Error(
                "THREE.GLTFLoader: Primitive mode unsupported: " + c.mode
              );
            h = new _C(n, d);
          }
          Object.keys(h.geometry.morphAttributes).length > 0 && gI(h, r),
            (h.name = t.createUniqueName(r.name || "mesh_" + e)),
            mI(h, r),
            c.extensions && fI(i, h, c),
            t.assignFinalMaterial(h),
            l.push(h);
        }
        if (1 === l.length) return l[0];
        const c = new AT();
        for (let e = 0, t = l.length; e < t; e++) c.add(l[e]);
        return c;
      })
    );
  }
  loadCamera(e) {
    let t;
    const n = this.json.cameras[e],
      i = n[n.type];
    if (i)
      return (
        "perspective" === n.type
          ? (t = new Ow(
              i.yfov * ax,
              i.aspectRatio || 1,
              i.znear || 1,
              i.zfar || 2e6
            ))
          : "orthographic" === n.type &&
            (t = new sS(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)),
        n.name && (t.name = this.createUniqueName(n.name)),
        mI(t, n),
        Promise.resolve(t)
      );
  }
  loadSkin(e) {
    const t = this.json.skins[e],
      n = { joints: t.joints };
    return void 0 === t.inverseBindMatrices
      ? Promise.resolve(n)
      : this.getDependency("accessor", t.inverseBindMatrices).then(function (
          e
        ) {
          return (n.inverseBindMatrices = e), n;
        });
  }
  loadAnimation(e) {
    const t = this.json.animations[e],
      n = [],
      i = [],
      r = [],
      s = [],
      a = [];
    for (let o = 0, l = t.channels.length; o < l; o++) {
      const e = t.channels[o],
        l = t.samplers[e.sampler],
        c = e.target,
        u = void 0 !== c.node ? c.node : c.id,
        h = void 0 !== t.parameters ? t.parameters[l.input] : l.input,
        d = void 0 !== t.parameters ? t.parameters[l.output] : l.output;
      n.push(this.getDependency("node", u)),
        i.push(this.getDependency("accessor", h)),
        r.push(this.getDependency("accessor", d)),
        s.push(l),
        a.push(c);
    }
    return Promise.all([
      Promise.all(n),
      Promise.all(i),
      Promise.all(r),
      Promise.all(s),
      Promise.all(a),
    ]).then(function (n) {
      const i = n[0],
        r = n[1],
        s = n[2],
        a = n[3],
        o = n[4],
        l = [];
      for (let e = 0, t = i.length; e < t; e++) {
        const t = i[e],
          n = r[e],
          c = s[e],
          u = a[e],
          h = o[e];
        if (void 0 === t) continue;
        let d;
        switch ((t.updateMatrix(), (t.matrixAutoUpdate = !0), lI[h.path])) {
          case lI.weights:
            d = KC;
            break;
          case lI.rotation:
            d = QC;
            break;
          default:
            d = tE;
        }
        const p = t.name ? t.name : t.uuid,
          f = void 0 !== u.interpolation ? cI[u.interpolation] : 2301,
          m = [];
        lI[h.path] === lI.weights
          ? t.traverse(function (e) {
              !0 === e.isMesh &&
                e.morphTargetInfluences &&
                m.push(e.name ? e.name : e.uuid);
            })
          : m.push(p);
        let g = c.array;
        if (c.normalized) {
          const e = yI(g.constructor),
            t = new Float32Array(g.length);
          for (let n = 0, i = g.length; n < i; n++) t[n] = g[n] * e;
          g = t;
        }
        for (let e = 0, i = m.length; e < i; e++) {
          const t = new d(m[e] + "." + lI[h.path], n.array, g, f);
          "CUBICSPLINE" === u.interpolation &&
            ((t.createInterpolant = function (e) {
              return new $L(
                this.times,
                this.values,
                this.getValueSize() / 3,
                e
              );
            }),
            (t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
              !0)),
            l.push(t);
        }
      }
      const c = t.name ? t.name : "animation_" + e;
      return new nE(c, void 0, l);
    });
  }
  createNodeMesh(e) {
    const t = this.json,
      n = this,
      i = t.nodes[e];
    return void 0 === i.mesh
      ? null
      : n.getDependency("mesh", i.mesh).then(function (e) {
          const t = n._getNodeRef(n.meshCache, i.mesh, e);
          return (
            void 0 !== i.weights &&
              t.traverse(function (e) {
                if (e.isMesh)
                  for (let t = 0, n = i.weights.length; t < n; t++)
                    e.morphTargetInfluences[t] = i.weights[t];
              }),
            t
          );
        });
  }
  loadNode(e) {
    const t = this.json,
      n = this.extensions,
      i = this,
      r = t.nodes[e],
      s = r.name ? i.createUniqueName(r.name) : "";
    return (function () {
      const t = [],
        n = i._invokeOne(function (t) {
          return t.createNodeMesh && t.createNodeMesh(e);
        });
      return (
        n && t.push(n),
        void 0 !== r.camera &&
          t.push(
            i.getDependency("camera", r.camera).then(function (e) {
              return i._getNodeRef(i.cameraCache, r.camera, e);
            })
          ),
        i
          ._invokeAll(function (t) {
            return t.createNodeAttachment && t.createNodeAttachment(e);
          })
          .forEach(function (e) {
            t.push(e);
          }),
        Promise.all(t)
      );
    })().then(function (t) {
      let a;
      if (
        ((a =
          !0 === r.isBone
            ? new qT()
            : t.length > 1
            ? new AT()
            : 1 === t.length
            ? t[0]
            : new Ab()),
        a !== t[0])
      )
        for (let e = 0, n = t.length; e < n; e++) a.add(t[e]);
      if (
        (r.name && ((a.userData.name = r.name), (a.name = s)),
        mI(a, r),
        r.extensions && fI(n, a, r),
        void 0 !== r.matrix)
      ) {
        const e = new ib();
        e.fromArray(r.matrix), a.applyMatrix4(e);
      } else void 0 !== r.translation && a.position.fromArray(r.translation), void 0 !== r.rotation && a.quaternion.fromArray(r.rotation), void 0 !== r.scale && a.scale.fromArray(r.scale);
      return i.associations.set(a, { type: "nodes", index: e }), a;
    });
  }
  loadScene(e) {
    const t = this.json,
      n = this.extensions,
      i = this.json.scenes[e],
      r = this,
      s = new AT();
    i.name && (s.name = r.createUniqueName(i.name)),
      mI(s, i),
      i.extensions && fI(n, s, i);
    const a = i.nodes || [],
      o = [];
    for (let l = 0, c = a.length; l < c; l++) o.push(bI(a[l], s, t, r));
    return Promise.all(o).then(function () {
      return s;
    });
  }
}
function bI(e, t, n, i) {
  const r = n.nodes[e];
  return i
    .getDependency("node", e)
    .then(function (e) {
      if (void 0 === r.skin) return e;
      let t;
      return i
        .getDependency("skin", r.skin)
        .then(function (e) {
          t = e;
          const n = [];
          for (let r = 0, s = t.joints.length; r < s; r++)
            n.push(i.getDependency("node", t.joints[r]));
          return Promise.all(n);
        })
        .then(function (n) {
          return (
            e.traverse(function (e) {
              if (!e.isMesh) return;
              const i = [],
                r = [];
              for (let s = 0, a = n.length; s < a; s++) {
                const e = n[s];
                if (e) {
                  i.push(e);
                  const n = new ib();
                  void 0 !== t.inverseBindMatrices &&
                    n.fromArray(t.inverseBindMatrices.array, 16 * s),
                    r.push(n);
                }
              }
              e.bind(new $T(i, r), e.matrixWorld);
            }),
            e
          );
        });
    })
    .then(function (e) {
      t.add(e);
      const s = [];
      if (r.children) {
        const t = r.children;
        for (let r = 0, a = t.length; r < a; r++) {
          const a = t[r];
          s.push(bI(a, e, n, i));
        }
      }
      return Promise.all(s);
    });
}
function wI(e, t, n) {
  const i = t.attributes,
    r = [];
  function s(t, i) {
    return n.getDependency("accessor", t).then(function (t) {
      e.setAttribute(i, t);
    });
  }
  for (const a in i) {
    const t = oI[a] || a.toLowerCase();
    t in e.attributes || r.push(s(i[a], t));
  }
  if (void 0 !== t.indices && !e.index) {
    const i = n.getDependency("accessor", t.indices).then(function (t) {
      e.setIndex(t);
    });
    r.push(i);
  }
  return (
    mI(e, t),
    (function (e, t, n) {
      const i = t.attributes,
        r = new Px();
      if (void 0 === i.POSITION) return;
      {
        const e = n.json.accessors[i.POSITION],
          t = e.min,
          s = e.max;
        if (void 0 === t || void 0 === s) return;
        if (
          (r.set(new Cx(t[0], t[1], t[2]), new Cx(s[0], s[1], s[2])),
          e.normalized)
        ) {
          const t = yI(iI[e.componentType]);
          r.min.multiplyScalar(t), r.max.multiplyScalar(t);
        }
      }
      const s = t.targets;
      if (void 0 !== s) {
        const e = new Cx(),
          t = new Cx();
        for (let i = 0, r = s.length; i < r; i++) {
          const r = s[i];
          if (void 0 !== r.POSITION) {
            const i = n.json.accessors[r.POSITION],
              s = i.min,
              a = i.max;
            if (void 0 !== s && void 0 !== a) {
              if (
                (t.setX(Math.max(Math.abs(s[0]), Math.abs(a[0]))),
                t.setY(Math.max(Math.abs(s[1]), Math.abs(a[1]))),
                t.setZ(Math.max(Math.abs(s[2]), Math.abs(a[2]))),
                i.normalized)
              ) {
                const e = yI(iI[i.componentType]);
                t.multiplyScalar(e);
              }
              e.max(t);
            }
          }
        }
        r.expandByVector(e);
      }
      e.boundingBox = r;
      const a = new Xx();
      r.getCenter(a.center),
        (a.radius = r.min.distanceTo(r.max) / 2),
        (e.boundingSphere = a);
    })(e, t, n),
    Promise.all(r).then(function () {
      return void 0 !== t.targets
        ? (function (e, t, n) {
            let i = !1,
              r = !1;
            for (let o = 0, l = t.length; o < l; o++) {
              const e = t[o];
              if (
                (void 0 !== e.POSITION && (i = !0),
                void 0 !== e.NORMAL && (r = !0),
                i && r)
              )
                break;
            }
            if (!i && !r) return Promise.resolve(e);
            const s = [],
              a = [];
            for (let o = 0, l = t.length; o < l; o++) {
              const l = t[o];
              if (i) {
                const t =
                  void 0 !== l.POSITION
                    ? n.getDependency("accessor", l.POSITION)
                    : e.attributes.position;
                s.push(t);
              }
              if (r) {
                const t =
                  void 0 !== l.NORMAL
                    ? n.getDependency("accessor", l.NORMAL)
                    : e.attributes.normal;
                a.push(t);
              }
            }
            return Promise.all([Promise.all(s), Promise.all(a)]).then(function (
              t
            ) {
              const n = t[0],
                s = t[1];
              return (
                i && (e.morphAttributes.position = n),
                r && (e.morphAttributes.normal = s),
                (e.morphTargetsRelative = !0),
                e
              );
            });
          })(e, t.targets, n)
        : e;
    })
  );
}
function SI(e, t) {
  let n = e.getIndex();
  if (null === n) {
    const t = [],
      i = e.getAttribute("position");
    if (void 0 === i) return e;
    for (let e = 0; e < i.count; e++) t.push(e);
    e.setIndex(t), (n = e.getIndex());
  }
  const i = n.count - 2,
    r = [];
  if (2 === t)
    for (let a = 1; a <= i; a++)
      r.push(n.getX(0)), r.push(n.getX(a)), r.push(n.getX(a + 1));
  else
    for (let a = 0; a < i; a++)
      a % 2 == 0
        ? (r.push(n.getX(a)), r.push(n.getX(a + 1)), r.push(n.getX(a + 2)))
        : (r.push(n.getX(a + 2)), r.push(n.getX(a + 1)), r.push(n.getX(a)));
  r.length;
  const s = e.clone();
  return s.setIndex(r), s;
}
const MI = new (class extends aE {
  constructor(e) {
    super(e),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (e) {
        return new NL(e);
      }),
      this.register(function (e) {
        return new FL(e);
      }),
      this.register(function (e) {
        return new zL(e);
      }),
      this.register(function (e) {
        return new OL(e);
      }),
      this.register(function (e) {
        return new DL(e);
      }),
      this.register(function (e) {
        return new UL(e);
      });
  }
  load(e, t, n, i) {
    const r = this;
    let s;
    (s =
      "" !== this.resourcePath
        ? this.resourcePath
        : "" !== this.path
        ? this.path
        : CE.extractUrlBase(e)),
      this.manager.itemStart(e);
    const a = function (t) {
        i && i(t), r.manager.itemError(e), r.manager.itemEnd(e);
      },
      o = new lE(this.manager);
    o.setPath(this.path),
      o.setResponseType("arraybuffer"),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (n) {
          try {
            r.parse(
              n,
              s,
              function (n) {
                t(n), r.manager.itemEnd(e);
              },
              a
            );
          } catch (i) {
            a(i);
          }
        },
        n,
        a
      );
  }
  setDRACOLoader(e) {
    return (this.dracoLoader = e), this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return (this.ktx2Loader = e), this;
  }
  setMeshoptDecoder(e) {
    return (this.meshoptDecoder = e), this;
  }
  register(e) {
    return (
      -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e),
      this
    );
  }
  unregister(e) {
    return (
      -1 !== this.pluginCallbacks.indexOf(e) &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
      this
    );
  }
  parse(e, t, n, i) {
    let r;
    const s = {},
      a = {};
    if ("string" == typeof e) r = e;
    else {
      if (CE.decodeText(new Uint8Array(e, 0, 4)) === BL) {
        try {
          s[RL.KHR_BINARY_GLTF] = new GL(e);
        } catch (c) {
          return void (i && i(c));
        }
        r = s[RL.KHR_BINARY_GLTF].content;
      } else r = CE.decodeText(new Uint8Array(e));
    }
    const o = JSON.parse(r);
    if (void 0 === o.asset || o.asset.version[0] < 2)
      return void (
        i &&
        i(
          new Error(
            "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
          )
        )
      );
    const l = new xI(o, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    });
    l.fileLoader.setRequestHeader(this.requestHeader);
    for (let u = 0; u < this.pluginCallbacks.length; u++) {
      const e = this.pluginCallbacks[u](l);
      (a[e.name] = e), (s[e.name] = !0);
    }
    if (o.extensionsUsed)
      for (let u = 0; u < o.extensionsUsed.length; ++u) {
        const e = o.extensionsUsed[u],
          t = o.extensionsRequired || [];
        switch (e) {
          case RL.KHR_MATERIALS_UNLIT:
            s[e] = new kL();
            break;
          case RL.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
            s[e] = new YL();
            break;
          case RL.KHR_DRACO_MESH_COMPRESSION:
            s[e] = new WL(o, this.dracoLoader);
            break;
          case RL.KHR_TEXTURE_TRANSFORM:
            s[e] = new qL();
            break;
          case RL.KHR_MESH_QUANTIZATION:
            s[e] = new XL();
            break;
          default:
            t.indexOf(e) >= 0 && a[e];
        }
      }
    l.setExtensions(s), l.setPlugins(a), l.parse(n, i);
  }
})();
async function TI(e, t = {}) {
  return new Promise((n, i) => {
    MI.load(
      e,
      (i) => {
        CL.add(e, i), t.onLoad && t.onLoad(i), n(i);
      },
      () => {},
      i
    );
  });
}
async function CI(e, t = {}) {
  const n = await fetch(e),
    i = await n.json();
  return CL.add(e, i), t.onLoad && t.onLoad(i), i;
}
function EI(e, t, n, i = 0) {
  const r = t.size,
    s = t.scale / Math.max(r.w, r.h),
    a = {},
    o = e.anchor || e.pivot || { x: 0.5, y: 0.5 };
  "hint" === n.split("_")[0] && ((o.x = 0), (o.y = 0));
  const l = e.frame,
    c = e.sourceSize,
    u = e.spriteSourceSize;
  a.id = n;
  const h = n.split("/");
  (a.sequence = h.pop()),
    (a.group = h.join("/")),
    (a.frameIndex = i),
    (a.texCoords = new Float32Array([
      l.x / r.w,
      (r.h - l.y - l.h) / r.h,
      l.w / r.w,
      l.h / r.h,
    ])),
    (a.meshCoords = new Float32Array([
      0.5 * u.w + u.x - c.w * o.x,
      -(0.5 * u.h + u.y - c.h * o.y),
      u.w,
      u.h,
    ]));
  for (let d = 0, p = a.meshCoords.length; d < p; d++) a.meshCoords[d] *= s;
  return (
    (a.anchor = o),
    (a.sourceSize = e.sourceSize),
    (a.spriteSourceSize = e.spriteSourceSize),
    (a.vertices = e.vertices),
    (a.verticesUV = e.verticesUV),
    (a.triangles = e.triangles),
    a
  );
}
(TI.setDRACOLoader = (e) => MI.setDRACOLoader(e)),
  (TI.loader = { name: "gltf", extensions: [".gltf", ".glb"], function: TI }),
  (CI.loader = { name: "json", extensions: [".json"], function: CI });
var AI = Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default: "/assets/nx.d415b4ef274a7243.avif",
  }),
  PI = Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default: "/assets/ny.43e25496274a7243.avif",
  }),
  LI = Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default: "/assets/nz.d3e9e244274a7243.avif",
  }),
  II = Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default: "/assets/px.344dbb21274a7243.avif",
  }),
  RI = Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default: "/assets/py.dcc357b9274a7243.avif",
  }),
  DI = Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default: "/assets/pz.6fb954e1274a7243.avif",
  }),
  kI = Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default: "/assets/nx.f9e72b50274a7243.webp",
  }),
  NI = Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default: "/assets/ny.7c4a5e3a274a7243.webp",
  }),
  OI = Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default: "/assets/nz.c2966f23274a7243.webp",
  }),
  FI = Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default: "/assets/px.0e95ae72274a7243.webp",
  }),
  zI = Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default: "/assets/py.80936952274a7243.webp",
  }),
  UI = Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default: "/assets/pz.fbb1f069274a7243.webp",
  }),
  BI = Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default: "/assets/nx.d00b0222274a7243.jpg",
  }),
  VI = Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default: "/assets/ny.7547b99b274a7243.jpg",
  }),
  HI = Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default: "/assets/nz.d8dc138b274a7243.jpg",
  }),
  GI = Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default: "/assets/px.104b0f3c274a7243.jpg",
  }),
  WI = Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default: "/assets/py.7137228c274a7243.jpg",
  }),
  qI = Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default: "/assets/pz.e8eabcfe274a7243.jpg",
  });
function jI(e, t = {}, n, i) {
  for (const r in e) {
    let s = r.split("/").pop().split(".").slice(0, -1).join(".");
    i && (s = i(s)),
      n
        ? (t[s] || (t[s] = {}), (t[s][n] = e[r].default))
        : (t[s] = e[r].default);
  }
}
const YI = {},
  XI = (e, t, n, i) => (YI[e] = { default: t, webp: n, avif: i }),
  $I = (YI.envmap = {});
jI(
  {
    "/src/assets/scene/envmap/nx.jpg": BI,
    "/src/assets/scene/envmap/ny.jpg": VI,
    "/src/assets/scene/envmap/nz.jpg": HI,
    "/src/assets/scene/envmap/px.jpg": GI,
    "/src/assets/scene/envmap/py.jpg": WI,
    "/src/assets/scene/envmap/pz.jpg": qI,
  },
  $I,
  "default"
),
  jI(
    {
      "/src/assets/scene/envmap/nx.webp": kI,
      "/src/assets/scene/envmap/ny.webp": NI,
      "/src/assets/scene/envmap/nz.webp": OI,
      "/src/assets/scene/envmap/px.webp": FI,
      "/src/assets/scene/envmap/py.webp": zI,
      "/src/assets/scene/envmap/pz.webp": UI,
    },
    $I,
    "webp"
  ),
  jI(
    {
      "/src/assets/scene/envmap/nx.avif": AI,
      "/src/assets/scene/envmap/ny.avif": PI,
      "/src/assets/scene/envmap/nz.avif": LI,
      "/src/assets/scene/envmap/px.avif": II,
      "/src/assets/scene/envmap/py.avif": RI,
      "/src/assets/scene/envmap/pz.avif": DI,
    },
    $I,
    "avif"
  ),
  XI(
    "sprites",
    "/assets/sprites.48581f03274a7243.jpg",
    "/assets/sprites.49a11731274a7243.webp",
    "/assets/sprites.d60fd3d4274a7243.avif"
  ),
  XI("bluenoise", "/assets/bluenoise.5c5463f0274a7243.png"),
  XI(
    "matcaps",
    "/assets/matcaps.12ef257a274a7243.jpg",
    "/assets/matcaps.d31cc084274a7243.webp",
    "/assets/matcaps.5e59986f274a7243.avif"
  ),
  XI(
    "bokeh",
    "/assets/bokeh_overlay.d509a5b1274a7243.jpg",
    "/assets/bokeh_overlay.0ab604e7274a7243.webp",
    "/assets/bokeh_overlay.7c87d4c3274a7243.avif"
  ),
  XI("flakes", "/assets/flakes_256.fdf868cc274a7243.png"),
  XI("carData", "/assets/car_data.f5aa5435274a7243.png"),
  XI(
    "roadDiffuse",
    "/assets/road_diffuse.94c7099e274a7243.jpg",
    "/assets/road_diffuse.cc0a0797274a7243.webp"
  ),
  XI("roadData", "/assets/road_data.b87b1527274a7243.png"),
  XI(
    "structureDiffuse",
    "/assets/structure_diffuse.1ae6f1a9274a7243.jpg",
    "/assets/structure_diffuse.27067941274a7243.webp",
    "/assets/structure_diffuse.58ce280f274a7243.avif"
  ),
  XI("structureData", "/assets/structure_data.896cea23274a7243.png"),
  (YI.sceneModel = "/assets/scene.42f4fab8274a7243.glb"),
  (YI.sceneModelDraco = "/assets/scene.drc.af74d8ad274a7243.glb"),
  (YI.roadCurveData = "/assets/road.1999f759274a7243.dat"),
  (YI.framesData = "/assets/positions.3bb996d1274a7243.dat"),
  (YI.spritesData = "/assets/sprites.e45dc30e274a7243.json");
var ZI = YI;
const KI = new HC(),
  JI = (e, t) => (
    t.position.copy(e.position),
    t.quaternion.copy(e.quaternion),
    t.scale.copy(e.scale),
    t.updateMatrix(),
    t
  ),
  QI = new Ab();
const eR = function (e) {
  const t = new aE(e);
  Object.assign(this, t),
    (this.decoderPath = ""),
    (this.decoderConfig = {}),
    (this.decoderBinary = null),
    (this.decoderPending = null),
    (this.workerLimit = 4),
    (this.workerPool = []),
    (this.workerNextTaskID = 1),
    (this.workerSourceURL = ""),
    (this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD",
    }),
    (this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array",
    });
};
(eR.prototype = Object.assign(Object.create(aE.prototype), {
  constructor: eR,
  setDecoderPath: function (e) {
    return (this.decoderPath = e), this;
  },
  setDecoderConfig: function (e) {
    return (this.decoderConfig = e), this;
  },
  setWorkerLimit: function (e) {
    return (this.workerLimit = e), this;
  },
  load: function (e, t, n, i) {
    const r = new lE(this.manager);
    r.setPath(this.path),
      r.setResponseType("arraybuffer"),
      "use-credentials" === this.crossOrigin && r.setWithCredentials(!0),
      r.load(
        e,
        (e) => {
          const n = {
            attributeIDs: this.defaultAttributeIDs,
            attributeTypes: this.defaultAttributeTypes,
            useUniqueIDs: !1,
          };
          this.decodeGeometry(e, n).then(t).catch(i);
        },
        n,
        i
      );
  },
  decodeDracoFile: function (e, t, n, i) {
    const r = {
      attributeIDs: n || this.defaultAttributeIDs,
      attributeTypes: i || this.defaultAttributeTypes,
      useUniqueIDs: !!n,
    };
    this.decodeGeometry(e, r).then(t);
  },
  decodeGeometry: function (e, t) {
    for (const o in t.attributeTypes) {
      const e = t.attributeTypes[o];
      void 0 !== e.BYTES_PER_ELEMENT && (t.attributeTypes[o] = e.name);
    }
    const n = JSON.stringify(t);
    if (eR.taskCache.has(e)) {
      const t = eR.taskCache.get(e);
      if (t.key === n) return t.promise;
      if (0 === e.byteLength)
        throw new Error(
          "DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let i;
    const r = this.workerNextTaskID++,
      s = e.byteLength,
      a = this._getWorker(r, s)
        .then(
          (n) => (
            (i = n),
            new Promise((n, s) => {
              (i._callbacks[r] = { resolve: n, reject: s }),
                i.postMessage(
                  { type: "decode", id: r, taskConfig: t, buffer: e },
                  [e]
                );
            })
          )
        )
        .then((e) => this._createGeometry(e.geometry));
    return (
      a.finally(() => {
        i && r && this._releaseTask(i, r);
      }),
      eR.taskCache.set(e, { key: n, promise: a }),
      a
    );
  },
  _createGeometry: function (e) {
    const t = new uw();
    e.index && t.setIndex(new Jb(e.index.array, 1));
    for (let n = 0; n < e.attributes.length; n++) {
      const i = e.attributes[n],
        r = i.name,
        s = i.array,
        a = i.itemSize;
      t.setAttribute(r, new Jb(s, a));
    }
    return t;
  },
  _loadLibrary: function (e, t) {
    const n = new lE(this.manager);
    return (
      n.setPath(this.decoderPath),
      n.setResponseType(t),
      new Promise((t, i) => {
        n.load(e, t, void 0, i);
      })
    );
  },
  preload: function () {
    return this._initDecoder(), this;
  },
  _initDecoder: function () {
    if (this.decoderPending) return this.decoderPending;
    const e =
        "object" != typeof WebAssembly || "js" === this.decoderConfig.type,
      t = [];
    return (
      e
        ? t.push(this._loadLibrary("draco_decoder.js", "text"))
        : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
          t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
      (this.decoderPending = Promise.all(t).then((t) => {
        const n = t[0];
        e || (this.decoderConfig.wasmBinary = t[1]);
        const i = eR.DRACOWorker.toString(),
          r = [
            "/* draco decoder */",
            n,
            "",
            "/* worker */",
            i.substring(i.indexOf("{") + 1, i.lastIndexOf("}")),
          ].join("\n");
        this.workerSourceURL = URL.createObjectURL(new Blob([r]));
      })),
      this.decoderPending
    );
  },
  _getWorker: function (e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const e = new Worker(this.workerSourceURL);
        (e._callbacks = {}),
          (e._taskCosts = {}),
          (e._taskLoad = 0),
          e.postMessage({ type: "init", decoderConfig: this.decoderConfig }),
          (e.onmessage = function (t) {
            const n = t.data;
            switch (n.type) {
              case "decode":
                e._callbacks[n.id].resolve(n);
                break;
              case "error":
                e._callbacks[n.id].reject(n);
            }
          }),
          this.workerPool.push(e);
      } else
        this.workerPool.sort(function (e, t) {
          return e._taskLoad > t._taskLoad ? -1 : 1;
        });
      const n = this.workerPool[this.workerPool.length - 1];
      return (n._taskCosts[e] = t), (n._taskLoad += t), n;
    });
  },
  _releaseTask: function (e, t) {
    (e._taskLoad -= e._taskCosts[t]),
      delete e._callbacks[t],
      delete e._taskCosts[t];
  },
  dispose: function () {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return (this.workerPool.length = 0), this;
  },
})),
  (eR.DRACOWorker = function () {
    let e, t;
    function n(e, t, n, i, r, s) {
      const a = s.num_components(),
        o = n.num_points() * a;
      let l, c, u;
      switch (r) {
        case Float32Array:
          (u = 4 * o),
            (l = e._malloc(u)),
            t.GetAttributeDataArrayForAllPoints(n, s, e.DT_FLOAT32, u, l),
            (c = new Float32Array(e.HEAPF32.buffer, l, o).slice()),
            e._free(l);
          break;
        case Int8Array:
          (l = e._malloc(o)),
            t.GetAttributeDataArrayForAllPoints(n, s, e.DT_INT8, o, l),
            (c = new Int8Array(e.HEAP8.buffer, l, o).slice()),
            e._free(l);
          break;
        case Int16Array:
          (u = 2 * o),
            (l = e._malloc(u)),
            t.GetAttributeDataArrayForAllPoints(n, s, e.DT_INT16, u, l),
            (c = new Int16Array(e.HEAP16.buffer, l, o).slice()),
            e._free(l);
          break;
        case Int32Array:
          (u = 4 * o),
            (l = e._malloc(u)),
            t.GetAttributeDataArrayForAllPoints(n, s, e.DT_INT32, u, l),
            (c = new Int32Array(e.HEAP32.buffer, l, o).slice()),
            e._free(l);
          break;
        case Uint8Array:
          (l = e._malloc(o)),
            t.GetAttributeDataArrayForAllPoints(n, s, e.DT_UINT8, o, l),
            (c = new Uint8Array(e.HEAPU8.buffer, l, o).slice()),
            e._free(l);
          break;
        case Uint16Array:
          (u = 2 * o),
            (l = e._malloc(u)),
            t.GetAttributeDataArrayForAllPoints(n, s, e.DT_UINT16, u, l),
            (c = new Uint16Array(e.HEAPU16.buffer, l, o).slice()),
            e._free(l);
          break;
        case Uint32Array:
          (u = 4 * o),
            (l = e._malloc(u)),
            t.GetAttributeDataArrayForAllPoints(n, s, e.DT_UINT32, u, l),
            (c = new Uint32Array(e.HEAPU32.buffer, l, o).slice()),
            e._free(l);
          break;
        default:
          throw new Error("DRACOLoader: Unexpected attribute type.");
      }
      return { name: i, array: c, itemSize: a };
    }
    onmessage = function (i) {
      const r = i.data;
      switch (r.type) {
        case "init":
          (e = r.decoderConfig),
            (t = new Promise(function (t) {
              (e.onModuleLoaded = function (e) {
                t({ draco: e });
              }),
                DracoDecoderModule(e);
            }));
          break;
        case "decode":
          const i = r.buffer,
            s = r.taskConfig;
          t.then((e) => {
            const t = e.draco,
              a = new t.Decoder(),
              o = new t.DecoderBuffer();
            o.Init(new Int8Array(i), i.byteLength);
            try {
              const e = (function (e, t, i, r) {
                  const s = r.attributeIDs,
                    a = r.attributeTypes;
                  let o, l;
                  const c = t.GetEncodedGeometryType(i);
                  if (c === e.TRIANGULAR_MESH)
                    (o = new e.Mesh()), (l = t.DecodeBufferToMesh(i, o));
                  else {
                    if (c !== e.POINT_CLOUD)
                      throw new Error("DRACOLoader: Unexpected geometry type.");
                    (o = new e.PointCloud()),
                      (l = t.DecodeBufferToPointCloud(i, o));
                  }
                  if (!l.ok() || 0 === o.ptr)
                    throw new Error(
                      "DRACOLoader: Decoding failed: " + l.error_msg()
                    );
                  const u = { index: null, attributes: [] };
                  for (const h in s) {
                    const i = self[a[h]];
                    let l, c;
                    if (r.useUniqueIDs)
                      (c = s[h]), (l = t.GetAttributeByUniqueId(o, c));
                    else {
                      if (((c = t.GetAttributeId(o, e[s[h]])), -1 === c))
                        continue;
                      l = t.GetAttribute(o, c);
                    }
                    u.attributes.push(n(e, t, o, h, i, l));
                  }
                  if (c === e.TRIANGULAR_MESH) {
                    const n = 3 * o.num_faces(),
                      i = 4 * n,
                      r = e._malloc(i);
                    t.GetTrianglesUInt32Array(o, i, r);
                    const s = new Uint32Array(e.HEAPU32.buffer, r, n).slice();
                    e._free(r), (u.index = { array: s, itemSize: 1 });
                  }
                  return e.destroy(o), u;
                })(t, a, o, s),
                i = e.attributes.map((e) => e.array.buffer);
              e.index && i.push(e.index.array.buffer),
                self.postMessage({ type: "decode", id: r.id, geometry: e }, i);
            } catch (l) {
              self.postMessage({ type: "error", id: r.id, error: l.message });
            } finally {
              t.destroy(o), t.destroy(a);
            }
          });
      }
    };
  }),
  (eR.taskCache = new WeakMap());
var tR = eR;
const nR = TL.select,
  iR = ["px", "nx", "py", "ny", "pz", "nz"];
async function rR(e) {
  const t = Gi() ? Yt("preloader") : Iy;
  PL.registerLoader(LL), PL.registerLoader(TI), PL.registerLoader(CI);
  const n = (e.geometries = {}),
    i = (e.meshes = {}),
    r = (e.curves = {}),
    s = (e.textures = {});
  function a(t, n) {
    const r = n.userData.name;
    "ROAD" === r
      ? (i.road = n)
      : "CAR" === r
      ? (function (e, t) {
          const n = e.meshes,
            i = (n.rawCar = t),
            r = i.children[i.children[0].name.includes("wh") ? 0 : 1],
            s = i.children[r === i.children[0] ? 1 : 0],
            a = (n.car = new Ab()),
            o = s.children[0].geometry;
          (a.body = new tC(o, KI, 1)),
            a.body.instanceMatrix.setUsage(35044),
            JI(s, a.body),
            JI(s.children[0], QI),
            a.body.setMatrixAt(0, QI.matrix),
            (a.body.instanceMatrix.needsUpdate = !0),
            a.add(a.body);
          const l = r.children[0].geometry;
          (a.wheels = new tC(l, KI, 4)),
            a.wheels.instanceMatrix.setUsage(35048),
            JI(r, a.wheels),
            a.add(a.wheels),
            (a.dummyWheels = r.children.map((e) => JI(e, new Ab())));
        })(e, n)
      : "STRUCTURE" === r && (i.structure = n);
  }
  function l(e, t) {
    const n = t.userData,
      i = n.name;
    if ((i && "*" === i[0] && (n.instancedMesh = !0), !n.instancedMesh))
      for (const r of t.children) l(t, r);
    a(0, t);
  }
  (e.assets = {}),
    (e.previousFrame = { value: null, type: "t" }),
    (e.currentFrame = { value: null, type: "t" }),
    (e.assets.load = async function () {
      const i = [];
      await TL.test(),
        (n.plane = new $w()),
        i.push(
          t.task(
            PL.load(ZI.spritesData, {
              onLoad: (t) => {
                e.atlas = (function (e) {
                  const t = { sprites: {}, meta: e.meta },
                    n = e.frames;
                  e.animations || (e.animations = {});
                  for (const i in e.animations) {
                    const r = e.animations[i],
                      s = (t.sprites[i] = []);
                    for (let t = 0, a = r.length; t < a; t++) {
                      const a = n[r[t]];
                      delete n[r[t]], s.push(EI(a, e.meta, i, t));
                    }
                  }
                  for (const i in n) {
                    const r = n[i],
                      s = (r.filename ? r.filename.toString() : i)
                        .replace(/[^a-zA-Z0-9-_-]/g, "")
                        .replace("png", ""),
                      a = (t.sprites[s] = []);
                    delete n[i], a.push(EI(r, e.meta, s));
                  }
                  return t;
                })(t);
              },
            })
          )
        ),
        i.push(
          t.task(
            Promise.all(iR.map((e) => nR(ZI.envmap[e])).map(PL.load))
              .then((e) => e.map((e) => e.node))
              .then((e) => {
                const t = new zw();
                (t.images = e), (t.needsUpdate = !0), (s.envMap2 = t);
              })
          )
        ),
        i.push(
          ...[
            [nR(ZI.sprites), "sprites", {}],
            [nR(ZI.bokeh), "bokeh", {}],
            [nR(ZI.bluenoise), "blueNoise", { repeat: !0 }],
            [nR(ZI.flakes), "flakes", { repeat: !0 }],
            [nR(ZI.matcaps), "matcaps"],
            [nR(ZI.carData), "carData"],
            [nR(ZI.roadDiffuse), "roadDiffuse"],
            [nR(ZI.roadData), "roadData"],
            [nR(ZI.structureDiffuse), "structureDiffuse"],
            [nR(ZI.structureData), "structureData"],
          ].map((e) =>
            t.task(
              PL.load(e[0], {
                onLoad: ({ node: t }) => {
                  s[e[1]] = (function (e) {
                    const t = new xx(e.img);
                    return (
                      void 0 !== e.flipY && (t.flipY = e.flipY),
                      void 0 !== e.mipmaps && (t.generateMipmaps = !!e.mipmaps),
                      e.magFilter && (t.magFilter = e.magFilter),
                      e.minFilter && (t.minFilter = e.minFilter),
                      e.encoding && (t.encoding = e.encoding),
                      e.mapping && (t.mapping = e.mapping),
                      e.premultiplyAlpha && (t.premultiplyAlpha = !0),
                      e.repeat
                        ? ((t.wrapS = 1e3), (t.wrapT = 1e3))
                        : (e.wrapS && (t.wrapS = e.wrapS),
                          e.wrapT && (t.wrapT = e.wrapT)),
                      e.format && (t.format = e.format),
                      e.type && (t.type = e.type),
                      (t.needsUpdate = !0),
                      t
                    );
                  })(o({ img: t, flipY: !1 }, e[2]));
                },
              })
            )
          )
        ),
        i.push(
          t.task(
            PL.load(ZI.framesData, {
              onLoad: (t) => {
                const n = new Float32Array(t),
                  i = (e.frames = []);
                for (let e = 0, r = n.length / 5; e < r; e++) {
                  let t = 5 * e;
                  i.push({
                    quaternion: new Tx(n[t++], n[t++], n[t++], n[t++]),
                    scale: n[t++],
                  });
                }
              },
            })
          )
        ),
        i.push(
          t.task(
            PL.load(ZI.roadCurveData, {
              onLoad: (e) => {
                const t = new Float32Array(e),
                  n = (r.road = new UC());
                let i = null;
                for (let r = 0, s = t.length / 9; r < s; r++) {
                  if (r + 1 >= s) continue;
                  const e = 9 * r,
                    a = i || new Cx(t[e], t[e + 1], t[e + 2]),
                    o = new Cx(t[e + 6], t[e + 7], t[e + 8]),
                    l = new Cx(t[e + 12], t[e + 13], t[e + 14]),
                    c = (i = new Cx(t[e + 9], t[e + 10], t[e + 11]));
                  n.add(new DC(a, o, l, c));
                }
              },
            })
          )
        );
      let a = ZI.sceneModel;
      const c = new tR();
      c.setDecoderPath(__DATA.config.basepath + "vendors/draco/"),
        c.preload(),
        TI.setDRACOLoader(c),
        (a = ZI.sceneModelDraco),
        i.push(
          t.task(
            TI(a, {
              onLoad: (e) => {
                for (const t of e.scene.children) l(e.scene, t);
              },
            })
          )
        ),
        await Promise.all(i),
        (e.atlas.meta.image = e.textures.sprites),
        (e.atlas.texture = e.textures.sprites);
    });
}
function sR(e) {
  e.store = {
    renderOrder: {
      background: 0,
      road: 1,
      carShadow: 2,
      car: 3,
      structure: 4,
      turboLine: 5,
      carTrails: 6,
      sprites: 7,
      cloudParticles: 8,
    },
    carShadow: new fx(),
    shadowActive: _d(!1),
  };
}
const aR = () => {};
function oR(e) {
  const t = {
    createBuffer: function (e) {
      return (function ({
        renderer: e,
        alpha: t,
        depth: n,
        stencil: i,
        width: r,
        height: s,
        name: a,
      }) {
        const o = fx.get();
        r && s ? o.set(r, s) : e.getDrawingBufferSize(o);
        const l = new Sx(o.x, o.y, {
          minFilter: 1006,
          magFilter: 1006,
          format: 1023,
          depthBuffer: !!n,
          stencilBuffer: !!i,
        });
        return o.release(), (l.texture.generateMipmaps = !1), l;
      })(e);
    },
    registerBuffer: aR,
    unregisterBuffer: aR,
  };
  e.fbo = t;
}
function lR(e) {
  const t = e.game,
    n = { IDLE: 0, STARTING: 1, ACTIVATING: 2, ACTIVE: 3, ENDED: 4 },
    i = "tuto_done";
  let r = 0,
    s = 0,
    a = !0,
    l = !1,
    c = 0,
    u = !0,
    h = -1,
    d = !1;
  const p = o(
    {
      current: n.IDLE,
      reset: function () {
        (r = 0), (s = 0), (a = !0), (l = !1), (c = 0), (h = -1), (d = !1);
      },
      update: function (o) {
        const x = p.current;
        (r = s),
          (s += o),
          x === n.STARTING
            ? (function (i) {
                const a = e.audio;
                0 === r && ((Pl.$stores.keysVisible = !1), a.setBgm("pad"));
                m(g) && a.playSound("UI_Countdown_Three");
                m(1700) && a.playSound("UI_Countdown_Two");
                m(2700) && a.playSound("UI_Countdown_One");
                m(3700) && a.playSound("UI_Countdown_GO");
                m(1e3) && t.view && t.view.countdown.value.show();
                s > 4e3 && f(n.ACTIVATING);
              })()
            : x === n.ACTIVATING
            ? ((a = !1),
              (l = !1),
              (c = 1e5),
              (Pl.$stores.keysVisible = !1),
              f(n.ACTIVE))
            : x === n.ACTIVE
            ? (function (r) {
                m(10) && e.audio.setBgm("pad+guitar");
                m(6e3) && e.audio.setBgm("pad+drum+guitar");
                m(12e3) && e.audio.setBgm("all");
                m(1e3) && t.view && t.view.timer.value.show();
                m(1200) &&
                  (t.view && !a && u && t.view.tuto.value.show(),
                  (a = !0),
                  (Pl.$stores.keysVisible = !0));
                a &&
                  s > 3200 &&
                  e.controls.active &&
                  (t.view && t.view.tuto.value.hide(),
                  (a = !1),
                  (u = !1),
                  sessionStorage.setItem(i, 1),
                  (c = s));
                !l &&
                  s - c > 1e3 &&
                  ((l = !0), t.view && t.view.turbo.value.show());
                t.progress >= t.checkpoints.list.finish &&
                  (t.updateBestTime(),
                  Pl.$rtcDisplay.enabled.value &&
                    Pl.$rtcDisplay.sendFinish(t.racetime, t.bestTime),
                  f(n.ENDED));
              })()
            : x === n.ENDED &&
              (function (n) {
                0 === r &&
                  ((Pl.$stores.keysVisible = !1),
                  e.audio.playSound("UI_Finish"));
                e.gameCam.activeInfluence < 0.08 &&
                  (h < 0 && (h = performance.now()),
                  (function (t) {
                    const n = performance.now();
                    if (n < v) return;
                    e.audio.playSound("FireworksEnd", {
                      volume: pA.randomFloat(0.4, 0.6),
                    }),
                      (y = Math.random() < _),
                      y ? (_ = 0) : (_ += 0.15 + _);
                    const i = y
                      ? pA.randomFloat(10, 90)
                      : pA.randomFloat(150, 420);
                    (v = n + i), e.scene.emitFirework();
                  })());
                m(20) && t.view && t.view.finish.value.show();
                m(700) && e.audio.setBgm("outro");
                m(10) &&
                  t.view &&
                  (t.view.tuto.value.hide(),
                  t.view.countdown.value.hide(),
                  t.view.turbo.value.hide());
                const i = performance.now();
                if (!d && p.stateTime > 4500 && i - h > 3e3) {
                  if (d) return;
                  Pl.$router.push({ name: "result" });
                }
              })();
      },
      isGameRunning: function () {
        return p.current > n.IDLE && p.current < n.ENDED;
      },
      hasEnded: function (e = 0, i = 0) {
        if (!e && !i) return p.current >= n.ENDED;
        const r = t.checkpoints.list.finish + i;
        return p.current >= n.ENDED && s >= e && t.progress >= r;
      },
      get stateTime() {
        return s;
      },
      set: f,
    },
    n
  );
  function f(e) {
    (p.current = e), (r = s = 0), (h = -1), (d = !1), t.ended.set(e > n.ACTIVE);
  }
  function m(e) {
    return r < e && s >= e;
  }
  const g = 700;
  let v = 0,
    _ = 1,
    y = !1;
  return p;
}
const cR = uR();
function uR() {
  return { position: new Cx(), quaternion: new Tx(), scale: new Cx(1, 1, 1) };
}
function hR(e) {
  const t = { reset: ud() },
    n = localStorage.getItem("best_time"),
    i = (e.game = {
      createFrameData: uR,
      currentCam: _d(null),
      time: 0,
      racetime: 0,
      elapsed: 0,
      bestTime: null == n || isNaN(n) ? -1 : n,
      getRoadData: function (e) {
        return u(i.progressNorm, e);
      },
      getRelativeRoadData: function (e, t) {
        return u(i.progressNorm + e / i.roadLength, t);
      },
      getAbsoluteRoadData: u,
      normalizeProgress: function (e) {
        return wy(e / i.roadLength, 0, 1);
      },
      roadLength: 0,
      minVelocity: 8,
      maxVelocity: 10.5,
      turboVelocity: 19.8,
      velocity: 0,
      progress: 0,
      progressNorm: 0,
      replay: function () {
        h();
      },
      resetting: !1,
      started: !1,
      ended: _d(!1),
      hooks: t,
      setView: function (e) {
        (i.view = e), h();
      },
      removeView: function (e) {
        if (i.view !== e) return;
        (i.view = null), h();
      },
      view: null,
      updateProgressNorm: d,
      updateBestTime: function () {
        (i.bestTime < 0 || i.racetime < i.bestTime) &&
          ((i.bestTime = i.racetime),
          localStorage.setItem("best_time", i.bestTime));
      },
      paused: _d(!1),
      isPaused: p,
      forceAutopilot: _d(!1),
    }),
    r = (function (e) {
      let t = 0;
      const n = {
        progress: 0,
        velProgress: 0,
        hover: !1,
        active: _d(!1),
        init: function () {
          e.game.hooks.reset.watch(i);
        },
        reset: i,
        update: function () {
          const i = e.time.stableDt,
            r = e.scene.road.car,
            s = e.game.progress;
          if (n.active.value)
            (n.progress -= 2.9 * i * 1e-4),
              n.progress <= 0 && (n.active.set(!1), (t = s));
          else if (
            (n.cooldownActive && (n.cooldownActive = s - t < 15),
            n.hover ||
              ((n.progress -= 2 * i * 1e-4),
              n.cooldownActive || n.ended || (n.velProgress -= 2.8 * i * 1e-4)),
            r.dip)
          ) {
            const e = 0.007 * wy(My(r.dipStrength, 0.01, 0.02, 0, 1), 0, 1);
            (n.progress -= e),
              n.active.value || n.cooldownActive || (n.velProgress -= e);
          }
          (n.velProgress = wy(n.velProgress, 0, 1)),
            (n.progress = wy(n.progress, 0, 1));
        },
        addHitDistance: function (i) {
          if (n.active.value) return;
          const r = n.progress,
            s = i / 50;
          n.progress = wy(n.progress + s, 0, 1);
          const a = i / 50;
          (n.velProgress = wy(n.velProgress + a, 0, 1)),
            n.progress >= 1 &&
              r < 1 &&
              ((n.cooldownActive = !0),
              (t = e.game.progress),
              n.active.set(!0),
              e.audio.playSound("Car_Engine_Boost"));
        },
        cooldownActive: !1,
        cooldown: 15,
        distanceToFill: 50,
        ended: !1,
      };
      return n;
      function i() {
        (n.progress = 0),
          (n.velProgress = 0),
          (n.hover = !1),
          n.active.set(!1),
          (n.cooldownActive = !1);
      }
    })(e);
  i.turbo = r;
  const s = lR(e);
  i.state = s;
  const a = (function (e) {
    return (
      e.game,
      {
        list: { start: 3, finish: 786.5 },
        reset: function () {},
        update: function (e) {},
      }
    );
  })(e);
  let o, l, c;
  function u(t, n) {
    t = wy(t, 0, 1);
    const i = n || cR,
      r = e.frames,
      s = t * (r.length - 1),
      a = Math.floor(s),
      l = s - a,
      c = r[a],
      u = r[a + 1] || c;
    return (
      (i.position = o.getPointAt(t, i.position)),
      i.quaternion.slerpQuaternions(c.quaternion, u.quaternion, l),
      i.scale.set(1, Cy(c.scale, u.scale, l), 1),
      i
    );
  }
  function h() {
    l = !0;
  }
  function d() {
    i.progressNorm = wy(i.progress / i.roadLength, 0, 1);
  }
  function p() {
    return i.paused.value && e.scene.gameCam.used;
  }
  (i.checkpoints = a),
    (i.autopilot = (function (e, t) {
      const n = new vd(),
        i = n.set.bind(n);
      delete n.set, (e = Array.isArray(e) ? e : [e]);
      const r = new Array(e.length);
      let s = [];
      for (let o = 0, l = e.length; o < l; o++) {
        const t = e[o],
          n = function (e) {
            (r[o] = e), a();
          };
        (r[o] = t.value), t.watch(n), s.push(t, n);
      }
      function a() {
        const e = t.apply(null, r);
        e && e.then ? e.then(i) : i(e);
      }
      return (
        (n.destroy = function () {
          for (let e = 0, t = s.length; e < t; e += 2) s[e].unwatch(s[e + 1]);
          (s = null), n.unwatchAll();
        }),
        a(),
        n
      );
    })(
      [i.forceAutopilot, i.turbo.active, i.currentCam, i.ended],
      (e, t, n, i) => e || t || (n && n.forceCarAutopilot) || i
    )),
    e.hooks.afterLoad.watchOnce(function () {
      br(() => {
        i.paused.set(Pl.$stores.gamePaused);
      }),
        (o = e.curves.road),
        (i.roadLength = o.getLength()),
        r.init();
    }),
    e.hooks.beforeUpdate.watch(function () {
      const n = e.time.stableDt;
      e.scene.currentCamera !== i.currentCam.value &&
        i.currentCam.set(e.scene.currentCamera);
      if (p()) return;
      c && ((i.resetting = !1), (c = !1));
      l &&
        (function () {
          (i.time = 0),
            (i.racetime = 0),
            (i.progress = 0),
            d(),
            (i.resetting = !0);
          const e = i.view;
          let n = s.IDLE;
          e && (n = s.STARTING);
          s.set(n),
            (l = !1),
            (c = !1),
            (i.progress = Math.min(a.list.start, i.roadLength)),
            t.reset.emit(),
            r.reset(),
            s.reset(),
            a.reset(),
            i.view && i.view.hideAll();
        })();
      const o = n / 1e3;
      (i.elapsed += n),
        (i.time += n),
        s.current === s.ACTIVE && (i.racetime += n);
      e.scene.road.car.updateVelocity(),
        (i.progress = wy(i.progress + i.velocity * o, 0, i.roadLength)),
        d(),
        r.update(n),
        s.update(n),
        i.resetting && (c = !0);
    }),
    e.hooks.afterStart.watchOnce(h);
}
var dR =
  "precision highp float;varying vec2 vUv;uniform sampler2D colorTexture;uniform vec2 texSize;uniform vec2 direction;uniform float sigma;uniform int kernelRadius;\n#ifdef USE_HIGH_PASS\nuniform float threshold;\n#include <shaderHighPass>\n#endif\nfloat gaussianPdf(in float x,in float sigma){return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;}void main(){vec2 invSize=1.0/texSize;float weightSum=gaussianPdf(0.0,sigma);\n#ifdef USE_HIGH_PASS\nvec3 diffuseSum=highPass(texture2D(colorTexture,vUv).rgba,threshold,0.001)*weightSum;\n#else\nvec3 diffuseSum=texture2D(colorTexture,vUv).rgb*weightSum;\n#endif\nif(kernelRadius==3){for(int i=1;i<3;i++){\n#include <shaderBlurChunk>\n}}else if(kernelRadius==5){for(int i=1;i<5;i++){\n#include <shaderBlurChunk>\n}}else if(kernelRadius==7){for(int i=1;i<7;i++){\n#include <shaderBlurChunk>\n}}else if(kernelRadius==9){for(int i=1;i<9;i++){\n#include <shaderBlurChunk>\n}}else if(kernelRadius==11){for(int i=1;i<11;i++){\n#include <shaderBlurChunk>\n}}gl_FragColor=vec4(diffuseSum/weightSum,1.0);}";
const pR = [3, 5, 7, 9, 11],
  fR = new fx(1, 0),
  mR = new fx(0, 0.8),
  gR = { format: 1022 },
  vR = {
    exposure: 0.9,
    threshold: 0.6,
    strength: 1.45,
    radius: 1,
    resolution: new fx(512, 512),
  },
  _R = [],
  yR = [],
  xR = [];
let bR, wR, SR, MR, TR;
function CR(e, t, n) {
  const i = new Sx(t, n, gR);
  return (
    (i.texture.name = e),
    (i.texture.generateMipmaps = !1),
    (e.endsWith("H.mip0") || e.endsWith("site")) && Nl.fbo.registerBuffer(e, i),
    i
  );
}
var ER = {
    init: function (e) {
      TR = Nl.threeRenderer;
      const t = fx.get().copy(vR.resolution);
      (Zw.shaderBlurChunk =
        "float x=float(i);float w=gaussianPdf(x,sigma);vec2 uvOffset=direction*invSize*x;\n#ifdef USE_HIGH_PASS\nvec3 sample1=highPass(texture2D(colorTexture,vUv+uvOffset).rgba,threshold,0.001);vec3 sample2=highPass(texture2D(colorTexture,vUv-uvOffset).rgba,threshold,0.001);\n#else\nvec3 sample1=texture2D(colorTexture,vUv+uvOffset).rgb;vec3 sample2=texture2D(colorTexture,vUv-uvOffset).rgb;\n#endif\ndiffuseSum+=(sample1+sample2)*w;weightSum+=2.0*w;"),
        (Zw.shaderHighPass =
          "const vec3 hp_DefaultColor=vec3(0.0);const vec3 hp_Luma=vec3(0.299,0.587,0.114);const vec3 pinkColor=vec3(1.,0.5,0.5);vec3 highPass(vec4 texel,float threshold,float epsilon){float neon=step(0.995,texel.g);float intensity=1.-texel.a;float hasWhite=step(0.995,texel.b);float whiteNeon=step(0.995,texel.b);float pinkNeon=step(0.995,texel.g);whiteNeon+=pinkNeon*hasWhite;pinkNeon*=(1.-hasWhite);whiteNeon*=texel.b;pinkNeon*=texel.g;float v=dot(texel.xyz,hp_Luma);float test=step(texel.a,0.999);return texel.rgb*intensity*2.;}");
      for (let n = 0; n < pR.length; n++)
        0 === n && (bR = CR("Bloom.composite", t.x, t.y)),
          _R.push(CR("BloomBlurH.mip" + n, t.x, t.y)),
          yR.push(CR("BloomBlurV.mip" + n, t.x, t.y)),
          xR.push(yR[n].texture),
          t.set((0.5 * t.x) | 0, (0.5 * t.y) | 0);
      fx.release(t),
        (wR = tA({
          name: "Bloom - Composite",
          renderer: Nl.threeRenderer,
          fragmentShader:
            "precision highp float;varying vec2 vUv;uniform sampler2D blurTexture1;uniform sampler2D blurTexture2;uniform sampler2D blurTexture3;uniform sampler2D blurTexture4;uniform sampler2D blurTexture5;uniform float bloomStrength;uniform float bloomRadius;uniform float bloomFactors[NUM_MIPS];uniform vec3 bloomTintColors[NUM_MIPS];float lerpBloomFactor(const in float factor){float mirrorFactor=1.2-factor;return mix(factor,mirrorFactor,bloomRadius);}void main(){gl_FragColor=bloomStrength*(lerpBloomFactor(bloomFactors[0])*vec4(bloomTintColors[0],1.0)*texture2D(blurTexture1,vUv)+lerpBloomFactor(bloomFactors[1])*vec4(bloomTintColors[1],1.0)*texture2D(blurTexture2,vUv)+lerpBloomFactor(bloomFactors[2])*vec4(bloomTintColors[2],1.0)*texture2D(blurTexture3,vUv)+lerpBloomFactor(bloomFactors[3])*vec4(bloomTintColors[3],1.0)*texture2D(blurTexture4,vUv)+lerpBloomFactor(bloomFactors[4])*vec4(bloomTintColors[4],1.0)*texture2D(blurTexture5,vUv));}",
          transparent: !1,
          uniforms: {
            blurTexture1: { value: yR[0].texture },
            blurTexture2: { value: yR[1].texture },
            blurTexture3: { value: yR[2].texture },
            blurTexture4: { value: yR[3].texture },
            blurTexture5: { value: yR[4].texture },
            bloomStrength: { value: 1 },
            bloomRadius: { value: 0 },
            bloomFactors: { value: [1, 0.8, 0.6, 0.4, 0.2] },
            bloomTintColors: {
              value: [
                new Cx(1, 1, 1),
                new Cx(1, 1, 1),
                new Cx(1, 1, 1),
                new Cx(1, 1, 1),
                new Cx(1, 1, 1),
              ],
            },
          },
          defines: { NUM_MIPS: pR.length },
        })),
        (MR = tA({
          renderer: Nl.threeRenderer,
          fragmentShader: dR,
          transparent: !1,
          uniforms: {
            colorTexture: { value: _R[0].texture },
            texSize: { value: new fx().setScalar(0.5 * vR.resolution) },
            direction: { value: fR },
            kernelRadius: { type: "i", value: pR[0] },
            sigma: { type: "f", value: pR[0] },
          },
        })),
        (SR = tA({
          renderer: Nl.threeRenderer,
          fragmentShader: dR,
          transparent: !1,
          uniforms: Object.assign({}, MR.u, { threshold: { value: 0.5 } }),
          defines: { USE_HIGH_PASS: !0 },
        }));
    },
    render: function (e) {
      if (0 === vR.exposure) return;
      let t = SR;
      t.uniforms.threshold.value = vR.threshold;
      for (let n = 0; n < pR.length; n++) {
        const i = pR[n];
        (t.u.kernelRadius.value = 0 | i), (t.u.sigma.value = i);
        const r = _R[n];
        t.u.texSize.value.set(r.width, r.height),
          (t.u.colorTexture.value = e.texture),
          (t.u.direction.value = fR),
          TR.setRenderTarget(r),
          t.render(),
          (t = MR),
          (t.u.colorTexture.value = _R[n].texture),
          (t.u.direction.value = mR),
          TR.setRenderTarget(yR[n]),
          t.render(),
          (e = yR[n]);
      }
      (wR.u.bloomStrength.value = vR.strength),
        (wR.u.bloomRadius.value = vR.radius),
        TR.setRenderTarget(bR),
        wR.render();
    },
    resize: function (e, t) {
      const n = fx.get().set(e, t);
      for (let i = 0; i < pR.length; i++)
        0 === i && bR.setSize(n.x, n.y),
          _R[i].setSize(n.x, n.y),
          yR[i].setSize(n.x, n.y),
          n.set((0.5 * n.x) | 0, (0.5 * n.y) | 0);
      fx.release(n);
    },
    blurTextures: xR,
    params: vR,
    get compositeTexture() {
      return bR.texture;
    },
  },
  AR = nA(
    QE,
    "precision highp float;\n#include <blend_add>\n#include <luma>\n#define PI 3.1415926538\nuniform sampler2D scene;uniform vec4 res;uniform float dpi;uniform vec4 uvOverlayOffset;uniform sampler2D bloom;uniform float time;uniform float bloomExposure;uniform sampler2D noise;uniform vec2 ditherOffset;uniform float menuInfluence;uniform sampler2D overlayTex;uniform vec2 press;varying vec2 vUv;const vec3 PINK=vec3(0.871,0.012,0.682);const vec3 BLUE=vec3(0.1,0.098,0.355);vec3 blendOverlay(vec3 base,vec3 blend){return mix(1.0-2.0*(1.0-base)*(1.0-blend),2.0*base*blend,step(base,vec3(0.5)));}vec3 blendSoftLight(vec3 base,vec3 blend){return mix(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend),2.0*base*blend+base*base*(1.0-2.0*blend),step(base,vec3(0.5)));}float gradientEase(float t){float tm1=t-1.0;float tm1_2=tm1*tm1;return 1.0-tm1_2*tm1_2;}vec2 correctRatio(vec2 inUv){return vec2(inUv.x*uvOverlayOffset.x+uvOverlayOffset.y,inUv.y*uvOverlayOffset.z+uvOverlayOffset.w);}const int speedBlurSamples=6;const float overlayRatio=1024./512.;void main(){vec2 uv=vUv;vec2 pxCoords=vUv*res.xy/dpi;vec2 buv=uv;buv.x+=cos(cos(buv.y)*120.+time*0.012)*0.0004;buv.y+=cos(buv.x*70.+time*0.022)*0.0002;vec3 bloomTexel=texture2D(bloom,buv).xyz;vec3 diffuse=texture2D(scene,vUv).rgb;float radius=length(vUv*2.-1.);diffuse=mix(diffuse,diffuse*0.4,smoothstep(0.8-menuInfluence*0.7,1.8,radius));bloomTexel=bloomTexel*bloomExposure;diffuse+=bloomTexel;diffuse=blendAdd(diffuse,bloomTexel*0.3);diffuse=blendAdd(diffuse,bloomTexel*0.2);diffuse=min(diffuse,1.);diffuse.r-=(1.-gradientEase(min(1.,(1.-vUv.y)*0.6+vUv.x*0.05)))*0.11;diffuse=mix(diffuse,BLUE,(1.-gradientEase(min(1.,(1.-vUv.x)*0.25+vUv.y*0.8-0.15)))*0.05);float screenRatio=res.x/res.y;vec2 overlayUv=mix(correctRatio(vUv.yx),correctRatio(vUv),step(1.,screenRatio));vec3 dirt=texture2D(overlayTex,overlayUv).rgb;diffuse=blendOverlay(diffuse,dirt*bloomTexel*1.8+0.5);diffuse=mix(diffuse,blendOverlay(diffuse,dirt+0.5),luma(diffuse)*0.15);float lum=clamp(luma(diffuse),0.,1.);vec3 dither=texture2D(noise,(pxCoords+ditherOffset)/NOISE_SIZE*dpi).rgb;vec3 ditheredDiffuse=blendSoftLight(diffuse,dither);diffuse=mix(diffuse,ditheredDiffuse,0.85);vec3 menuDiffuse=diffuse*vec3(0.4+diffuse.r*0.6,0.2,0.2);diffuse=mix(diffuse,menuDiffuse,menuInfluence);float vtouch=cos(uv.y*PI*2.)*0.02+0.13;float touch=smoothstep(0.8,1.3,(1.-uv.x)-vtouch)*press.x+smoothstep(0.8,1.3,uv.x-vtouch)*press.y;diffuse=mix(diffuse,vec3(2.,0.5,0.5),touch*4.);gl_FragColor=vec4(diffuse,1.);}"
  );
let PR = 1;
const LR = new wx();
function IR(e) {
  const t = {},
    n = {},
    i = {};
  let r = 128;
  const s = {
    init: function () {
      ER.init(undefined),
        (t.ping = e.fbo.createBuffer({
          name: "Scene - Main Ping",
          renderer: e.threeRenderer,
          depth: !0,
          alpha: !0,
          stencil: !0,
        })),
        (t.pong = e.fbo.createBuffer({
          name: "Scene - Main Pong",
          renderer: e.threeRenderer,
          depth: !0,
          alpha: !0,
          stencil: !0,
        })),
        o(),
        (r = e.textures.blueNoise.image.naturalWidth),
        (n.main = tA({
          renderer: e.threeRenderer,
          vertexShader: AR.vs,
          fragmentShader: AR.fs,
          uniforms: Object.assign({
            res: { value: new wx() },
            dpi: { value: 0 },
            scene: e.currentFrame,
            uvOverlayOffset: { value: new wx() },
            time: { value: 0 },
            bloom: { value: ER.compositeTexture },
            bloomExposure: { value: ER.params.exposure },
            noise: { value: e.textures.blueNoise },
            ditherOffset: { value: [0, 0] },
            overlayTex: { value: e.textures.bokeh },
            menuInfluence: { value: 0 },
            press: { value: [0, 0] },
          }),
          defines: {
            NOISE_SIZE: ((s = r), s.toString().includes(".") ? s : s + "."),
          },
        })),
        (i.dither = {
          maxFrames: 1,
          frame: 0,
          value: n.main.u.ditherOffset.value,
        }),
        AR.use(n.main.material),
        e.renderer.drawingBufferSize.watchImmediate(l);
      var s;
    },
    enabled: !0,
    update: function () {
      const t = n.main.u;
      (t.menuInfluence.value = Cy(
        t.menuInfluence.value,
        e.game.paused.value ? 1 : 0,
        0.1
      )),
        (t.time.value = e.time.elapsed),
        (a = Cy(a, e.controls.pressed ? 1 : 0, e.controls.pressed ? 0.8 : 0.1));
      const s = t.press.value;
      (s[0] = Cy(
        s[0],
        a * Math.min(0, e.controls.turn) * -1,
        e.controls.active ? 0.15 : 0.2
      )),
        (s[1] = Cy(
          s[1],
          a * Math.max(0, e.controls.turn),
          e.controls.active ? 0.15 : 0.2
        )),
        (function (e) {
          if (((e.frame += 1), e.frame < e.maxFrames)) return;
          (e.frame = 0),
            (e.value[0] = pA.randomInt(0.5 * -r, 0.5 * r)),
            (e.value[1] = pA.randomInt(0.5 * -r, 0.5 * r));
        })(i.dither);
    },
    render: function () {
      (n.main.u.bloomExposure.value = ER.params.exposure), n.main.render();
    },
    renderBloom: function (e) {
      ER.render(e);
    },
    buffers: t,
    filters: n,
    bloom: ER,
    pingpong: o,
  };
  e.postprocess = s;
  let a = 0;
  function o() {
    const n = t.ping,
      i = t.pong,
      r = t.main === n ? n : i,
      s = r === i ? n : i;
    (t.main = s),
      (e.previousFrame.value = r.texture),
      (e.currentFrame.value = s.texture);
  }
  function l(i) {
    t.ping.setSize(i.x, i.y),
      t.pong.setSize(i.x, i.y),
      (PR = i.x > i.y ? i.x / i.y : i.y / i.x),
      n.main.u.res.value.set(i.x, i.y, 1 / i.x, 1 / i.y),
      (n.main.u.dpi.value = e.renderer.pixelRatio.value),
      (LR.x = 2 > PR ? PR / 2 : 1),
      (LR.y = 2 > PR ? 0.5 * (1 - PR / 2) : 0),
      (LR.z = 2 <= PR ? 2 / PR : 1),
      (LR.w = 2 <= PR ? 0.5 * (1 - 2 / PR) : 0),
      n.main.u.uvOverlayOffset.value.copy(LR);
  }
}
const RR = ["INPUT", "SELECT", "TEXTAREA", "A", "BUTTON"].reduce(
  (e, t) => ((e[t] = 1), e),
  {}
);
function DR(e) {
  e.hooks.afterLoad.watchOnce(function () {
    window.addEventListener("keydown", s),
      window.addEventListener("keyup", a),
      e.viewport.visible.watchImmediate(() => {
        for (const e in t) t[e] = !1;
      });
  }),
    e.hooks.beforeFrame.watch(function () {
      const r = e.touch.value,
        s = Pl.$rtcDisplay,
        a = s.enabled.value;
      s.controls.state,
        t.keyA || t.KeyD || t.ArrowLeft || t.ArrowRight
          ? (i.keyboard = !0)
          : (r.pressed || (a && s.controls.state)) && (i.keyboard = !1);
      Pl.$rtcDisplay.enabled.value
        ? ((n.left = s.controls.state < 0), (n.right = s.controls.state > 0))
        : ((n.left =
            t.KeyA ||
            t.ArrowLeft ||
            (r.pressed && r.activeFinger.normalizePos.x < 0)),
          (n.right =
            t.KeyD ||
            t.ArrowRight ||
            (r.pressed && r.activeFinger.normalizePos.x > 0)));
      const o = e.time.stableDt,
        l = o / 16.6667,
        c = (i.active = !(!n.left && !n.right)),
        u = (i.keyboard, c ? 0.15 : 0.18);
      i.turnTarget = (-1 * +n.left + 1 * +n.right) * l;
      (e.game.state.current !== e.game.state.ACTIVE ||
        e.game.autopilot.value) &&
        ((i.turnTarget = 0), (i.active = !1));
      (i.pressed = r.pressed),
        (i.turn = Py(i.turn, i.turnTarget, u, o, 0.001)),
        i.direction.set(n.right ? 1 : n.left ? -1 : 0);
    });
  const t = { KeyA: !1, KeyD: !1, ArrowLeft: !1, ArrowRight: !1 },
    n = { left: !1, right: !1 },
    i = (e.controls = {
      active: !1,
      turn: 0,
      turnTarget: 0,
      pressed: !1,
      keyboard: !0,
      steeringMultKeyboard: 1.1,
      steeringMultTouch: 0.9,
      rotationMultKeyboard: 1,
      rotationMultTouch: 0.9,
      direction: _d(0),
    }),
    r = Object.keys(t).reduce((e, t) => ((e[t] = 1), e), {});
  function s(e) {
    (function (e) {
      return !(RR[e.tagName] || (e.code && !r[e.code]));
    })(e) && (t[e.code] = !0);
  }
  function a(e) {
    r[e.code] && (t[e.code] = !1);
  }
}
const kR = ["INPUT", "SELECT", "TEXTAREA", "A", "BUTTON"].reduce(
    (e, t) => ((e[t] = 1), e),
    {}
  ),
  NR = ["game", "webgl"].reduce((e, t) => ((e[t] = 1), e), {}),
  OR =
    void 0 !== window.visualViewport && void 0 !== window.visualViewport.scale,
  FR = [{ identifier: -987654321, clientX: 0, clientY: 0 }];
function zR(e) {
  return (FR[0].clientX = e.clientX || 0), (FR[0].clientY = e.clientY || 0), FR;
}
let UR, BR;
const VR = () => (UR = !1);
function HR() {
  (UR = !0), clearTimeout(BR), (BR = setTimeout(VR, 200));
}
function GR(e) {
  let t;
  const n = El(),
    i = n.$router,
    r = n.$viewport;
  function s(e) {
    (this.name = e),
      (this.position = this.pos = new fx()),
      (this.prevPosition = this.prevPos = new fx()),
      (this.relPos = this.relativePos = new fx()),
      (this.normalizePos = new fx()),
      (this.normalizeRelPos = this.normalizeRelativePos = new fx()),
      (this.initialPos = new fx()),
      (this.vel = this.velocity = new fx()),
      (this.identifier = -1),
      (this.used = !1),
      (this.use = (e) => {
        (this.used = !0), (this.id = e.identifier);
        const t = r.width.value,
          n = r.height.value;
        this.initialPos.set(e.clientX || 0, e.clientY || 0),
          this.pos.set(e.clientX || 0, e.clientY || 0),
          this.relPos.set(0, 0),
          this.vel.set(0, 0),
          this.normalizePos.set(
            My(this.pos.x, 0, t, -1, 1),
            My(this.pos.y, 0, n, 1, -1)
          ),
          this.normalizeRelPos.set(0, 0);
      }),
      (this.move = (e) => {
        const t = r.width.value,
          n = r.height.value;
        this.pos.set(e.clientX, e.clientY),
          this.relPos.subVectors(this.pos, this.initialPos),
          this.normalizePos.set(
            My(this.pos.x, 0, t, -1, 1),
            My(this.pos.y, 0, n, 1, -1)
          ),
          this.normalizeRelPos.set(
            My(this.relPos.x, 0, t, -1, 1),
            My(this.relPos.y, 0, n, 1, -1)
          );
      }),
      (this.unuse = () => {
        (this.used = !1), (this.id = -1);
      });
  }
  const a = new s("Finger 1"),
    o = new s("Finger 2"),
    l = _d({
      pressed: !1,
      clickIn: !1,
      clickOut: !1,
      pos: new fx(),
      relativePos: new fx(),
      delta: new fx(),
      normalizePos: new fx(),
      normalizeRelativePos: new fx(),
      activeFinger: a,
    }),
    c = {
      firstPos: new fx(),
      prevPos: new fx(),
      clickIn: !1,
      clickOut: !1,
      pressed: !1,
      pos: new fx(0, 0),
      relativePos: new fx(0, 0),
      delta: new fx(0, 0),
      interactive: !1,
      active: !1,
      useTouch: !1,
      fingerCount: 0,
      containerOffset: new fx(),
    };
  function u(e) {
    return (
      !!e &&
      (!e.target ||
        !(function (e) {
          if (!e) return !1;
          const t = e.tagName,
            n = i.currentRoute.value.name || "";
          return !!(
            !NR[n] ||
            kR[t] ||
            (OR && 1 !== window.visualViewport.scale)
          );
        })(e.target))
    );
  }
  function h(e) {
    return e.changedTouches[e.changedTouches.length - 1];
  }
  function d(e) {
    if (e && void 0 !== e.identifier)
      return a.id === e.identifier ? a : o.id === e.identifier ? o : null;
  }
  function p(e) {
    const n = !!e.changedTouches;
    if (n) HR();
    else if (UR) return;
    if (!n && 0 !== e.button) return;
    if (c.fingerCount >= 2) return;
    if (!u(e)) return;
    e.preventDefault();
    const i = n ? h(e) : e;
    c.delta.set(0, 0),
      c.firstPos.set(i.clientX || 0, i.clientY || 0),
      c.prevPos.copy(c.firstPos),
      c.pos.copy(c.firstPos),
      (c.pressed = !0),
      (c.clickIn = !0),
      (c.clickOut = !1);
    const r = n ? e.changedTouches : zR(e);
    for (let t = 0; t < r.length; t++) {
      const e = r[t];
      let n = d(e);
      n ||
        c.fingerCount >= 2 ||
        ((n = a.used ? o : a), n.use(e), (v = n), c.fingerCount++);
    }
    (t = !0), _();
  }
  function f(e) {
    const n = !!e.changedTouches,
      i = n ? h(e) : e;
    c.pos.set(i.clientX || 0, i.clientY || 0),
      c.pressed
        ? c.relativePos.copy(c.pos).sub(c.firstPos)
        : c.relativePos.set(0, 0);
    const r = n ? e.changedTouches : zR(e);
    for (let t = 0; t < r.length; t++) {
      const e = r[t],
        n = d(e);
      n && n.move(e);
    }
    t = !0;
  }
  function m(e) {
    const n = !!e.changedTouches;
    if (n) HR();
    else if (UR) return;
    if (!n && 0 !== e.button) return;
    if (u(e)) e.preventDefault();
    else if (!c.pressed) return;
    n && h(e);
    const i = n ? e.changedTouches : zR(e);
    for (let t = 0; t < i.length; t++) {
      const e = d(i[t]);
      if (!e) return;
      e.unuse(), c.fingerCount--;
    }
    (c.clickIn = !1),
      (c.clickOut = c.pressed),
      (t = !0),
      (c.pressed = !(c.fingerCount <= 0)),
      _(),
      (t = !0),
      c.relativePos.set(0, 0);
  }
  function g() {
    (c.clickIn || c.clickOut) && (t = !0),
      (c.clickOut = c.clickIn = !1),
      c.delta.copy(c.pos).sub(c.prevPos),
      c.prevPos.copy(c.pos);
    const e = l.value.delta;
    t || (t = !c.delta.equals(e) || 0 !== c.delta), t && _(), (t = !1);
  }
  (e.touch = l),
    e.hooks.afterLoad.watchOnce(function () {
      const t = window,
        n = "addEventListener",
        i = { passive: !1 };
      t[n]("touchstart", p, i),
        t[n]("touchmove", f, i),
        t[n]("touchend", m, i),
        t[n]("touchcancel", m, i),
        t[n]("mousedown", p, i),
        t[n]("mousemove", f, i),
        t[n]("mouseup", m, i),
        t[n]("gesturestart", (e) => e.preventDefault(), i),
        e.hooks.beforeFrame.watch(g);
    });
  let v = a;
  function _() {
    const e = l.value;
    (e.pressed = c.pressed),
      (e.clickIn = c.clickIn),
      (e.clickOut = c.clickOut),
      e.pos.copy(c.pos),
      e.relativePos.copy(c.relativePos),
      e.delta.copy(c.delta);
    const t = { x: r.width.value, y: r.height.value };
    (e.activeFinger =
      o.used && !a.used
        ? o
        : (a.used && !o.used) || (a.used && o.used && v === a)
        ? a
        : a.used && o.used && v === o
        ? o
        : a),
      e.normalizePos.set(
        My(e.pos.x, 0, t.x, -1, 1),
        My(e.pos.y, 0, t.y, 1, -1)
      ),
      e.normalizeRelativePos.copy(e.relativePos).divide(t),
      l.set(e, !0);
  }
}
const WR = 2 * Math.PI,
  qR = new Xb(1, 1, 1),
  jR = new Cx();
var YR = {
    beforeEmit: function (e = {}) {
      e.position || (e.position = jR),
        (e.scale = e.scale || 1),
        (e.angOffset = pA.randomFloat(0, WR));
    },
    particleEmitted: function (
      e,
      {
        angOffset: t,
        position: n,
        scale: i,
        velDrag: r,
        durationMin: s,
        durationMax: a,
        sprite: o,
        color: l,
        amount: c,
        billboard: u,
        velocity: h,
        opacity: d,
        gravity: p = 0,
      }
    ) {
      const f = WR / c,
        m = e.index * f + pA.randomFloat(-0.2, 0.2) + t;
      let g = (0.01 + pA.randomFloat(-0.005, 0.007)) * i;
      (g = 0.003 * h.x),
        (e.billboard = u),
        (e.angVelocity = 0),
        (e.spriteId = o),
        e.velocity.copy(h).multiplyScalar(-1),
        (e.velocity.z += g * Math.cos(m)),
        (e.velocity.y += g * Math.sin(m)),
        (e.rotation.x = Math.PI / -2),
        (e.rotation.z = g * e.velocity.x * Math.cos(m)),
        e.velocityDrag.setScalar(r || 0.98),
        (e.useVelocityDragMult = !0),
        (e.gravity.y = 0),
        e.position.copy(n),
        (e.duration = pA.randomFloat(s || 500, a || 900)),
        e.scaleFrom.copy(i),
        e.scaleTo.setScalar(0),
        (e.alpha = 0.9),
        e.colorFrom.copy(l || qR).multiplyScalar(d),
        e.colorTo.copy(e.colorFrom);
    },
  },
  XR = Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default: YR,
  });
const $R = new Map(),
  ZR = (e) => e;
function KR(e) {
  return e
    ? ($R.has(e) || $R.set(e, sl(e[0], e[1], e[2], e[3])), $R.get(e))
    : ZR;
}
const JR = Math.PI;
new Xb(1, 1, 1);
const QR = new Cx(),
  eD = new Cx(),
  tD = new Ab(),
  nD = new Ab();
let iD = 0;
var rD = {
    beforeAlloc: function (e) {
      (e.amount = Math.min(150 - iD, e.amount)), (iD += e.amount);
    },
    beforeEmit: function (e = {}) {
      e.position || (e.position = QR),
        (e.scale = e.scale || 1),
        (e.angOffset = pA.randomFloat(JR, 0));
    },
    particleEmitted: function (
      e,
      {
        angOffset: t,
        position: n,
        scale: i,
        velDrag: r,
        durationMin: s,
        durationMax: a,
        sprite: o,
        color: l,
        amount: c,
        billboard: u,
        gravity: h = 0,
      }
    ) {
      (e.spriteId = "particleA"),
        (e.fadeIn = 1e3),
        (e.colorEase = KR()),
        (e.progressEase = KR()),
        (e.colorFrom = new Xb(0)),
        (e.colorTo = new Xb(16777215));
      const d = wy(Sy(Nl.game.velocity, 10, 18), 0, 1),
        p = Cy(pA.randomFloat(5, 12), pA.randomFloat(2, 4), d),
        f = Nl.game.getRelativeRoadData(p),
        m = pA.randomFloat(f.scale.y / 7, f.scale.y / 2);
      tD.position.copy(f.position),
        tD.quaternion.copy(f.quaternion),
        tD.scale.setScalar(m),
        tD.updateMatrixWorld();
      const g = t,
        v = pA.randomFloat(3, 4),
        _ = v * Math.cos(g),
        y = v * Math.sin(g),
        x = tD.localToWorld(QR.set(0, y, _));
      nD.position.copy(x),
        nD.up.copy(eD.set(0, 1, 0).applyQuaternion(f.quaternion)),
        nD.lookAt(tD.position),
        nD.updateMatrixWorld(),
        (e.initialRoadProgress = Nl.game.progress + p),
        e.position.copy(nD.position),
        e.rotation.copy(nD.rotation),
        (e.scale.x = 1 * Nl.game.velocity),
        (e.scale.y = 0.11);
    },
    particleUpdate: function (e, t) {
      e.initialRoadProgress - Nl.game.progress < -3 && (e.killable = !0),
        (e.progress = e.progressEase(wy(e.age / e.fadeIn, 0, 1))),
        e.color
          .copy(e.colorFrom)
          .lerp(e.colorTo, e.colorEase(e.progress))
          .multiplyScalar(
            Ty(9.5, 15, Nl.game.velocity) * Nl.scene.gameCam.activeInfluence
          );
      const n = 0.3 * Nl.scene.gameCam.activeInfluence;
      e.alpha = 1 - n + (1 - Ty(10, 17, Nl.game.velocity));
    },
    particleReleased: function () {
      iD = Math.max(iD - 1, 0);
    },
  },
  sD = Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default: rD,
  });
const aD = 2 * Math.PI,
  oD = new Xb(1, 1, 1),
  lD = new Cx();
var cD = {
    beforeEmit: function (e = {}) {
      e.position || (e.position = lD),
        (e.scale = e.scale || 1),
        (e.angOffset = pA.randomFloat(0, aD));
    },
    particleEmitted: function (
      e,
      {
        angOffset: t,
        position: n,
        scale: i,
        velDrag: r,
        sprite: s,
        color: a,
        amount: o,
        billboard: l,
        duration: c = 1e3,
        velocity: u = 1,
        opacity: h,
        gravity: d = 0,
      }
    ) {
      const p = aD / o,
        f = e.index * p + pA.randomFloat(-0.2, 0.2) + t;
      (u += pA.randomFloat(-0.05, 0.1)),
        (u *= 1.03),
        (e.delay = pA.randomFloat(0, 20)),
        (e.billboard = l || !0),
        (e.angVelocity = 0),
        (e.spriteId = s),
        (e.velocity.x += u * Math.cos(f)),
        (e.velocity.y += u * Math.sin(f)),
        (e.angle = -f + Math.PI / 16),
        e.velocityDrag.setScalar(r || 0.97),
        (e.useVelocityDragMult = !0),
        (e.gravity.y = -0.03),
        e.position.copy(n),
        e.position.add(lD.copy(e.velocity).multiplyScalar(5.5)),
        (e.duration = c * pA.randomFloat(0.8, 1));
      const m = (i = i || 1).x || i,
        g = i.y || i;
      e.scaleFrom.set(m, g),
        e.scaleTo.setScalar(0),
        (h *= pA.randomFloat(0.8, 1.2)),
        (e.alpha = 0.3),
        e.colorFrom.copy(a || oD).multiplyScalar(h),
        e.colorTo.copy(e.colorFrom);
    },
  },
  uD = Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default: cD,
  });
const hD = 2 * Math.PI,
  dD = new Xb(1, 1, 1),
  pD = new Cx(),
  fD = hD;
var mD = {
    beforeEmit: function (e = {}) {
      e.position || (e.position = pD),
        (e.scale = e.scale || 1),
        (e.angOffset = 0.6 * hD);
    },
    particleEmitted: function (
      e,
      {
        angOffset: t,
        position: n,
        scale: i,
        velDrag: r,
        sprite: s,
        color: a,
        amount: o,
        billboard: l,
        duration: c,
        velocity: u = 1,
        opacity: h,
        gravity: d = 0,
      }
    ) {
      const p = fD / o,
        f = e.index * p + pA.randomFloat(-0.2, 0.2) + t;
      (u *= pA.randomFloat(0.8, 1.2)),
        (e.billboard = l || !0),
        (e.delay = pA.randomFloat(20, 100)),
        (e.angVelocity = 0),
        (e.spriteId = s),
        (e.velocity.x += u * Math.cos(f)),
        (e.velocity.y += u * Math.sin(f)),
        (e.angle = -f + Math.PI / 16),
        e.velocityDrag.setScalar(r || 0.98),
        (e.useVelocityDragMult = !0),
        (e.gravity.y = -0.2 * pA.randomFloat(0.2, 2.5)),
        e.position.copy(n),
        e.position.add(pD.copy(e.velocity).multiplyScalar(2.5)),
        (e.duration = c * pA.randomFloat(0.8, 1));
      const m = (i = i || 1).x || i,
        g = i.y || i;
      e.scaleFrom.set(m, g),
        e.scaleTo.setScalar(0),
        (e.alpha = 0.9),
        e.colorFrom.copy(a || dD).multiplyScalar(h),
        e.colorTo.copy(e.colorFrom);
    },
  },
  gD = Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default: mD,
  });
const vD = new Xb(1, 1, 1),
  _D = new Xb(0, 0, 0);
new Ab();
const yD = new Cx(),
  xD = [0, 0.815, 0.145, 1],
  bD = [0, 0.485, 0.465, 1];
var wD = {
  particleEmitted: function (
    e,
    {
      position: t,
      scale: n,
      sprite: i,
      duration: r,
      rotation: s = 0,
      power: a,
      gravityY: o = 0,
      powerMult: l = 1,
      glowMult: c = 1,
    }
  ) {
    (e.billboard = !0),
      (e.spriteId = i),
      e.position.copy(t || yD),
      (e.duration = r || 1e3);
    const u = (n = n || 1).x || n,
      h = n.y || n;
    e.scaleFrom.set(u, h),
      e.scaleTo.copy(e.scaleFrom).multiplyScalar(1.1),
      (e.gravity.y = o),
      (e.angle = s),
      (e.alphaEase = KR(bD)),
      (e.alphaFrom = (1 - (0.3 + 0.7 * a)) * c),
      (e.alphaTo = 1),
      (e.colorEase = KR(xD)),
      e.colorFrom.lerpColors(_D, vD, (0.5 + 0.5 * a) * l),
      e.colorTo.copy(_D);
  },
};
var SD = Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  default: wD,
});
const MD = new Xb(1, 1, 1),
  TD = new Xb(0, 0, 0);
new Ab();
const CD = new Cx(),
  ED = [0, 0.815, 0.145, 1],
  AD = [0, 0.485, 0.465, 1];
var PD = {
  particleEmitted: function (
    e,
    { position: t, scale: n, sprite: i, duration: r, power: s }
  ) {
    (e.billboard = !0),
      (e.spriteId = i),
      e.position.copy(t || CD),
      (e.duration = r || 1e3);
    const a = (n = n || 1).x || n,
      o = n.y || n;
    e.scaleFrom.set(a, o),
      e.scaleTo.copy(e.scaleFrom).multiplyScalar(1.1),
      (e.alphaEase = KR(AD)),
      (e.alphaFrom = 1 - (0.3 + 0.7 * s)),
      (e.alphaTo = 1),
      (e.colorEase = KR(ED)),
      e.colorFrom.lerpColors(TD, MD, 0.5 + 0.5 * s),
      e.colorTo.copy(TD);
  },
};
var LD = Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  default: PD,
});
const ID = 2 * Math.PI,
  RD = new Xb(1, 1, 1),
  DD = new Ab();
var kD = {
  beforeEmit: function (e = {}) {
    e.position || (e.position = tVec3);
    (e.scale = e.scale || 1), (e.angOffset = pA.randomFloat(0, ID));
  },
  particleEmitted: function (
    e,
    {
      velDrag: t,
      position: n,
      scale: i,
      sprite: r,
      rotate: s,
      durationMin: a,
      durationMax: o,
    }
  ) {
    (e.billboard = !1),
      (e.duration = pA.randomFloat(a || 100, o || 300)),
      (e.rotation.z = s ? Math.PI / 2 : 0),
      (e.angVelocity = 0),
      (e.spriteId = r),
      (e.velocity.x = -0.04);
    const l = 0.006;
    (e.velocity.y = pA.randomFloat(0.1 * -0.006, 0.0072)),
      (e.velocity.z = pA.randomFloat(-0.006, l)),
      e.velocityDrag.setScalar(t || 0.88),
      (e.useVelocityDragMult = !0),
      e.position.copy(n),
      e.scaleFrom.set(1 * i, i * pA.randomFloat(7, 12)),
      e.scaleTo.set(0.1 * i, 6 * i),
      DD.position.setScalar(0),
      DD.lookAt(e.velocity),
      DD.rotateX(-Math.PI / 2),
      e.rotation.copy(DD.rotation),
      (e.alphaFrom = 0),
      (e.alphaTo = 1),
      e.colorFrom.copy(RD),
      e.colorTo.copy(RD);
  },
};
var ND = Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  default: kD,
});
const OD = 2 * Math.PI,
  FD = new Xb(1, 1, 1),
  zD = new Xb(1, 0, 0),
  UD = new Cx();
var BD = {
    beforeEmit: function (e = {}) {
      e.position || (e.position = UD),
        (e.scale = e.scale || 1),
        (e.angOffset = pA.randomFloat(0, OD));
    },
    particleEmitted: function (
      e,
      {
        angOffset: t,
        position: n,
        scale: i,
        velDrag: r,
        sprite: s,
        color: a,
        amount: o,
        billboard: l,
        velocity: c,
        opacity: u,
      }
    ) {
      const h = OD / o,
        d = e.index * h + pA.randomFloat(-0.2, 0.2) + t,
        p = pA.randomFloat(0.0018, 0.002);
      (e.billboard = l),
        (e.angVelocity = 0),
        (e.spriteId = s),
        e.velocity.copy(c),
        (e.velocity.x *= -1 * pA.randomFloat(0.0075, 0.015));
      const f = pA.randomFloat(0.7, 0.9);
      (e.velocity.z += p * Math.cos(d) * f),
        (e.velocity.y += p * Math.sin(d) * f),
        (e.angle = f * Math.cos(d)),
        e.velocityDrag.setScalar(r || 0.98),
        (e.useVelocityDragMult = !0),
        (e.gravity.y = pA.randomFloat(-1e-4, 22e-5)),
        e.position.copy(n),
        (e.duration = pA.randomFloat(500, 900)),
        e.scaleFrom.copy(i),
        e.scaleTo.setScalar(0),
        (e.alpha = 0.2),
        e.colorFrom.copy(a || FD).multiplyScalar(u),
        e.colorTo.copy(zD);
    },
  },
  VD = Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default: BD,
  });
const HD = 2 * Math.PI,
  GD = new Xb(1, 1, 1),
  WD = new Cx();
var qD = {
    beforeEmit: function (e = {}) {
      e.position || (e.position = WD),
        (e.scale = e.scale || 1),
        (e.angOffset = pA.randomFloat(0, HD));
    },
    particleEmitted: function (
      e,
      {
        angOffset: t,
        position: n,
        scale: i,
        velDrag: r,
        durationMin: s,
        durationMax: a,
        sprite: o,
        color: l,
        amount: c,
        billboard: u,
        velocity: h,
        opacity: d,
        gravity: p = 0,
      }
    ) {
      const f = HD / c,
        m = e.index * f + pA.randomFloat(-0.2, 0.2) + t;
      let g = (0.01 + pA.randomFloat(-0.005, 0.007)) * i;
      (g = 0.003 * h.x),
        (e.billboard = u),
        (e.angVelocity = 0),
        (e.spriteId = o),
        e.velocity.copy(h).multiplyScalar(-1),
        (e.velocity.z += g * Math.cos(m)),
        (e.velocity.y += g * Math.sin(m)),
        (e.rotation.x = Math.PI / -2),
        (e.rotation.z = g * e.velocity.x * Math.cos(m)),
        e.velocityDrag.setScalar(r || 0.98),
        (e.useVelocityDragMult = !0),
        (e.gravity.y = 0),
        e.position.copy(n),
        (e.duration = pA.randomFloat(s || 500, a || 900)),
        e.scaleFrom.copy(i),
        e.scaleTo.setScalar(0),
        (e.alpha = 0.9),
        e.colorFrom.copy(l || GD).multiplyScalar(d),
        e.colorTo.copy(e.colorFrom);
    },
  },
  jD = Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    default: qD,
  });
const YD = new Tx(),
  XD = 1 / Number.MAX_SAFE_INTEGER,
  $D = {};
let ZD;
new Ab();
class KD extends nP {
  constructor(e) {
    (e.useEuler = !0),
      super(e),
      ZD || (ZD = kl()),
      this.batcher && this.batcher.removeInstance(this),
      (this.spriteId = null),
      (this.spriteFrame = 0),
      (this.spriteFrameDuration = 50),
      (this.spriteLoop = !1),
      (this.spriteAutoplay = !1),
      (this.rotation = new pb()),
      (this.delay = 0),
      (this.duration = 0),
      (this.age = 0),
      (this.progress = 0),
      (this.onProgress = null),
      (this.onComplete = null),
      (this.onEnd = null),
      (this.angVelocity = 0),
      (this.angVelocityDrag = 0),
      (this.velocity = new Cx()),
      (this.velocityDrag = new Cx()),
      (this.velocityDragMult = new Cx()),
      (this.useVelocityDragMult = !1),
      (this.scaleWithVel = !1),
      (this.gravity = new Cx()),
      (this.scaleFrom = new fx()),
      (this.scaleTo = new fx()),
      (this.colorFrom = new Xb()),
      (this.colorTo = new Xb()),
      (this.alphaFrom = 1),
      (this.alphaTo = 1),
      (this.alive = !1),
      (this.killable = !1),
      (this.progressEase = KR()),
      (this.scaleEase = KR()),
      (this.alphaEase = KR()),
      (this.colorEase = KR()),
      (this.scaleVelEase = KR([0, 1, 0.5, 1]));
  }
  reset() {
    this.alive && this.onRelease && this.onRelease(),
      this.preset &&
        this.preset.particleReleased &&
        this.preset.particleReleased(this, this.presetOptions),
      (this.parent = null),
      (this.preset = $D),
      (this.spriteId = null),
      (this.spriteFrame = 0),
      (this.spriteFrameDuration = 50),
      (this.spriteLoop = !1),
      (this.spriteAutoplay = !1),
      (this.billboard = !1),
      (this.angle = 0),
      this.quaternion.copy(YD),
      this.rotation.set(0, 0, 0),
      this.position.setScalar(0),
      this.scale.setScalar(1),
      (this.delay = 0),
      (this.duration = 1e3),
      (this.age = 0),
      (this.progress = 0),
      (this.onProgress = null),
      (this.onComplete = null),
      (this.onRelease = null),
      (this.angVelocity = 0),
      (this.angVelocityDrag = 0),
      this.velocity.setScalar(0),
      this.velocityDrag.setScalar(0),
      (this.useVelocityDragMult = !1),
      (this.scaleWithVel = !1),
      this.gravity.setScalar(0),
      this.scaleFrom.setScalar(1),
      this.scaleTo.setScalar(1),
      this.colorFrom.setRGB(255, 255, 255),
      this.colorTo.setRGB(255, 255, 255),
      (this.alphaFrom = 1),
      (this.alphaTo = 1),
      (this.progressEase = KR()),
      (this.scaleEase = KR()),
      (this.alphaEase = KR()),
      (this.colorEase = KR()),
      (this.scaleVelEase = KR([0.7, 0.3, 0.2, 0.2]));
  }
  emit(e, t, n, i) {
    this.reset(),
      (this.batcher = e),
      (this.spriteId = this.killable = !1),
      (this.alive = !0),
      (this.index = i),
      (this.billboard = n.billboard || !1),
      (this.parent = n.parent),
      (this.preset = t || $D),
      (this.presetOptions = n || $D),
      this.preset.particleEmitted &&
        this.preset.particleEmitted(this, this.presetOptions),
      this.sprite.setAtlas(this.batcher.atlas),
      this.sprite.change({
        id: this.spriteId,
        frame: this.spriteFrame,
        frameDuration: this.spriteFrameDuration,
        loop: this.spriteLoop,
        autoplay: this.spriteAutoplay,
      }),
      this.batcher.addInstance(this),
      this.sprite.update(1),
      this.update(0);
  }
  kill() {
    this.killable &&
      this.preset.particleKilled &&
      this.preset.particleKilled(this, this.presetOptions),
      this.killable && this.onComplete && this.onComplete(),
      this.batcher &&
        (this.batcher.removeInstance(this), (this.batcher = null)),
      this.reset(),
      (this.progress = 1),
      (this.alive = !1),
      (this.killable = !1);
  }
  update() {
    if (!this.alive || this.killable) return;
    if (this.progress >= 1) return (this.killable = !0);
    let e = ZD.time.stableDt;
    if (this.delay > 0) {
      if (((this.delay -= e), this.delay > 0))
        return (this.alpha = 0), void this.scale.setScalar(XD);
      e = Math.max(0, e + this.delay);
    }
    super.update(e);
    const t = Math.max(Math.min(e / 16.666666667, 1.5), 0.5);
    if (
      ((this.age += e),
      (this.progress = this.progressEase(wy(this.age / this.duration, 0, 1))),
      this.preset.particleUpdate)
    )
      this.preset.particleUpdate(this, this.presetOptions);
    else {
      if (this.useVelocityDragMult)
        this.velocity.multiply(this.velocityDrag),
          this.velocity.lengthSq < 1e-4 && this.velocity.setScalar(0);
      else {
        if (this.velocity.x) {
          const e = Math.sign(this.velocity.x);
          (this.velocity.x -= e * this.velocityDrag.x * t),
            Math.sign(this.velocity.x) !== e && (this.velocity.x = 0);
        }
        if (this.velocity.y) {
          const e = Math.sign(this.velocity.y);
          (this.velocity.y -= e * this.velocityDrag.y * t),
            Math.sign(this.velocity.y) !== e && (this.velocity.y = 0);
        }
        if (this.velocity.z) {
          const e = Math.sign(this.velocity.z);
          (this.velocity.z -= e * this.velocityDrag.z * t),
            Math.sign(this.velocity.z) !== e && (this.velocity.z = 0);
        }
      }
      if (this.angVelocity) {
        const e = Math.sign(this.angVelocity);
        (this.angVelocity -= e * this.angVelocityDrag * t),
          Math.sign(this.angVelocity) !== e && (this.angVelocity = 0);
      }
      (this.position.x += (this.velocity.x + this.gravity.x) * t),
        (this.position.y += (this.velocity.y + this.gravity.y) * t),
        (this.position.z += (this.velocity.z + this.gravity.z) * t),
        this.billboard
          ? (this.angle += this.angVelocity * t)
          : (this.rotation.z += this.angVelocity * t),
        this.scaleWithVel
          ? this.scale
              .copy(this.scaleFrom)
              .lerp(this.scaleTo, this.scaleVelEase(this.progress))
          : this.scale
              .copy(this.scaleFrom)
              .lerp(this.scaleTo, this.scaleEase(this.progress)),
        this.color
          .copy(this.colorFrom)
          .lerp(this.colorTo, this.colorEase(this.progress)),
        (this.alpha = Cy(
          this.alphaFrom,
          this.alphaTo,
          this.alphaEase(this.progress)
        ));
    }
    this.preset.particleUpdated &&
      this.preset.particleUpdated(this, this.presetOptions),
      this.onProgress && this.onProgress(this, this.progress);
  }
}
const JD = {};
class QD extends lA {
  constructor(e) {
    super(e),
      e.batcher && (e.batchers = [e.batcher]),
      (this.count = e.count || 150),
      (this.dead = new Array(this.count).fill(0).map(() => new KD({}))),
      (this.alive = []),
      (this.batchers = e.batchers || []);
  }
  emit(e, t = {}, n) {
    "number" == typeof t && (t = { amount: t });
    const i = (t.amount = t.amount || 1),
      r = JD[e];
    if (!r) return;
    if ((r.beforeAlloc && r.beforeAlloc(t), t.amount <= 0)) return;
    const s = this.batchers[n] || this.batchers[0],
      a = this.alloc(i);
    r.beforeEmit && r.beforeEmit(t, a);
    for (let o = a.length - 1; o >= 0; o--)
      a[o].alive || 0, this.alive.push(a[o]), a[o].emit(s, r, t, o);
  }
  update(e) {
    const t = [];
    for (let n = this.alive.length - 1; n >= 0; n--) {
      const i = this.alive[n];
      i.update(e),
        i.killable && (t.push(i), this.alive.splice(n, 1), this.dead.push(i));
    }
    for (let n = t.length - 1; n >= 0; n--) t[n].kill();
  }
  alloc(e) {
    const t = this.dead,
      n = this.alive;
    let i = [],
      r = e;
    return (
      t.length > 0 && (i = t.splice(0, r)),
      (r -= i.length),
      r > 0 && (i = i.concat(n.splice(0, r))),
      i
    );
  }
  killAll() {
    for (let e = this.alive.length - 1; e >= 0; e--)
      this.alive[e].kill(),
        this.dead.push(this.alive[e]),
        this.alive.splice(e, 1);
  }
  registerPreset(e, t) {
    !(function (e, t) {
      t || (t = {}), (JD[e] = t);
    })(e, t);
  }
}
let ek = 0;
const tk = new $w(),
  nk = new Map(),
  ik = new Ab(),
  rk = new Tx(),
  sk = { default: 1, additive: 2 },
  ak = { double: 2, front: 0, back: 1 };
var ok = class extends zA {
    init(e) {
      (this.needsUpdate = !0),
        (this.atlas = e.atlas),
        (this.count = e.count || 200),
        (this.geo = new EE()),
        (this.geo.index = tk.index),
        (this.geo.attributes.position = tk.attributes.position),
        (this.geo.attributes.uv = tk.attributes.uv),
        this.initAttributes(),
        (this.layers = []),
        (this.layersHashmap = {}),
        (this.instances = new Set()),
        this.setDynamic(e.dynamic);
      const t = this.getMaterial(e);
      (this.base = new Aw(this.geo, t)),
        (this.base.renderOrder = e.renderOrder),
        (this.base.frustumCulled = !!e.frustumCulled),
        (this.currentCount = 0),
        (this.updateAttributes = this.updateAttributes.bind(this));
    }
    setDynamic(e) {
      (this.dynamic = null == e || !!e),
        this.interleavedBuffer.setUsage(this.dynamic ? 35048 : StaticDrawUsage),
        (this.interleavedBuffer.needsUpdate = !0),
        (this.needsUpdate = !0);
    }
    getMaterial(e) {
      const t = e.material;
      if (!t) return;
      nk.has(t) || nk.set(t, {});
      const n = nk.get(t),
        i = e.atlas;
      if (!i) return;
      null == i.meta.atlasIndex && (i.meta.atlasIndex = ++ek);
      const r = null == e.depthWrite || e.depthWrite,
        s = null == e.depthTest || e.depthTest,
        a = null != e.blending ? e.blending : "default",
        c = null != e.transparent && e.transparent,
        u = null != e.alphaTest && e.alphaTest,
        h = null != e.side ? e.side : "front",
        d = [
          i.meta.atlasIndex,
          h + "",
          r.toString(),
          s.toString(),
          a.toString(),
          c.toString(),
          u.toString(),
        ].join("_");
      if (n[d]) return n[d];
      const p = o({}, e);
      return (
        delete p.material,
        (n[d] = new t(
          l(o({}, p), {
            atlas: i,
            side: ak[h],
            blending: "function" == typeof a ? a : sk[a],
            depthWrite: !!r,
            depthTest: !!s,
            transparent: !!c,
            alphaTest: !!u,
          })
        ))
      );
    }
    initAttributes() {
      (this.stride = 20),
        (this.buffer = new Float32Array(this.count * this.stride));
      const e = this.geo,
        t = (this.interleavedBuffer = new zE(this.buffer, this.stride));
      e.setAttribute("texCoords", new zT(t, 4, 0, !1)),
        e.setAttribute("meshCoords", new zT(t, 4, 4, !1)),
        e.setAttribute("spritePos", new zT(t, 3, 8, !1)),
        e.setAttribute("billboard", new zT(t, 1, 11, !1)),
        e.setAttribute("spriteQt", new zT(t, 4, 12, !1)),
        e.setAttribute("spriteColor", new zT(t, 4, 16, !1)),
        (t.needsUpdate = !0);
    }
    updateAttributes(e) {
      if (!e || !e.visible) return;
      const t = this.currentCount++,
        n = this.buffer,
        i = this.stride,
        r = e.sprite.frame;
      let s = t * i;
      e.useEuler && e.quaternion.setFromEuler(e.rotation);
      let a = e.position,
        o = e.quaternion,
        l = e.scale;
      if (e.parent) {
        const t = e.parent;
        ik.position.copy(a),
          ik.quaternion.copy(e.billboard ? rk : o),
          ik.scale.set(l.x, l.y, 1),
          ik.applyMatrix4(t.matrixWorld),
          ik.updateMatrixWorld(),
          (a = ik.position),
          (o = ik.quaternion),
          (l = ik.scale);
      }
      const c = e.billboard ? e.angle : o.x;
      (n[s++] = r.texCoords[0]),
        (n[s++] = r.texCoords[1]),
        (n[s++] = r.texCoords[2]),
        (n[s++] = r.texCoords[3]),
        (n[s++] = r.meshCoords[0] * e.scale.x),
        (n[s++] = r.meshCoords[1] * e.scale.y),
        (n[s++] = r.meshCoords[2] * e.scale.x),
        (n[s++] = r.meshCoords[3] * e.scale.y),
        (n[s++] = a.x),
        (n[s++] = a.y),
        (n[s++] = a.z),
        (n[s++] = e.billboard ? 1 : 0),
        (n[s++] = c),
        (n[s++] = o.y),
        (n[s++] = o.z),
        (n[s++] = o.w),
        (n[s++] = e.color.r),
        (n[s++] = e.color.g),
        (n[s++] = e.color.b),
        (n[s++] = e.alpha);
    }
    addInstance(e) {
      this.instances.has(e) || this.instances.add(e);
    }
    removeInstance(e) {
      this.instances.has(e) && this.instances.delete(e);
    }
    update() {
      this.dynamic &&
        ((this.currentCount = 0),
        this.instances.forEach(this.updateAttributes),
        (this.geo.instanceCount = this.currentCount),
        (this.interleavedBuffer.needsUpdate = !0));
    }
    clearInstances() {
      this.instances.clear();
    }
    destroy() {
      this.clearInstances(), this.geo.dispose(), super.destroy();
    }
  },
  lk = nA(
    "precision highp float;attribute vec4 texCoords;attribute vec4 meshCoords;attribute vec3 spritePos;attribute vec4 spriteQt;attribute vec4 spriteColor;attribute float billboard;varying vec2 vUv;varying vec4 vColor;\n#include <get_instance_matrix>\nvoid main(){vColor=spriteColor;vUv=uv*texCoords.zw+texCoords.xy;vUv.y=1.-vUv.y;vec3 transformed=position;transformed.xy=transformed.xy*meshCoords.zw+(meshCoords.xy*0.5);transformed.xy+=meshCoords.xy*0.5;mat4 instanceMatrix=getInstanceMatrix(spritePos,spriteQt,vec3(1.));vec4 mvPosition=modelViewMatrix*instanceMatrix*vec4(transformed,1.);vec4 bbPosition=modelViewMatrix*instanceMatrix*vec4(0.0,0.0,0.0,1.0);bbPosition.x+=cos(spriteQt.x)*transformed.x-sin(spriteQt.x)*transformed.y;bbPosition.y+=sin(spriteQt.x)*transformed.x+cos(spriteQt.x)*transformed.y;mvPosition=mix(mvPosition,bbPosition,billboard);gl_Position=projectionMatrix*mvPosition;}",
    "precision highp float;uniform sampler2D atlas;varying vec2 vUv;varying vec4 vColor;void main(){vec2 uv=vUv;vec3 color=texture2D(atlas,uv).rgb;float alpha=1.-(color.r*(1.-vColor.a));gl_FragColor=vec4(vColor.rgb*color,alpha);}"
  );
class ck extends kw {
  constructor(e = {}) {
    const t = e.atlas;
    delete e.atlas, delete e.renderOrder;
    const n = "function" == typeof e.blending && e.blending;
    n && delete e.blending,
      super(e),
      (this.uniforms = l(o({}, e.uniforms || {}), {
        atlas: { value: t.texture, type: "t" },
      })),
      n && n(this),
      e.vertexShader || e.fragmentShader || lk.use(this);
  }
}
const uk = {
    "/webgl/particlePresets/burst.js": XR,
    "/webgl/particlePresets/dashline.js": sD,
    "/webgl/particlePresets/fireworksBurst.js": uD,
    "/webgl/particlePresets/fireworksBurstFall.js": gD,
    "/webgl/particlePresets/fireworksFlash.js": SD,
    "/webgl/particlePresets/flash.js": LD,
    "/webgl/particlePresets/hitSparkles.js": ND,
    "/webgl/particlePresets/line.js": VD,
    "/webgl/particlePresets/smoke.js": jD,
  },
  hk = Object.entries(uk).map(([e, t]) => ({
    id: e.split("/").pop().split(".js").shift(),
    module: t.default,
  }));
function dk(e) {
  const t = {
    init: function (t) {
      const a = {
        renderOrder: e.store.renderOrder.sprites,
        material: ck,
        atlas: e.atlas,
        blending: IP,
        depthWrite: !1,
        depthTest: !1,
      };
      (n = new ok(o({}, a))),
        (i = new ok(l(o({}, a), { depthTest: !0 }))),
        t.add(n.base),
        t.add(i.base);
      (r = new QD({ batchers: [n, i] })),
        hk.forEach((e) => r.registerPreset(e.id, e.module)),
        e.game.hooks.reset.watch(s);
    },
    emit: function (e, t = {}) {
      if (!r) return;
      const n = t.depthTest ? 1 : 0;
      return r.emit(e, t, n);
    },
    update: function () {
      if (e.game.isPaused()) return;
      n.update(), i.update(), r.update();
    },
    get batcher() {
      return n;
    },
    get batcherDepth() {
      return i;
    },
  };
  let n, i, r;
  function s() {
    r.killAll();
  }
  e.particles = e.game.particles = t;
}
function pk() {}
const fk = {},
  mk = {};
function gk(e) {
  try {
    return e.stop(), !1;
  } catch (t) {
    return !0;
  }
}
function vk(e) {
  return (
    fk[e] ||
      (fk[e] = new Promise((t) => {
        const n = new XMLHttpRequest();
        n.open("GET", e, !0),
          (n.responseType = "arraybuffer"),
          (n.onload = () => t(n.response)),
          n.send();
      })),
    fk[e]
  );
}
function _k(e, t) {
  return e
    ? (mk[t] ||
        (mk[t] = new Promise((n) => {
          vk(t).then((t) => {
            e.decodeAudioData(t, (e) => n(e));
          });
        })),
      mk[t])
    : vk(t);
}
class yk {
  constructor(e) {
    (this.onEnded = this.onEnded.bind(this)),
      (this.onLoaded = this.onLoaded.bind(this)),
      (this.controller = e),
      (this.context = e.getContext()),
      (this.input = null),
      (this.output = this.context.createGain());
  }
  reset(e = {}) {
    (this.onStop = null),
      this.stop(),
      (this.pausedProgress = 0),
      (this.fadein = e.fadein || 0),
      (this.fadeout = e.fadeout || 0),
      (this.fadeinTimer = 0),
      (this.fadeoutTimer = 0),
      (this.fadeinActive = !1),
      (this.fadeoutActive = !1),
      (this.needsPlay = !1),
      (this.isPlaying = !1),
      (this.isStopping = !1),
      (this.hasEnded = !1),
      (this.loaded = !1),
      (this.stopped = !1),
      (this.id = e.id || null),
      (this.source = null),
      (this.buffer = null),
      (this.loop = !!e.loop),
      (this.autoplay = !!e.autoplay),
      (this.playbackRate = e.playbackRate || 1),
      (this.volume = e.volume || 1),
      (this.realvolume = -1),
      (this.loopStart = e.loopStart || 0),
      (this.loopEnd = e.loopEnd || 0),
      (this.onStop = e.onStop || pk),
      (this.baseOffset = e.start || e.baseOffset || 0),
      (this.duration = e.duration);
    const t = e.input || this.controller.getInput();
    t !== this.input &&
      (this.input && this.output.disconnect(this.input),
      (this.input = t),
      this.output.connect(this.input)),
      _k(this.context, e.path).then(this.onLoaded),
      this.autoplay && this.play();
  }
  onLoaded(e) {
    this.isStopping ||
      this.stopped ||
      this.stopped ||
      ((this.loaded = !0), (this.buffer = e), this.needsPlay && this.play());
  }
  onEnded() {
    this.loop || ((this.hasEnded = !0), this.stop());
  }
  getOutput() {
    return this.output;
  }
  update(e) {
    if (!this.source) return;
    let t = this.volume;
    if (this.fadeinActive) {
      this.fadeinTimer += e;
      const n = wy(this.fadeinTimer / this.fadein, 0, 1);
      (t *= n), 1 === n && (this.fadeinActive = !1);
    }
    if (this.fadeoutActive) {
      this.fadeoutTimer += e;
      const n = wy(1 - this.fadeoutTimer / this.fadeout, 0, 1);
      (t *= n), 0 === n && this.realstop();
    }
    t !== this.realvolume && this.setVolume(t);
  }
  play() {
    if ((this.source && this.stop(), !this.loaded))
      return void (this.needsPlay = !0);
    const e = (this.source = this.context.createBufferSource());
    if (
      ((e.buffer = this.buffer),
      (e.onended = this.onEnded),
      (this.startTime = this.context.currentTime),
      (this.isPlaying = !0),
      (this.needsPlay = !1),
      !e || !e.buffer)
    )
      return this.stop();
    (this.progressStart = this.startTime - this.offset),
      this.duration || (this.duration = e.buffer.duration);
    const t = Math.max(this.duration - this.offset, 0.01),
      n = (function (e, t, n, i) {
        try {
          return e.start(t, n, i), !1;
        } catch (r) {
          return !0;
        }
      })(
        this.source,
        this.startTime,
        (this.baseOffset + this.offset) % e.buffer.duration,
        this.duration ? t : void 0
      );
    n
      ? requestAnimationFrame(() => this.stop())
      : (this.fadein && 0 === this.fadeinTimer
          ? this.setVolume(0, !0)
          : this.setVolume(this.volume, !0),
        this.fadein && (this.fadeinActive = !0),
        this.setPlaybackRate(this.playbackRate),
        this.connect(),
        this.setLoop(this.loop));
  }
  getCurrentTime() {
    return this.getProgress() * this.duration;
  }
  getProgress() {
    return this.isPlaying
      ? (this.context.currentTime - this.progressStart) / this.duration
      : this.pausedProgress;
  }
  connect() {
    this.source.connect(this.output);
  }
  disconnect() {
    this.source.disconnect(this.output);
  }
  pause() {
    (this.pausedProgress = this.getProgress()),
      (this.offset +=
        (this.context.currentTime - this.startTime) * this.playbackRate),
      (this.needsPlay = !1),
      (this.isPlaying = !1),
      this.source &&
        (gk(this.source), (this.source.onended = null), (this.source = null));
  }
  realstop() {
    this.onStop && this.onStop(this),
      (this.onStop = null),
      (this.offset = 0),
      (this.needsPlay = !1),
      (this.isPlaying = !1),
      (this.isStopping = !1),
      (this.fadeinActive = !1),
      (this.fadeoutActive = !1),
      (this.stopped = !0),
      this.source &&
        (gk(this.source), (this.source.onended = null), (this.source = null));
  }
  stop(e = {}) {
    this.isStopping ||
      ((this.isStopping = !0),
      e.fadeout && (this.fadeout = e.fadeout),
      this.fadeout ? (this.fadeoutActive = !0) : this.realstop());
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  setPlaybackRate(e) {
    (this.playbackRate = e),
      this.isPlaying &&
        this.source &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01
        );
  }
  getLoop() {
    return this.loop;
  }
  setLoop(e) {
    (this.loop = e),
      this.isPlaying &&
        this.source &&
        ((this.source.loop = this.loop),
        (this.source.loopStart = this.loopStart),
        (this.source.loopEnd = this.loopEnd));
  }
  getVolume() {
    return this.output.gain.value;
  }
  setVolume(e, t, n = 0.01) {
    (this.realvolume = e),
      t && (this.output.gain.value = this.realvolume),
      this.output.gain.setTargetAtTime(
        this.realvolume,
        this.context.currentTime,
        n
      );
  }
  release() {
    yk.release(this);
  }
}
(yk.pool = []),
  (yk.get = function (e, t) {
    const n = yk.pool.pop() || new yk(e);
    return n.reset(t), n;
  }),
  (yk.release = function (e) {
    (e.buffer = null),
      (e.onStop = null),
      yk.pool.length < 50 && yk.pool.push(e);
  });
const xk = window.performance || window.Date,
  bk = ["click", "touchend", "keydown"],
  wk = window.AudioContext || window.webkitAudioContext;
let Sk = null,
  Mk = null,
  Tk = null,
  Ck = !1;
const Ek = {
    initialized: !1,
    unlocked: !1,
    unlockerListening: !0,
    lastStuckCheck: xk.now(),
    stuckTimer: 0,
    previousWebAudioTime: 0,
  },
  Ak = { onContextCreation: null, onUnlock: null, onStuck: null };
function Pk(e) {
  const t = e.createBufferSource();
  (t.buffer = e.createBuffer(1, 1, 44100)),
    t.connect(e.destination),
    t.start(0),
    t.disconnect();
}
function Lk() {
  Ek.unlocked ||
    (!(function () {
      if (Tk) return;
      (Tk = (function () {
        try {
          const e = new wk();
          return Pk(e), e.close(), new wk();
        } catch (e) {
          return null;
        }
      })()),
        (Ek.initialized = !0),
        Ak.onContextCreation && Ak.onContextCreation(Tk);
      Dk();
    })(),
    Tk.suspend(),
    window.setTimeout(() => Tk.resume(), 10),
    Pk(Tk),
    Ik(),
    (function () {
      Ek.unlockerListening = !1;
      for (const e of bk) document.removeEventListener(e, Lk, { passive: !0 });
    })(),
    (Ek.unlocked = !0),
    (Ek.stuckTimer = -800),
    (Ek.lastStuckCheck = xk.now()),
    Ak.onUnlock && Ak.onUnlock());
}
function Ik(e = !1) {
  return new Promise((e) => {
    Mk ||
      ((Mk = document.createElement("audio")),
      Mk.setAttribute("x-webkit-airplay", "deny"),
      (Mk.preload = "auto"),
      (Mk.loop = !1),
      (Mk.src = Sk),
      Mk.load()),
      Mk.pause(),
      (Mk.currentTime = 0);
    try {
      Promise.resolve()
        .then(() => Mk.play())
        .then(() => e(!0))
        .catch((t) => {
          e(!1);
        });
    } catch (t) {
      e(!1);
    }
  });
}
function Rk() {
  (Ek.unlocked = !1), (Ek.unlockerListening = !0);
  for (const e of bk) document.addEventListener(e, Lk, { passive: !0 });
}
function Dk() {
  window.requestAnimationFrame(Dk);
  const e = xk.now(),
    t = e - Ek.lastStuckCheck;
  if (!Ek.initialized || !Tk || t < 400) return;
  const n = Tk.currentTime,
    i = n === Ek.previousWebAudioTime;
  (Ek.stuckTimer = i ? Ek.stuckTimer + t : 0),
    (Ek.previousWebAudioTime = n),
    (Ek.lastStuckCheck = e),
    Ek.stuckTimer > 400 &&
      Ek.unlocked &&
      !Ek.unlockerListening &&
      (Rk(), Ak.onStuck && Ak.onStuck());
}
var kk = {
  init: function () {
    Ek.initialized ||
      ((Sk = (function (e) {
        const t = new ArrayBuffer(10),
          n = new DataView(t);
        return (
          n.setUint32(0, e, !0),
          n.setUint32(4, e, !0),
          n.setUint16(8, 1, !0),
          `data:audio/wav;base64,UklGRisAAABXQVZFZm10IBAAAAABAAEA${window
            .btoa(String.fromCharCode(...new Uint8Array(t)))
            .slice(0, 13)}AgAZGF0YQcAAACAgICAgICAAAA=`
        );
      })(44100)),
      Rk(),
      (async function () {
        (await Ik(!0)) && Lk();
      })());
  },
  getVolume: function (e) {
    return e.gain.value;
  },
  setVolume: function (e, t) {
    e.gain.setTargetAtTime(t, Tk.currentTime, 0.01);
  },
  getContext: () => Tk,
  isUnlocked: () => Ek.unlocked,
  set debug(e) {
    Ck = e;
  },
  set onContextCreation(e) {
    Ak.onContextCreation = e;
  },
  set onUnlock(e) {
    Ak.onUnlock = e;
  },
  set onStuck(e) {
    Ak.onStuck = e;
  },
};
const Nk = {};
JSON.parse(
  '[["Boost_Line_Loop",0,16,16],["Button",16.25,16.5,0.25],["Car_Engine_Boost",16.75,22.3809,5.6309],["Car_Engine_Loop_AirFlow",22.6309,27.1309,4.5],["Car_Engine_Loop_High",27.3809,31.8809,4.5],["Car_Engine_Loop_Low",32.1309,36.6309,4.5],["Car_Engine_Loop_Mid",36.8809,41.3809,4.5],["Car_Friction_Loop",41.6309,45.1375,3.5066],["Car_Impact",[[45.3875,46.2837,0.8962],[46.5337,47.43,0.8962],[47.68,48.5762,0.8962],[48.8262,49.7224,0.8962],[49.9724,50.8686,0.8962]]],["FireworksEnd",[[51.1186,52.7831,1.6645],[53.0331,55.007,1.9739],[55.257,57.0637,1.8067],[57.3137,59.0446,1.7309],[59.2946,60.9627,1.6681]]],["UI_Countdown_GO",61.2127,64.3783,3.1656],["UI_Countdown_One",64.6283,67.316,2.6877],["UI_Countdown_Three",67.566,70.1448,2.5788],["UI_Countdown_Two",70.3948,73.1069,2.7121],["UI_Finish",73.3569,76.5225,3.1656],["UI_Hover_Tiny",76.7725,76.8764,0.1039],["UI_Pause",77.1264,78.9815,1.8551],["UI_QRCode",79.2315,81.5343,2.3028],["UI_ResulTime",81.7843,84.4429,2.6585],["UI_Title_TheRace",84.6929,87.5254,2.8326],["UI_Validate_Big",87.7754,89.8833,2.1079],["UI_Validate_Small",90.1333,91.8986,1.7654]]'
).forEach(([e, t, n, i]) => {
  Nk[e] = Array.isArray(t)
    ? {
        id: e,
        path: "/assets/audiosprites.5ae006ed274a7243.m4a",
        variations: t.map((t) => ({
          id: e,
          start: t[0],
          end: t[1],
          duration: t[2],
        })),
      }
    : {
        id: e,
        path: "/assets/audiosprites.5ae006ed274a7243.m4a",
        start: t,
        end: n,
        duration: i,
      };
}),
  (Nk.Music_Layer1_SoftBeat = {
    path: "/assets/Music_Layer1_SoftBeat.d230ffac274a7243.m4a",
    unique: !0,
  }),
  (Nk.Music_Layer2_Pad = {
    path: "/assets/Music_Layer2_Pad.97e61a1b274a7243.m4a",
    unique: !0,
  }),
  (Nk.Music_Layer3_Drum = {
    path: "/assets/Music_Layer3_Drum.c70889f1274a7243.m4a",
    unique: !0,
  }),
  (Nk.Music_Layer4_BassSnare = {
    path: "/assets/Music_Layer4_BassSnare.0c2dc411274a7243.m4a",
    unique: !0,
  });
var Ok = Nk;
const Fk = 0.05 * Math.log(10);
const zk = (e) => {
    return (t = e + 0), Math.exp(t * Fk);
    var t;
  },
  Uk = (e, t) => Object.assign(Ok[e], t);
Uk("Music_Layer1_SoftBeat", { volume: zk(0), fadein: 5e3, loop: !0 }),
  Uk("Music_Layer2_Pad", { volume: zk(0), fadein: 5e3, loop: !0 }),
  Uk("Music_Layer3_Drum", { volume: zk(0), fadein: 5e3, loop: !0 }),
  Uk("Music_Layer4_BassSnare", { volume: zk(0), fadein: 5e3, loop: !0 });
Uk("Car_Engine_Loop_Low", { fadein: 1e3, loop: !0 }),
  Uk("Car_Engine_Loop_Mid", { fadein: 1e3, loop: !0 }),
  Uk("Car_Engine_Loop_High", { fadein: 1e3, loop: !0 }),
  Uk("Car_Engine_Loop_AirFlow", { fadein: 1e3, loop: !0 }),
  Uk("Car_Friction_Loop", { loop: !0, fadein: 300, fadeout: 300 }),
  Uk("Boost_Line_Loop", { loop: !0 }),
  Uk("UI_Hover_Tiny", { randomRate: [0.9, 1.1], volume: 0.75 }),
  Uk("UI_Validate_Big", { volume: 0.7 }),
  Uk("UI_Validate_Small", { volume: 0.7 }),
  Uk("Button", { randomRate: [0.1, 2], volume: 0.8 });
const Bk = [
    { id: "Music_Layer1_SoftBeat", type: "softbeat" },
    { id: "Music_Layer2_Pad", type: "pad" },
    { id: "Music_Layer3_Drum", type: "drum" },
    { id: "Music_Layer4_BassSnare", type: "snareGuitar" },
  ],
  Vk = {
    nothing: [],
    pad: ["pad"],
    "pad+drum": ["pad", "drum"],
    "pad+guitar": ["pad", "snareGuitar"],
    "pad+drum+guitar": ["pad", "drum", "snareGuitar"],
    "pad+drum+softbeat": ["pad", "drum", "softbeat"],
    "pad+guitar+softbeat": ["pad", "snareGuitar", "softbeat"],
    all: ["softbeat", "pad", "drum", "snareGuitar"],
    intro: ["softbeat", "pad"],
    outro: ["pad", "drum"],
  };
const Hk = KR([0.345, 0.005, 0.635, 1]),
  Gk = () => 0,
  Wk = () => 1,
  qk = (e) => Hk(e),
  jk = (e) => 1 - Hk(e),
  Yk = KR([0.57, 0.06, 0.925, 0.595]),
  Xk = (e) => e,
  $k = KR([0.555, 0.03, 1, 0.81]),
  Zk = KR([0, 0.705, 0.49, 0.995]),
  Kk = KR([0, 0.705, 0.49, 0.995]),
  Jk = [
    {
      id: "Car_Engine_Loop_Low",
      pitchFrom: 0.5,
      pitchTo: 2,
      before: jk,
      middle: 0.6,
      after: Gk,
      gain: 0.63,
    },
    {
      id: "Car_Engine_Loop_Mid",
      pitchFrom: 0.5,
      pitchTo: 2,
      before: qk,
      middle: 0.5,
      after: jk,
      gain: 0.63 * 0.95,
    },
    {
      id: "Car_Engine_Loop_High",
      pitchFrom: 0.5,
      pitchTo: 2,
      before: Gk,
      middle: 0.3,
      after: qk,
      gain: 0.63 * 0.9,
    },
    {
      id: "Car_Engine_Loop_AirFlow",
      pitchFrom: 1,
      pitchTo: 3,
      before: Wk,
      middle: 0.5,
      after: Wk,
      gain: 1.2,
    },
  ],
  Qk = KR([0, 0.745, 0.195, 0.995]),
  eN = KR([0.735, 0.02, 1, 0.295]),
  tN = [4, 5.2, 6.5, 7.7, 8.3, 9.4],
  nN = ["INACTIVE", "DECREASE", "INCREASE", "COOLDOWN"].reduce(
    (e, t, n) => ((e[t] = n), e),
    {}
  );
function iN(e, t) {
  const n = e.game;
  let i = !1,
    r = 0,
    s = 0,
    a = 0,
    o = 1,
    l = 1,
    c = 0,
    u = nN.INACTIVE,
    h = 0,
    d = 1,
    p = 1;
  return {
    onUnlock: async function () {
      const n = [];
      for (const e of Jk) n.push(t.preloadSound(e.id));
      await Promise.all(n);
      for (const e of Jk) t.stopSound(e.id), (e.instance = t.playSound(e.id));
      i || (e.hooks.afterUpdate.watch(m), (i = !0));
    },
  };
  function f(e, t) {
    null != t && (d = p = t), (h = 0), (u = e);
  }
  function m() {
    !(function () {
      if (e.game.paused.value) return;
      const t = e.time.stableDt,
        i = n.velocity;
      if (((h += t), e.game.turbo.active.value)) f(nN.INACTIVE, 1);
      else
        switch (u) {
          case nN.INACTIVE:
            for (let e = 0; e < tN.length; e++) {
              const t = tN[e];
              if (c < t && i >= t) {
                (c = t), f(nN.DECREASE, 1);
                break;
              }
              i <= t && c >= t && (c = t);
            }
            break;
          case nN.DECREASE:
            (d = Ay(d, 0, 0.6, t)),
              (p = My(Qk(d), 0, 1, 0.55, 1)),
              d < 1e-4 && f(nN.INCREASE);
            break;
          case nN.INCREASE:
            (d = Ay(d, 1, 0.1, t)),
              (p = My(eN(d), 0, 1, 0.55, 1)),
              d > 0.999 && f(nN.COOLDOWN, 1);
            break;
          case nN.COOLDOWN:
            h > 150 && f(nN.INACTIVE, 1);
        }
    })();
    const t = e.time.stableDt,
      i = n.velocity;
    o = Cy(o, 1 - e.game.paused.value, 0.1);
    const m = 0.25 * n.minVelocity,
      g = wy(Sy(i, m, n.maxVelocity), 0, 1),
      v = Xk(wy(Sy(i, 0, m), 0, 1));
    let _ = Yk(g) * p;
    const y = Cy(1, 0.8, $k(wy(Sy(_, 0.6, 1), 0, 1))),
      x = e.scene.currentCamera,
      b = e.scene.road.pointer,
      w = x.base.position.distanceTo(b.base.position),
      S = x.isGameCamera && x.activeInfluence < 0.9999,
      M = +(x.isIdleCamera || 1 - (x.activeInfluence || 0));
    const T = Cy(1, 1.15 * (1 - Zk(wy(Sy(w, 0.3, 15), 0, 1))), M);
    let C = ((e) => 1 - Kk(wy(Sy(e, 0, 20), 0, 1)))(w);
    x.carTowardsCam && (C = 1 - C);
    let E = null != x.engineMult ? x.engineMult : 1;
    S && (E = 1.2);
    const A = Cy(0.8 * _ * E, _ * E, C);
    _ = Cy(_, A, M);
    const P = e.game.turbo.active.value;
    (l = Cy(l, P ? 1.2 : 1, P ? 0.1 : 0.07)),
      (_ *= l),
      (a = 1 * Math.abs(e.controls.turn - r) + 0.1 * Math.abs(e.controls.turn)),
      (s = Ay(s, a, 0.1, t)),
      (r = e.controls.turn),
      (_ *= 1 - s);
    for (let e = 0; e < Jk.length; e++) {
      const t = Jk[e],
        n = Cy(t.pitchFrom, t.pitchTo, _);
      t.rate = n;
      const i = _ > t.middle,
        r = i ? t.middle : 0,
        s = i ? 1 : t.middle,
        a = (i ? t.after : t.before)(Sy(_, r, s));
      (t.volume = a * v * y * t.gain * T * o),
        t.instance &&
          ((t.instance.volume = t.volume), t.instance.setPlaybackRate(t.rate));
    }
  }
}
const rN = (e, t) => (void 0 !== e ? e : t);
function sN(e) {
  const t = _d(!1);
  let n,
    i,
    r,
    s = !1,
    a = !1;
  const o = (e) => e.update(r),
    l = {},
    c = new Set();
  let u = 1;
  const h = { main: 1, fade: 1, mute: 1 },
    d = {
      muted: t,
      init: function () {
        if (s) return;
        (s = !0),
          (kk.debug = !0),
          (kk.onUnlock = _),
          (kk.onContextCreation = g),
          (kk.onStuck = v),
          kk.init(),
          Uc.add(x),
          Sr(
            () => Pl.$stores.muted,
            (e) => d.muted.set(e),
            { immediate: !0 }
          ),
          e.viewport.visible.watch(m),
          d.muted.watchImmediate(y);
      },
      get masterVolume() {
        return u;
      },
      getContext: () => n,
      getInput: () => i,
      play: w,
      pause: S,
      stop: M,
      playSound: T,
      stopSound: function (e, t = {}) {
        const n = l[e];
        if (!n) return;
        n.forEach((e) => e.stop(t));
      },
      preloadSound: function (e) {
        const t = Ok[e];
        if (!t) return;
        const i = t.path;
        return _k(n, i);
      },
      setBgm: function (e) {
        p.setPreset(e);
      },
    };
  e.audio = e.game.audio = d;
  const p = (function (e, t) {
      let n = Vk.nothing,
        i = !1;
      return {
        onUnlock: r,
        setPreset: function (e) {
          const t = Vk[e];
          t && t !== n && ((n = t), a());
        },
        restart: function () {
          i && r();
        },
      };
      async function r() {
        const e = [];
        for (const n of Bk) e.push(t.preloadSound(n.id));
        await Promise.all(e);
        for (const n of Bk)
          t.stopSound(n.id),
            (n.instance = t.playSound(n.id)),
            (n.baseVolume = n.instance.volume),
            (n.targetVolume = n.baseVolume);
        i || (Uc.add(s), (i = !0)), a(!0);
      }
      function s() {
        for (const e of Bk)
          e.instance.volume !== e.targetVolume &&
            (e.instance.volume = Ey(
              e.instance.volume,
              e.targetVolume,
              0.025,
              0.001
            ));
      }
      function a(e) {
        for (const t of Bk)
          (t.targetVolume = n.includes(t.type) ? t.baseVolume : 0),
            e && (t.instance.volume = t.targetVolume);
      }
    })(0, d),
    f = iN(e, d);
  function m(e) {
    n && (e ? (w(), (h.fade = 1)) : (S(), (h.fade = 0)), b());
  }
  function g(e) {
    (n = e), (i = e.createGain()), i.connect(e.destination);
  }
  function v() {
    M();
  }
  function _() {
    p.onUnlock(n), f.onUnlock(n);
  }
  function y(e) {
    h.mute = e ? 0 : 1;
  }
  function x(e) {
    if (kk.isUnlocked()) {
      r = e;
      for (const t of c)
        (t.timer -= e), t.timer <= 0 && (c.delete(t), T(t.id, t.opts));
      if ((b(), !a)) for (const e in l) l[e].forEach(o);
    }
  }
  function b() {
    const e = h;
    (u = e.main * e.fade * e.mute), kk.setVolume(i, u);
  }
  function w() {
    if (a) {
      a = !1;
      for (const e in l)
        l[e].forEach((e) => {
          e.loop || e.play();
        });
    }
  }
  function S() {
    if (!a) {
      a = !0;
      for (const e in l)
        l[e].forEach((e) => {
          e.loop || e.pause();
        });
    }
  }
  function M() {
    for (const e in l) l[e].forEach((e) => e.stop());
  }
  function T(e, t = {}) {
    if (!kk.isUnlocked()) return;
    const n = Ok[e];
    if (!n) return;
    if (t.delay) {
      const n = t.delay;
      return delete t.delay, void c.add({ id: e, opts: t, timer: n });
    }
    if ((l[e] || (l[e] = new Set()), n.unique && l[e].size > 0)) {
      const t = l[e].values().next().value;
      return t.play(), t;
    }
    if (
      ((t.id = e),
      (t.path = n.path),
      (t.onStop = C),
      (t.autoplay = !0),
      (t.loop = rN(t.loop, !!n.loop)),
      (t.fadein = t.fadein || n.fadein),
      (t.fadeout = t.fadeout || n.fadeout),
      n.variations)
    ) {
      let e = t.variation && n.variations[t.variation - 1];
      e || (e = IA(n.variations)),
        (t.start = rN(t.start, e.start)),
        (t.duration = rN(t.duration, e.duration)),
        (t.loopStart = rN(t.loopStart, rN(e.loopStart, t.start))),
        (t.loopEnd = rN(t.loopEnd, rN(e.loopEnd, t.start + t.duration)));
    } else
      (t.start = rN(t.start, n.start)),
        (t.duration = rN(t.duration, n.duration)),
        (t.loopStart = rN(t.loopStart, rN(n.loopStart, t.start))),
        (t.loopEnd = rN(t.loopEnd, rN(n.loopEnd, t.start + t.duration)));
    var i, r;
    (t.volume = rN(t.volume, rN(n.volume, 1))),
      (t.playbackRate = n.randomRate
        ? ((i = n.randomRate[0]),
          (r = n.randomRate[1]),
          Math.random() * (r - i) + i)
        : null != t.playbackRate
        ? t.playbackRate
        : 1);
    const s = yk.get(d, t);
    return l[e].add(s), s;
  }
  function C(e) {
    const t = l;
    e.release();
    const n = t[e.id];
    n && n.delete(e);
  }
}
function aN(e) {
  let t, n;
  async function i() {
    const i = e.postprocess;
    n.update(), t.update(), i.update();
  }
  async function r() {
    const i = e.threeRenderer,
      r = e.postprocess;
    r.enabled && r.pingpong(),
      i.setRenderTarget(r.enabled ? r.buffers.main : null),
      i.clearDepth(),
      n.render(),
      t.render(),
      r.enabled &&
        (r.bloom.enabled && r.renderBloom(r.buffers.main),
        i.setRenderTarget(null),
        r.render());
  }
  function s(t) {
    const n = El(),
      i = e.renderer,
      r = e.threeRenderer,
      s = e.postprocess,
      a = e.scene,
      o = a.lightning,
      l = s.bloom,
      c = n.$device.type.mobile,
      u = r.capabilities.isWebGL2,
      h = "safari" === n.$device.browser,
      d = c || !u || h;
    switch ((a.setNear(d ? 0.18 : 0.1), t)) {
      case 5:
        i.setMaxPixelRatio(2),
          i.setMinPixelRatio(1.5),
          o.setShadowSize(256),
          o.toggleShadow(!0),
          a.setFar(d ? 150 : 200),
          l.resize(512, 512),
          (l.enabled = !0),
          (e.postprocess.enabled = !0);
        break;
      case 4:
        i.setMaxPixelRatio(c ? 1.6 : 1.75),
          i.setMinPixelRatio(c ? 1 : 1.2),
          o.setShadowSize(128),
          o.toggleShadow(!0),
          a.setFar(d ? 150 : 190),
          l.resize(512, 512),
          (l.enabled = !0),
          (e.postprocess.enabled = !0);
        break;
      case 3:
        i.setMaxPixelRatio(c ? 1.25 : 1.5),
          i.setMinPixelRatio(1),
          o.setShadowSize(64),
          o.toggleShadow(!0),
          a.setFar(d ? 150 : 175),
          l.resize(256, 256),
          (l.enabled = !0),
          (e.postprocess.enabled = !0);
        break;
      case 2:
        i.setMaxPixelRatio(c ? 1 : 1.15),
          i.setMinPixelRatio(1),
          o.setShadowSize(64),
          o.toggleShadow(!0),
          a.setFar(150),
          l.resize(256, 256),
          (l.enabled = !0),
          (e.postprocess.enabled = !0);
        break;
      case 1:
        i.setMaxPixelRatio(1),
          i.setMinPixelRatio(1),
          o.setShadowSize(4),
          o.toggleShadow(!1),
          a.setFar(150),
          l.resize(128, 128),
          (l.enabled = !1),
          (e.postprocess.enabled = !0);
        break;
      default:
        i.setMaxPixelRatio(1),
          i.setMinPixelRatio(1),
          o.setShadowSize(4),
          o.toggleShadow(!1),
          a.setFar(140),
          l.resize(128, 128),
          (l.enabled = !1),
          (e.postprocess.enabled = !1);
    }
  }
  !(function () {
    for (const e in wL) {
      const t = e.split("/").pop().slice(0, -".glsl".length);
      Zw[t] = wL[e].default;
    }
  })(),
    e.plugins.push(rR, sR, GR, oR, hR, DR, dk, IR, sN),
    Object.assign(e, {
      init: async function () {
        const { renderer: t } = e;
        Object.assign(t.options, {
          precision: "highp",
          antialiased: !1,
          premultipliedAlpha: !1,
          stencil: !1,
        }),
          (e.time.clampTo60Fps = !0),
          t.init();
        const n = t.instance;
        XE(n),
          n.setClearColor(11184810),
          (n.autoClear = !1),
          t.setMaxPixelRatio(1),
          (n.shadowMap.enabled = !0),
          (n.shadowMap.type = 2);
      },
      start: async function () {
        (n = e.background = new oA()),
          (t = e.scene = new bL()),
          e.renderer.resize(),
          e.time.init(),
          e.postprocess.init(),
          e.audio.init(),
          e.prerender(),
          e.quality.current.watchImmediate(s);
      },
      load: async function () {
        return e.audio.preloadSound("Car_Engine_Loop_AirFlow"), e.assets.load();
      },
      update: i,
      render: r,
      prerender: async function () {
        i(), r();
      },
    });
}
const oN = function () {};
let lN = null;
var cN;
(cN = async (e, t = {}) => {
  ix(Tx, (e) => e.set(0, 0, 0, 0)),
    ix(Xb, (e) => e.setRGB(0, 0, 0)),
    ix(fx, (e) => e.setScalar(0)),
    ix(Cx, (e) => e.setScalar(0)),
    ix(wx, (e) => e.setScalar(0)),
    ix(pb, (e) => e.set(0, 0, 0, "XYZ")),
    ix(ib);
  const n = t,
    i = {},
    r = [!1, qE, GE, jE, YE].filter(Boolean),
    s = ud(),
    a = ud(),
    o = ud(),
    l = ud(),
    c = ud(),
    u = ud(),
    h = ud(),
    d = ud(),
    p = ud(),
    f = ud(),
    m = ud(),
    g = ud(),
    v = ud(),
    _ = ud(),
    y = ud(),
    x = ud(),
    b = {
      beforePluginsInstall: s,
      afterPluginsInstall: a,
      beforeInit: o,
      afterInit: l,
      beforeLoad: c,
      afterLoad: u,
      beforeStart: h,
      afterStart: d,
      beforePrerender: p,
      afterPrerender: f,
      beforeFrame: m,
      afterFrame: g,
      beforeUpdate: v,
      afterUpdate: _,
      beforeRender: y,
      afterRender: x,
    };
  function w() {
    e.update(), e.render();
  }
  function S(t, n) {
    return t.install
      ? t.install(e, n)
      : "function" == typeof t
      ? t(e, n)
      : void 0;
  }
  function M(t, n) {
    const i = e[t] || oN;
    if ("function" == typeof n) e[t] = n(i);
    else {
      const s = !!n,
        a = (r = t).charAt(0).toUpperCase() + r.slice(1),
        o = b["before" + a] || oN,
        l = b["after" + a] || oN;
      e[t] = s
        ? async function (e) {
            o.emit(), await i(e), l.emit();
          }
        : function (e) {
            o.emit(), i(e), l.emit();
          };
    }
    var r;
    return e[t];
  }
  return (
    Object.assign(e, {
      options: n,
      state: i,
      plugins: r,
      hooks: b,
      init: function () {
        e.renderer.init();
      },
      load: oN,
      start: function () {
        e.renderer.resize(), e.time.init();
      },
      frame: w,
      update: oN,
      render: oN,
      prerender: w,
    }),
    aN(e),
    M("load", !0),
    M("start", !0),
    M("frame"),
    M("update"),
    M("render"),
    M("init", (t) => (n) => {
      o.emit(),
        (function () {
          s.emit();
          const t = e.plugins.filter(Boolean);
          for (const e of t) {
            const t = Array.isArray(e);
            S(t ? e[0] : e, t ? e[1] : {});
          }
          a.emit();
        })(),
        t(n),
        l.emit();
    }),
    M("prerender", (e) => (t) => {
      p.emit(), (i.prerendering = !0), e(t), (i.prerendering = !1), f.emit();
    }),
    await e.init(t),
    (lN = e),
    e
  );
}),
  Ol(async (e) => {
    (Dl = {}), await cN(Dl, e);
  });
const uN = () => lN;
function hN(e = {}) {
  const t = cu();
  let n = {
    initialized: t,
    start: async function (e = {}) {
      await s.start(e);
    },
    post: function (e, t = {}) {
      t.type = e;
    },
  };
  e.customize && (n = e.customize(n) || n);
  const i = n.init,
    r = n.load;
  (n.init = (e) => (
    (async function (e = {}) {
      i && (e = await i(e));
      await (async function (e) {
        (Rl = !0), (Il = e);
        for (const t of Ll) await t(e);
        Ll.length = 0;
      })(e),
        (s = uN()),
        t.resolve();
    })(e),
    t
  )),
    (n.load = async function (e = {}) {
      await t, r && (e = await r(e));
      await s.load(e);
    });
  let s = null;
  return n;
}
let dN = null;
function pN(e = {}) {
  let t, n;
  const i = (dN = {
    getElement: function () {
      return t;
    },
    install: function (r) {
      const s = r.config.globalProperties;
      (s.$webGL = i),
        r.provide("webGL", i),
        r.component("WebGL", Qy),
        (t = document.createElement("canvas")),
        (n = hN({ app: r, customize: e.bridge })),
        (i.bridge = n),
        (i.load = (e) => s.$preloader.task(n.load(e))),
        (i.prerender = n.prerender),
        s.$preloader.task(n.init({ canvas: t })),
        i.load({ type: "main" }),
        s.$preloader.beforeExit(n.start),
        delete i.install;
    },
  });
  return i;
}
const fN = { key: 0, class: "cookie-consent" },
  mN = { class: "cookie-consent__inner" },
  gN = ["innerHTML"],
  vN = { class: "cookie-consent__buttons" },
  _N = ["innerHTML"],
  yN = ["innerHTML"],
  xN = {
    props: {
      textHtml: { type: String, default: "Accept cookies?" },
      acceptHtml: { type: String, default: "Accept" },
      declineHtml: { type: String, default: "Decline" },
      visible: { type: Boolean, default: !0 },
    },
    emits: ["accept", "decline"],
    setup(e, { emit: t }) {
      const n = e,
        i = Yt("preloader"),
        r = Yt("stats"),
        s = void 0 !== typeof window,
        a = "cookieAccepted",
        o = (function () {
          const e = document.cookie.match(
            "(^|;)\\s*cookieAccepted\\s*=\\s*([^;]+)"
          );
          return e ? !!+e.pop() : null;
        })(),
        l = Tt(null !== o),
        c = Tt(o),
        u = Rt(
          () =>
            (!i || (void 0 !== typeof i.hidden && i.hidden)) &&
            !l.value &&
            !!n.visible
        );
      function h() {
        const e = c.value;
        t(e ? "accept" : "decline"),
          e && r && r.init && r.init(),
          s && document.documentElement.classList.add("cookie-consent-hidden");
      }
      function d() {
        f(!0);
      }
      function p() {
        f(!1);
      }
      function f(e) {
        if (l.value) return;
        (l.value = !0), (c.value = !!e), h();
        let t = new Date(Date.now() + 5184e6);
        (t = t.toUTCString()),
          (document.cookie = [
            a + "=" + (e ? 1 : 0) + ";",
            "Path=/;",
            "SameSite=none;",
            "Secure; Expires=" + t,
          ].join(" "));
      }
      return (
        l.value && h(),
        (e, t) => (
          pi(),
          _i(
            Xr,
            { name: "cookie-consent", appear: "" },
            {
              default: Vt(() => [
                At(u)
                  ? (pi(),
                    vi("div", fN, [
                      Mi("div", mN, [
                        Mi(
                          "p",
                          {
                            class: "cookie-consent__description",
                            innerHTML: n.textHtml,
                          },
                          null,
                          8,
                          gN
                        ),
                        Mi("div", vN, [
                          Mi(
                            "button",
                            {
                              class:
                                "cookie-consent__cta cookie-consent__cta--decline",
                              onClick: p,
                            },
                            [
                              Mi(
                                "p",
                                {
                                  class: "cta__text",
                                  innerHTML: n.declineHtml,
                                },
                                null,
                                8,
                                _N
                              ),
                            ]
                          ),
                          Mi(
                            "button",
                            {
                              class:
                                "cookie-consent__cta cookie-consent__cta--accept",
                              onClick: d,
                            },
                            [
                              Mi(
                                "p",
                                { class: "cta__text", innerHTML: n.acceptHtml },
                                null,
                                8,
                                yN
                              ),
                            ]
                          ),
                        ]),
                      ]),
                    ]))
                  : Pi("", !0),
              ]),
              _: 1,
            }
          )
        )
      );
    },
  };
export {
  w_ as $,
  Ay as A,
  ki as B,
  Gc as C,
  Cl as D,
  Sr as E,
  oi as F,
  y as G,
  Pi as H,
  pr as I,
  iy as J,
  py as K,
  br as L,
  nh as M,
  ni as N,
  _i as O,
  xN as P,
  Ei as Q,
  Tl as R,
  Al as S,
  qs as T,
  wl as U,
  Yo as V,
  ql as W,
  wc as X,
  h_ as Y,
  c_ as Z,
  Fl as _,
  ys as a,
  Ai as a0,
  bc as a1,
  ms as a2,
  jn as a3,
  cs as a4,
  Di as a5,
  lu as a6,
  us as a7,
  fu as a8,
  yy as a9,
  Va as aa,
  xy as ab,
  dt as ac,
  _d as ad,
  Wa as ae,
  Ko as af,
  by as b,
  zv as c,
  gc as d,
  Ry as e,
  Fy as f,
  Xy as g,
  Jy as h,
  pN as i,
  vi as j,
  Mi as k,
  Pl as l,
  Bt as m,
  g as n,
  pi as o,
  Ut as p,
  Rt as q,
  Tt as r,
  Ti as s,
  Ga as t,
  At as u,
  vc as v,
  Nl as w,
  pn as x,
  Uc as y,
  vn as z,
};
